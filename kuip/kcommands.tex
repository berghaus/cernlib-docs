\DEFMENU{0}{KUIP}{KUIP}
\ifMENUtext
   \par
Command Processor commands.  


\fi

\DEFCMD{K}{HELP}{KUIP}{HELP}{ [ item option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu path}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{View mode}{ D='N'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{EDIT}{\par
The help text is written to a file and the editor is invoked,
}
\DEFOPT{E}{\par
Same as 'EDIT'.
}
\DEFOPT{NOEDIT}{\par
The help text is output on the terminal output.
}
\DEFOPT{N}{\par
Same as 'NOEDIT'
}
\ENDOPT

   \par
Give the help of a command.  If ITEM is a command its full explanation is 
   given:  syntax (as given by the command USAGE), functionality, list of 
   parameters with their attributes (prompt, type, default, range, etc.).  If 
   ITEM='/' the help for all commands is given.  

   \par
If HELP is entered without parameters or ITEM is a submenu, the dialogue 
   style is switched to 'AN', guiding the user in traversing the tree command 
   structure.  

   \par
'HELP -EDIT' (or just 'HELP -E') switches to edit mode:  instead of writing 
   the help text to the terminal output, it is written into a temporary file 
   and the pager or editor defined by the command HOST_PAGER is invoked.  (On 
   Unix workstations the pager can be defined to display the help text 
   asynchrously in a separated window.) 'HELP -NOEDIT' (or just 'HELP -N') 
   switches back to standard mode.  The startup value is system dependent.  

\ENDCMD

\DEFCMD{K}{USAGE}{KUIP}{USAGE}{ item}

\BEGARG
\DEFARG{ITEM}{C}{Command name}{}
\ENDARG

   \par
Give the syntax of a command.  If ITEM='/' the syntax of all commands is 
   given.  

\ENDCMD

\DEFCMD{K}{MANUAL}{KUIP}{MANUAL}{ item [ output option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu path}{}
\DEFARG{OUTPUT}{C}{Output file name}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Text formatting system}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{\par
plain text : plain text format
}
\DEFOPT{LATEX}{\par
LaTeX format (encapsulated)
}
\DEFOPT{TEX}{\par
LaTeX format (without header)
}
\ENDOPT

   \par
Write on a file the text formatted help of a command.  If ITEM is a menu 
   path the help for all commands linked to that menu is written.  If ITEM='/' 
   the help for the complete command tree is written.  If OUTPUT=' ' the text 
   is written to the terminal.  

   \par
The output file produced with option LATEX can be processed directly by 
   LaTeX, i.e. it contains a standard header defining the meta commands used 
   for formatting the document body.  With option TEX only the document body 
   is written into the output file which can be included by a driver file 
   containing customized definitions of the standard meta commands.  Example:  
\begin{verbatim}
    MANUAL / MAN.TEX LATEX
\end{verbatim}
   \par
will produce the file MAN.TEX containg the documentation of all available 
   commands in LaTeX format.  

\ENDCMD

\DEFCMD{K}{EDIT}{KUIP}{EDIT}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Invoke the editor on the file.  The command HOST_EDITOR can be used to 
   define the editor.  

   \par
If FNAME does not contain an extension the default filetype '.KUMAC' is 
   supplied.  The search path defined by the command DEFAULTS is used to find 
   an already existing file.  If the file does not exist it is created with 
   the given name.  

\ENDCMD

\DEFCMD{K}{PRINT}{KUIP}{PRINT}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Send a file to the printer.  The command HOST_PRINT can be used to define 
   the host command for printing the file depending on it file extension.  

\ENDCMD

\DEFCMD{K}{PSVIEW}{KUIP}{PSVIEW}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Invoke the PostScript viewer on the file.  The command HOST_PSVIEWER can 
   be used to define the PostScript viewer.  

   \par
If FNAME does not contain an extension the default filetype '.PS' is 
   supplied.  

\ENDCMD

\DEFCMD{K}{LAST}{KUIP}{LAST}{ [ n fname ]}

\BEGARG
\DEFARG{N}{I}{N last commands to be saved}{ D=-99 R=-99:}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Perform various operations with the history file.  

   \par
If FNAME is not specified, the current history file is assumed by default 
   (the startup history file name is LAST.KUMAC).  To change the history file 
   the command LAST 0 NEW-FNAME must be entered.  

   \par
If N.EQ.-99 (default case) the default host editor is called to edit the 
   current history file, containing all the commands of the session.  

   \par
If N.LT.0 the last -N commands are printed on the screen.  On MVS this 
   allows to edit and resubmit commands.  On workstations this allows to 
   resubmit blocks of commands by mouse-driven cut-and-paste operations.  

   \par
If N.EQ.0 the history file FNAME is rewound and set as the current one (the 
   command LAST 0 FNAME itself is not recorded).  

   \par
If N.GT.0 the last N commands of the session are saved in the current 
   history file.  

   \par
See also the command RECORDING.  

\ENDCMD

\DEFCMD{K}{MESSAG}{KUIP}{MESSAGE}{ [ string ]}

\BEGARG
\DEFARG{STRING}{C}{Message string}{ D=\EMPTY{} Separate}
\ENDARG

   \par
Write a message string on the terminal.  A useful command inside a macro.  
   Several message strings can be given in the same command line, each of them 
   separated by one or more spaces (the usual parameter separator); therefore 
   multiple blanks will be dropped and only one will be kept.  If multiple 
   blanks should not be dropped, the string must be surrounded by single 
   quotes.  

\ENDCMD

\DEFCMD{K}{SHELL}{KUIP}{SHELL}{ [ cmd ]}

\BEGARG
\DEFARG{CMD}{C}{Shell command string}{ D=\EMPTY{}}
\ENDARG

   \par
Execute a command of the host operating system.  The command string is 
   passed to the command processor defined by HOST_SHELL.  If CMD=' ' the 
   shell is spawned as interactive subprocess.  To return from the shell enter 
   'RETURN' (the full word, not just \BRA{}CR\KET{}) or 'exit' (depending on 
   the operation system).  

\ENDCMD

\DEFCMD{K}{WAIT}{KUIP}{WAIT}{ [ string sec ]}

\BEGARG
\DEFARG{STRING}{C}{Message string}{ D=\EMPTY{}}
\DEFARG{SEC}{R}{Number of seconds}{ D=0 R=0:}
\ENDARG

   \par
Make a pause (e.g. inside a macro).  Wait a given number of seconds (if 
   SEC.GT.0) or just until \BRA{}CR\KET{} is entered (if SEC.EQ.0).  A message 
   string is also written on the terminal before waiting.  

\ENDCMD

\DEFCMD{K}{IDLE}{KUIP}{IDLE}{ sec [ string ]}

\BEGARG
\DEFARG{SEC}{I}{Number of seconds}{ R=0:}
\DEFARG{STRING}{C}{Command string}{ D=\EMPTY{}}
\ENDARG

   \par
Execute a command if program is idle.  The command string is executed if 
   there was no keyboard activity during SEC seconds.  

\ENDCMD

\DEFCMD{K}{UNITS}{KUIP}{UNITS}{}

   \par
List all Input/Output logical units currently open.  The files attached to 
   them are also shown.  

\ENDCMD

\DEFCMD{K}{EXIT}{KUIP}{EXIT}{}

   \par
End of the interactive session.  

\ENDCMD

\DEFCMD{K}{QUIT}{KUIP}{QUIT}{}

   \par
End of the interactive session.  

\ENDCMD

\DEFCMD{K}{FUNCTI}{KUIP}{FUNCTIONS}{}

\begin{verbatim}
          *** KUIP System Functions ***
\end{verbatim}
\ENDVERB
   \par
The function name (and arguments) is literally replaced, at run-time, by 
   its current value.  At present, the following functions are available:  
\begin{verbatim}
    $DATE  .......................  Current date in format DD/MM/YY
    $TIME  .......................  Current time in format HH.MM.SS
    $CPTIME  .....................  CP time elapsed since last call (in sec)
    $RTIME  ......................  Real time elapsed since last call (in sec)
    $VDIM(VNAME,IDIM)  ...........  Physical length of vector VNAME
                                    on dimension IDIM (1..3)
    $VLEN(VNAME,IDIM)  ...........  As above, but for the logical length
                                    (i.e. stripping trailing zeroes)
    $NUMVEC  .....................  Current number of vectors
    $VEXIST(VNAME)  ..............  Index of vector VNAME
                                    (1..$NUMVEC or 0 if VNAME does not exist)
    $SUBSTRING(STRING,IX,NCH)  ...  STRING(IX:IX+NCH-1)
    $UPPER(STRING)  ..............  STRING changed to upper case
    $LOWER(STRING)  ..............  STRING changed to lower case
    $LEN(STRING)  ................  Length of STRING
    $INDEX(STR1,STR2)  ...........  Position of first occurrence of STR2 in 
   STR1
    $WORDS(STRING,SEP)  ..........  Number of words separated by SEP
    $WORD(STRING,K,N,SEP)  .......  Extract N words starting at word K
    $QUOTE(STRING)  ..............  Add quotes around STRING
    $UNQUOTE(STRING)  ............  Remove quotes around STRING
    $EXEC('macro args')  .........  EXITM value of EXEC call
    $EVAL(Expression)  ...........  Result of the Expression computed by KUIP
    $SIGMA(Expression)  ..........  Result of the Expression computed by SIGMA
    $RSIGMA(Expression) ..........  As above but a decimal point is added to
                                    integer results
    $FORMAT(number,format)  ......  Format a number according to a Fortran
                                    format string, e.g.
                                    $FORMAT(1.5,F5.2) ==> ' 1.50'
                                    $FORMAT(123,I5.5) ==> '00123'
    $ARGS  .......................  Command line at program invocation
    $KEYNUM  .....................  Address of latest clicked key in style GP
    $KEYVAL  .....................  Value of latest clicked key in style GP
    $LAST  .......................  Latest command line executed
    $ANUM  .......................  Number of aliases
    $ANAM(I)  ....................  Name of I-th alias
    $AVAL(I)  ....................  Value of I-th alias
    $STYLE  ......................  Current style as defined by SET/STYLE
    $OS  .........................  Operating system name, e.g. UNIX or VMS
    $MACHINE  ....................  Hardware or Unix brand, e.g. VAX or HPUX
    $IQUEST(I)  ..................  Value of IQUEST(I) status vector
    $ENV(var)  ...................  Value of environment variable
    $FEXIST(file)  ...............  1 if file exists or 0 otherwise
    $SHELL(cmd[,n])  .............  n'th line of shell command output (Unix 
   only).
                                    n=0 (default) returns the complete output
                                    with newlines replaced by blanks.
\end{verbatim}


\ENDCMD
\DEFMENU{1}{ALIAS}{KUIP/ALIAS}
\ifMENUtext
   \par
Operations with aliases.  Aliases are defined to provide shortcut 
   abbreviations for the input line or some part of it.  When encountered on 
   an input line an alias is replaced by its string value which can contain 
   further aliases.  (Be careful not to define recursive aliases.) 

   \par
To juxtaposition aliases, a double slash can be used as concatenation sign. 
   Inside quoted strings and for the ALIAS commands themselves the alias 
   substitution is inhibited.  Otherwise 
\begin{verbatim}
    ALIAS/CREATE ALPHA BETA
    ALIAS/CREATE ALPHA BETA
\end{verbatim}
   \par
whould create an recursive alias BETA and 
\begin{verbatim}
    ALIAS/CREATE ALPHA BETA
    ALIAS/CREATE BETA GAMMA
    ALIAS/DELETE ALPHA
\end{verbatim}
   \par
would delete the alias name BETA instead of ALPHA itself.  


\fi

\DEFCMD{KA}{CREATE}{KUIP/ALIAS}{CREATE}{ name value [ chopt ]}

\BEGARG
\DEFARG{NAME}{C}{Alias name}{}
\DEFARG{VALUE}{C}{Alias value}{}
\DEFARG{CHOPT}{C}{Option}{ D='A'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
create an Argument alias
}
\DEFOPT{C}{\par
create a Command alias
}
\DEFOPT{N}{\par
No alias expansion of value
}
\ENDOPT

   \par
Create an alias NAME which should be substituted by VALUE.  An alias name 
   is a sequence of letters and digits starting with a letter.  The 
   underscores ('_'), the at-sign ('@') and the dollar-sign ('\$') count as 
   letters.  

   \par
There are two types of aliases:  Command aliases are recognized only if 
   they occur in the command position, i.e. as the first token on the line.  
   Argument aliases are recognized anywhere on the command line (except inside 
   quoted strings) if they are surrounded by one of the following separators:  
\begin{verbatim}
    blank  /  ,  =  :  .  %  '  (  )
\end{verbatim}
\ENDVERB
   \par
Also switch ON the alias translation, i.e. ALIAS/TRANSLATION ON.  If 
   CHOPT='C' then the alias is a command alias, i.e. an alias that will only 
   be translated when it is the first token on a command line.  Example:  
\begin{verbatim}
    Alias/Create GG Graph/Struct/Scratch
    Alias/Create FF File1/Name1/Name2
    GG FF/ID
\end{verbatim}
   \par
is equivalent to 
\begin{verbatim}
    Graph/Struct/Scratch File1/Name1/Name2/ID
\end{verbatim}
\begin{verbatim}
    Alias/Create LS DIR C
\end{verbatim}
   \par
is equivalent to 
\begin{verbatim}
    DIR
\end{verbatim}
   \par
only when LS is the first token on a command line.  In the following case 
   LS will not be translated 
\begin{verbatim}
    SHELL LS
\end{verbatim}
\ENDVERB
   \par
Aliases occuring inside an value are expanded indepedent whether the value 
   is enclosed by quotes.  The option -N allows to suppress this implicit 
   alias expansion.  

\ENDCMD

\DEFCMD{KA}{LIST}{KUIP/ALIAS}{LIST}{}

   \par
List all aliases (names and values).  

\ENDCMD

\DEFCMD{KA}{DELETE}{KUIP/ALIAS}{DELETE}{ alist}

\BEGARG
\DEFARG{ALIST}{C}{Alias list}{ Loop}
\ENDARG

   \par
Delete the definition of aliases in the list ALIST.  The aliases are 
   separated in the list by a comma and embedded blanks are not allowed.  If 
   ALIST='*' then delete all aliases and the alias translation is switched OFF 
   (i.e.: ALIAS/TRANSLATION OFF is executed).  

\ENDCMD

\DEFCMD{KA}{TRANSL}{KUIP/ALIAS}{TRANSLATION}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{ON}{\par
switch alias translation ON
}
\DEFOPT{OFF}{\par
switch alias translation OFF
}
\ENDOPT

   \par
Switch ON/OFF the alias translation.  If OFF, alias definitions are not 
   used in parsing the command lines.  It is automatically switched ON when an 
   alias is created.  If OPTION='?' the current value is shown.  The startup 
   value is OFF.  

\ENDCMD
\DEFMENU{1}{SET_SHOW}{KUIP/SET_SHOW}
\ifMENUtext
   \par
Set or show various KUIP parameters and options.  


\fi

\DEFCMD{KS}{STYLE}{KUIP/SET_SHOW}{STYLE}{ [ option sgylen sgsize sgyspa sgbord wktype ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='?'}
\DEFARG{SGYLEN}{R}{max Y LENgth of each menu item box}{ D=0.025 R=0.005:0.25}
\DEFARG{SGSIZE}{R}{space available for the application}{ D=0.8 R=0:0.90}
\DEFARG{SGYSPA}{R}{max Y length of space between menus}{ D=0.02 R=-0.5:0.50}
\DEFARG{SGBORD}{R}{X or Y border for menus}{ D=0.015 R=0:0.25}
\DEFARG{WKTYPE}{I}{Graphics workstation type}{ D=0}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current style
}
\DEFOPT{C}{\par
Command line : select Command line input
}
\DEFOPT{AN}{\par
Menu with Numbers : select general Alpha menu (with Numbers)
}
\DEFOPT{AL}{\par
Menu with Letters : select general Alpha menu (with Letters)
}
\DEFOPT{G}{\par
Graphics menu hardware : select Graphics menu (with hardware character fonts)
}
\DEFOPT{GW}{\par
Graphics menu shadowed : select Graphics menu (with shadowed Width effect)
}
\DEFOPT{GS}{\par
Graphics menu Software : select Graphics menu (with Software character fonts)
}
\DEFOPT{GP}{\par
Panel keys : select Graphics menu (with Panel keys only, i.e. no command tree 
menu)
}
\DEFOPT{XM}{\par
Motif/X11 : select Motif/X11 interface
}
\ENDOPT

   \par
Select the user dialogue style (or working mode).  The startup value is 'C' 
   (command mode).  The current value is returned by the system function 
   \$STYLE.  

   \par
The G-styles are only available if the application program is calling 
   KUWHAG instead of KUWHAT.  When one of these options is choosen the 
   remaining parameters control the geometrical layout of the menus on the 
   screen and the graphics workstation type (in case HIGZ was not 
   initialized).  

   \par
Style 'XM' is only available if the program is calling KUWHAM.  In that 
   case switching to other styles is not possible.  

\ENDCMD

\DEFCMD{KS}{NEWPAN}{KUIP/SET_SHOW}{NEWPANEL}{ line col title width height xpos ypos}

\BEGARG
\DEFARG{LINE}{I}{Number of lines}{ D=5 R=1:30}
\DEFARG{COL}{I}{Number of columns}{ D=5 R=1:30}
\DEFARG{TITLE}{C}{Panel Title}{ D='New Panel'}
\DEFARG{WIDTH}{I}{Panel width (in pixels)}{ D=300 R=10:}
\DEFARG{HEIGHT}{I}{Panel height (in pixels)}{ D=300 R=10:}
\DEFARG{XPOS}{I}{X Position (in pixels)}{ D=0 R=0:}
\DEFARG{YPOS}{I}{Y Position (in pixels)}{ D=0 R=0:}
\ENDARG

   \par
Set up a new panel with empty keys (to be filled interactively).  

\ENDCMD

\DEFCMD{KS}{COMMAN}{KUIP/SET_SHOW}{COMMAND}{ [ chpath ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name for command line}{ D=\EMPTY{}}
\ENDARG

   \par
Set a filter for the parsing of command lines.  If it has been called, it 
   means that whenever a command line is entered, if and only if it is not an 
   existing command (not just ambiguous), it is inserted into the CHPATH 
   string, with \$n (n=1..9) being replaced by the n-th token of the command 
   (tokens are separated by spaces), or \$* being replaced by the whole 
   command line. Examples:  
\begin{verbatim}
    COMMAND 'V/CR $*(10)'
    AA                     =>   V/CR AA(10)
    BB                     =>   V/CR BB(10)
    V/LIST                 =>   V/LIST
\end{verbatim}
\begin{verbatim}
    COMMAND 'VECTOR/PLOT $1 555 $2'
    AA E                   =>   VECTOR/PLOT AA 555 E
    BB                     =>   VECTOR/PLOT BB 555
\end{verbatim}
\begin{verbatim}
    COMMAND                =>   shows its current value
    COMMAND *              =>   reset (equivalent to COMMAND $*)
\end{verbatim}
   \par
Note that COMMAND and subsequent command lines can be used inside macros, 
   excepted when producing macro statements (like EXEC, IF, GOTO, etc.).  For 
   example, the above examples would work also inside macros, while COMMAND 
   'EXEC \$*' or COMMAND 'GOTO \$1' will not.  

\ENDCMD

\DEFCMD{KS}{APPLIC}{KUIP/SET_SHOW}{APPLICATION}{ path [ cmdex ]}

\BEGARG
\DEFARG{PATH}{C}{Application name}{ D=\EMPTY{}}
\DEFARG{CMDEX}{C}{Exit command}{ D='EXIT'}
\ENDARG

   \par
Set the application name.  This means that all input lines will be 
   concatenated to the string PATH (until the command specified by the 
   parameter CMDEX is executed, which resets the application to the null 
   string). The value of CMDEX may be specified if the default value EXIT has 
   to be changed (i.e. because already used by the application).  APPLICATION 
   can also be inserted in a macro: in this case at least 4 characters must be 
   specified (i.e. APPL).  

\ENDCMD

\DEFCMD{KS}{ROOT}{KUIP/SET_SHOW}{ROOT}{ [ path ]}

\BEGARG
\DEFARG{PATH}{C}{Root directory}{ D='/'}
\ENDARG

   \par
Set the root for searching commands.  If PATH='?' the current root is 
   shown.  This allows to access commands regardless of possible ambiguities 
   with different menus.  Commands are first searched starting from the 
   current root:  if a command is found it is executed.  Only if a command is 
   not found a second pass of search is done, starting now from the top root 
   of the command tree (i.e. '/').  

\ENDCMD

\DEFCMD{KS}{TIMING}{KUIP/SET_SHOW}{TIMING}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\DEFOPT{ALL}{}
\ENDOPT

   \par
Set ON/OFF/ALL the timing of commands.  If ON, the real time and the CPU 
   time for the latest executed command (or macro) are presented.  If ALL, the 
   time is shown for each command being executed within a macro.  The startup 
   value is OFF.  

\ENDCMD

\DEFCMD{KS}{PROMPT}{KUIP/SET_SHOW}{PROMPT}{ prompt}

\BEGARG
\DEFARG{PROMPT}{C}{Prompt string}{ D=\EMPTY{}}
\ENDARG

   \par
Set the prompt string for the command mode dialogue.  If PROMPT is blank 
   the current prompt is left unchanged.  If PROMPT contains the character 
   sequence '[]' the current command number is inserted between the square 
   brackets.  

\ENDCMD

\DEFCMD{KS}{BREAK}{KUIP/SET_SHOW}{BREAK}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\DEFOPT{TB}{}
\DEFOPT{?}{}
\ENDOPT

   \par
Set ON/OFF the break handling.  If OPTION='?' the current value is shown.  
   The startup value is ON.  

   \par
Hitting the keyboard interrupt (CTRL/C on VMS or CTRL/Q on the Apollo) 
   under break ON condition, the current command or macro execution will be 
   interrupted and the user will get again the application prompt.  

   \par
BREAK TB switch ON the traceback of the routines called, with their line 
   numbers, when an error occurs. This allows the detection of the routines 
   which provoked the error.  

\ENDCMD

\DEFCMD{KS}{COLUMN}{KUIP/SET_SHOW}{COLUMNS}{ [ ncol ]}

\BEGARG
\DEFARG{NCOL}{I}{Number of columns for terminal output}{ D=80 R=-1:}
\ENDARG

   \par
Set the maximum number of columns for terminal output.  If NCOL=0 the 
   current number of columns is shown.  If NCOL=-1 the current number of 
   columns is taken from the environment variable COLUMNS.  If COLUMNS is 
   undefined the startup value is 80.  

\ENDCMD

\DEFCMD{KS}{RECORD}{KUIP/SET_SHOW}{RECORDING}{ [ nrec ]}

\BEGARG
\DEFARG{NREC}{I}{Rate for recording on history file}{ D=25 R=0:}
\ENDARG

   \par
Set the recording rate for the history file.  Every NREC commands of the 
   session the current history file is updated.  If NREC=0 the history is not 
   kept at all (i.e. the file is not written).  See also the command LAST.  

\ENDCMD

\DEFCMD{KS}{HOSTED}{KUIP/SET_SHOW}{HOST_EDITOR}{ [ editor top left width height dxpad dypad npads ]}

\BEGARG
\DEFARG{EDITOR}{C}{Host editor command}{ D='?'}
\DEFARG{TOP}{I}{Top position of the edit window}{ D=20 R=0:}
\DEFARG{LEFT}{I}{Left position of the edit window}{ D=20 R=0:}
\DEFARG{WIDTH}{I}{Width of the edit window}{ D=0 R=0:}
\DEFARG{HEIGHT}{I}{Height of the edit window}{ D=0 R=0:}
\DEFARG{DXPAD}{I}{X offset for help PAD windows}{ D=30 R=0:}
\DEFARG{DYPAD}{I}{Y offset for help PAD windows}{ D=20 R=0:}
\DEFARG{NPADS}{I}{Maximum number of shifted pads}{ D=4 R=1:}
\ENDARG

   \par
Set the host command to invoke the editor.  The EDIT command will invoke 
   this editor.  If EDITOR='?' the current host editor command is shown.  

   \par
On Apollo the special value EDITOR='DM' invoke Display Manager pads.  The 
   special values EDITOR='WINDOW' and 'PAD' can be used to specify the window 
   positions (in pixel units).  'WINDOW' defines the parameters for edit pads, 
   while 'PAD' defines the parameters for read-only pads (e.g. used by 'HELP 
   -EDIT').  

   \par
On VMS the special values EDITOR='EDT' and 'TPU' invoke the callable 
   editors.  The startup time is considerably lower compared to spawning the 
   editor as a subprocess.  The callable EDT has one disadvantage though:  
   after an error, e.g. trying to edit a file in a non-existing directory, 
   subsequent calls will always fail.  The TPU call can be augmented by 
   command line options, e.g.  
\begin{verbatim}
    HOST_EDITOR TPU/DISP=DECW    | DECwindow interface to EVE
\end{verbatim}
\ENDVERB
   \par
On Unix a variety of editors are available, e.g.  
\begin{verbatim}
    HOST_EDITOR vi
    HOST_EDITOR 'emacs -geometry 80x48'
\end{verbatim}
\ENDVERB
   \par
On Unix workstations it is possible to do asynchronous editing via the KUIP 
   edit server, i.e. to start an editor in a separate window while the 
   application can continue to receive commands.  In order to do that the 
   following conditions must be fulfilled:  
\begin{verbatim}
    - The KUIP edit server 'kuesvr' must be found in the search path.
    - The editor command set by HOST_EDITOR must end with an ampersand ('&').
    - The environment variable 'DISPLAY' must be set.
\end{verbatim}
\ENDVERB
   \par
The ampersand flags your intention to use the edit server if possible.  If 
   the edit server cannot be used the ampersand will be ignored, i.e. even 
   with 
\begin{verbatim}
    HOST_EDITOR 'vi &'
\end{verbatim}
   \par
the KUIP/EDIT command will block until the editor terminates if either the 
   'kuesvr' is not available or 'DISPLAY' is undefined.  When using the edit 
   server the editor command is expected to create its own window.  'vi' being 
   a frequent choice, the above command is automatically interpreted as 
\begin{verbatim}
    HOST_EDITOR 'xterm -e vi &'
\end{verbatim}
\ENDVERB
   \par
The startup value can be defined by the environment variable 'EDITOR'.  
   Otherwise it is set to a system dependent default:  'DM' (Apollo), 'EDT' 
   (VMS), 'XEDIT' (VM/CMS), 'vi' (Unix).  

\ENDCMD

\DEFCMD{KS}{HOSTPA}{KUIP/SET_SHOW}{HOST_PAGER}{ [ pager ]}

\BEGARG
\DEFARG{PAGER}{C}{Host pager command}{ D='?'}
\ENDARG

   \par
Set the host command to view a file in read-only mode.  If OPTION='?' the 
   current host pager command is shown.  The 'HELP -EDIT' command will invoke 
   this pager, e.g.  
\begin{verbatim}
    HOST_PAGER more
\end{verbatim}
\ENDVERB
   \par
On Unix workstations the pager can be asynchronous by creating a separate 
   window, e.g.  
\begin{verbatim}
    HOST_PAGER 'xterm -e view &'
    HOST_PAGER 'ved &'
\end{verbatim}
\ENDVERB
   \par
On Apollo the special value PAGER='DM' defines the use of Display Manager 
   read-only pads.  The pad positions can be adjusted by the HOST_EDITOR 
   command.  

   \par
The startup value can be defined by the environment variables 'KUIPPAGER' 
   or 'PAGER'.  If neither of them is defined the value set by the 
   HOST_EDITOR command is used.  On VAX/VMS the startup value is 'TYPE/PAGE'. 

\ENDCMD

\DEFCMD{KS}{HOSTPR}{KUIP/SET_SHOW}{HOST_PRINTER}{ [ command filetype ]}

\BEGARG
\DEFARG{COMMAND}{C}{Host printer command}{ D='?'}
\DEFARG{FILETYPE}{C}{File extension}{ D=\EMPTY{}}
\ENDARG

   \par
Set the host commands for printing files with KUIP/PRINT.  The KUIP/PRINT 
   command will use the host command matching the file extension or use the 
   default command defined for FILETYPE=' '.  

   \par
If COMMAND='?' the currently set commands are shown.  If COMMAND=' ' the 
   currently defined command is delete.  The command string can contain '\$*' 
   and '\$-' to indicate the position where the file name with/without file 
   extension should be inserted.  For example, 
\begin{verbatim}
    MANUAL / refman.tex latex
    HOST_PRINTER 'latex $* ; dvips $-' .tex
    KUIP/PRINT refman.tex
\end{verbatim}
   \par
invokes the shell command 'latex refman.tex ; dvips refman'.  The 
   predefined defaults are not guaranteed to work since the actual print 
   commands are very much installation dependent.  

\ENDCMD

\DEFCMD{KS}{HOSTPS}{KUIP/SET_SHOW}{HOST_PSVIEWER}{ [ psviewer ]}

\BEGARG
\DEFARG{PSVIEWER}{C}{Host PostScript Viewer command}{ D='?'}
\ENDARG

   \par
Set the host command to invoke the PostScript Viewer.  The PSVIEW command 
   will invoke this PostScript Viewer.  If PSVIEWER='?' then the current 
   viewer command is shown.  

   \par
The startup value can be defined by the environment variables 
   'KUIPPSVIEWER' or 'PSVIEWER'.  

   \par
On Unix workstations it is by default set to 'ghostview'.  On VAX/VMS the 
   default commands is 'VIEW/FORM=PS/INTERFACE=DECWINDOWS'.  

\ENDCMD

\DEFCMD{KS}{HOSTSH}{KUIP/SET_SHOW}{HOST_SHELL}{ [ shell ]}

\BEGARG
\DEFARG{SHELL}{C}{Host shell command}{ D='?'}
\ENDARG

   \par
Set the default host shell invoked by the KUIP/SHELL command.  If 
   OPTION='?' the current host shell is shown.  The startup value is taken 
   from the 'SHELL' environment variable.  

\ENDCMD

\DEFCBIG{KS}{RECALL}{KUIP/SET_SHOW}{RECALL_STYLE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Command recall and editing style}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{KSH}{\par
Korn shell : Emacs like command line editing
}
\DEFOPT{KSHO}{\par
Korn shell + Overwrite : like 'KSH' but overwrite instead of insert mode
}
\DEFOPT{DCL}{\par
VAX/VMS DCL : DCL command line editing
}
\DEFOPT{DCLO}{\par
VAX/VMS DCL + Overwrite : like 'DCL' but overwrite instead of insert mode
}
\DEFOPT{NONE}{\par
disable command line editing
}
\ENDOPT

   \par
Set the command recall and editing style.  If OPTION='?' the current style 
   is shown.  The startup value is 'DCL' on VAX/VMS, 'NONE' on Cray and Apollo 
   DM pads, and 'KSH' on other systems.  

   \par
If the terminal emulator returns ANSI escape sequences (hpterm doesn't!) 
   the up/down arrow keys can be used to recall items from the command history 
   list and the left/right arrow keys to move the cursor.  

   \par
'KSH' style provides the following control keys for editing:  
\begin{verbatim}
     ^A/^E   : Move cursor to beginning/end of the line.
     ^F/^B   : Move cursor forward/backward one character.
     ^D      : Delete the character under the cursor.
     ^H, DEL : Delete the character to the left of the cursor.
     ^K      : Kill from the cursor to the end of line.
     ^L      : Redraw current line.
     ^O      : Toggle overwrite/insert mode. Text added in overwrite mode
               (including yanks) overwrites existing text, while insert mode
               does not overwrite.
     ^P/^N   : Move to previous/next item on history list.
     ^R/^S   : Perform incremental reverse/forward search for string on
               the history list.  Typing normal characters adds to the
               current search string and searches for a match.  Typing
               ^R/^S marks the start of a new search, and moves on to
               the next match.  Typing ^H or DEL deletes the last
               character from the search string, and searches from the
               starting location of the last search.
               Therefore, repeated DELs appear to unwind to the match
               nearest the point at which the last ^R or ^S was typed.
               If DEL is repeated until the search string is empty the
               search location begins from the start of the history
               list. Typing ESC or any other editing character accepts
               the current match and loads it into the buffer,
               terminating the search.
     ^T      : Toggle the characters under and to the left of the cursor.
     ^U      : Kill from the prompt to the end of line.
     ^Y      : Yank previously killed text back at current location.
               Note that this will overwrite or insert, depending on
               the current mode.
     TAB     : By default adds spaces to buffer to get to next TAB stop
               (just after every 8th column).
     LF, CR  : Returns current buffer to the program.
\end{verbatim}
\ENDVERB
   \par
'DCL' style provides the following control keys for editing:  
\begin{verbatim}
     BS/^E   : Move cursor to beginning/end of the line.
     ^F/^D   : Move cursor forward/backward one character.
     DEL     : Delete the character to the left of the cursor.
     ^A      : Toggle overwrite/insert mode.
     ^B      : Move to previous item on history list.
     ^U      : Delete from the beginning of the line to the cursor.
     TAB     : Move to next TAB stop.
     LF, CR  : Returns current buffer to the program.
\end{verbatim}

\ENDCBIG

\DEFCMD{KS}{VISIBI}{KUIP/SET_SHOW}{VISIBILITY}{ cmd [ chopt ]}

\BEGARG
\DEFARG{CMD}{C}{Command name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{?, OFF, ON}{ D='?'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{?}{}
\DEFOPT{OFF}{}
\DEFOPT{ON}{}
\ENDOPT

   \par
Set or show the visibility attributes of a command.  

   \par
If CHOPT='OFF':  
\begin{verbatim}
    - the command it is not executable anymore
    - STYLE G draws a shadowed box on the command
    - HELP may be still requested on the command
\end{verbatim}
   \par
The startup value is ON.  

\ENDCMD

\DEFCMD{KS}{DOLLAR}{KUIP/SET_SHOW}{DOLLAR}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Substitution of environment variables}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{ON}{\par
enable substitution
}
\DEFOPT{OFF}{\par
disable substitution
}
\ENDOPT

   \par
Set or show the status of environment variable substitution.  

   \par
This command allows to enable/disable the interpretation of environment 
   variables in command lines.  The startup value is 'ON', i.e. 
   \DQUOTE{}\$var\DQUOTE{} is substituted by the variable value.  

   \par
Note that the system function \DQUOTE{}\$ENV(var)\DQUOTE{} allows using 
   environment variables even for 'DOLLAR OFF' .  

\ENDCMD

\DEFCMD{KS}{FILECA}{KUIP/SET_SHOW}{FILECASE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Case conversion for filenames}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{KEEP}{\par
filenames are kept as entered on the command line
}
\DEFOPT{CONVERT}{\par
filenames are case converted
}
\DEFOPT{RESTORE}{\par
restore previous FILECASE setting
}
\ENDOPT

   \par
Set or show the case conversion for filenames.  

   \par
This command has only an effect on Unix systems to select whether filenames 
   are kept as entered on the command line.  The startup value is 'CONVERT', 
   i.e. filenames are converted to lowercase.  

   \par
On other systems filenames are always converted to uppercase.  

   \par
The 'RESTORE' option set the conversion mode to the value effective before 
   the last FILECASE KEEP/CONVERT command.  E.g. the sequence 
\begin{verbatim}
        FILECASE KEEP; EDIT Read.Me; FILECASE RESTORE
\end{verbatim}
   \par
forces case sensitivity for the EDIT command and restores the previous mode 
   afterwards.  

\ENDCMD

\DEFCMD{KS}{LCDIR}{KUIP/SET_SHOW}{LCDIR}{ [ directory ]}

\BEGARG
\DEFARG{DIR*ECTORY}{C}{Directory name}{ D=\EMPTY{}}
\ENDARG

   \par
Set or show the local working directory.  

   \par
The current working directory is set to the given path name or the current 
   directory is shown.  

   \par
To show the current directory used LCDIR without argument.  'LCDIR ~' 
   switches to the home directory.  'LCDIR .' switches back to the working 
   directory at the time the program was started.  

\ENDCMD
\DEFMENU{0}{MACRO}{MACRO}
\ifMENUtext
   \par
Macro Processor commands.  


\fi

\DEFCMD{M}{EXEC}{MACRO}{EXEC}{ mname [ margs ]}

\BEGARG
\DEFARG{MNAME}{C}{Macro name}{}
\DEFARG{MARGS}{C}{Macro arguments}{ D=\EMPTY{} Separate}
\ENDARG

   \par
Execute the command lines contained in the macro MNAME.  As a file can 
   contain several macros, the character '\#' is used to select a particular 
   macro inside a file as explained below.  

   \par
If MNAME does not contain the character '\#', the file MNAME.KUMAC is 
   searched and the first macro is executed (it may be an unnamed macro if a 
   MACRO statement is not found as first command line in the file).  

   \par
If MNAME is of the form FILE\#MACRO, the file named FILE.KUMAC is searched 
   and the macro named MACRO is executed.  

   \par
Examples:  
\begin{verbatim}
    EXEC ABC   to exec first (or unnamed) macro of file ABC.KUMAC
    EXEC ABC#M to exec macro M of file ABC.KUMAC
\end{verbatim}
\ENDVERB
   \par
The command MACRO/DEFAULTS can be used to define a directory search path 
   for macro files.  

\ENDCMD

\DEFCMD{M}{LIST}{MACRO}{LIST}{ [ mname ]}

\BEGARG
\DEFARG{MNAME}{C}{Macro name pattern}{ D=\EMPTY{}}
\ENDARG

   \par
List all macros in the search path defined by MACRO/DEFAULTS.  Macros are 
   files with the extension KUMAC.  MNAME may be specified to restrict the 
   list to the macros containing such a string in the first part of their 
   name.  For example, 
\begin{verbatim}
    MACRO/LIST ABC
\end{verbatim}
   \par
will list only macros starting with ABC.  

\ENDCMD

\DEFCMD{M}{TRACE}{MACRO}{TRACE}{ [ option level ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\DEFARG{LEVEL}{C}{Level}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\ENDOPT
\BEGOPT{LEVEL}
\DEFOPT{\EMPTY}{}
\DEFOPT{TEST}{}
\DEFOPT{WAIT}{}
\DEFOPT{FULL}{}
\DEFOPT{DEBUG}{}
\ENDOPT

   \par
Set ON/OFF the trace of commands during macro execution.  If TRACE='ON' the 
   next command is written on the terminal before being executed.  If 
   LEVEL='TEST' the command is only echoed but not executed.  If LEVEL='WAIT' 
   the command WAIT is automatically inserted after the execution of each 
   command.  The startup values are OPTION='OFF' and LEVEL=' '.  

\ENDCMD

\DEFCMD{M}{DEFAUL}{MACRO}{DEFAULTS}{ [ path option ]}

\BEGARG
\DEFARG{PATH}{C}{Search path for macro files}{ D='?'}
\DEFARG{OPTION}{C}{Automatic EXEC}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{Command}{\par
search for commands only
}
\DEFOPT{C}{\par
same as 'Command'
}
\DEFOPT{Auto}{\par
search for commands before macros
}
\DEFOPT{A}{\par
same as 'Auto'
}
\DEFOPT{AutoReverse}{\par
search for macros before commands
}
\DEFOPT{AR}{\par
same as 'AutoReverse'
}
\ENDOPT

   \par
Set or show MACRO search attributes.  

   \par
On Unix and VMS systems PATH defines a comma separated list of directories 
   in which the commands KUIP/EDIT, MACRO/EXEC, and MACRO/LIST search for 
   macro files.  For example, 
\begin{verbatim}
    MACRO/DEFAULT '.,macro,~/macro'          | Unix
    MACRO/DEFAULT '[],[.macro],[macro]'      | VMS
\end{verbatim}
   \par
defines to search files first in the current directory, then in the 
   subdirectory 'macro' of the current directory, and last the subdirectory 
   'macro' of the home directory.  

   \par
On VM/CMS system PATH defines a comma separated list of filemodes.  E.g.  
\begin{verbatim}
    MACRO/DEFAULT '*'       | search all disks
    MACRO/DEFAULT 'A,C'     | search only disks A and C
\end{verbatim}
\ENDVERB
   \par
If PATH='?' the currently defined search path is shown.  If PATH='.' the 
   search path is undefined, i.e. files are search for in the current 
   directory (A-disk on VM/CMS) only.  The startup value is PATH='.'.  

   \par
The search path is not applied if the file specification already contains 
   an explicit directory path or if it starts with a '-' character (which is 
   stripped off).  

   \par
OPTION allows to define whether macros can be invoked by their name only 
   without prepending the KUIP/EXEC command:  
\begin{verbatim}
    DEFAULT -Command
    CMD                     | CMD must be a command
    DEFAULT -Auto
    CMD                     | if CMD is not a command try EXEC CMD
    DEFAULT -AutoReverse
    CMD                     | try EXEC CMD first; if not found try command CMD
\end{verbatim}
   \par
The startup value is 'Command' (also reset by PATH='.').  

   \par
Important note:  

   \par
Inside macros the DEFAULT -A (or -AR) logic is disabled, i.e.  DEFAULT -C 
   is always assumed.  

\ENDCMD

\DEFCMD{M}{DATA}{MACRO}{DATA}{}

   \par
Application command to store immediate data into a file.  Example:  
\begin{verbatim}
    Application DATA vec.dat
    1  2  3
    4  5  6
    7  8  9
    vec.dat
    vec/read x,y,z vec.dat
\end{verbatim}

\ENDCMD
\DEFMENU{1}{SYNTAX}{MACRO/SYNTAX}
\ifMENUtext
   \par
Explanation of KUIP macro syntax.  

   \par
A macro is a set of command lines stored in a file, which can be created 
   and modified with any text editor.  

   \par
In addition to all available KUIP commands the  special \DQUOTE{}macro 
   statements\DQUOTE{} listed below are valid only inside macros. Note that 
   the statement keywords are fixed. Aliasing such as \DQUOTE{}ALIAS/CREATE 
   jump GOTO\DQUOTE{} is not allowed.  


\fi
\DEFMENU{2}{Expressions}{MACRO/SYNTAX/Expressions}
\ifMENUtext
   \par
Explanation of KUIP expression syntax.  

   \par
KUIP has a built-in parser for different kinds of expressions: arithmetic 
   expressions, boolean expressions, string expressions, and \DQUOTE{}garbage 
   expressions\DQUOTE{}.  


\fi

\DEFCMD{MSE}{Arithm}{MACRO/SYNTAX/Expressions}{Arithmetic}{}

   \par
Explanation of arithmetic expression syntax.  

   \par
The syntactic elements for building arithmetic expressions are:  

\begin{verbatim}
           expr ::=  number
                   | vector-name                (for scalar vectors)
                   | vector-name(expr)
                   | vector-name(expr,expr)
                   | vector-name(expr,expr,expr)
                   | [variable-name]            (if value is numeric or
                                                 the name of a scalar vector)
                   | [variable-name](expr...)   (if value is a vector name)
                   | alias-name                 (if value is numeric constant)
                   | $system-function(...)
                   | - expr
                   | expr + expr
                   | expr - expr
                   | expr * expr
                   | expr / expr
                   | (expr)
                   | ABS(expr)
                   | INT(expr)
                   | MOD(expr,expr)
\end{verbatim}
\ENDVERB
   \par
They can be used in the macro statements DO, FOR, and EXITM, in macro 
   variable assignments, as system function arguments where a numeric value is 
   expected, or as the argument to the \$EVAL function.  

   \par
Note that all arithmetic operations are done in floating point, i.e., 
   \DQUOTE{}5/2\DQUOTE{} becomes \DQUOTE{}2.5\DQUOTE{}. If a floating point 
   result appears in a place where an integer is expected, for example as an 
   index, the value is truncated.  

\ENDCMD

\DEFCMD{MSE}{Boolea}{MACRO/SYNTAX/Expressions}{Boolean}{}

   \par
Explanation of Boolean expression syntax.  

   \par
Boolean expressions can only be used in the macro statements IF, WHILE, and 
   REPEAT. The possible syntactic elements are shown below.  

\begin{verbatim}
            bool  ::= expr rel-op expr
                    | string eq-op string
                    | expr eq-op string
                    | .NOT. bool
                    | bool .AND. bool
                    | bool .OR. bool
                    | ( bool )
\end{verbatim}
\begin{verbatim}
           rel-op ::= .LT. | .LE. | .GT. | .GE.
                    |  <   |  <=  |  >   |  >=
                    | eq-op
\end{verbatim}
\begin{verbatim}
           eq-op  ::= .EQ. | .NE.
                    |  =   | <>
\end{verbatim}

\ENDCMD

\DEFCMD{MSE}{String}{MACRO/SYNTAX/Expressions}{String}{}

   \par
Explanation of string expression syntax.  

   \par
String expressions can be used in the macro statements CASE, FOR, and 
   EXITM, in macro variable assignments, as system function arguments where a 
   string value is expected, or as the argument to the \$EVAL function. They 
   may be constructed from the syntactic elements shown below.  

\begin{verbatim}
           string ::= quoted-string
                    | unquoted-string
                    | string // string             (concatenation)
                    | expr // string               (expr represented as string)
                    | [variable-name]
                    | alias-name
                    | $system-function(...)
\end{verbatim}

\ENDCMD

\DEFCMD{MSE}{Garbag}{MACRO/SYNTAX/Expressions}{Garbage}{}

   \par
Explanation of \DQUOTE{}garbage\DQUOTE{} expression syntax.  

   \par
Expressions which do not satisfy any of the other syntax rules we want to 
   call \DQUOTE{}garbage\DQUOTE{} expressions.  For example, 

\begin{verbatim}
           s = $OS$MACHINE
\end{verbatim}
\ENDVERB
   \par
is not a proper string expression. Unless they appear in a macro statement 
   where specifically only an arithmetic or a boolean expression is allowed, 
   KUIP does not complain about these syntax errors. Instead the following 
   transformations are applied:  

\begin{verbatim}
      o  alias substitution
\end{verbatim}
\begin{verbatim}
      o  macro variable replacement; values containing a
         blank character are implicitly quoted
\end{verbatim}
\begin{verbatim}
      o  system function calls are replaced one by one with
         their value provided that the argument is a syntactically
         correct expression
\end{verbatim}
\begin{verbatim}
      o  string concatenation
\end{verbatim}

\ENDCMD
\DEFMENU{2}{Variables}{MACRO/SYNTAX/Variables}
\ifMENUtext
   \par
Explanation of KUIP macro variables.  

   \par
Macro variables do not have to be declared. They become defined by an 
   assignment statement, 

\begin{verbatim}
           name = expression
\end{verbatim}
\ENDVERB
   \par
The right-hand side of the assignment can be an arithmetic expression, a 
   string expression, or a garbage expression (see MACRO/SYNTAX/Expressions). 
   The expression is evaluated and the result is stored as a string (even for 
   arithmetic expressions).  

   \par
A variable value can be used in other expressions or in command lines by 
   enclosing the name in square brackets, [name]. If the name enclosed in 
   brackets is not a macro variable then no substitution takes place.  


\fi

\DEFCMD{MSV}{Number}{MACRO/SYNTAX/Variables}{Numbered}{}

   \par
Accessing macro arguments.  

   \par
The EXEC command can pass arguments to a macro. The arguments are assigned 
   to the numbered variables [1], [2], etc., in the order given in the EXEC 
   command.  The name of the macro, including the file specification, is 
   assigned to [0].  

   \par
A numbered variable cannot be redefined, i.e., an assignment such as 
   \DQUOTE{}1 = foo\DQUOTE{} is illegal.  See MACRO/SYNTAX/SHIFT.  

\ENDCMD

\DEFCMD{MSV}{Specia}{MACRO/SYNTAX/Variables}{Special}{}

   \par
Predefined special macro variables.  

   \par
For each macro the following special variables are always defined:  

\begin{verbatim}
           [0]     Fully qualified name of the macro.
           [#]     Number of macro arguments
           [*]     List of all macro arguments, separated by blanks
           [@]     EXITM return code of the last macro called by
                   the current one.  The value is "0" if the last
                   macro did not supply a return code or no macro
                   has been called yet.
\end{verbatim}
\ENDVERB
   \par
As for numbered variables these names cannot be used on the left-hand side 
   of an assignment. The values or [\#] and [*] are updated by the SHIFT 
   statement.  

\ENDCMD

\DEFCMD{MSV}{Indire}{MACRO/SYNTAX/Variables}{Indirection}{}

   \par
Referencing a macro variable indirectly.  

   \par
Macro variables can be referenced indirectly. If the variable [name] 
   contains the name of another variable the construct 

\begin{verbatim}
           [%name]
\end{verbatim}
\ENDVERB
   \par
is substituted by that other variable's value.  For example, this is 
   another way to traverse the list of macro arguments:  

\begin{verbatim}
           DO i=1,[#]
             arg = [%i]
             ...
           ENDDO
\end{verbatim}
\ENDVERB
   \par
There is only one level of indirection, i.e., the name contained in 
   \DQUOTE{}name\DQUOTE{} may not start with another \DQUOTE{}\%\DQUOTE{}.  

\ENDCMD

\DEFCMD{MSV}{READ}{MACRO/SYNTAX/Variables}{READ}{}

   \par
Reading a variable value from the keyboard.  

\begin{verbatim}
           READ name  [ prompt ]
\end{verbatim}
\ENDVERB
   \par
Variable values can be queried from the user during macro execution. The 
   READ statement prompts for the variable value. If name is already defined 
   the present value will be proposed as default.  

\ENDCMD

\DEFCMD{MSV}{SHIFT}{MACRO/SYNTAX/Variables}{SHIFT}{}

   \par
Manipulation numbered variables.  

   \par
The only possible manipulation of numbered variables is provided by the 
   SHIFT statement which copies [2] into [1], [3] into [2], etc., and discards 
   the value of the last defined numbered variable. For example, the construct 

\begin{verbatim}
           WHILE [1] <> ' ' DO
             arg = [1]
             ...
             SHIFT
           ENDDO
\end{verbatim}
\ENDVERB
   \par
allows to traverse the list of macro arguments.  

\ENDCMD
\DEFMENU{2}{Definitions}{MACRO/SYNTAX/Definitions}
\ifMENUtext
   \par
Statements for defining macros.  


\fi

\DEFCMD{MSD}{MACRO}{MACRO/SYNTAX/Definitions}{MACRO}{}

   \par
Defining a macro.  

   \par
A .kumac file may contain several macros.  An individual macro has the form 

\begin{verbatim}
           MACRO macro-name [ parameter-list ]
              statements
           RETURN
\end{verbatim}
\ENDVERB
   \par
Each statement is either a command line or one of the macro constructs 
   described in this section (MACRO/SYNTAX).  For the first macro in the file 
   the MACRO header can be omitted.  For the last macro in the file the RETURN 
   trailer may be omitted.  Therefore a .kumac file containing only commands 
   (like the LAST.KUMAC) already constitutes a valid macro.  

\ENDCMD

\DEFCMD{MSD}{RETURN}{MACRO/SYNTAX/Definitions}{RETURN}{}

   \par
Ending a macro definition 

\begin{verbatim}
           RETURN [ value ]
\end{verbatim}
   \par
The RETURN statement flags the end of the macro definition and not the end 
   of macro execution, i.e., the construct 

\begin{verbatim}
           IF ... THEN
             RETURN         | error!
           ENDIF
\end{verbatim}
\ENDVERB
   \par
is illegal.  See MACRO/SYNTAX/EXITM.  

   \par
The value is stored into the variable [@] in the calling macro. If no value 
   is given it defaults to zero.  

\ENDCMD

\DEFCMD{MSD}{EXITM}{MACRO/SYNTAX/Definitions}{EXITM}{}

   \par
Terminate macro execution and return to calling macro.  

\begin{verbatim}
           EXITM [ value ]
\end{verbatim}
\ENDVERB
   \par
In order to return from a macro prematurely the EXITM statement must be 
   used.  The value is stored into the variable [@] in the calling macro. If 
   no value is given it defaults to zero.  

\ENDCMD

\DEFCMD{MSD}{STOPM}{MACRO/SYNTAX/Definitions}{STOPM}{}

   \par
Terminate macro execution and return to command line prompt.  

\begin{verbatim}
           STOPM
\end{verbatim}
\ENDVERB
   \par
The STOPM statement unwinds nested macro calls and returns to the command 
   line prompt.  

\ENDCMD

\DEFCMD{MSD}{ENDKUM}{MACRO/SYNTAX/Definitions}{ENDKUMAC}{}

   \par
Ignore rest of KUMAC file.  

   \par
A logical \DQUOTE{}end of file\DQUOTE{} marker.  The KUIP parser will not 
   read any part of a .kumac file which appears after the 
   \DQUOTE{}ENDKUMAC\DQUOTE{} command.  

\ENDCMD
\DEFMENU{2}{Branching}{MACRO/SYNTAX/Branching}
\ifMENUtext
   \par
Macro statements for general flow control.  


\fi

\DEFCMD{MSB}{CASE}{MACRO/SYNTAX/Branching}{CASE}{}

   \par
Select one of many branches.  

\begin{verbatim}
           CASE expression IN
           (label)  statement  [ statements ]
           ...
           (label)  statement  [ statements ]
           ENDCASE
\end{verbatim}
\ENDVERB
   \par
The CASE switch evaluates the string expression and compares it one by one 
   against the label lists until the first match is found. If a match is found 
   the statements up to the next label are executed before skipping to the 
   statement following the ENDCASE. None of the statements are executed if 
   there is no match with any label.  

   \par
Each label is a string constant and the comparison witht the selection 
   expression is case-sensitive.  If the same statement sequence should be 
   executed for distinct values a comma-separated list of values can be used.  

   \par
The \DQUOTE{}*\DQUOTE{} character in a label item acts as wildcard matching 
   any string of zero or more characters, i.e., \DQUOTE{}(*)\DQUOTE{} 
   constitutes the default label.  

\ENDCMD

\DEFCMD{MSB}{GOTOan}{MACRO/SYNTAX/Branching}{GOTO_and_IF_GOTO}{}

   \par
Unconditional and conditional branching.  

\begin{verbatim}
           GOTO label
\end{verbatim}
\ENDVERB
   \par
The simplest form of flow control is provided by the GOTO statement which 
   continues execution at the statement following the target 
   \DQUOTE{}label:\DQUOTE{}. If the jump leads into the scope of a block 
   statement, for example a DO-loop, the result is undefined.  

   \par
The target may be given by a variable containing the actual label name.  

\begin{verbatim}
           IF expression GOTO label
\end{verbatim}
\ENDVERB
   \par
This old-fashioned construct is equivalent to 

\begin{verbatim}
           IF expression THEN
              GOTO label
           ENDIF
\end{verbatim}

\ENDCMD

\DEFCMD{MSB}{IFTHEN}{MACRO/SYNTAX/Branching}{IF_THEN}{}

   \par
Conditional execution of statement blocks.  

\begin{verbatim}
           IF expression THEN
              statements
           ELSEIF expression THEN
              statements
           ...
           ELSEIF expression THEN
              statements
           ELSE
              statements
           ENDIF
\end{verbatim}
\ENDVERB
   \par
The general IF construct executes the statements following the first 
   IF/ELSEIF clause for with the boolean expression is true and then continues 
   at the statement following the ENDIF. The ELSEIF clause can be repeated any 
   number of times or can be omitted altogether. If none of the expressions is 
   true, the statements following the optional ELSE clause are executed.  

\ENDCMD

\DEFCMD{MSB}{ONERRO}{MACRO/SYNTAX/Branching}{ON_ERROR}{}

   \par
Installing an error handler.  

   \par
Each command returns a status code which should be zero if the operation 
   was successful or non-zero if any kind of error condition occurred.  The 
   status code can be tested by \$IQUEST(1) system function.  

\begin{verbatim}
           ON ERROR GOTO label
\end{verbatim}
\ENDVERB
   \par
installs an error handler which tests the status code after each command 
   and branches to the given label when a non-zero value is found.  The error 
   handler is local to each macro.  

\begin{verbatim}
           ON ERROR EXITM  [ expression ]
\end{verbatim}
   \par
and 
\begin{verbatim}
           ON ERROR STOPM
\end{verbatim}
\ENDVERB
   \par
are short-hand notations for a corresponding EXITM or STOPM statement at 
   the targat label.  

\begin{verbatim}
           ON ERROR CONTINUE
\end{verbatim}
\ENDVERB
   \par
continues execution with the next command independent of the status code.  
   This is the initial setting when entering a macro.  

\begin{verbatim}
           OFF ERROR
\end{verbatim}
\ENDVERB
   \par
An error handler can be deactivated by this statement.  

\begin{verbatim}
           ON ERROR
\end{verbatim}
\ENDVERB
   \par
An error handler can be reactivated by this statement.  

\ENDCMD
\DEFMENU{2}{Looping}{MACRO/SYNTAX/Looping}
\ifMENUtext
   \par
Macro statements for construction loops.  


\fi

\DEFCMD{MSL}{DO}{MACRO/SYNTAX/Looping}{DO}{}

   \par
Loop incrementing a loop counter.  

\begin{verbatim}
           DO loop = start_expr, finish_expr  [, step_expr ]
              statements
           ENDDO
\end{verbatim}
\ENDVERB
   \par
The step size (setp_expr) defaults to \DQUOTE{}1\DQUOTE{}. The arithmetic 
   expressions involved can be floating point values but care must be taken of 
   rounding errors.  

   \par
Note that \DQUOTE{}DO i=1,0\DQUOTE{} results in zero iterations and that 
   the expressions are evaluated only once.  

\ENDCMD

\DEFCMD{MSL}{FOR}{MACRO/SYNTAX/Looping}{FOR}{}

   \par
Loop over items in an expression list.  

\begin{verbatim}
           FOR name IN expr_1 [ expr_2 ... expr_n ]
              statements
           ENDFOR
\end{verbatim}
\ENDVERB
   \par
In a FOR-loop the number of iterations is determined by the number of items 
   in the blank-separated expression list. The expression list must not be 
   empty. One by one each expression evaluated and assigned to the variable 
   name before the statements are executed.  

   \par
The expressions can be of any type: arithmetic, string, or garbage 
   expressions, and they do not need to be all of the same type. In general 
   each expression is a single list item even if the result contains blanks.  

   \par
The variable [*] is treated as a special case being equivalent to the 
   expression list \DQUOTE{}[1] [2] ... [n]\DQUOTE{} which allows yet another 
   construct to traverse the macro arguments:  

\begin{verbatim}
           FOR arg IN [*]
              ...
           ENDFOR
\end{verbatim}

\ENDCMD

\DEFCMD{MSL}{REPEAT}{MACRO/SYNTAX/Looping}{REPEAT}{}

   \par
Loop until condition becomes true.  

\begin{verbatim}
           REPEAT
              statements
           UNTIL expression
\end{verbatim}
\ENDVERB
   \par
The body of a REPEAT-loop is executed at least once and iterated until the 
   boolean expression evaluates to true.  

\ENDCMD

\DEFCMD{MSL}{WHILE}{MACRO/SYNTAX/Looping}{WHILE}{}

   \par
Loop while condition is true.  

\begin{verbatim}
           WHILE expression DO
              statements
           ENDWHILE
\end{verbatim}
\ENDVERB
   \par
The WHILE-loop is iterated while the boolean expression evaluates to true. 
   The loop body is not executed at all if the boolean expression is false 
   already in the beginning.  

\ENDCMD

\DEFCMD{MSL}{BREAKL}{MACRO/SYNTAX/Looping}{BREAKL}{}

   \par
Terminate a loop.  

\begin{verbatim}
           BREAKL [ level ]
\end{verbatim}
\ENDVERB
   \par
Allows to terminate a loop prematurely. The BREAKL continues executing 
   after the end clause of a DO, FOR, WHILE, or REPEAT block, where 
   \DQUOTE{}level\DQUOTE{} indicates how many nested constructs to terminate.  
   The default value level=1 terminates the innermost loop construct.  

\ENDCMD

\DEFCMD{MSL}{NEXTL}{MACRO/SYNTAX/Looping}{NEXTL}{}

   \par
Continue with next loop iteration.  

\begin{verbatim}
           NEXTL [ level ]
\end{verbatim}
\ENDVERB
   \par
Allows to continue with the next loop iteration without executing the rest 
   of the loop body.  Execution continues just before the end clause of a DO, 
   FOR, WHILE, or REPEAT block, where \DQUOTE{}level\DQUOTE{} indicates how 
   many nested blocks to skip.  The default value level=1 skips to the end of 
   the innermost loop construct.  

\ENDCMD
\DEFMENU{0}{VECTOR}{VECTOR}
\ifMENUtext
   \par
Vector Processor commands.  Vectors are equivalent to FORTRAN 77 arrays and 
   they use the same notation except when omitting indexes (see last line 
   below).  Up to 3 dimensions are supported. Examples:  
\begin{verbatim}
    Vec(20) (mono-dimensional with 20 elements)
\end{verbatim}
   \par
may be addressed by:  
\begin{verbatim}
    Vec          for all elements
    Vec(13)      for element 13-th
    Vec(12:)     for elements 12-th to last
    Vec(:10)     for elements first to 10-th
    Vec(5:8)     for elements 5-th to 8-th
\end{verbatim}
\begin{verbatim}
    Vec(3,100) (2-dimensional with 3 columns by 100 rows):
\end{verbatim}
   \par
may be addressed by:  
\begin{verbatim}
    Vec(2,5:8)   for elements 5-th to 8-th in 2-nd column
    Vec(2:3,5:8) for elements 5-th to 8-th in 2-nd to 3-rd columns
    Vec(2,5)     for element 5-th in 2-nd column
    Vec(:,3)     for all elements in 3-rd row
    Vec(2)       for all elements in 2-nd column (SPECIAL CASE)
\end{verbatim}
   \par
The latest line shows the special (and non-standard with FORTRAN 77) 
   notation such that missing indexes are substituted to the right.  

   \par
An 'invisible' vector called '?', mono-dimensional and of length 100, is 
   always present. Is is used for communicating between user arrays and KUIP 
   vectors, being equivalenced with the real array VECTOR(100) in the labeled 
   common block /KCWORK/.  


\fi

\DEFCMD{V}{CREATE}{VECTOR}{CREATE}{ vname [ type values ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name(length)}{}
\DEFARG{TYPE}{C}{Vector type}{ D='R'}
\DEFARG{VALUES}{C}{Value list}{ D=\EMPTY{} Separate Vararg}
\ENDARG
\BEGOPT{TYPE}
\DEFOPT{R}{}
\DEFOPT{I}{}
\ENDOPT

   \par
Create a vector named VNAME (elements are set to zero).  The dimensions are 
   taken from the name, for example VEC(20), VEC(3,100), VEC(2,2,10).  Up to 3 
   dimensions are supported. Dimensions which are not specified are taken to 
   1, for example VEC(10) ---\KET{} VEC(10,1,1) and VEC ---\KET{} VEC(1,1,1).  
   The vector may be of type Real or Integer.  A vector is filled at the same 
   time if parameters are given after the TYPE:  
\begin{verbatim}
    VEC/CREATE V(10) R 1 2 3 4 5 66 77 88 99 111
    VEC/CREATE W(20) R 1 2 3
\end{verbatim}
   \par
In the last example only the first three elements are filled.  Vector 
   elements may be changed later with the command VECTOR/INPUT.  

   \par
If many equal values have to be entered consecutively, one can specify just 
   one value and precede it by a repetition factor and an asterisk. Example:  
\begin{verbatim}
    VEC/CREATE Z(20) R 5*1 2 4*3   --->   VEC/CREATE Z(20) R 1 1 1 1 1 2 3 3 3 
   3
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{LIST}{VECTOR}{LIST}{}

   \par
List all vectors (name, dimensions, type).  

\ENDCMD

\DEFCMD{V}{DELETE}{VECTOR}{DELETE}{ vlist}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Delete from memory all vectors in the list VLIST.  The vectors are 
   separated in the list by a comma and embedded blanks are not allowed. An 
   asterisk at the end of VLIST acts as wild-card:  
\begin{verbatim}
    VEC/DEL AB*          --->  deletes all vectors starting by AB
    VEC/DEL *            --->  deletes all vectors
\end{verbatim}

\ENDCMD

\DEFCMD{V}{COPY}{VECTOR}{COPY}{ vnam1 vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
Copy a vector into another one.  Mixed vector type copy is supported (e.g. 
   Integer ---\KET{} Real and viceversa).  If VNAM2 does not exist it is 
   created with the required dimensions, not necessarily the same as the 
   source vector if a sub-range was specified.  For example, if A is a 3 x 100 
   vector and B does not exist, COPY A(2,11:60) B will create B as a 50 
   elements mono-dimensional vector; a special (and non-standard with FORTRAN 
   77) notation is used such that, still using the above vectors, COPY 
   A(2,1:100) B and COPY A(2) B have the same effect.  

   \par
Note that VECTOR/COPY does not allow a range for the destination vector not 
   specifying consecutive elements (i.e. along the first dimension):  
\begin{verbatim}
    VEC/COPY V(5)      W(3,4)     | O.K.
    VEC/COPY V1(2:3,5) V2(4:5,9)  | O.K.
    VEC/COPY V1(5,2:3) V2(4:5,9)  | O.K.
    VEC/COPY V1(3,3:4) V2(4,4:5)  | NOT allowed
    VEC/COPY V1(2:3,5) V2(2,4:5)  | NOT allowed
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{INPUT}{VECTOR}{INPUT}{ vname [ values ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{VALUES}{C}{Value list}{ D=\EMPTY{} Separate Vararg}
\ENDARG

   \par
Enter values into a vector from the terminal.  Example:  
\begin{verbatim}
    VEC/INPUT V(6:10) 1.1 2.22 3.333 4.4444 5.55555
\end{verbatim}
   \par
If many equal values have to be entered consecutively, one can specify just 
   one value and precede it by a repetition factor and an asterisk. Example:  
\begin{verbatim}
    VEC/INPUT V 5*1 2 4*3   --->   VEC/INPUT V 1 1 1 1 1 2 3 3 3 3
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{PRINT}{VECTOR}{PRINT}{ vname [ dense ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{DENSE}{I}{Output density}{ D=1 R=0:2}
\ENDARG

   \par
Write to the terminal the content of a vector.  Enter HELP VECTOR for more 
   information on vector addressing.  

   \par
If DENSE.EQ.0 the output is one vector element per line.  If DENSE.EQ.1 the 
   output for a sequence of identical vector elements is compressed to two 
   lines stating the start and end indices.  If DENSE.EQ.2 the output for a 
   sequence of identical vector elements is compressed to a single line.  

\ENDCMD

\DEFCMD{V}{READ}{VECTOR}{READ}{ vlist fname [ format opt match ]}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Format}{ D=\EMPTY{}}
\DEFARG{OPT}{C}{Options}{ D='OC'}
\DEFARG{MATCH}{C}{Matching pattern}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPT}
\DEFOPT{OC}{}
\DEFOPT{O}{}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{}
\ENDOPT

   \par
Enter values into vector(s) from a file.  A format can be specified, e.g. 
   FORMAT='F10.5,2X,F10.5', or the free format is used if FORMAT is not 
   supplied.  

   \par
If vector(s) are not existing they will be created of the size as read from 
   the file.  

   \par
Vectors in the list VLIST are separated by a comma and embedded blanks are 
   not allowed. If subscripts are present in vector names, the smallest one is 
   taken.  

   \par
OPT is used to select between the following options:  
\begin{verbatim}
    'OC'   file is Opened, read and then Closed (default case)
    'O'    file is Opened and then read (left open for further reading)
    ' '    file is read (already open, left so for further reading)
    'C'    file is read and then Closed (already open)
\end{verbatim}
   \par
If the character 'Z' is present in OPT, the vector elements equal to zero 
   after reading are set to the latest non-zero element value (for example 
   reading 1 2 3 0 0 4 0 5 will give 1 2 3 3 3 4 4 5).  

   \par
MATCH is used to specify a pattern string, restricting the vector filling 
   only to the records in the file which verify the pattern. Example of 
   patterns:  
\begin{verbatim}
     /string/      match a string (starting in column 1)
    -/string/      do not match a string (starting in column 1)
     /string/(n)   match a string, starting in column n
     /string/(*)   match a string, starting at any column
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{WRITE}{VECTOR}{WRITE}{ vlist [ fname format chopt ]}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Format}{ D='5(1X,G13.7)'}
\DEFARG{CHOPT}{C}{Options}{ D='OC'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{OC}{}
\DEFOPT{O}{}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{}
\ENDOPT

   \par
Write to a file the content of vector(s).  If FNAME=' ' the content is 
   written to the terminal.  A format can be specified, e.g. 
   FORMAT='F10.5,2X,F10.5', or the default one is used if FORMAT is not 
   supplied.  

   \par
Vectors in the list VLIST are separated by a comma and embedded blanks are 
   not allowed. If subscripts are present in vector names, the smallest one is 
   taken.  

   \par
CHOPT is used to select between the following options:  
\begin{verbatim}
    'OC'   file is Opened, written and then Closed (default case)
    'O'    file is Opened and then written (left open for further writing)
    ' '    file is written (already open, left so for further writing)
    'C'    file is written and then Closed (already open)
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD
\DEFMENU{1}{OPERATIONS}{VECTOR/OPERATIONS}
\ifMENUtext
   \par
Simple arithmetic operations between vectors.  In all the operations only 
   the minimum vector length is considered, i.e. an operation between a vector 
   A of dimension 10 and a vector B of dimension 5 will involve the first 5 
   elements in both vectors.  If the destination vector does not exist, it is 
   created with the same length as the source vector.  


\fi

\DEFCMD{VO}{VBIAS}{VECTOR/OPERATIONS}{VBIAS}{ vnam1 bias vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{BIAS}{R}{Bias value}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM2(I) = BIAS     + VNAM1(I) 

\ENDCMD

\DEFCMD{VO}{VSCALE}{VECTOR/OPERATIONS}{VSCALE}{ vnam1 scale vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{SCALE}{R}{Scale factor}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM2(I) = SCALE    * VNAM1(I) 

\ENDCMD

\DEFCMD{VO}{VADD}{VECTOR/OPERATIONS}{VADD}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) + VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VMULTI}{VECTOR/OPERATIONS}{VMULTIPLY}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) * VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VSUBTR}{VECTOR/OPERATIONS}{VSUBTRACT}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) - VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VDIVID}{VECTOR/OPERATIONS}{VDIVIDE}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) / VNAM2(I)     ( or 0 if VNAM2(I)=0 ) 

\ENDCMD
