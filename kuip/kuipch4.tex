%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                 %
%   KUIP  - Reference Manual -- LaTeX Source                      %
%                                                                 %
%   Chapter 4: KUIP Calling sequences                             %
%                                                                 %
%   External EPS files referenced: none                           %
%                                                                 %
%   Editor: Michel Goossens / CN-AS                               %
%   Last Mod.: 10 Dec  1991   mg                                  %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\Vskip{\vspace{\baselineskip}}
\chapter{\KUIP{} calling sequences}

In the specification of arguments for the \KUIP{} calling sequences
the Fortran-77 conventions are followed,
i.e.\ integer type arguments are starting with \Lit{I-N}, and
character type arguments always start with \Lit{CH}.

The scope of variables is \Lit{INPUT} (by default),
\Lit{OUTPUT} (if a \Lit{*} follows the name), \Lit{INPUT-OUTPUT} 
(if a~\Lit{*} precedes and follows the parameter's name).
%---------------------------------------------------------------------------
\section{Control}

\Shubr{KUINIT}{(NWORDS)}
\Action creates a division in ZEBRA store for \KUIP{}
and initializes the root bank.
The division is
created in the common \Lit{/PAWC/} which must be declared in the
user code. Calls
to \Rind{ZEBRA} and \Rind{MZPAW} are mandatory before the call to \Rind{KUINIT}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[NWORDS] number of words to be allocated as minimum
size of \KUIP{} division in the ZEBRA store.
\end{DLtt}

\Vskip\Shubr{KUWHAG}{}
\Action to be called (in alternative to \Rind{KUWHAT}) to give control to \KUIP{}.
The commands \Command{KUIP/QUIT} or
\Command{KUIP/EXIT} cause a return from this routine.
See also \Rind{KUWHAT} (below).
The difference from \Rind{KUWHAT} is that \Rind{KUWHAG} loads explicitly some
HIGZ \cite{bib-HIGZ} and GKS \cite{bib-GKS1} routines, allowing the user
to enter the HIGZ Graphics mode (by the command \Cind[STYLE]{STYLE G} or 
\Command{STYLE GP}).

\Vskip\Shubr{KUWHAT}{}
\Action to be called (in alternative to \Rind{KUWHAG}) to give control to \KUIP{}.
The commands \Cind[QUIT]{KUIP/QUIT} or \Cind[EXIT]{KUIP/EXIT} 
cause a return from this routine.
See also \Rind{KUWHAG} (above).
The difference from \Rind{KUWHAG} is that \Rind{KUWHAT} does not load explicitly any
HIGZ \cite{bib-HIGZ}
or
GKS \cite{bib-GKS1} routines, preventing the user
from entering the HIGZ Graphics mode (by the command 
\Cind[STYLE]{'STYLE G'} or \Command{'STYLE GP'}).


\Vskip\Shubr{KUWHAM}{(CHCLASS)}
\label{ref:rekuwham}
\Action gives control to the \Motif{} main loop of events (XtAppMainLoop).
\Pdesc\begin{DLtt}{mmmmmmmmmm}
\item[CHCLASS] application class-name: name 
to be used for setting the application resources (see section 
\ref{ref:rekmres}). If CHCLASS=' ' then the class-name is set by default
to ``Mkuip''.
\end{DLtt}

\Shubr{KUINIM} {(CHCLASS)}
\Action Special \KUIP{} initialization for using \KUIPMotif{} with HIGZ (graphical 
application).
\Pdesc\begin{DLtt}{mmmmmmmmmm}
\item[CHCLASS] application class-name: name 
to be used for setting the application resources (see section
\ref{ref:rekmres}). If CHCLASS=' ' then the class-name is set by default
to ``Mkuip''.
\end{DLtt}

\Vskip\Shubr{KUEXEC}{(CHLINE)}
\Action decodes the command line \Rarg{CHLINE} into command path plus parameters
and executes it.
This routine is therefore an alternative to the standard input modes
(selected by the command 'STYLE') of \KUIP{} after the call to
\Rind{KUWHAT} or \Rind{KUWHAG}.

On the IBM this routine, if called within an action routine,
does not work: it may be called
only before calling \Rind{KUWHAG} or \Rind{KUWHAT}. On the other hand it can also execute
a macro, e.g.\ \Rind[KUEXEC]{CALL KUEXEC('EXEC LOGON')}.

See also \Rind{KUEXEL}(page \pageref{ref:rekuex}).
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHLINE] command line to be executed
\end{DLtt}

\Shubr{KUEXEL}{(CHLINE)}   
\label{ref:rekuex}
\Action decodes the command line \Rarg{CHLINE} into command path plus parameters
and executes it.

It works on all machines, also if called within an action routine.
On the other hand it cannot execute a macro, i.e.\ the command \Cind{EXEC}.

See also \Rind{KUEXEC}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHLINE] command line to be executed
\end{DLtt}

\Vskip\Shubr{KUEXIT}{(EXROUT)}
\Action defines the user exit routine, which is called by entering the command 
\Cind{EXIT}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[EXROUT] Name of the user exit routine (must be defined as \Lit{EXTERNAL})
\end{DLtt}

\Shubr{KUQUIT}{(QUROUT)}
\Action defines the user quit routine, which is called by entering the command 
\Cind{QUIT}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[QUROUT] Name of the user quit routine (must be defined as \Lit{EXTERNAL})
\end{DLtt}

%---------------------------------------------------------------------------

\section{Parameter retrieval}

\Shubr{KUGETC}{(CHPAR*,LENGTH*)}
\Action gets a character string parameter from the decoded command line
and returns it in upper case.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPAR] Character string parameter read in
\item[LENGTH] Logical length of the string above, i.e.\ without
trailing blanks.
{\tt LENGTH=0 if CHPAR=' '}.
\end{DLtt}

\Shubr{KUGETE}{(CHEXPR*,LENGTH*)}
\Action gets the remaining string (or expression) from the
decoded command line.
The string can be any expression, containing single quote characters,
slashes, blanks, etc.
It must follow the last formal parameter of a command line.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHEXPR] Expression string read in
\item[LENGTH] Logical length of the string,
i.e.\ without trailing blanks.
{\tt LENGTH=0 if CHEXPR=' '}.
\end{DLtt}

\Shubr{KUGETF}{(CHPAR*,LENGTH*)}
\Action gets a file parameter from the
decoded command line.
It is equivalent to \Rind{KUGETS} (see below); in addition
the file name is converted to upper case on IBM (VM-CMS and MVS-TSO),
to lower case elsewhere.
On UNIX platforms, if STYLE '-FILECASE ON' was entered,
the case conversion will not be performed,
thus permitting mixed case file names.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPAR] File parameter read in
\item[LENGTH] Logical length of the string above, i.e.\ without
trailing blanks.
{\tt LENGTH=0 if CHPAR=' '}.
\end{DLtt}

\Shubr{KUGETH}{(HOPAR*,LENGTH*)}
\Action gets an Hollerith parameter from the
decoded command line and return it in upper case.
Note: when the string from the command line is '0' the result is a numeric 0
and not an Hollerith '0'.
\Pdesc\begin{DLtt}{MMMMMM}
\item[HOPAR (must be declared as integer)] Hollerith parameter read in
\item[LENGTH] Logical length of the string above, i.e.\ without
trailing blanks.
\Rarg{LENGTH=0} if \Lit{HOPAR=' '}.
\end{DLtt}

\Shubr{KUGETI}{(IPAR*)}
\Action gets an integer type parameter from the
decoded command line.
An integer parameter
must be entered in a form readable by the I~format descriptor of Fortran.
\Pdesc\begin{DLtt}{MMMMMM}
\item[IPAR] Integer parameter read in
\end{DLtt}

\Shubr{KUGETL}{(CHPAR*,LENGTH*)}
\Action gets the next list element of a string parameter from the
decoded command,
i.e.\ get a sub-parameter of the result of \Rind{KUGETC} or \Rind{KUGETS},
hence \Rind{KUGETL} must be called after \Rind{KUGETC} or \Rind{KUGETS}.
Sub-parameters must be separated by a comma.
If {\tt LENGTH=0} no more elements are present.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPAR] Character string parameter read in
\item[LENGTH] Logical length of the string above, i.e.\ without
trailing blanks.
\end{DLtt}

\Shubr{KUGETR}{(RPAR*)}
\Action gets a real type parameter from the
decoded command line.
A real parameter
must be entered in a form readable by I, F or E~format descriptors of Fortran.
\Pdesc\begin{DLtt}{MMMMMM}
\item[RPAR] Real parameter read in
\end{DLtt}

\Shubr{KUGETS}{(CHPAR*,LENGTH*)}
\Action gets a character string parameter from the
decoded command line
(with no case conversion).
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPAR] Character string parameter read in
\item[LENGTH] Logical length of the string above, i.e.\ without
trailing blanks.
{\tt LENGTH=0 if CHPAR=' '}.
\end{DLtt}

\Shubr{KUGETV}{(CHNAME*, LLOW*,LHIGH*)}
\Action gets vector from the
decoded command line.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHNAME] vector name
\item[LLOW] low address
\item[LHIGH] high address
\end{DLtt}
\Remark
If the vector was not previously created then \Rarg{LLOW=0} and \Rarg{LHIGH=0}.

Vector \Rarg{CHNAME} can be accessed by \Lit{Q(LLOW:LHIGH)} if \Lit{ITYPE=1},
or \Lit{IQ(LLOW:LHIGH)} if \Lit{ITYPE=2}
(\Lit{Q} and \Lit{IQ} are equivalenced in the ZEBRA
store \Lit{/PAWC/}, see the example below).

\subsubsection*{KUGETV return codes}

The ZEBRA vector \Lit{/IQUEST/}, which is used to pass information
from ZEBRA to the user, will contain on return:

\begin{DLtt}{1234567890}
\item[IQUEST(10)] \Rarg{NCHNAM}, the number of characters of \Rarg{CHNAME}.
\item[IQUEST(11)] \Rarg{LENTOT}, the total number of elements of the vector.
\item[IQUEST(12)] \Rarg{ILOW}, the lower boundary of the vector.
\item[IQUEST(13)] \Rarg{IHIGH}, the higher boundary of the vector.
\item[IQUEST(14)] \Rarg{ITYPE}, the type of the elements (1=real, 2=integer, 3=Hollerith)
\end{DLtt}

\Sfunc{KUNPAR}{NP = KUNPAR (IDUMMY)}
\Action returns the number of parameters supplied
in the last command line entered
following the prompt issued by \KUGETx{}. Hence, it must
be called after \KUGETx{}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[IDUMMY] dummy argument
\end{DLtt}



\Shubr{KUPATL}{(CHPATH*,NPAR*)}
\Action returns the bottom level command element.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPATH] bottom level command element (must be defined as {\tt CHARACTER*32)}
\item[NPAR] number of parameters given in the command line
\end{DLtt}

\Shubr{KUPATH}{(CHPATH*, NLEV*,NPAR*)}
\Action returns the decoded command line arguments. 
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPATH] command element full path 
(must be defined as {\tt CHARACTER*32 CHPATH(10)})
\item[NLEV] number of command element in the command element full path
\item[NPAR] number of parameters given in the command line
\end{DLtt}
\begin{XMPt}{Example of the use of KUPATH}
If H/H/DIV or HISTOGRAM/OPERATIONS/DIVIDE is entered, then ...
 
      CHARACTER*32 CHPATH(10),CHPATL
 
      CALL KUPATH(CHPATH,NLEV,NPAR)
      CALL KUPATL(CHPATL,NPAR)
 
 ...   will return   ...
 
CHPATH(1)='HISTOGRAM'
CHPATH(2)='OPERATIONS'
CHPATH(3)='DIVIDE'
NLEV=3
CHPATL='DIVIDE'
\end{XMPt}



\Shubr{KUSPY}{(CHOPT)}
\Action allows the application to spy parameters
(always using the \KUGETx{} routines) before retrieving them
effectively with \KUGETx{}.
Note: Calling \Command{KUSPY('NEVER')} will disable automatic \Lit{SPY ON/OFF} mechanism
in \Rind{KUPROx} routines, until \Command{KUSPY('ON')} is called again.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHOPT] option
\end{DLtt}
Suppose that a command has 5 parameters; the third one (of type Character)
is used to specify whether the first two parameters are either
of type Integer or of type Character (i.e.\ whether they must be
retrieved either by \Rind{KUGETI} or by \Rind{KUGETC}); therefore one wants
to retrieve the parameters twice, a first time to spy only
the third one plus a second time to retrieve all in the correct way.
\begin{figure}[tb]\centering
\begin{XMPin}[.51]{Steering routine}
   SUBROUTINE GETPAR
   CHARACTER*8 CHP1,CHP2,CHP3,CHP4,CHP5
   CALL CHECK(ISTAT)
   IF (ISTAT.EQ.1) THEN
     CALL KUGETI(IP1)
     CALL KUGETI(IP2)
     CALL KUGETC(CHP3,NCH)
   ELSEIF (ISTAT.EQ.2) THEN
     CALL KUGETC(CHP1,NCH)
     CALL KUGETC(CHP2,NCH)
     CALL KUGETC(CHP3,NCH)
   ELSE
     GO TO 99
   ENDIF
   CALL KUGETC(CHP4,NCH)
   CALL KUGETC(CHP5,NCH)
   ...
99 END
\end{XMPin}
\begin{XMPout}[.47]{Spying routine}
      SUBROUTINE CHECK(ISTAT)
      CHARACTER*8 CHP1,CHP2,CHP3
      CALL KUSPY('ON')
      CALL KUGETC(CHP1,NCH)
      CALL KUGETC(CHP2,NCH)
      CALL KUGETC(CHP3,NCH)
      CALL KUSPY('OFF')
      IF (CHP3.EQ.'-I') THEN
        ISTAT=1
      ELSEIF (CHP3.EQ.'-C') THEN
        ISTAT=2
      ELSE
        ISTAT=-1
      ENDIF
      END
\end{XMPout}
\end{figure}

\Shubr{KUPROC}{(CHPROM, CHPAR*,LENGTH*)}
\Action writes the string \Rarg{CHPROM} on the terminal
and reads the character variable \Rarg{CHPAR}
returning it in upper case.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPROM] prompt string
\item[CHPAR] Character parameter read in
\item[LENGTH] Logical length of string, i.e.\ without
trailing blanks.
\Rarg{LENGTH=0} if \Rarg{CHPAR=' '}.
\end{DLtt}

\Shubr{KUPROI}{(CHPROM,IPAR*)}
\Action writes the string \Rarg{CHPROM} on the terminal
and reads the integer variable \Rarg{IPAR}.
An integer parameter
must be entered in a form readable by the \Lit{I}~format descriptor of Fortran.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPROM] prompt string
\item[IPAR] Integer parameter read in
\end{DLtt}

\Shubr{KUPROR}{(CHPROM,RPAR*)}
\Action writes the string \Rarg{CHPROM} on the terminal
and reads the real variable \Rarg{RPAR}.
A real parameter
must be entered in a form readable by \Lit{I}, \Lit{F} 
or \Lit{E}~format descriptors of Fortran.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPROM] prompt string
\item[RPAR] Real parameter read in
\end{DLtt}

\Shubr{KUPROS}{(CHPROM, CHPAR*,LENGTH*)}
\Action writes the string \Rarg{CHPROM} on the terminal
and reads the character variable \Rarg{CHPAR}
(with no case conversion).
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPROM] prompt string
\item[CHPAR] Character parameter read in
\item[LENGTH] Logical length of string, i.e.\ without
trailing blanks.
\Rarg{LENGTH=0} if \Rarg{CHPAR=' '}.
\end{DLtt}
%---------------------------------------------------------------------------

\section{Vector handling}

\Shubr{KUVECT}{(CHNAME, LLOW*,LHIGH*)}
\Action gets address of vector {\tt CHNAME}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHNAME] vector name
\item[LLOW] low address, or 0 if the vector does not exist
\item[LHIGH] high address, or 0 if the vector does not exist
\end{DLtt}
\Remark
The vector {\tt CHNAME} can be accessed by 
{\tt Q(LLOW:LHIGH)} if {\tt ITYPE=1},
or {\tt IQ(LLOW:LHIGH)} if {\tt ITYPE=2}
({\tt Q} and {\tt IQ} are equivalenced in the ZEBRA
store {\tt /PAWC/}, see the example below).
If the vector was not previously created then {\tt LLOW=LHIGH=0}.
The ZEBRA store {\tt /IQUEST/}, which is generally used to pass information
from ZEBRA to the user, will contain on return:

\begin{DLtt}{1234567890}
\item[IQUEST(10)] \Rarg{NCHNAM}, the number of characters of \Rarg{CHNAME}.
\item[IQUEST(11)] \Rarg{LENTOT}, the total number of elements of the vector.
\item[IQUEST(12)] \Rarg{ILOW}, the lower boundary of the vector.
\item[IQUEST(13)] \Rarg{IHIGH}, the higher boundary of the vector.
\item[IQUEST(14)] \Rarg{ITYPE}, the type of the elements (1=real, 2=integer, 3=Hollerith)
\end{DLtt}

\begin{figure}[tb]
\begin{XMPt}{Example of the use of KUVECT}
      COMMON /PAWC/ NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKUIP,IFENCE(5),
     +              LMAIN, WS(9989)
      DIMENSION IQ(1),Q(1),LQ(8000)
      EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN)
      COMMON /QUEST/ IQUEST(100)
 
      CALL KUGETV('MYVECT',LLOW,LHIGH)
 
      IF (LLOW.EQ.0) THEN
        PRINT *,'Vector does not exist'
      ELSE
        IF (IQUEST(14).EQ.1) THEN
          PRINT *,'Element are:',(Q(I),I=LLOW,LHIGH)
        ELSE IF (IQUEST(14).EQ.2) THEN
          PRINT *,'Element are:',(IQ(I),I=LLOW,LHIGH)
        ENDIF
      ENDIF
\end{XMPt}
\end{figure}


\Shubr{KUVCRE}{(CHNAME, CHTYPE, LENGTH, LLOW*, LHIGH*)}
\Action creates a \KUIP{} vector of a given type and length 
and returns its address in the ZEBRA store.

\Pdesc\begin{DLtt}{MMMMMM}
\item[CHNAME] Vector name
\item[CHTYPE] Vector type (\Ropt{R} for real or \Ropt{I} for integer)
\item[LENGTH] Vector length array (dimensioned to 3) with \Rarg{LENGTH(I)} containing
the \Lit{I}-th dimension length or 0 if the dimension is not used;
e.g.\ \Lit{LENGTH(1)=10} and \Lit{LENGTH(2)=LENGTH(3)=0} 
define a one-dimensional vector of length 10.
\item[LLOW] Returned low address in the \Lit{Q} store
\item[LHIGH] Returned high address in the \Lit{Q} store
\end{DLtt}

The vector is accessed as \Lit{Q(LLOW:LHIGH)} for \Rarg{CHTYPE='R'}
or as \Lit{IQ(LLOW:LHIGH)} for \Rarg{CHTYPE='I'}.
If \Lit{LLOW=0} an error occurred.

\Shubr{KUVDEL}{(CHNAME)}
\Action deletes the \KUIP{} vector named {\tt CHNAME}.
If {\tt CHNAME='*'} all vectors are deleted.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHNAME] Vector name
\end{DLtt}

\Shubr{KUVEC}{(CHNAME, *X*, NELEMS,CHOPT)}
\Action performs some vector operations,
namely creation and copying of a Fortran array from/to a \KUIP{} vector,
depending on the argument \Rarg{CHOPT}.

\Pdesc\begin{DLtt}{MMMMMM}
\item[CHNAME] Vector name
\item[X] Fortran array
\item[NELEMS] Number of elements to be copied
\item[CHOPT] Character variable specifying the required option
\begin{DLtt}{123}
\item['R'] read into array \Rarg{X} the content of vector \Rarg{CHNAME}
           (i.e.\ \Lit{CHNAME => X})
          starting at vector element \Rarg{ILOW}
          (e.g.\ \Lit{ILOW=1} is the first one).\\
          \Rarg{NELEMS} elements are read (\Lit{CHNAME(ILOW:ILOW+NELEMS-1})
          or all if \Lit{NELEMS\(\leq\)0} or \Lit{NELEMS\(\geq\)LENTOT}.\\
          If the vector does not exist, then \Lit{IQUEST(1)=1}.
\item[' '] same as \Ropt{R}.
\item['W'] write array \Rarg{X} into vector \Rarg{CHNAME} 
          (i.e.\ \Lit{X => CHNAME})
          starting at vector element \Rarg{ILOW}
          (e.g.\ \Lit{ILOW=1} is the first one).
          \Rarg{NELEMS} elements are written e.g.\ \Lit{X(1:NELEMS)}.
          If the vector is not large enough, it is automatically extended.
          If the vector does not exist, it is created.
\item['-'] (used together with option \Ropt{W}) same as \Lit{CHOPT='W'} and in addition
          the vector is shrunk to its actual size.
\item['C'] just create the vector if it does not exist.
\item['I'] (used together with option \Ropt{W} or \Ropt{C}) vector is of type Integer
          (default case is Real)
\item['H'] (used together with option \Ropt{W} or \Ropt{C}) vector is of type Hollerith
          (default case is Real)
\end{DLtt}
\end{DLtt}

Note that here \Rarg{ILOW} stands for \Lit{ILOW(IDIM)},
\Rarg{IHIGH} for \Lit{IHIGH(IDIM)} and \Rarg{LENTOT}
for \Lit{LENGTH(IDIM)}, where \Lit{IDIM} is the dimension (1, 2 or 3) affected.

\subsubsection*{IQUEST return code}
\index{QUEST@{\tt QUEST}}

\begin{DLtt}{1234567890}
\item[IQUEST(10)] \Rarg{NCHNAM} (number of characters of \Rarg{CHNAME})
\item[IQUEST(11)] \Rarg{LENTOT} (total number of elements of vector)
\item[IQUEST(12)] \Rarg{LLOW}  (low address)
\item[IQUEST(13)] \Rarg{LHIGH} (high address)
\item[IQUEST(14)] \Rarg{ITYPE} (type: 1=real, 2=integer, 3=Hollerith)
\item[IQUEST(20)] \Rarg{ICOPY} (if $\neq 0$ a copy on a temporary vector was done,
                     with \Rarg{LENFR} and \Rarg{LENTO} addresses defined as follow)
\item[IQUEST(21)] \Rarg{LENFR(1)}
\item[IQUEST(22)] \Rarg{LENFR(2)}
\item[IQUEST(23)] \Rarg{LENFR(3)}
\item[IQUEST(31)] \Rarg{LENTO(1)}
\item[IQUEST(32)] \Rarg{LENTO(2)}
\item[IQUEST(33)] \Rarg{LENTO(3)}
\end{DLtt}

The vector elements can be addressed individually, if the common block \Lit{/PAWC/}
is present, by \Lit{Q(LLOW+I)} or \Lit{IQ(LLOW+I)}, with \Lit{I} ranging from 
\Lit{0} to 1 \Lit{LENTOT-1}.

The array \Rarg{X} should be defined in the calling routine of the right type,
INTEGER or REAL, corresponding to the vector type.

Only one dimension can be handled by this routine, ex. \Rarg{CHNAME} can be
\Lit{VEC(3)}, \Lit{VEC(2,3:5)}, etc.\ if \Lit{VEC} is two-dimensional,
but cannot be \Lit{VEC(2:3,3:5)}.
%---------------------------------------------------------------------------
\section{Break handling}

\Shubr{KUBREK}{(BREROU)}
\Action defines the break recovering routine, called after a break interception.
\Pdesc\begin{DLtt}{MMMMMM}
\item[BREROU] User break routine (must be defined as EXTERNAL)
\end{DLtt}

\Shubr{KUSIBR}{}
\Action simulates a break exception.

\Vskip\Shubr{KUBROF}{}
\Action disables the keyboard interrupt (e.g.\ \Lit{CTRL/C}),
i.e.\ a keyboard interrupt
will have no effect whatsoever and the program will continue.

Commands which should never be interrupted (like writing on disk, etc.)
should be protected by calling \Rind{KUBROF} inside their
corresponding actions routine.
\Rind{KUBRON} is always called before the execution of a new command,
thus re-enabling the break handling, if previously disabled;
this means that \Rind{KUBRON} is valid for the command in whose action
routine \Rind{KUBROF} was called.

\Vskip\Shubr{KUBRON}{}
\Action enables the keyboard interrupt (e.g.\ CTRL/C),
i.e.\ a keyboard interrupt
will break correctly the program.
The current command execution will be interrupted and the prompt
will be shown again, if the command \Lit{BREAK ON} was entered,
which is the default (\Rind{KUINIT} does this at startup);
otherwise, i.e.\ if the command \Lit{BREAK OFF} was entered by the user,
the program will terminate immediately.
%---------------------------------------------------------------------------
\section{Utility and miscellaneous}

\Shubr{KUHOME}{(*CHFILE*,*LENFIL*)}
\Action replaces backslash
at the beginning of a filename by the users home
directory. {\tt CHFILE} is assumed to be lower case.
This routine should be used for APOLLO, UNIX and CRAY systems.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHFILE] input/output string containing the filename (in lower case)
\item[LENFIL] length of \Rarg{CHFILE}
\end{DLtt}

\Shubr{KGETAR}{(ARGOUT*)}
\Action reads the command line issued from the operating system,
at invocation of the application program using \KUIP{},
and returns the arguments in {\tt ARGOUT}.  
Useful to fetch run-time arguments typed in by the user.
\Pdesc\begin{DLtt}{MMMMMM}
\item[ARGOUT] output string containing the arguments
\end{DLtt}

Note that system function \Rind{\$ARGS} can be invoked
by the user to get the same information.

\Vskip\Shubr{KUAPPL}{(LUN*, MACFLG*,CHEXIT*)}
\Action returns the logical unit, the command/macro mode flag and
the 'exit' keyword to a \KUIP{} application; it must be called
inside the routine defining the \KUIP{} application.
\condbreak{2cm}
\Pdesc\begin{DLtt}{MMMMMM}
\item[LUN] logical unit
\item[MACFLG] command/macro mode flag (0=command, 1=macro)
\item[CHEXIT] \Lit{exit} keyword
\end{DLtt}


\Shubr{KUARGS}{(PRGNAM, LOGONF*, BATCHF*, LOGFIL*,IERROR*)}
\Action reads in the arguments from the command line.
\Pdesc\begin{DLtt}{MMMMMM}
\item[PRGNAM] input string containing the program name
\item[LOGONF] output string containing the logon file
\item[BATCHF] output string containing the batch file
\item[LOGFIL] output string containing the log file
(same as the batch file but with the extension \Lit{.LOG})
\item[IERROR] integer containing the error code (0 = no error)
\end{DLtt}
\begin{XMPt}{Example of command line arguments}
{\rm for Apollo, UNIX and Cray:}
             
  filename -n    {\rm or }   filename -b batchf   {\rm or}  filename -l logonf
           
{\rm for the VAX:}
            
  filename/nolog   {\rm or }   filename/batch=batchf   {\rm or}
  filename/logon=logonf
           
{\rm for IBM/VM:}
            
  filename (nolog  {\rm or }   filename (batch=batchf  {\rm or}
  filename (logon=logonf

-b {\rm or} /BATCH {\rm implies} -n {\rm or} /NOLOG
\end{XMPt}                         


\Shubr{KUCMDL}{(CHPATH)}
\Action sets a filter for the parsing of command lines.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPATH] command line string
\end{DLtt}
\Remark
After \Rind{KUCMDL} has been called and when an {\bf invalid} command is entered,
then string \Rarg{CHPATH} is prefixed to the string typed,
with \Lit{$n (n=1..9)} being replaced
by the \Lit{n}-th token of the command (tokens are separated by spaces),
or \Lit{\$*} being replaced by the whole command line.

\begin{XMPt}{Example of command completion}
COMMAND 'H/PLOT $* E'
110                    =>   H/PLOT 110 E
110 B                  =>   H/PLOT 110 B E
*
COMMAND 'HISTO/PLOT $1 1 $2'
A E                    =>   HISTO/PLOT A 1 E
B                      =>   HISTO/PLOT A 1
*
COMMAND 'SIGMA $*'
X=ARRAY(100,0#1)       =>   SIGMA X=ARRAY(100,0#1)
VECTOR/LIST            =>   VECTOR/LIST
*
COMMAND 'MESSAGE $SIGMA($*)'
1+2                    =>   3
SQRT(PI)               =>   1.772454
VECTOR/LIST            =>   VECTOR/LIST
*
command 'v/create $1(10)'
a                      =>   v/create a(10)
b c d                  =>   v/create b(10)
v/delete a,b           =>   v/delete a,b
*
COMMAND                =>   shows its current value
COMMAND *              =>   reset (equivalent to COMMAND $*)
\end{XMPt}


\Shubr{KUDPAR}{(CHSTRG, IPAR*, RPAR*, CHPAR*, LENGTH*, CHTYPE*)}
\Action decodes unknown parameter in \Rarg{CHSTRG}.
\Rarg{CHTYPE} returns 'I' (Integer in {\tt IPAR}), 'R' (Real in {\tt RPAR}),
'C' (Character in {\tt CHPAR} of length {\tt LENGTH}) 
or a blank string on case of an error.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHSTRG] string containing the unknown-type parameter
\item[IPAR] Integer value decoded if \Rarg{CHTYPE}=\Lit{I}
\item[RPAR] real value decoded if \Rarg{CHTYPE}=\Lit{R}
\item[CHPAR] character value decoded if \Rarg{CHTYPE}=\Lit{C}
\item[LENGTH] logical length of character \Rarg{CHPAR} if \Rarg{CHTYPE}=\Lit{C}
\item[CHTYPE] type of parameter \Rarg{CHSTRG} 
\begin{DLtt}{123}
\item['I'] for INTEGER
An integer parameter is defined as a string readable by a Fortran
internal READ using the \Lit{I}~format descriptor.
\item['R'] for REAL   
A real parameter is defined as a string readable by a Fortran
internal READ using \Lit{F} or \Lit{E}~format descriptors.
\item['C'] for CHARACTER
A character parameter is defined as a string not readable by a Fortran
internal READ using any of the \Lit{I}, \Lit{F} or \Lit{E}~format
descriptors. 
\item[' '] in case of error
\end{DLtt}
\end{DLtt}

\Shubr{KUEDIT}{(CHFILE,IST*)}
\Action Edit the given file.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHFILE] File name of the form \Lit{FILNAM.FILEXT} on all machines (IBM/VM-CMS included)
If \Lit{.FILEXT} is not provided
a standard extension \Lit{.KUMAC} is assumed, meaning that the file is a macro.
The file name is converted to uppercase on IBM (VM-CMS and MVS-TSO),
to lower case elsewhere.
On Unix platforms, if \Cind[STYLE]{STYLE '-FILECASE ON'} was entered,
the case conversion will not be performed,
thus permitting mixed case file names.
\condbreak{3\baselineskip}
\item[IST] Returned status 
\begin{DLtt}{12}
\item[0] normal exit
\item[1] user abort or quit (currently set only on Apollo)
\item[2] error
\end{DLtt}
\end{DLtt}


\Shubr{KUENV}{(LUN,CHOPT)}
\Action saves/restores \KUIP{} environment on the file connected to unit {\tt LUN}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[LUN] logical unit number on which the save/restore file is connected
\item[CHOPT] CHARACTER variable specyfying option desired
\begin{DLtt}{123}
\item['S'] save
\item['R'] restore
\item['M'] save/restore memory tree structure to/from RZ file
\item['A'] save/restore aliases to/from binary file
\end{DLtt}
\end{DLtt}

\Shubr{KUHELP}{(LUN*,CHPATH*)}
\Action should be called in the User help routine (associated to the \CDF{}
keyword \Cind{$>$U}), to inquire the logical unit number on which
the additional user help has to be written.
\Pdesc\begin{DLtt}{MMMMMM}
\item[LUN] logical unit number on which the addition user help has to be written
\item[CHPATH] bottom level command element (must be defined as \Lit{CHARACTER*32})
\end{DLtt}

\Shubr{KUINQF}{(*CHNAME*,*LUN*)}
\Action inquires about open Fortran files and their corresponding logical units.
\Pdesc\begin{DLtt}{1234567890}
\item[CHNAME$\neq$' ']
inquires the existence and open/close status of file \Rarg{CHNAME}
and returns : 
\begin{DLtt}{12345678}
\item[LUN = -1] if the file does not exist,
\item[LUN =  0] if the file exists but is not open,
\item[LUN >  0] if the file is open on the logical unit \Rarg{LUN}
\end{DLtt}
\item[CHNAME=' ']
inquires the open/close status of unit \Rarg{LUN}
and returns :
\begin{DLtt}{12345678}
\item[CHNAME=' '] if the unit is not used,
\item[CHNAME$\neq$' '] if the unit is connected to file \Rarg{CHNAME}
\end{DLtt}
\end{DLtt}
\subsubsection*{Return codes}
\begin{DLtt}{1234567890}
\item[IQUEST(11)] returns the format mode :
\begin{DLtt}{12}
\item[1] \Lit{FORMATTED}
\item[2] \Lit{UNFORMATTED}
\item[0] other  
\end{DLtt}
\condbreak{3\baselineskip}
\item[IQUEST(12)] returns the access type :
\begin{DLtt}{12}
\item[1] \Lit{SEQUENTIAL}
\item[2] \Lit{DIRECT}      
\item[0] other 
\end{DLtt}
\item[IQUEST(13)] return the record length of direct access files.
\end{DLtt}


\Shubr{KULUN}{(LUN)}
\Action sets the base logical unit used by \KUIP{}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[LUN] base logical unit
Startup values are units 11 to 15, i.e.\ \Lit{CALL KULUN(11).}
\end{DLtt}
\begin{XMPt}{Example of setting the \KUIP{} logical units}
      CALL KULUN(71)        {\rm to use units 71 to 75}
\end{XMPt}
 
\Shubr{KUOPEN}{(LUN, CHFILE, CHSTAT,ISTAT*)}

\Action opens a \Lit{FORMATTED} file, executing the \Lit{OPEN} statement
(as well as the \Lit{FILEDEF} for IBM/VM-CMS). 
Remember that logical units 11 to 15 (included) are
reserved by \KUIP{}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[LUN] Logical unit
\item[CHFILE] File name, which is 
converted to uppercase on IBM (VM-CMS and MVS-TSO), to lower case elsewhere.
On Unix platforms, if \Lit{STYLE '-FILECASE ON'} was entered,
the case conversion will not be performed,
thus permitting mixed case file names.
\item[CHSTAT] Status, e.g.\ \Ropt{'OLD'}, \Ropt{'NEW'}, \Ropt{'UNKNOWN'}, etc.
\begin{DLtt}{123456}
\item['OLD'] on VAX the file is opened with option \Lit{READONLY}\\
on IBM/VM-CMS function \Lit{STATE} is called to inquire if the file
already exists.
\item[{\rm not } 'OLD'] on VAX the file is opened with option \Ropt{SHARED}.
\end{DLtt}
On IBM/VM-CMS the file is always opened with \Lit{RECFM=F} and \Lit{LRECL=80}.
\item[ISTAT] Returned error status (0 if everything OK)
\end{DLtt}

\Shubr{KUPAD}{(CHFILE)}

\Action shows the text of a file.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHFILE] File name
\end{DLtt}

Depending on the machine type this routine:
\begin{itemize} 
\item Creates a \Lit{PAD} window on Apollo to view the
file in read-only mode 
(in this case the command \Cind[HOST-EDITOR]{HOST\_EDITOR} may be used also
to set window position/size).
\item Issues the command \Command{TYPE/PAGE} on the VAX.
\item Issues the command \Command{more} on Unix machines (including Cray).
\item Enters \Lit{XEDIT} on IBM/VM-CMS.
\end{itemize}


\Shubr{KUPANL}{(RLINE,CHKEY)}

\Action sets up the panel of graphics keys (used by \Cind[STYLE]{STYLE GP}).
\Pdesc\begin{DLtt}{MMMMMM}
\item[RLINE] line number
\item[CHKEY] key string
\end{DLtt}
At present maximum values for the key layout are:
1 panel, 10 lines/panel, 30 keys/line, 32 characters/key.

\begin{XMPt}{Example of setting up a panel}
CALL KUPANL ( 0,' ')              | reset the panel
CALL KUPANL ( 2.,'A/L QUIT V/L')  | initialize line 2 with 3 graphics key
                                  | respectively A/L, QUIT, V/L
CALL KUPANL ( 2.,'A/L '' ''  V/L '' '' '' ''')
                                  | initialize line 2 with 5 graphics key
                                  |  and fill 1st and 3rd keys
CALL KUPANL ( 2.04,'MESSAGE')     | initialize 4th key of 2nd line to MESSAGE
CALL KUPANL ( 2.04,' ')           | clear 4th key of 2nd line
CALL KUPANL (-2.08,' ')           | initialize line 2 with 8 graphics key
\end{XMPt}

\Shubr{KUQCAS}{FC = KUQCAS (DUMMY)}
\Action logical function returning the file case. Its value is:
\begin{DLtt}{123456}
\item[.TRUE.] if \Cind[STYLE]{STYLE '-FILECASE ON'} is active.  
\item[.FALSE.] if \Cind[STYLE]{STYLE '-FILECASE OFF'} is active.
\end{DLtt} 
\Pdesc\begin{DLtt}{MMMMMM}
\item[DUMMY] Dummy argument
\end{DLtt}

\Shubr{KUSIGM}{(SIROU)}
\Action defines the SIGMA entry routine.
\Pdesc\begin{DLtt}{MMMMMM}
\item[SIROU] \Rind{SIGMAE}, the SIGMA 
entry routine (must be defined as \Lit{EXTERNAL})
\index{SIGMA} 
\end{DLtt}

If SIGMA is linked with the \KUIP{} application program, the following code
must be present after calling \Rind{KUINIT} and before 
calling \Rind{KUWHAT}/\Rind{KUWHAG}:
\begin{XMP}{Code to be inserted after KUINIT}
      EXTERNAL SIGMAE
      .....
      CALL SIGINT
      CALL KUSIGM(SIGMAE)
\end{XMP}
\Rind{SIGINT} and \Rind{SIGMAE} are in the \PAWLIB{} library.


\Shubr{KUSAPP}{(CHPATH,CHEXIT)}
\Action set the application to \Rarg{CHPATH}.
\Pdesc\begin{DLtt}{MMMMMM}
\item[CHPATH] Application name
\item[CHEXIT] Command to exit from the application
\end{DLtt}
\Remark
Setting an application implies that all input lines will be concatenated
to the string \Rarg{CHPATH},
until the command specified by the argument \Rarg{CHEXIT} is executed,
which resets the application to the null string.

Calling \Rind{KUSAPP} is equivalent to entering the
command \Command{SET\_SHOW/APPLICATION}.

\begin{XMPin}{Example of setting an application}
 CMD1
 SET_SHOW/APPLICATION CALCULATOR
 A=10
 PRINT A
 PRINT (A+1124)/10.
 EXIT
 CMD2
\end{XMPin}
\begin{XMPout}{Equivalent set of commands}
 CMD1
 CALCULATOR A=10
 CALCULATOR PRINT A
 CALCULATOR PRINT (A+1124)/10.
 CMD2
\end{XMPout}
\vskip\baselineskip

In this example, \Command{CALCULATOR} could be a command that calls 
a user routine (say \Command{MYCALC}) performing arithmetic 
calculations on the input string given as
parameters of the command \Command{CALCULATOR}.

The advantage of this is that although it appears to the user that
control has been transferred to his application, this is still
under control of \KUIP{}, and therefore all the intrinsic features of \KUIP{}
(like macro execution, history file, etc.) are still available.
Note that in this case these features will use
commands known by the application rather than \KUIP{} commands.

In this example the action routine associated to
the command \Command{CALCULATOR} should have code to execute the 
various commands, e.g.\
\begin{XMPt}{Example of user code for application}
CALL KUGETE(CHLINE,NCHLIN)   ! Retrieve parameter CHLINE 
                             ! (e.g. CHLINE='PRINT (A+1124)/10.')
CALL MYCALC(CHLINE)          ! Perform actual calculation on input string
                             ! and print result,
\end{XMPt}


\Shubr{KUSER}{(USROU)}
\Action defines the ``user command'' routine, 
in which the user can filter the command
line and possibly modify it before execution, and even prevent its
execution.
\Pdesc\begin{DLtt}{MMMMMM}
\item[USROU] ``user command'' routine (must be defined as \Lit{EXTERNAL})
\end{DLtt}
\Remark
In the ``user command'' routine the input command line can
be retrieved from character array \Lit{CMDLIN} in common block \Lit{/KCPARC/}.
If the command has not to be executed, the user routine should set
\Lit{IQUEST(1) \(\neq\) 0} in the common block \Lit{/QUEST/}.

\begin{XMPt}{Example of a user command routine}
      SUBROUTINE MYCMD
*
      COMMON /KCPARC/ CMDLIN
      COMMON /QUEST/ IQUEST(100)
      CHARACTER*255 CMDLIN,CHTEMP
*      
      IQUEST(1)=0
*
      IF (CMDLIN(1:1).GE.'1'.AND.CMDLIN(1:1).LE.'9') THEN
*
*  Each command starting with a non-zero number (e.g. 5) is treated  as a
*  VECTOR/PRINT of a vector corresponding to that number (e.g. VECTOR/PRINT V5).
*
        CHTEMP='VECTOR/PRINT V'//CMDLIN
        CMDLIN=CHTEMP
      ELSE IF (CMDLIN(1:1).EQ.'0') THEN
*
*  If number starts with zero (0), skip the execution of the command.
*
        IQUEST(1)=1
      ENDIF
*
      END
\end{XMPt}

\Shubr{KUTERM}{(TEROU)}

\Action defines the ``terminal'' routine, called before writing any
Fortran text on the terminal. A standard code inside the
terminal routine will call a routine to switch into ``alpha'' mode. 
\Pdesc\begin{DLtt}{MMMMMM}
\item[TEROU] ``terminal'' routine (must be defined as \Lit{EXTERNAL})
\end{DLtt}

\Shubr{KUTIME}{}
\Action prints the current Real and CPU time, in the same format as it is
printed after issued the command \Cind[TIMING]{TIMING ON}.

%
%\Vskip\Shubr{KUVAR}{(CHLINE)}
%\Action allows a macro
%variable assignment when called by an action routine of
%a command being executed from a macro.
%\Pdesc\begin{DLtt}{MMMMMM}
%\item[CHLINE] string containing variable assignment
%\end{DLtt}
%
%\begin{XMPt}{Example of the use of KUVAR}
%     CALL KUVAR ('A=10')      ! set variable A for macro being executed.
%*  Warning: no blank may appear before or after the equal sign,
%     CALL KUVAR ('A= 10')     ! will generate an error
%\end{XMPt}   
%If an error occurs, or if the command was not issued from a macro,
%\Lit{IQUEST(1)} in common block \Lit{/QUEST/} is set different fron 0.
%
%\Shubr{KUQVAR}{(CHINP,CHOUT*)}
%\Action called inside the user program
%to inquire the value of a macro variable or of an alias or function.
%\Pdesc\begin{DLtt}{MMMMMM}
%\item[CHINP] input line, e.g.\ variable/alias/function name
%\item[CHOUT] output value
%\end{DLtt}
%\begin{XMPt}{Example of the use of KUQVAR}
%     CALL KUQVAR('A',CHOUT)   ! set CHOUT to the value of variable  A
%                              ! for macro being currently executed.
%\end{XMPt}
%%---------------------------------------------------------------------------
%%\section{Called by the \KUIP{} Interface Builder}
%%\par
%%These routines are called by the \KUIP{} Interface Builder
%%according to the input \CDF{}, therefore the user do not need to call them directly.
%%%*********>
%%\Shubr{KUXXXX}{CALL KUACG  (CHPATH,GUIROU)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUACH  (CHPATH,HELROU)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUACT  (CHPATH,ACTROU)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUCMD  (CHPATH, CHITEM,CHOPT)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUGUID (CHPATH, CHGUID, NLINES,CHOPT)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUNDPV (NWDEF, NWLOW, NWHIG, NPVAL,NWPV)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUNWG  (NWG)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUPAR  (CHPATH, CHNAME, CHPROM, CHTYPE,CHOPT)}
%%%*********>
%%\Shubr{KUXXXX}{CALL KUPVAL (CHPATH, CHNAME, IVAL, RVAL, CHVAL,CHOPT)}

\condbreak{.5\textheight}
\section{Main Program Skeletons}

Following are examples of a user main program using \KUIP{}.

\begin{XMPt}{User main program for basic \KUIP{}}
      PROGRAM MAIN
*
      COMMON/PAWC/PAW(50000)
      EXTERNAL MYEXIT
*
* Initialize ZEBRA and the store /PAWC/
*
      CALL MZEBRA(-3)
      CALL MZPAW(50000,' ')
*
* Initialize KUIP with NWORDS words as minimum division size
*
      NWORDS=5000
      CALL KUINIT(NWORDS)
*
* Create the user command structure from the definition file
* generated automatically by the KUIP Compiler.
* The command definition routine name has been defined in the
* CDF (Command Definition File) through the control line '>Name DEF'
*
      CALL DEF
*
* Define the exit routine.
* Entering the command 'EXIT' this routine is executed,
* then the program continues from the line after CALL KUWHAT (or KUWHAG).
*
      CALL KUEXIT(MYEXIT)
*
* Change the prompt
*
      CALL KUEXEC('SET/PROMPT ''My_prompt >''')
*
* Execute a logon macro
*
      CALL KUEXEC('EXEC MYLOGON')
*
* Give control to KUIP (with no 'STYLE G', call KUWHAG to have 'STYLE G').
* Entering the command 'QUIT' or 'EXIT' the program continues
* from the line after CALL KUWHAT (or CALL KUWHAG).
*
      CALL KUWHAT
*
* Entering the command 'QUIT' or 'EXIT' we return here
*
      END
\end{XMPt}


\begin{XMPt}{User main program for \KUIPMotif{} without HIGZ graphics}
      PROGRAM MAIN
*
* Basic KUIP/Motif Application (no HIGZ graphics)
*
      COMMON/PAWC/PAW(50000)
*
* Initialize ZEBRA and the store /PAWC/
*
      CALL MZEBRA(-3)
      CALL MZPAW(50000,' ')
*
* Initialize KUIP with NWORDS words as minimum division size
*
      NWORDS=2000
      CALL KUINIT(NWORDS)
*
* Create the user command structure from definition file (CDF)
*
      CALL VECDEF
*     CALL ...
*
* Gives access to KUIP browsers for commands, files and macros
*
      CALL KUIDFM
*
* Execute some KUIP Initialization Commands
*
      CALL KUEXEC('PROMPT ''KTEST >''')
      CALL KUEXEC('LAST 0')
*
* Give control to MOTIF
*
      CALL KUWHAM ('Ktest')
*
      END
\end{XMPt}

If your application requires high level graphics managed by HIGZ, then you
have to add a small part for the HIGZ (and eventually
HPLOT) initialization.  The following is a user main program skeleton
for a graphical application using HIGZ and HPLOT.


\begin{XMPt}{User main program for \KUIPMotif{} with HIGZ graphics}
      PROGRAM MAIN
*
* Basic KUIP/Motif Application (no HIGZ graphics)
*
      PARAMETER (NWHIGZ=10000)
      COMMON/PAWC/PAW(50000)
*
      EXTERNAL      IGTERM
*
* Initialize ZEBRA and the store /PAWC/
*
      CALL MZEBRA(-3)
      CALL MZPAW(50000,' ')
*
* Initialize KUIP with NWORDS words as minimum division size
*
      NWORDS=2000
      CALL KUINIT(NWORDS)
*
* Create the user command structure from definition file (CDF)
*
      CALL VECDEF
      CALL KTDEF            ! (*) see below ...
*     CALL ...              ! (code generated from the CDF compilation)
*
* Gives access to KUIP browsers for commands, files and macros
*
      CALL KUIDFM
*
* Special KUIP initialization for using Motif with HIGZ
*
      CALL KUINIM('Ktest')
*
* Initialize HIGZ
*
      CALL IGINIT(NWHIGZ)
      CALL KUGRFL(IGTERM)   ! flush the graphics output after each command
*
* Initialize HPLOT
*
      IWK=999
      CALL HPLINT(IWK)
      CALL IGSA(0)
*
* Execute some KUIP Initialization Commands
*
      CALL KUEXEC('PROMPT ''KTEST >''')
      CALL KUEXEC('LAST 0')
*
* Give control to MOTIF
*
      CALL KUWHAM ('Ktest')
*
      END
\end{XMPt}

(*)  The subroutine KTDEF is automatically generated from the \CDF{}
(directive {\tt ``>Name KTDEF''}. This \CDF{} must contain the directive 
``{\tt >Graphics}'' (see sections \ref{ref:regraph2} and \ref{ref:reexnogr}).

