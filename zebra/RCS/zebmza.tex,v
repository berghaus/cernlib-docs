head	1.1;
access;
symbols;
locks
	goossens:1.1; strict;
comment	@% @;


1.1
date	93.11.13.15.25.14;	author goossens;	state Exp;
branches;
next	;


desc
@initial entry
@


1.1
log
@Initial revision
@
text
@\Filename{H1-Summary-of-KERNLIB-routines}
\chapter{Summary of KERNLIB routines}

% N103  JX = IUWEED (AV,N)              locate floating-point exception in AV

\begin{verbatim}
        The first letter indicates the mode of the variable according
        to the Fortran convention, thus I -> N is INTEGER, else REAL,
        and we add: small c  to designate CHARACTER
                    small l  to designate LOGICAL
     *  marks output variables
     V  as last or last-but-one letter indicates a vector variable
     W  as last or last-but-one letter indicates a matrix variable
    sW  as last letters indicate a packed symmetric  matrix variable
    tW  as last letters indicate a packed triangular matrix variable
     M  as last letter means that the mode of the variable is immaterial
    FL  stands for Fortran Library

      COMMON /SLATE/ISL(40)  returns extra information
\end{verbatim}

\subsection*{General}

\begin{verbatim}
Z035  CALL ABEND                      abnormal job-step termination
Z007  CALL DATIME (IDATE*,ITIME*)     integer date / time, IDATE= yymmdd, ITIME= hhmm
                                      ISL(1/6) = 19yy mm dd hh mm ss
Z007  CALL DATIMH (IDTV*,ITMV*)       Hollerith date and time
                                      IDT= 8Hyy/mm/dd, ITM= 8Hhh.mm.ss
M220  CALL IE3FOD (DV,TV*,NDP,JBAD)   convert IEEE <- Double
M220  CALL IE3FOS (SV,TV*,N,  JBAD)   convert IEEE <- Single
M220  CALL IE3TOD (TV,DV*,NDP,JBAD)   convert IEEE -> Double
M220  CALL IE3TOS (TV,SV*,N,  JBAD)   convert IEEE -> Single
Z044  lo = INTRAC ()                  .true. if interactive running
Y201  IX = IUBIN  (A,PAR,SPILL)       histogram bin,  PAR=NA,DA,ALOW
Y201  IX = IUCHAN (A,ALOW,DA,NA)      histogram bin IX
V304  JX = IUCOMP (IT,IAV,N)          find first IT in IA, JX=O if not found
V304  JX = IUCOLA (IT,IAV,N)          find  last IT in IA, JX=O if not found
V304  JX = IUFIND (IT,IAV,JL,JR)      find first IT in IA(JL/JR), JX=JR+1 if not found
V304  JX = IUFILA (IT,IAV,JL,JR)      find  last IT in IA(JL/JR), JX=JR+1 if not found
Y201  IX = IUHIST (A,PAR,SPILL)       histogram bin,  PAR=NA,1./DA,ALOW
V304  JX = IUHUNT (IT,IAV,N,NA)       find IT in IA(1/N),every NA, JX=0 if not found
V304  JX = IULAST (IT,IAV,N)          find last word in IA(1/N) not having IT
                                                   JX=0 if all are IT
M501  NX = IUSAME (IAV,JL,JR,MIN,JS*) search IA(JL/JR) for string of at
                                      least MIN same elements,
                                      if found: NX same elements, first is IA(JS)
                                      else:     NX=0, JS=JR+1
Z100  CALL JOBNAM (IDV*)              get name of job into 8 char. Hollerith
Z042  IAD= JUMPAD (external)          get the target transfer adr
Z042  CALL JUMPST (IAD)               set the target transfer adr
Z042  CALL JUMPX0                     transfer with no parameters as set
Z042  CALL JUMPX1 (p1)                transfer with  1 parameter
Z042  CALL JUMPX2 (p1,p2)             transfer with  2 parameters
Z043  CALL JUMPT0 (IAD)               transfer with no parameters to IAD
Z043  CALL JUMPT1 (IAD,p1)            transfer with  1 parameter
Z043  CALL JUMPT2 (IAD,p1,p2)         transfer with  2 parameters
Z001  CALL KERNGT (LUN)               print current version of KERNLIB
M432  NX = LNBLNK (cTEXT)             find last non-blank character in cTEXT
N100  JX = LOCF   (A)                 absolute word adr of variable A
N100  JX = LOCB   (A)                 absolute byte adr of variable A
M215  FA = PSCALE (NX,NMAX,A,NDIG)    find power of ten to scale for printing
Z041  CALL QNEXTE                     enter or re-enter into user routine QNEXT
V104  X  = RNDM   ()                  simple random number
V104  CALL RDMIN  (ISEED)             set the seed for RNDM
V104  CALL RDMOUT (ISEED*)            get the seed for RNDM
M107  CALL SORTI  (IXW*,NCOL,NROW,JEL)  sort rows of integer matrix on element JEL
M107  CALL SORTR   (XW*,NCOL,NROW,JEL)  sort rows of    real matrix on element JEL
M107  CALL SORTD  (DXW*,NCOL,NROW,JEL)  sort rows of  double matrix on element JEL
N203  CALL TCDUMP (TITL,AVM,N,MODE)   MODE=3HFIH  floating,integer,hollerith
Z007  CALL TIMED  (T*)                T= seconds since last call to TIMED
Z007  CALL TIMEL  (T*)                T= seconds left until time-limit
Z007  CALL TIMET  (T*)                T= seconds of job ex. time used so far
Z007  CALL TIMEST (TLIM)              init. for TIMEL on IBM
N105  CALL TRACEQ (LUN,N)             print subroutine trace-back N levels deep
V300  CALL UBLANK (IXV*,JL,JR)        IX(J)= 'blanks'           for J=JL,JR
M409  CALL UBLOW  (IAm,  IA1*,  NCH)  copy Hollerith  Am to A1, NCH characters
M409  CALL UBUNCH (IA1,  IAm*,  NCH)  copy Hollerith  A1 to Am
M409  CALL UCTOH  (cHO,  IAn*,N,NCH)  copy Char/Holl  Am to An
M409  CALL UCTOH1 (cHO,  IA1*,  NCH)  copy Char/Holl  Am to A1
M409  CALL UHTOC  (IAn,N,cCH*,  NCH)  copy Hollerith  An to Character
M409  CALL UH1TOC (IA1,  cCH*,  NCH)  copy Hollerith  A1 to Character
V301  CALL UCOPY  (AVM,XVM*,N)        copy X(J) = A(J)          for J=1,N
V301  CALL UCOPY2 (AMV,XVM*,N)        copy A to X, any overlap
V301  CALL UCOPYN (IAV,IXV*,N)        copy -ve integer:   IX(J) = -IA(J)
V301  CALL UCOPIV (AVM,XVM*,N)        copy inverted, eg. X(1)=A(N)
V302  CALL UCOCOP (AVM,XVM*,IDO,N,NA,NX) copy IDO times N words, every NA,NX
V302  CALL UDICOP (AVM,XVM*,IDO,N,NA,NX) copy IDO times N words, every NA,NX
V300  CALL UFILL  (XVM*,JL,JR,AM)     X(J)= A                   for J=JL,JR
M502  CALL UOPT   (IACT,IPOSS,IXV*,N) select options from poss., Hollerith
M502  CALL UOPTC  (cACT,cPOSS,IXV*)   select options from possibilities
V301  CALL USWOP  (XVM*,YVM*,N)       swop  X(J)=Y(J), Y(J)=X(J)
V300  CALL UZERO  (IXVM*,JL,JR)       IX(J)= O                  for J=JL,JR
F121  CALL VBLANK (IXV*,N)            IX(J)= hollerith BLANK    for J=1,N
F121  CALL VFILL  (XVM*,N,AM)         X(J)= A                   for J=1,N
F121  CALL VFIX   (AV,IXV*,N)         IX(J) =  A(J)             for J=1,N
F121  CALL VFLOAT (IAV,XV*,N)          X(J) = IA(J)             for J=1,N
F121  CALL VZERO  (IXVM*,N)           IX(J)= O                  for J=1,N
J200  CALL VIZPRI (LUN,cTEXT)         print 1 line of large characters
Z203  CALL XINB   (LUN,XV*,*NX*)      var.  length:   READ (LUN) NX,XV
Z203  CALL XINBF  (LUN,XV*,*NX*)      fixed length:   READ (LUN) XV
Z203  CALL XINBS  (LUN,XAV*,NA,XV*,*NX*)     split:   READ (LUN) NX,XAV,XV
Z203  CALL XOUTB  (LUN,V,N)           var.  length:  WRITE (LUN) N,V
Z203  CALL XOUTBF (LUN,V,N)           fixed length:  WRITE (LUN) V
Z203  CALL XOUTBS (LUN,AV,NA,V,N)     split mode:    WRITE (LUN) N,AV,V
\end{verbatim}

\subsection*{Bitwise logical operations on full words}

\begin{verbatim}
M441  IX = IAND   (IWD1,IWD2)    logical AND
M441  IX = IEOR   (IWD1,IWD2)    logical exclusive OR
M441  IX = IOR    (IWD1,IWD2)    logical OR
M441  IW = NOT    (IWD)          logical NOT
M441  IX = ISHFT  (IWD,NSH)     +ve:  logical  left shift by  NSH places
                                -ve:  logical right shift by -NSH places
M441  IX = ISHFTC (IWD,NSH,NBITS) left-circular shift by (+-)NSH places
                                  of the right-most NBITS bits
\end{verbatim}

\subsection*{Bit / byte handling, least significant bit is 1}

\begin{verbatim}
  symbolic:  'byt' ==  IWD,J,NBITS  is byte at J of NBITS bits in IWD

M421  IX = JBIT   (IWD,J)        get bit J
M421  IX = JBYT   ( byt)         get byte at J of NBITS bits in IWD
M421  IX = JBYTET (IA, byt)      get logical AND of IA and "byt"
M421  IX = JBYTOR (IA, byt)      get logical  OR of IA and "byt"
M421  IX = JRSBYT (IA, byt*)     get "byt" and reset it to IA

M421  CALL  SBIT  (I,IWD*,J)     set in IWD   bit J to I
M421  IX = MSBIT  (I,IWD, J)     get IWD with bit J set to I
M421  CALL  SBIT0   (IWD*,J)     set in IWD   bit J to zero
M421  IX = MSBIT0   (IWD, J)     get IWD with bit J set to zero
M421  CALL  SBIT1   (IWD*,J)     set in IWD   bit J to 1
M421  IX = MSBIT1   (IWD, J)     get IWD with bit J set to 1
M421  CALL  SBYT  (I, byt*)      set in IWD   "byt" to I
M421  IX = MSBYT  (I, byt)       get IWD with "byt" set to I
M421  CALL SBYTOR (I, byt*)      set in IWD   "byt"     to  OR of "byt" and I
M421  IX = MBYTOR (I, byt)       get IWD with "byt" set to  OR of "byt" and I
M421  IX = MBYTET (I, byt)       get IWD with "byt" set to AND of "byt" and I
M421  CALL  CBYT  (IWS,JS, byt*) copy byte at JS in IWS to "byt"
M421  IX = MCBYT  (IWS,JS, byt)  get IWD with "byt" set to byte at JS of IWS

M503  CALL UBITS  (IAV,NBITS,IXV*,NX*)  make list of bit-nos of non-zero bits
M428  JX = LOCBYT (I,IAV,N,NEV,J,NBITS)  is IUHUNT for byte-content I
\end{verbatim}

\subsection*{Handling packed byte vectors}

\begin{verbatim}
  MPAK=NBITS,INWORD: bytes of NBITS bits packed r-to-l, INWORD of them per word
       if NBITS = 0: assume NBITS=1 and INWORD = maximum

M423  IX = INCBYT (INC,IPV*,J,MPAK)   increment packed byte
M422  IX = JBYTPK (IPV,J,MPAK)        get packed byte
M422  CALL SBYTPK (I,IPV*,J,MPAK)     set packed byte
M422  CALL PKBYT  (IAV,IPV*,J,N,MPAK) pack byte-vector right-to-left
M422  CALL UPKBYT (IPV,J,IAV*,N,MPAK) unpack byte-vector right-to-left

  MPAR=NBITS,NCHAR,NZONE,IGNOR,NFILL   packing control, l-to-r

M427  CALL PKCHAR (IAV,IPV*,N,MPAR)   pack integers left-to-right
M427  CALL UPKCH  (IPV,IAV*,N,MPAR)   unpack byte-vector left-to-right
\end{verbatim}

\subsection*{Bit / byte handling, least significant bit is 0}

\begin{verbatim}
M441  IX = IBITS  (IWD,J,NBITS)  get byte at J of NBITS bits
M441  lo = BTEST  (IWD,J)        true if bit J is 1
M441  IX = IBSET  (IWD,J)        IX= IWD with bit J set to 1
M441  IX = IBCLR  (IWD,J)        IX= IWD with bit J set to 0
M441  CALL MVBITS (IA,JA,NBITS,IWD*,J)  store byte at JA of IA into byte at J in IWD
\end{verbatim}

\subsection*{Unix functions}

\begin{verbatim}
      some use COMMON /SLATE/ND,DUMMY(39), and status IST=0 if good

Z265  IST= CHDIRF (cNAME)             set current working directory
Z265  CALL CTIMEF (ICLOCK,cTIME*)     decode time from STATF to TIME*24
Z265  CALL GETENVF(cNAME,cVAL*)       get value of environment variable
                                      ND = LNBLNK(cVAL)  =0 if not found
Z265  CALL GETPIDF(IPID*)             get ID of the current process
Z265  CALL GETWDF (cNAME*)            get current working directory
                                      ND = LNBLNK(cNAME)
Z265  CALL GMTIMEF(ICLOCK,ITM*)       decode time from STATF TO ITM(1-9)
      CALL JMPSET (AREA*,external)    do "setjmp" and go to "external"
      CALL JMPLONG(AREA,NUM)          do "longjmp"
Z265  IST= KILLF  (IPID,ISGNAL)       send signal to process IPID
Z265  CALL PERRORF(cTEXT)             print last Unix error tagged with cTEXT
Z265  IST= RENAMEF(cFROM,cTO)         rename file cFROM --> cTO
      IPR= SIGNALF(NUMSIG,ext,IFLAG)  establish signal handler
Z265  CALL SLEEPF (NSECS)             suspend process for NSECS seconds
Z265  IST= STATF  (cNAME,INF*)        get info about file cNAME to INF(1-12)
Z265  IST= SYSTEMF(cCOMMAND)          submit shell command
      CALL TMINIT (INIT*)             initialize TMPRO / TMREAD
      CALL TMPRO  (cPROMPT)           display prompt on terminal
      CALL TMREAD (MAXCH,cLINE*,NCH*,IST*)  read line from terminal
                                      NCH characters read into LINE
                                      IST -ve: EoF signal
\end{verbatim}

\subsection*{Z310 -- C interface to read/write fixed-lenth records, \Lit{CFIO}}

\begin{verbatim}
  symbolic  "lmr" == LUNDES,MEDIUM,NWREC

            LUNDES: file-descriptor of C, output parameter of CFOPEN
            MEDIUM: 0 disk, 1 tape, 2 user disk, 3 user tape
            NWREC:   number of Fortran words per record
            status return ISTAT is zero for success

  CALL CFOPEN (LUNDES*,MEDIUM,NWREC,cMODE,0,cNAME,ISTAT*)   open the file cNAME
                                          cMODE= r r+ w w+ a a+
  CALL CFGET  ("lmr",*NB*,MBUF*,ISTAT*)   read next record into MXBUF
                                             in: NB words to be tranfered
                                            out: NB words transfered
  CALL CFPUT  ("lmr",MBUF, ISTAT*)        write next record
  CALL CFSEEK ("lmr",NREC, ISTAT*)        set current file position
  CALL CFTELL ("lmr",NREC*,ISTAT*)        get current file position
  CALL CFSIZE ("lmr",NREC*,ISTAT*)        seek file to end and get its size
                                     NREC: so many records before the next
  CALL CFREW  (LUNDES,MEDIUM)             rewind the file
  CALL CFCLOS (LUNDES,MEDIUM)             close  the file
\end{verbatim}

\subsection*{Maths General}

\begin{verbatim}
FL     X = ACOS   (A)                 arcus cosinus, 0 -> PI
FL     X = ASIN   (A)                 arcus sinus, -PI/2 -> PI/2
FL     X = ATAN   (A)                 arcus tangens, -PI/2 -> PI/2
FL     X = ATAN2  (RSIN,RCOS)         arcus tangens, -PI -> PI
B101   X = ATG    (RSIN,RCOS)         arcus tangens, 0 -> 2*PI
F117  CALL CROSS  (AV,BV,XV*)         A CROSS B  into  X
F116   X = DOTI   (AV,BV)             X = A(1)B(1) +...+ A(3)B(3) - A(4)B(4)
C300   X = ERF    (A)                 error function, integral 0 -> A
C300   X = ERFC   (A)                 compl. error function, A to infinity
E104   X = FINT   (...)               interpolation routine
C300   X = FREQ   (A)                 normal frequence function, -INF to A
U101  CALL LOREN4 (AV,BV,XV*)         Lorentz transformation
U102  CALL LORENB (EN,REFV,STV,XV*)   Lorentz transformation, backward
U102  CALL LORENF (EN,REFV,STV,XV*)   Lorentz transformation, forward
G100   X = PROB   (CHI2,N)            convert CHI-square to probability
B102   X = PROXIM (ALPHA,REF)         X = ALPHA + 2N*PI  nearest to REF
F118  CALL ROT    (AV,TH,XV*)         rotate around Z-axis
FL     X = TAN    (A)                 tangens
\end{verbatim}

\subsection*{Maths -- F121, Vector handling package, \Lit{VECMAN}}

\begin{verbatim}
E103   X = AMAXMU (AV,IDO,NWD,NA)     largest ABS element in scattered vector
F121  LX = LVMAX  (AV,N)              loc of biggest  A(J)      for J=1,N
F121  LX = LVMAXA (AV,N)              loc of biggest  ABS(A(J))
F121  LX = LVSMX  (AV,N,INC)          loc of biggest  A(J) every INC
F121  LX = LVSDMX (DV,N,INC)          loc of biggest  D(J) every INC, double
F121  LX = LVSIMX (IV,N,INC)          loc of biggest  I(J) every INC
F121  LX = LVMIN  (AV,N)              loc of smallest A(J)
F121  LX = LVMINA (AV,N)              loc of smallest ABS(A(J))
F121  LX = LVSMI  (AV,N,INC)          loc of smallest A(J) every INC
F121  LX = LVSDMI (DV,N,INC)          loc of smallest D(J) every INC, double
F121  LX = LVSIMI (IV,N,INC)          loc of smallest I(J) every INC
F121  CALL VADD   (AV,BV,XV*,N)       X(J) = A(J) + B(J)        for J=1,N
F121   X = VASUM  (AV,N)              X = sum ABS(A(J))         for J=1,N
F121  CALL VBIAS  (AV,C,XV*,N)        X(J) = A(J) + C           for J=1,N
F121  CALL VCOPYN (AV,  XV*,N)        copy -ve:   X(J) = -A(J)  for J=1,N
F121   X = VDIST  (AV,BV,N)           X = SQRT (VDIST2(A,B,N))
F121   X = VDIST2 (AV,BV,N)           X = (A-B)*(A-B)
F121   X = VDOT   (AV,BV,N)           X = A * B
F121   X = VDOTN  (AV,BV,N)           X =  A*B / SQRT(A*A * B*B)
F121   X = VDOTN2 (AV,BV,N)           X = (A*B)**2 / (A*A * B*B)
F121  CALL VEXCUM (AV,XV*,N)          X=Minimum,Maximum,Sum -- cumulative
F121  CALL VFILL  (XVM*,N,AM)         X(J) = A                  for J=1,N
F121  CALL VFIX   (AV,IXV*,N)         IX(J)=  A(J)              for J=1,N
F121  CALL VFLOAT (IAV,XV*,N)         X(J) = IA(J)              for J=1,N
F121  CALL VLINCO (AV,S,BV,T,XV*,N)   X(J) = A(J)*S + B(J)*T    for J=1,N
F121  CALL VMATL  (GW,CV,XV*,NI,NJ)   X = G * C
F121  CALL VMATR  (AV,GW,YV*,NI,NJ)   Y = A * G
F121   X = VMAX   (AV,N)              biggest  A(J)             for J=1,N
F121   X = VMAXA  (AV,N)              biggest  ABS(A(J))        for J=1,N
F121   X = VMIN   (AV,N)              smallest A(J)             for J=1,N
F121   X = VMINA  (AV,N)              smallest ABS(A(J))        for J=1,N
F121   X = VMOD   (AV,N)              X = SQRT ( VDOT(A,A,N) )
F121  CALL VMUL   (AV,BV,XV*,N)       X(J) = A(J) * B(J)        for J=1,N
F121  CALL VSCALE (AV,C, XV*,N)       X(J) = A(J) * C           for J=1,N
F121  CALL VSUB   (AV,BV,XV*,N)       X(J) = A(J) - B(J)        for J=1,N
F121   X = VSUM   (AV,N)              X = sum A(J)              for J=1,N
F121  CALL VUNIT  (AV,XV*,N)          X(J) = A(J) / VMOD(A,N)   for J=1,N
F121  CALL VZERO  (IXVM*,N)           IX(J)= O                  for J=1,N
\end{verbatim}

\subsection*{Maths  Householder fitting and triangular matrices}

\begin{verbatim}
E230  CALL TLERR  (AW,XW*,AUX,IPIV)   error matrix after fit
E230  CALL TLRES  (AW,XV*,AUX)        residuals after fit
E230  CALL TLS    (AW,BW,AUX,IPIV,EPS,XW*)      unconstrained L.S.FIT
E230  CALL TLSC   (AW,BW,AUX,IPIV,EPS,XW*)      constrained L.S.FIT

F112  CALL TRAAT  (AW,XsW*,M,N)       rectang * rectang(T) X = A * AT
F112  CALL TRAL   (AW,BtW,XW*,M,N)    rectang * triang     X = A * B
F112  CALL TRALT  (AW,BtW,XW*,M,N)    rectang * triang     X = A * BT
F112  CALL TRAS   (AW,BsW,XW*,M,N)    rectang * symm       X = A * B
F112  CALL TRASAT (AW,BsW,XsW*,M,N)   transform symm       X = A * B * AT
F112  CALL TRATA  (AW,XsW*,M,N)       rectang(T) * rectang X = AT* A
F112  CALL TRATS  (AW,BsW,XW*,M,N)    rectang * symm       X = AT* B
F112  CALL TRATSA (AW,BsW,XsW*,M,N)   transform symm       X = AT* B * A
F112  CALL TRCHLU (AsW,XtW*,N)        Choleski decomposition A = X*XT
F112  CALL TRCHUL (AsW,XtW*,N)        Choleski decomposition A = XT*X
F112  CALL TRINV  (AtW,XtW*,N)        inversion of triangular matrix
F112  CALL TRLA   (AtW,BW,XW*,M,N)    triang. * rectang.   X = A * B
F112  CALL TRLTA  (AtW,BW,XW*,M,N)    triang. * rectang.   X = AT* B
F112  CALL TRPCK  (AW,XsW*,N)         pack A into symmetric form
F112  CALL TRQSQ  (AsW,BsW,XsW*,N)    transform symm       X = A * B * A
F112  CALL TRSA   (AsW,BW,XW*,M,N)    symm * rectang       X = A * B
F112  CALL TRSAT  (AsW,BW,XW*,M,N)    symm * rectang       X = A * BT
F112  CALL TRSINV (AsW,XsW*,N)        inversion of symmetric matrix
F112  CALL TRSMLU (AtW,XsW*,N)        product of triang matrices  X = A * AT
F112  CALL TRSMUL (AtW,XsW*,N)        product of triang matrices  X = AT* A
F112  CALL TRUPCK (AsW,XW*,N)         unpack symm. A into full  form
\end{verbatim}

\subsection*{M432 -- Utilities for Character string analysis, \Lit{CHPACK}}

\begin{verbatim}
  using  COMMON /SLATE/ND,NE,NF,NG,NUM(2),DUMMY(34) to return information
                standard meaning:  ND: number of digits or characters seen
                                   NE: COL(NE) is the terminating character

         CHARACTER    LINE*(512), COL(512)*1
         EQUIVALENCE (LINE,COL)

  most routines have the 3 parameters  LINE,JL,JR  to designate the
  field LINE(JL:JR) to be used, abbreviated to 'llr' if short of space.

CALL CFILL  (cIT,LINE*,JL,JR) fill llr with as many copies of cIT*(*) as poss.
CALL CKRACK (LINE,JL,JR)      krack numeric field; ND digits seen, NE term.
                              NF= -ve bad, 0 blank, 1 B, 2 I, 3 F, 4 D seen
                              NG= 0 good termination, NUM returns the number
CALL CLEFT  (LINE*,JL,JR)     left-justify squeezing blanks,
                              ND non-blanks, COL(NE) first blank
CALL CRIGHT (LINE*,JL,JR)     right-justify squeezing blanks,
                              ND non-blanks, COL(NE) last blank
CALL CLTOU  (LINE(JL:JR)*)    convert low to up
CALL CUTOL  (LINE(JL:JR)*)    convert  up to low
CALL CSETDI (INT,LINE*,JL,JR) set decimal integer right-justified, ND digits
                              COL(NE+1)  most significant digit set
                              COL(NF+1)  most significant character set
                              NG=0 good, else field too small
CALL CSETHI (INT,LINE*,JL,JR) set hex integer right-justified,
                              ND,NE,NF,NG as for CSETDI
CALL CSQMBL (LINE*,JL,JR)     left-justify squeezing multiple blanks,
                              ND retained, COL(NE) first after
                              NE=JR+1 if no multiple blanks
CALL CSQMCH (cSG,LINE*,JL,JR) left squeeze multiple occurrences of cSG*1
                              ND,NE as for CSQMBL
CALL CTRANS (cOLD,cNEW, llr*) replace each occurrence of cOLD*1 by cNEW*1
IX = ICDECI (LINE,JL,JR)      read decimal integer, ND digits, COL(NE) term.
                              NG=0 if terminated by blank or end-of-field
JX = ICFIND (cSG,LINE,JL,JR)  find COL(JX) first occ. of cSG*1 or JX=JR+1
                              NG=0 not found, else =JX
JX = ICFILA (cSG,LINE,JL,JR)  find COL(JX) last occ. of cSG*1 or JX=JR+1
                              NG=0 not found, else =JX
JX = ICFMUL (cIT,LINE,JL,JR)  find COL(JX) first occ. of any cIT(j:j) or JX=JR+1
                              ND=j, NG=0 not found, else =JX
JX = ICFNBL (LINE,JL,JR)      find COL(JX) first non-blank, or JX=JR+1
                              NG=0 all blank, else =JX
IX = ICHEXI (LINE,JL,JR)      read hex integer, ND,NE,NG as for ICDECI
JX = ICLOC  (cIT,NI, llr)     locate cIT(1:NI) as is in LINE(JL:JR)
                              COL(JX) start, JX=0 if not found
JX = ICLOCL (cIT,NI, llr)     as ICLOC case insensitive, cIT given as lower
JX = ICLOCU (cIT,NI, llr)     as ICLOC case insensitive, cIT given as upper
JX = ICLUNS (LINE,JL,JR)      COL(JX) first 'unseen', else JX=0
JX = ICNEXT (LINE,JL,JR)      LINE(JX:NE-1) is next 'word' in llr
                              ND chars in word; no next: JX=NE=JR+1 ND=0
JX = ICNTH  (cACT,cPOSS,NPO)  cACT as is matches cPOSS(JX), else JX=0
JX = ICNTHL (cACT,cPOSS,NPO)  as ICNTH case insensitive, cPOSS given as lower
JX = ICNTHU (cACT,cPOSS,NPO)  as ICNTH case insensitive, cPOSS given as upper
JX = ICNUM  (LINE,JL,JR)      find COL(JX) first non-numeric, non-blank
                              JX=JR+1 NG=0 if none, ND digits before JX
JX = ICNUMA (LINE,JL,JR)      COL(JX) first non-alphameric, non-blank
                              JX=JR+1 if none, ND alphamerics chars.
                              NG=0 all alphanumeric, else =JX
                              COL(NE) first numeric, else NE=0
                              COL(NF) first alpha,   else NF=0
IX = ICTYPE (cSG)             cSG*1 of type IX = 0 unseen, 1 others,
                                    2 numeric, 3 lower, 4 upper case
NX = LNBLNK (LINE(JL:JR))     find last non-blank character
\end{verbatim}
@
