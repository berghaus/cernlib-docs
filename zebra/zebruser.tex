%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                 %
%   ZEBRA User Guide -- LaTeX Source                              %
%                                                                 %
%   This document needs the following external EPS files:         %
%   LINSTRU EPS, GENSTRU EPS, ZEBLINK EPS, BNKFORM EPS,           %
%   RELOCAT EPS, FMZSTOR EPS, FMZWORK EPS, FMZBOK1 EPS,           %
%   FMZBOK2 EPS, FMZBOK3 EPS, FMZBOK4 EPS, FSHUNT1 EPS,           %
%   FSHUNT2 EPS, FSHUNT3 EPS, FSHUNT4 EPS, FSHUNT5 EPS,           %
%   FSHUNT6 EPS, FSHUNT7 EPS,                                     %
%                                                                 %
%   Editor: Michel Goossens / AS-MI                               %
%   Last Mod.: 28 Nov. 1990   mg                                  %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentstyle[11pt,times]{book}
\documentstyle[11pt,epsf]{book}
\newfont{\ttsc}{cmtcsc10 scaled 1095}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                 %
%  Set the page size parameters                                   %
%    A4 size  210mm by 297 mm                                     %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% width of text
%
\setlength{\textwidth}{165mm}
\setlength{\hoffset}{-1in}
% vertical space
\setlength{\voffset}{-1in}
\setlength{\topmargin}{2cm}
\setlength{\headheight}{5mm}
\setlength{\headsep}{5mm}
\setlength{\footheight}{5mm}
\setlength{\footskip}{5mm}
%
% margins
%
\setlength{\evensidemargin}{25mm}
\setlength{\oddsidemargin}{20mm}
\setlength{\marginparsep}{25mm}
\setlength{\marginparpush}{25mm}
\setlength{\marginparwidth}{25mm}
%
% number of lines of text and interline space
%
\setlength{\baselineskip}{15pt}
\setlength{\textheight}{47\baselineskip}
%%%%%%%%%%%% Simple commands  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Routine index:
% Put text in tt boldface and enter routine name in index
\newcommand{\Rind}[1]{{\ttsc #1}\protect\index{Routine #1}}
\newcommand{\Iind}[1]{\protect\index{Routine HIDOPT}
\protect\index{Option #1}\protect\index{#1 option}}
\newcommand{\ttbf}[1]{{\ttsc #1}}% tt font boldface
\newcommand{\action}{\par{\bf Action: }}% Action of  routine
\newcommand{\remark}{\par{\bf Remark:}\par}% Remark for routine
\newcommand{\Pdesc}{\par{\bf Parameter Description}}%
%%%%%%%%%%%% Command \Func    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Func}[1]{\par\vspace*{3mm}\framebox[.98\textwidth]
{\vspace*{3mm}{\ttsc#1}\vspace*{3mm}}\vspace*{3mm}%
\def\cut##1= ##2 ##3 {\gdef\subnam{##2}}
\setbox77\hbox{\cut#1 A }%Placeholder for case without argument
\protect\label{SR_\subnam}% mark the Function definition
\protect\index{Function \subnam}% Enter Function definition in index
}% ***** end of \newcommand{\Func}
%%%%%%%%%%%% Command \Subr    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Subr}[1]{\par\vspace*{3mm}\framebox[.98\textwidth]
{\vspace*{3mm}{\ttsc#1}\vspace*{3mm}}\vspace*{3mm}%
\def\cut##1 ##2 ##3 {\gdef\subnam{##2}}
\setbox77\hbox{\cut#1 A }%Placeholder for case without argument
\protect\label{SR_\subnam}% mark the subroutine definition
\protect\index{Routine \subnam}% Enter subroutine def in index
}% ***** end of \newcommand{\Subr}
%%%%%%%%%%%% Environment DL   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{DL}[1]{% The parameter is the width of the term
\begin{list}{\phantom{#1}}
   {\settowidth{\labelwidth}{\bf #1}% define global width
    \setlength{\leftmargin}{\labelwidth}% set global width
    \setlength{\labelsep}{0pt}% horizontal separation term-item
    \setlength{\itemsep}{0pt}% vertical separation between two items
    \setlength{\parsep}{0pt}% vertical separation paragraphs in item
    \setlength{\topsep}{0pt}% vertical separation text/list
    \renewcommand{\makelabel}[1]{\ttsc ##1\hfill}}}% from item
{\end{list}}% ***** end of environment{DL}
%%%%%%%%%%%% Environment  UL  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{UL}{%
\begin{list}{}
   {\setlength{\labelsep}{0pt}% horizontal separation term-item
    \setlength{\itemsep}{0pt}% vertical separation between items
    \setlength{\parsep}{0pt}% vertical separation paragraphs in item
    \setlength{\topsep}{0pt}% vertical separation text/list
    \renewcommand{\makelabel}{\hfill$\bullet$\hskip6pt}}}%
{\end{list}}
%%%%%%%%%%%% Environment  OL  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{cOL}
\newenvironment{OL}{%
\begin{list}{\hfill{\bf\arabic{cOL}}\hskip6pt}%
   {\setlength{\labelsep}{0pt}% horizontal separation term-item
    \setlength{\itemsep}{0pt}% vertical separation between items
    \setlength{\parsep}{0pt}% vertical separation paragraphs in item
    \setlength{\topsep}{0pt}% vertical separation text/list
    \usecounter{cOL}}}{\end{list}}
%%%%%%%%%%%% Other options    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeindex
\parindent=0pt
\begin{document}
\begin{titlepage}
\title{CERN Program Library Entry Q100\\[2cm]
ZEBRA User Guide\\[2cm]
Data Structure Management System\\[2cm]
Version 3.xx (January 1991)}
\author{Ren\'e Brun and Julius Zoll\\[7mm]
CERN Geneva, Switzerland}
\end{titlepage}
\fbox{\parbox{\textwidth}{
\begin{center}Copyright Notice\end{center}
{\bf ZEBRA - Data Structure Management System}
 
CERN Program Library entry {\bf Q100}
 
Copyright CERN, Geneva 1991
 
Copyright and any other appropriate legal protection of these
computer programs and associated documentation reserved in all
countries of the world.
 
These programs or documentation may not be reproduced by any
method without prior written consent of the Director-General
of CERN or his delegate.
 
Permission for the usage of any programs described herein is
granted apriori to those scientific institutes associated with
the CERN experimental program or with whom CERN has concluded
a scientific collaboration agreement.
 
Requests for information should be addressed to:
 
\begin{center}\begin{tabular}{l}
{\tt CERN Program Library Office}\\
{\tt CERN-DD Division            }\\
{\tt CH-1211 Geneva 23           }\\
{\tt Switzerland                 }\\
{\tt Tel.      +41 22 767 4951   }\\
{\tt Fax.      +41 22 767 7155   }\\
{\tt Bitnet:   CERNLIB@CERNVM    }\\
{\tt DECnet:   VXCERN::CERNLIB (node 22.190)  }\\
{\tt Internet: CERNLIB@CERNVM.CERN.CH}
\end{tabular}\end{center}
 
}} %end of parbox in fbox
\newpage
\section*{About this guide}
\par This user guide contains a description of the basic
ZEBRA routines. The
calling sequences which an ``average user'
will need in most of his work are treated in
detail. Programmers who are
responsible for the layout of the basic software in their experiment
and those who
have to know more about the internal conventions used by ZEBRA
will want to consult the ZEBRA reference manual.
The latter explains the
philosophy behind each ZEBRA construct, discusses each user routine
giving its full calling sequence with
a list of possible error return codes and detailed examples.
It discusses exception handling and provides a description
of the layout of the system tables and banks.
\section*{Acknowledgements}
\par The authors would like to thank all their colleagues, who by their
continuous interest and encouragement, have given them the
necessary input to provide a modern system which, they hope, will allow
an easy development of the basic software
in high energy physics and related fields.
\par In particular
M.Goossens acted as editor of the present guide and he wrote the code
of the DZ package, while
M.Metcalf reviewed the entire document and
is the main author of the introductory chapter.
\section*{Related Publications}
\par This User Guide should be complemented by the following
{\bf ZEBRA Reference Manual} set available from the
Program Library:
\begin{DL}{MMM}
\item[DIA]Error Diagnostics
\item[FZ]Sequential I/O
\item[MZ]Memory Management
\end{DL}
\tableofcontents
\listoffigures
\chapter{ZEBRA - An overview}
\section{Why ZEBRA?}
\par All off-line programming in high-energy physics is carried out, for
various reasons, in the FORTRAN 77 programming language. While this
language offers certain advantages over its competitors, it does suffer
from one serious defect, namely its lack of dynamic data structuring
facilities. The only data structures it contains at all are the array of
homogeneous elements and the common block for shared data. Neither of
these structures can be manipulated as an entity, and neither of them
can be defined dynamically at execution-time. No pointers are available
to link these structures together at a higher level.
If we were to attempt to
define structures using standard FORTRAN they would thus, at best, be in
the following style:
\begin{verbatim}
      PARAMETER (NTRACKS = 100 , NPTS = 20)
      COMMON/POINTS/PTRACK(3,NTRACK),XYZ(NPTS,NTRACK),...
\end{verbatim}
and almost the whole program would have to be regenerated and recompiled
every time one of the symbolic constants is altered.
Relationships between data items would have to be programmed explicitly
using integer arrays of indices.
\par It is to overcome these limitations that the ZEBRA system has been
designed and written. It allows not only a truely dynamic
creation of data structures at execution-time, but also the added
advantage of being able to
{\bf\it manipulate} those structures, and even to write them to an external
storage medium and to recover them intact on some other computer.
In order to achieve this, the
user has to communicate with the ZEBRA system by (mostly) simple calls
to ZEBRA routines, and by following a number of rules and conventions.
Once a program has been written in this fashion, it becomes easy
for anyone knowing rather few of the details to use and to modify the
program, without having to worry about the side-effects of any changes
he or she makes, and without having to recompile large sections of the
code solely in order to obtain a few extra storage locations.
\par ZEBRA provides a significant extension to the power of FORTRAN, in
general at an insignificant cost in terms of execution-time overheads.
However, even that small cost is tiny compared with the extra time which
would otherwise be wasted in developing large programs using only the
conventional facilities.
\par The purpose of this chapter is to introduce the novice user to the basic
terms and concepts of ZEBRA. The actual use of the system
is described in later
chapters, where all the relevant information on calling sequences and so
forth is set out.
\section{Logical Data Structures}
\subsection{The bank}
\par
Imagine that we wish to store all the information about, say, a track in
a single unit, containing perhaps details of its momentum, direction,
coordinates etc. Using a call to the ZEBRA routine MZBOOK, we can ask
for an area of contiguous storage of a given length to be provided. The
actual location of this area is returned by MZBOOK as a
{\bf\it base address} which has to be used in all references to that area.
This unit of storage is called a
{\bf\it bank}, and in FORTRAN code will be referenced as in
\begin{verbatim}
      Q(LTK+1) = PX
      Q(LTK+2) = PY
      etc.
\end{verbatim}
where Q, by convention, is the name of the FORTRAN array underlying the
data structure, and LTK is the base address,
provided by MZBOOK, being the location of the word
preceding the first data word in the bank.
\par An advantage of ZEBRA is that it allows banks to contain data of
differing types. This is explained in detail later, but a simple
application would allow us to address another data word in the bank just
referenced as an integer, e.g.
\begin{verbatim}
      IQ(LTK+19) = NPOINTS
\end{verbatim}
It is important to understand that for data structuring purposes
ZEBRA requires no knowledge of or control
over the actual contents of a bank. Whether it contains track data or a
list of family birthdays is not ZEBRA's concern. The internal details of
the data in a bank are solely the responsibility of the user(s), and it is
vital to maintain an adequate documentation of bank contents.
However, for input/output across computers and for printing
purposes, ZEBRA has to know the type of the bank contents, i.e. whether
the numbers are floating point, integer, Hollerith, etc.
This can be declared by a call to MZFORM.
\subsection{The linear structure}
\par
In our example of a track bank, it is clear that in a given application
there may be a large and variable number of tracks to deal with.
To permit the realization of sets of objects of the same kind, ZEBRA
provides the construct of the {\bf\it linear structure}.
A linear structure consists of a series of linked banks, with each bank
holding in a reserved system word, called the {\bf\it next link},
the base address of the next member of the set. The next link of the
last bank of a linear structure has the value zero, indicating that
there is no next bank.
\index{link!next}
\index{data structure!linear}
\par
A linear structure may be visualized as in Figure~\pageref{LINSTRU}.
\begin{figure}%FRAME=BOX PLACE=INLINE>
\caption{A simple linear structure}
\label{LINSTRU}
\epsffile{linstr.ps}%CENTER WIDTH=16cm DEPTH=4cm>
\end{figure}
The next link is stored in the word LQ(LTK) of the bank,
with the vector LQ
in offset EQUIVALENCE to the vector Q and IQ, as explained later.
The ZEBRA equivalent of a FORTRAN DO-loop to process
all the banks of a linear structure would be :
\begin{verbatim}
      LTK = LFIRST                      -- address of the first bank
   10 IF (LTK.EQ.0) GO TO finished      -- No next bank left ?
            .....                       -- Process data for the bank at LTK
          LTK = LQ(LTK)                 -- Get the address of the next bank
      GO TO 10                          -- Loop
\end{verbatim}
Banks are created dynamically at execution time, and because each
bank has one word to connect the rest of the structure of which it is a
member, the linear structure permits the creation at
execution time of sets of an arbitrary number of objects,
independent of any declaration of maximum dimension, either at
execution time or at compile time, as would be the case with FORTRAN
arrays.
\par
The order of the banks in a linear structure, although defined, is not
normally significant. It depends on the details of the creation process,
as will be seen later. The user may, however, associate significance to
the defined order, and ZEBRA utilities are provided to re-order the
banks in a linear structure by re-arranging the next links (ZSORT).
\index{MZ!ZSORT}
\par
It will be necessary to refer to the
``address of a linear structure'.
This is simply the base address of its first bank. If this address is
available, all the banks of the linear structure can be reached.
\subsection{The general data structure}
\index{data structure!general}
\index{link!down}
\par
In the general case, more complex structures are needed than the linear
one just described. For instance, in the context of a high-energy
physics program a number of track banks may depend on a bank at a
logically higher level which
describes a track vertex. This vertex bank will
contain a link to the first of the track banks. Such a link is called a
{\bf\it down} link.
It is possible for a given bank to have a large number of
down links, and for it to depend similarly on a logically yet higher bank
through a down link in that bank.
We thus see that the down links allow the construction of
a tree structure, and that at each node there may be either a
single bank or a linear structure. This may be pictured as in
Figure~ref{GENSTRC}.
\begin{figure}%FRAME=BOX PLACE=INLINE>
\caption{An example of a general structure}
\label{GENSTRC}
\epsffile{genstru.ps}%CENTER WIDTH=16cm DEPTH=7cm>
\end{figure}
All the links so far described are stored by ZEBRA as part of the bank
concerned. We note that the down and next links are referred to collectively
as {\bf\it structural} links, as they represent the basic connections
of a data structure.
\subsection{Reverse links}
\par
Each ZEBRA bank contains a link pointing to the bank on which the
whole linear structure of which it is a member depends. This is called
the {\bf\it up link}. The value of
this link is zero if the bank concerned is itself at the top of the tree
structure.
Finally, each bank has also an {\bf\it origin} link, which points
to the structural link supporting the bank.
The up link and the origin link are
known as {\bf\it reverse} links.
A summary of the four types of links known to ZEBRA is given in
\index{link!reverse}
\index{link!origin}
\index{link!up}
\subsection{Reference links}
\par The links so far described are an integral part of the data structure
which they represent. It often happens that a user wishes to establish
links between various banks which are not part of the structure itself,
but merely references that the user wishes to record.
These are then known as
{\bf\it reference links}. A bank can contain a large number of such links,
and their use is at the discretion of the user, and entirely his
responsiblity. For the reference links the task of
the ZEBRA system is limited to changing their
values in the event that, for reasons to be explained
below, banks have to be moved, or relocated, in memory. Reference links
provide a high level of generality in the design of complete data
structures, and are another of those features which so greatly
enhances the power of FORTRAN.
Figure~ref{ZEBLINK}.
\begin{figure}%FRAME=BOX PLACE=INLINE>
\caption{A schematic overview of the links known to ZEBRA}
\label{ZEBLINK}
\epsffile{zeblink.ps}%CENTER WIDTH=16cm DEPTH=5cm>
\end{figure}
\section{Physical Storage}
\par It is clear that somehow the banks just described have to be mapped on
to physical computer storage, or memory.
This is achieved in ZEBRA by declaring to the system one or more common
blocks which are to provide the actual storage for the data structures.
It is often sufficient for off-line programs to declare a single large
common block; it is for on-line applications, or for certain large
off-line applications that the possibility to define several distinct
blocks is foreseen. A typical declaration has the following form:
\begin{verbatim}
      COMMON /MYSTOR/ IFENCE(10),LINKS(10),LINKR(20),ISTORE(10000)
      DIMENSION     LQ(999),IQ(999),Q(999)
      EQUIVALENCE  (LINKS(9),LQ(9),IQ(1),Q(1))
\end{verbatim}
An actual common block is declared to ZEBRA by a call to MZSTOR,
and in ZEBRA is termed a {\bf\it dynamic store}.
\par
Within the common block just described, we notice that the effect of the
EQUIVALENCE statement is to offset the arrays Q and LQ by eight
locations. This permits in the references to the data words and to the
links a simple form of subscript, namely that each data word is
addressed as Q(L+n), as already seen, and that each link is referenced
as LQ(L-m). This may be better appreciated by studying the layout of an
actual bank, whose layout is detailed in Figure~\ref{BNKFORM},
where the various sections of the bank may be seen, in particular the
data and the links.
\begin{figure}
\caption{The format of a ZEBRA bank}
\label{BNKFORM}
\epsffile{bnkform.ps}%CENTER WIDTH=16cm DEPTH=18cm>
\end{figure}
\par
The total number of links NL plus a constant plus the number of the
optional, so-called extra I/O words, stored
in the lower part of the first word of the bank (see below),
is required to step over the link
region to reach the central area during a sequential scan
through the store.
The upper part of the first word contains the I/O control-byte.
Together with the extra I/O words, if any, it constitutes the
``I/O characteristic', describing the nature of the bank contents,
as needed for conversion if the bank is written to a file for reading
on some other computer, and also for interpretative dumps
(see routine MZFORM for more details).
\index{bank!I/O characteristic}
\index{MZ!MZFORM}
\index{link!next}
\index{link!up}
\index{link!origin}
\par The central part of the bank starts with the next link,
accessed as LQ(L).
The up link at LQ(L+1) points to the header bank supporting
the linear structure of which the bank is a member;
it is zero if the bank is a primary header bank.
The origin link at LQ(L+2) points to the link
through which the bank is reached.
The origin link is not usually of interest to the user,
its sole purpose is to free the user from having to remember the
supporting link. These three links, next, up and origin are present
in every bank and are not counted in NL and NS.
\index{bank identifier!numeric}
\index{bank identifier!Hollerith}
\par
The two words IQ(L-5) and IQ(L-4) contain the numeric and Hollerith bank
identifiers, IDN and IDH. Usually all the banks of a linear structure
have the same IDH, but different IDN's to permit ready
identification of a particular bank in interactive work.
Words IQ(L-3) and IQ(L-2)
hold the total number of links (NL) and the number of structural
links (NS), respectively,
and word IQ(L-1) holds the number of data words (ND).
\par
The status word at IQ(L) provides in positions
1 to 18 for user status bits,
while positions 19 to 32 are reserved for system use. In particular
bits 19 to 22 contain the number of extra I/O descriptor words NIO,
needed to go backwards from the centre to the start of a bank.
\par
With this format the smallest possible, but useless, ZEBRA
bank (NL=NS=ND=0) occupies 10 words.
\par
\subsection{Divisions}
\index{division}
\par
So far we have seen how banks are stored in a dynamic
store. In fact, a dynamic store may physically be subdivided into
{\bf\it divisions}. The purpose of the division is to enable ZEBRA to
manipulate groups of logically associated banks efficiently, for instance
for input-output or for dropping banks, and also to allow it to handle links
more efficiently when it knows that they are restricted to a single
division.
\par
When a store is initialized by MZSTOR, it automatically creates three
divisions, one for itself and two for the user. Further divisions may be
created explicitly by a call to MZDIV.
\par
It should be noted that stores and divisions are identified by
means of a store/division index whose value never changes. These indices
should be maintained in, for instance, the common block to which they
refer, for reasons of
data integrity.
\index{link area}
\subsection{Link areas}
\par
It is possible for a user to store bank addresses or links, for ease
of manipulation, in a user-defined area, or {\bf\it link area}.
These should be kept in a common block, and a call to
MZLINK or MZLINT is necessary to declare these areas to ZEBRA, which
will then maintain them in the event of a bank relocation. For this
reason, the link areas associated with different stores have to be kept
separately.
\subsection{Working space}
\index{working space}
\par
It happens frequently in a program that some temporary working space is
required, perhaps for use within one or two routines. ZEBRA permits a
user to ask for such working space by a call to MZWORK. The necessary
storage is made physically available at the beginning of the relevant
store, and may contain reference links and data. It should be noted that
the first division in the store is logically part of the working space,
and its existing contents are destroyed by a call to MZWORK. Normally,
therefore, the first division should itself be used only for banks which
are very short term.
\section{Dropping banks and garbage collection}
\index{MZ!MZDROP}
\par
Initially a dynamic store is empty, except for a few system banks in the
system division. As banks are created the occupied space increases and
the free space decreases. By calling MZDROP the user may {\bf\it drop}
banks, which are not needed any longer. MZDROP logically removes banks,
or whole sub-structures, from the surrounding data structure and marks
the banks as dropped. These dropped banks stay intact in memory and in
particular, reference links pointing to dropped banks continue to point
to valid information.
\index{garbage collection}
\par
Possibly, but not normally, the situation can arise, that the free space
is not sufficient to satisfy a request for creating a bank, in which case
ZEBRA will recuperate the space occupied by the dropped banks. This
operation, called {\bf\it garbage collection}, moves the active
banks of
a division to form one contiguous area, squeezing out the dropped banks
and thereby increasing again the free space, updating all links for the
new positions of the banks in memory, including a reset to zero of
reference links which used to point to the dropped banks which have now
disappeared. The process of changing the links for the new position in
memory is called {\bf\it relocation}.
\index{relocation}
\par
ZEBRA triggers a garbage collection automatically whenever a request
for memory cannot be satisfied. If even after garbage collection there
is not enough space, MZBOOK etc. will take an error exit and thus the
user does not have to test, after each call to MZBOOK etc., for the
successful completion of the request.
\par
For garbage collection the ZEBRA system has to know the whereabouts of
{\bf\it all} the links in the program. For this reason it
is essential that the user keeps all bank addresses in locations known
to ZEBRA, either in the link part of banks, or in the link part of the
working space or in link areas. Any link kept elsewhere will be invalid
after a garbage collection.
\par The memory move involved in a garbage collection is represented in
Figure~\ref{RELOCAT}.
\begin{figure}%FRAME=BOX PLACE=INLINE>
\caption[The layout of memory in a division before and after garbage collection]
The layout of memory in a division before and after garbage collection
\par
The top part of the picture
shows a number of ``live' banks numbered 1 to 7
and 5' to 1', which interspersed ``dead'
banks (i.e. banks whose information is no longer needed and whose space
can hence be recovered).
The bottom part of the picture shows the same ``live'
banks which have been left justified to increase the free space.}
\label{RELOCAT}
\epsffile{relocat.ps}%CENTER WIDTH=15cm DEPTH=7.0cm>
\end{figure}
\section{Wiping divisions}
\index{MZ!MZWIPE}
\par In high energy physics repetitive ``event processing'
is a very common
situation: event-by-event the data are read, processed, output and
dropped. Each event is represented by one or several data structures,
which disappear completely before the next event is dealt with.
In this situation it would be inefficient to drop the event with MZDROP
and to rely on garbage collection to recover the space of the previous
event only later, maybe at the moment when the data volume of the new
event is already substantial and would have to be copied. It is much
more efficient to separate the short term data of the event from the
long term data (data held by the program over many events), by
directing them into separate divisions. The event can then be
abandoned with MZWIPE which resets one or several divisions to be empty,
thereby freeing the space for immediate re-use.
\section{Input/Output}
\par One of the important features of ZEBRA is its ability to handle the
transfer of data structures to and from an external
medium. This is performed by calls to routines in the FZ part of the
system, and the user does not need to program any explicit FORTRAN input/output
statements. But the power of the system goes beyond that of a simple data
transfer. It is able to maintain the integrity of a data structure
between an output operation and a subsequent input operation by
appropriate changes to the values of the links connecting the
structure. In addition, ZEBRA permits
input/output to either sequential or direct access files, depending on the
nature
of the data and, very important, it also provides two modes of data
representation. The first is called
{\bf\it native} mode, and implies that the data undergo no conversion when
transfered between storage and the external medium. Such data may be read
only on a computer of a compatible architecture. The
{\bf\it exchange} mode, on the other hand,
allows transfer of data between a large variety of
computers by making appropriate conversions to and from an interchange
format.
\section{Debugging problems}
\subsection{The debugging package}
\par
It is inevitable that errors will sometimes be made in constructing and
manipulating the data structures supported by ZEBRA. In order to allow
a simple and convenient means of checking the integrity of the structures,
including the links and the data, the DZ package has been provided.
It has various options to display and validate the whole or part of a dynamic
store.
\subsection{The user communication array IQUEST}
\par
Information about problems or important input/output running
parameters is available in the user communication array IQUEST in common
QUEST. In order to have access to the information
in this array
the user should include the following definition in his code:
\index{QUEST!user communication array IQUEST}
\index{IQUEST!user communication common QUEST}
\index{QUEST!IQUEST}
\index{QUEST!error reporting}
\index{QUEST!running parameters}
\index{error reporting!QUEST}
\index{running parameters!QUEST}
\begin{verbatim}
      COMMON /QUEST/IQUEST(100)
\end{verbatim}
When a routine detects an error, it identifies itself and gives the
case number describing the problem. This number, together with the
detailed description of the contents of the IQUEST elements, will allow
the user to trace the problem (see the ZEBRA reference guide
for more details).
\par In the case of input/output routines (i.e. the FZ and RZ packages)
information about the last operation is available via IQUEST
(see the description of each routine for the meaning of the
IQUEST entries in each instance).
\section{Some conventions}
\par
ZEBRA uses certain conventions,
for instance that the second letter of each routine or common block
name is a Q or Z. For this reason, users are urged not to
write common block or routine names which could be confused with ZEBRA
names, by avoiding these two letters in that position. Users are also
recommended to begin all link names with an L, in order that this become
a common convention, thereby improving the readability of programs.
\section{Summary}
\par
This chapter has tried to set out the basic features of ZEBRA, together
with a justification for attempting to increase the power of the
programming facilities available to a programmer in this way. The nature
of the data structures has been described, together with the manner
in which they
can be manipulated, displayed, and written and read.
\par
The ZEBRA system has been developed, in part, because of weaknesses in
FORTRAN. It might be that one day comparable
features are provided as part
of a new language standard.
Until then, high-energy physics programmers are able
to develop data structures, one of the most important parts of
programming, using ZEBRA,
a simple, flexible and powerful tool,
providing them with all
the capabilities they require in this area of their research activity.
% ---------------------- MZ routines ------------------------->
\chapter{MZ: The memory manager}
\section{System initialization and end-of-run statistics}
\par Routine MZEBRA must be called to initialize the ZEBRA system.
In particular the ZEBRA standard input and output unit numbers are
preset to the values they should have on any given machine.
\par MZEBRA prints at log level -1 or above (see MZLOGL below)
an initialization message
showing, amongst other things, the version number of the
current ZEBRA system.
\par The parameter in the call to MZEBRA may select initialization
options either with an integer constant or with a list as detailed below.
\Subr{CALL MZEBRA (I)      or    CALL MZEBRA(LIST)}
\index{MZ!MZEBRA}
\index{initialization}
\par
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[I
]Integer variable specifying the output options
\begin{DL}{MMMMM}
\item[ 0
]Standard defaults
\item[-1
]Direct the ZEBRA system output to the terminal
\item[-2
]Print only error messages
\item[-3
]Combination of -1 and -2.
\end{DL}
\end{DL}
\end{DL}
See the ZEBRA reference guide for a description of the meaning
of the parameters in the array LIST.
\subsection{Example}
\par The following call to initialise the MZEBRA system:
\begin{verbatim}
      CALL MZEBRA(-1)
\end{verbatim}
will print a message like the following on the terminal:
\begin{verbatim}
ZEBRA SYSTEM  3.6100      Date/Time 890801/1200
ZEMQ     3.61  890626 17.10
\end{verbatim}
MZEBRA only initializes the general ZEBRA system commons,
it does not initialize the dynamic store.
Before any request to the ZEBRA system involving the store,
the user must initialize it by calling MZSTOR (see below)
\Subr{CALL MZEND}
\index{MZ!MZEND}
\par <P>At the end of execution the user should issue a call to routine
MZEND to obtain
the statistics of usage of the dynamic store.
%??.cc 50>
\section{Initialization of a dynamic store}
\par
ZEBRA can handle up to 16 different dynamic stores. Each such store
must reside in a COMMON block.
Before any operation using a store
it must be initialized by calling MZSTOR.
All transactions with ZEBRA involving stores require the specification
of the
{\bf\it store index IXSTOR}
(or IXDIV which identifies both the store and the division).
The first store initialized is called the primary store and
its store index IXSTOR will be zero, i.e.
when one uses only one store then zero can be specified
as store index in all calls to the ZEBRA routines.
Further secondary stores, when initialized, will have
non-zero IXSTOR values.
\index{store!index}
\index{store!initialization}
\index{store!primary}
\index{store!secondary}
\par Each call to MZSTOR automatically creates two user short term
divisions (called division 1 and 2) and a system division (see MZDIV
for more details).
\Subr{CALL MZSTOR}
(IXSTOR*,CHNAM,CHOPT,FENCE,LQ(1),LQ(LR),LQ(LW),LQ(LIM2),LQ(LAST))
\par Initialises a given dynamic store.
\index{MZ!MZSTOR}
\index{store!definition}
\begin{DL}{MMMMM}
\item[Input:]
\begin{DL}{MMMMM}
\item[CHNAM]Character variable specifying the name of the store for
printing purposes (8 characters maximum).
\item[CHOPT]Character variable specifying the options selected
\begin{DL}{MMMMM}
\item['Q']Quite, set the log level to -2 for this store
\end{DL}
\item[FENCE]Safety area immediately in front of the store to
protect against illegal use of LQ(0), LQ(-1), etc.
The fence extends from FENCE(1) to LQ(0).
\item[LQ(1)]First word of the dynamic store
\item[LQ(LR)]First permanent reference link, if any
\item[LQ(LW)]First word in the store after the permanent links,
this is the first word available to the working
space, or to division 1. The following words are
allocated as permanent user links, if any:\\
LQ(1)  to LQ(LR-1)  structural links, if any\\
LQ(LR) to LQ(LW-1)  reference links, if any.
\item[LQ(LIM2)]Lowest position of the upper limit of division 2,
to protect divisions 1 and 2 from being squeezed out
of existence by other divisions created later.
\item[LQ(LAST)
]Last word of the dynamic store.
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:]
\begin{DL}{MMMMM}
\item[IXSTOR*]The index of the store,
to be used when specifying this store in subsequent calls
to the ZEBRA system. IXSTOR is set to zero for the primary store.
\end{DL}
\end{DL}
\par The division indices for divisions 1 and 2 created by MZSTOR are:\\
For division 1:  IXDIV = IXSTOR + 1\\
For division 2:  IXDIV = IXSTOR + 2
\subsection{Notes:}
\par
\begin{UL}
\item The fence must have one word at least, but at most 1000 words.
\item The data region of the store
(i.e. the total store minus the permanent links)
must be at least 2000 words.
\item The sizes of the various parts of the store must be such
that there are always at least 164 words of reserve area
between divisions 1 and 2 available as working area for the system
[40 words for a secondary store].
\end{UL}
%??.CC 50>
\subsection{Layout of memory after a call to MZSTOR}
\index{IQNIL}
\par
\begin{figure}\label{FMZSTOR FRAME=BOX PLACE=INLINE>
\caption{Layout of memory after a call to MZSTOR}
\epsffile{fmFMZSTOR }%CENTER WIDTH=13.5cm DEPTH=3.2cm>
\end{figure}
The fence region is preset to contain IQNIL
\footnote{IQNIL is a machine dependent bitstring which
is as incompatible as possible with any acceptable data type on the
given machine.
}
in every word, this must never be changed;
the debug aids will check for over-writing.
The permanent links are cleared to zero; the rest of the store is not
touched.
\subsection{Examples}
\par For the primary store:
\begin{verbatim}
      PARAMETER   (NAQ = 120000)
 
      COMMON //    FENDA(16),              the fence area
     +             LMAIN, ...              the structural links
     +             L1, ...                 the reference  links
     +             DIV12(70000) , OTHER
 
      DIMENSION    LA(NAQ) , IA(NAQ) , A(NAQ)
      EQUIVALENCE (LMAIN   , LA(1))  , (A(1) , IA(1) , LA(9))
 
      CALL MZSTOR (0,'//',' ',FENDA,LA,L1,DIV12,OTHER,A(NAQ))
\end{verbatim}
\par For a secondary store without permanent links:
\begin{verbatim}
      COMMON /BDYN/ IXBST     , IXBDV1 , IXBDV2 , IXBHIT ,
     +              FENDB(16) , LB     , LASTB
 
      DIMENSION     LB(40000) , IB(40000) , B(40000)
      EQUIVALENCE  (B(1) , IB(1) , LB(9))
 
      CALL MZSTOR (IXBST,'/BDYN/','Q',FENDB,LB,LB,LB,LB(30000),LASTB)
      IXBDV1 = IXBST + 1
      IXBDV2 = IXBST + 2
\end{verbatim}
%??.cc 50>
\section{Set the log level for a store}
\par Various parts of the ZEBRA system write log messages
to the standard system output,
and occasionally also to the on-line terminal, if any.
\par Examples of messages provided for are:
\begin{UL}
\item Messages for recoverable errors: read errors, data errors
\item Initialization messages for: stores, divisions, link areas, files
\item Termination messages giving statistics of usage of
various facilities like memory, files
\item Operation messages: change in program phase, end-of-file
\item Watch messages for hopefully rare, expensive events:
garbage collection, MZPUSH with relocation
\item Monitor messages to help the user debug his program
\end{UL}
\par To control the amount of information thus provided to the user,
a log level is defined and can be set and reset by the user
at execution time.
The default log level zero enables the messages which one would
usually like to see for record in a production run.
The user may reduce the log level to cut out most or all messages;
he may increase the level to watch the running of his program,
or even to debug his data or his input files.
\par Separate ZEBRA entities, such as dynamic stores or files,
each have their own attached log level,
which may be changed by the user at any time.
By default they inherit the global system-wide default log-level
set by MZEBRA, whose own default is zero.
\par The log level attached to a particular dynamic store is initialized
by MZSTOR, normally to the global default log level.
The user may change it at any time with:
\Subr{CALL MZLOGL (IXSTOR,LOGLEV)}
\index{MZ!MZLOGL}
\index{logging level}
\par
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store
for which the logging level has to be set
\item[LOGLEV
]Logging level
\begin{DL}{MMMMM}
\item[-3
]Suppress all log messages
\item[-2
]Error messages: ZFATAL, ZPHASE
\item[-1
]Terse logging: MZEBRA, MZSTOR, ZPHASE
\item[ 0
]Normal logging: MZDIV, MZLINK
\item[ 1
]Log to watch: MZLINT, MZGARB, MZPUSH, MZFORM, MZIOBK, MZIOCH
\item[ 2
]Log to monitor ZEBRA calls: MZLINT,
MZWORK, MZBOOK, MZLIFT, MZDROP, MZPUSH, MZGARB, MZLOGL
\end{DL}
\end{DL}
\end{DL}
\index{MZ!MZSTOR}
%??.cc 50>
\section{Creation of a division}
\par A dynamic store can be physically subdivided into {\bf divisions}.
Up to 20 divisions are allowed, which permits 17 divisions
to be created by the user with MZDIV, beyond the 3 divisions
created by MZSTOR.
\index{division!creation}
\index{division!mode}
\begin{DL}{MMMMM}
\item[Mode of a division:
]Depending on whether a division grows
at its higher or its lower end,
a division is said to be of mode ``forward' or ``reverse'.
By default a division is created with mode ``forward'.
\item[Kind of a division:
]Depending on its usage,
we distinguish three kinds of divisions (apart from the
system division, which is used by the ZEBRA system itself):
\index{division!kind}
\begin{DL}{MMMMM}
\item[User short term
]A division which will be wiped clean after every
``event'(default);
\item[User long term
]A division for data associated to several events or needed
throughout the program execution up to the termination phase;
\item[Package
]A division used by some service
packages, and whose contents are not normally of any concern to the user.
\end{DL}
\item[Division cross-reference matrix:
]As a default, links in a user division
may point to any other user division in the same store,
except that a linear structure must be contained within one division.
More restricted inter-division cross-reference maps can be defined,
either by using the
'C' (contained) option of MZDIV, which indicates that the division
in question does not reference any other division, or, for more general
cases, by using routine MZXREF
as described on page on Page~\pageref{MZXREF FORM=PAGEONLY}.
\index{MZ!MZXREF}
\end{DL}
\Subr{CALL MZDIV (IXSTOR,IXDIV*,CHNAM,NW,NWMAX,CHOPT)}
\index{MZ!MZDIV}
\index{division!initialization}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Store index (zero for the primary store)
\item[CHNAM
]Character variable specifying the
name of the division for printing purposes
(8 characters maximum).
\item[NW
]Number of words (minimum 100) to be allocated to the division
initially. Later the division
may grow, but not beyond NWMAX.
\item[NWMAX
]Maximum size of the division (at least NW).
\item[CHOPT
]Character string specifying the options desired.
\begin{DL}{MMMMM}
\item['R'
]Reverse division (default is Forward)
\item['L'
]Long term division (default is user short term)
\item['P'
]Package division (default is user short term)
\newline (P implies C, overrides L)
\item['C'
]Division is Contained (i.e. no links point outside)
\newline Default: all user divisions point to all other user divisions.
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[IXDIV*
]Index of the created division. This index
must be used when specifying this division in subsequent calls
to ZEBRA.
\end{DL}
\end{DL}
%??.CC 12>
\subsection{Examples}
\par Create a user short term division called HITS in
forward mode in the primary store.
\begin{verbatim}
      CALL MZDIV (0 , IXHITS , 'HITS' , 10000 , 20000 , ' ')
\end{verbatim}
\par Create a user long term division called CALIB in
reverse mode in the secondary store with index IXCST.
\begin{verbatim}
      CALL MZDIV (IXCST , IXCALI , 'CALIB' , 8000 , 8000 , 'RL')
\end{verbatim}
%??.cc 30>
\section{The initialization of a link area}
\par A link area is a vector of links outside any dynamic store, with
all its links pointing to one particular store. A link area
consists of NS structural links followed by NR reference links.
Either NS or NR may be zero.
\index{link area!initialization}
\par We distinguish two kinds of link areas:
\begin{OL}
\item A {\bf\it permanent}
link area is initialized once at the steering level
and is valid for the whole program;
\index{link area!permanent}
\item A {\bf\it temporary}
link area is requested and deactivated
by lower-level code any number of times.
\index{link area!temporary}
\end{OL}
A permanent link area consists of just the vector of links;
a temporary link area has two words prefixed to the link-vector
for efficiency:
\begin{UL}
\item {\bf Word 1}
is a flag indicating whether the area is active or not;
if this word is zero, the contents of the area will
not be updated in case of a memory move.
The user may reset this word to zero to de-active the link area.
\item {\bf Word 2} is a key allowing the system to find easily the
whereabouts of this area in the system tables without searching.
This word must never be redefined by the user.
\end{UL}
A link area must be in COMMON storage;
if it is in local storage there is a danger that FORTRAN
optimization causes a register to preserve the old value of a link
across a relocation operation,
for garbage collection,
but also for simple updating with MZDROP, ZSHUNT, etc.
%??.cc 50>
\Subr{CALL MZLINK (IXSTOR,CHNAM,LAREA,LREF,LREFL)}
\index{MZ!MZLINK}
\par Declares a permanent link area. It should only be {\bf called
once} for any given area.
\index{link area!declaration}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store into which the links will point.
\item[CHNAM
]Character variable specifying the
name of the FORTRAN COMMON in which the link area resides,
for printing purposes (8 characters maximum).
\item[LAREA
]First word of the link area,
being also the first link of this area
\item[LREF
]First reference link, if any;
last structural link, if no reference links
\item[LREFL
]Last reference link, if any,
if none: give LAREA in this parameter position
\end{DL}
\end{DL}
\par MZLINK will clear the links to zero.
%??.cc 20>
\subsection{Examples [for the primary store]}
\subsubsection{Mixed link area}}}}}
\begin{verbatim}
      COMMON /LAMIX/ LS1,...,LSN, LR1,...,LRN
 
      CALL MZLINK (0,'/LAMIX/',LS1,LR1,LRN)
\end{verbatim}
\subsubsection{Structural link area}}}}}
\begin{verbatim}
      COMMON /LASTR/ LS1, ..., LSN
 
      CALL MZLINK (0,'/LASTR/',LS1,LSN,LS1)
\end{verbatim}
\subsubsection{Reference link area}}}}}
\begin{verbatim}
      COMMON /LAREF/ LR1, ..., LRN
 
      CALL MZLINK (0,'/LAREF/',LR1,LR1,LRN)
\end{verbatim}
%??.cc 50>
\Subr{CALL MZLINT (IXSTOR,CHNAM,LAREA,LREF,LREFL)}
\index{MZ!MZLINT}
\index{link area!declaration}
\par This call declares and initialises or re-initialises
a temporary link area.
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store into which the links will point.
\item[CHNAM
]Character variable specifying the
name of the FORTRAN COMMON in which the link area resides,
for printing purposes (8 characters maximum).
\item[LAREA
]First word of the link area, with
\begin{DL}{MMMMM}
\item[LAREA(1)
]The user flag word
\item[LAREA(2)
]A system word, which must not be redefined by the user
\item[LAREA(3)
]The first link of the area
\end{DL}
\item[LREF
]First reference link, if any;
last structural link, if no reference links
\item[LREFL
]Last reference link, if any;
if none: give LAREA in this parameter position
\end{DL}
\end{DL}
\par MZLINT will clear the links to zero,
set the flag-word LAREA(1) to be non-zero,
and set the system-word LAREA(2) on first use.
\par To deactivate a temporary link area the user sets LAREA(1)=0.
From then on the links in this area are no longer relocated,
and hence will be meaningless.
\par To reactivate the area the user should call MZLINT again.
%??.cc 20>
\subsection{Examples [primary store]}
\subsubsection{Mixed link area}}}}}
\begin{verbatim}
      COMMON /LAMIX/ LAMIX(2), LS1,...,LSN, LR1,...,LRN
 
      CALL MZLINT (0,'/LAMIX/',LAMIX,LR1,LRN)
\end{verbatim}
\subsubsection{Structural link area}}}}}
\begin{verbatim}
      COMMON /LASTR/ LASTR(2), LS1, ..., LSN
 
      CALL MZLINT (0,'/LASTR/',LASTR,LSN,LASTR)
\end{verbatim}
\subsubsection{Reference link area}}}}}
\begin{verbatim}
      COMMON /LAREF/ LAREF(2), LR1, ..., LRN
 
      CALL MZLINT (0,'/LAREF/',LAREF,LR1,LRN)
\end{verbatim}
%??.cc 50>
\section{Working space allocation}
\par The region at the beginning of a dynamic store just after
the permanent links may be used as working space,
consisting of a set of reference links followed by
a set of data words.The use of this facility is as follows:
\Subr{CALL MZWORK (IXSTOR,DFIRST,DLAST,IFLAG)}
\index{MZ!MZWORK}
\index{working space!declaration}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store where the working space has to be provided
\item[DFIRST
]First data word of the working space,
the preceding words are taken as reference links;
this parameter is ignored if IFLAG is 2 or -1
\item[DLAST
]Last data word,
this parameter is ignored if IFLAG is -1
\item[IFLAG
]Integer constant defining action desired
\begin{DL}{MMMMM}
\item[ 0
]Define a new working space
\newline The previous contents are not to be retained
\item[ 1
]Vary the limits of the working space and keep
intact the links which are common to
both the old and the new working space.
\item[ 2
]Vary only the DLAST limit of the working space and retain
all links and the data words
which are common to the old and the new working space.
\item[-1
]Reset the working space to null,
i.e. zero links and zero data words
\end{DL}
\end{DL}
\end{DL}
\par A call to MZWORK destroys division 1 of the store
{\bf\it without}
a relocation pass to reset links pointing into division 1.
This is for efficiency,
hence normally only very temporary data should be kept in division 1,
and only working space links should point to them.
To say it differently : division 1 is logically part of the
working space,
its time of existence is the same as that of the working space,
and it is good practice to maintain links into division 1
only in the working space.
If however it is necessary to hold such links elsewhere,
one should either reset them explicitly or wipe the division with
CALL MZWIPE before calling MZWORK
\par The links of the working space (if IFLAG=1: the new links only)
are initialized to  IQNIL+L,
where L is the location of the link in the store.
\index{IQNIL}
\subsection{Example}
\begin{verbatim}
   COMMON /STORE1/ IFENCE , LQPERM(100),    fence and permanent links
  +                LR1, ...                 working space reference links
  +                DFIRST, ...              working space data words
  +                DLAST
 
   CALL MZWORK (0 , DFIRST , DLAST , 0)
\end{verbatim}
\begin{figure}\label{FMZWORK FRAME=RULE PLACE=INLINE>
\caption{Layout of the store after a call to MZWORK}
\epsffile{FMZWORK }%CENTER WIDTH=15.5cm DEPTH=3.cm>
\end{figure}
%??.cc 50>
\section{Bank creation}
\par A bank may be created by calling either MZBOOK or MZLIFT.
The functions of both routines are identical, and so is the
significance of the parameters. The routines differ only in the way the
input parameters are passed. They are both available since they
answer different needs.
\Subr{CALL MZBOOK (IXDIV,L*,*LSUP*,JBIAS,CHIDH,NL,NS,ND,NIO,NZERO)}
\index{MZ!MZBOOK}
\index{bank!booking}
\par Routine
MZBOOK is provided for local creation of a bank, with all parameters
describing the bank present in the CALL sequence itself.
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]Index of the division into which the bank is
to be introduced, see below
\item[*LSUP*
]if JBIAS < 0:  address of the supporting up bank
\newline if JBIAS = 0:  address of the supporting previous bank
\newline if JBIAS = 1:  supporting link
\item[JBIAS
]if JBIAS < 1:  link bias in the supporting bank
\newline if JBIAS = 1:  create top-level bank
\newline if JBIAS = 2:  create stand-alone bank
\item[CHIDH
]Character variable specifying the bank Hollerith identifier
\item[NL
]Total number of links, NL < 64000
\item[NS
]Number of structural links, NS |< NL
\newline (not counting the 3 links next, up, and origin)
\index{link!next}
\index{link!up}
\index{link!origin}
\item[ND
]Number of data words
\item[NIO
]IO characteristic, describing the type of the data words given as:
\newline - An I/O characteristic itself, as returned by MZIOCH
\newline - The index of the I/O characteristic, as returned by MZFORM
\newline - An immediate value, if the whole bank is of the same type:
\begin{DL}{MMMMM}
\item[ 0
]Undefined data type (the bank cannot be transported between
computers)
\item[ 1
]The whole bank is of type {\bf\it bit string}
\item[ 2
]The whole bank is of type {\bf\it integer}
\item[ 3
]The whole bank is of type {\bf\it floating point}
\item[ 4
]The whole bank is of type {\bf\it double precision}
\item[ 5
]The whole bank is of type {\bf\it Hollerith}
\item[ 7
]The whole bank is {\bf\it self describing}
\item[ 9
]Retrieve the I/O characteristic by scanning the system
bank created by MZFORM using the IDH identifier.
\item[ 11
]Take the I/O characteristic of any bank in the target
linear structure, if this is empty act as for 9.
\end{DL}
\item[NZERO
]Controls whether and how much of the data-part
of the bank is preset to zero:
\begin{DL}{MMMMM}
\item[-1
]No presetting
\item[ 0
]The whole bank is cleared
\item[>0
]The first N words are preset
\end{DL}
\newline The links of the bank are always cleared to zero.
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[L*
]Address of the created bank.
\item[*LSUP*
]Address of the supporting bank.
\end{DL}
\end{DL}
%??.cc 50>
\Subr{CALL MZLIFT (IXDIV,L*,*LSUP*,JBIAS,MMBK,NZERO)}
\index{MZ!MZLIFT}
\index{bank!lifting}
\par Routine
MZLIFT is provided in the context of a centralized organization
of bank descriptors, held normally in a COMMON block.
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]Index of the division into which the bank is
to be introduced, see below
\item[*LSUP*
]if JBIAS < 0:  address of the supporting up bank
\newline if JBIAS = 0:  address of the supporting previous bank
\newline if JBIAS = 1:  supporting link
\item[JBIAS
]if JBIAS < 1:  link bias in the supporting bank
\newline if JBIAS = 1:  create top-level bank
\newline if JBIAS = 2:  create stand-alone bank
\item[MMBK
]The bank descriptor vector:
\begin{DL}{MMMMM}
\item[MMBK(1) = IDH
]Hollerith string
\footnote{Hollerith
constants are not explicitly part of the FORTRAN standard and
hence their use in DATA or assignment statements can yield problems
with some compilers. In that case routine UCTOH
%??.* BIBREF REFID=UCTOH>
(available as CERN program library routine M409) can be used
to translate between character variables and Hollerith strings.
}
of the form 4Hxxxx specifying the bank name
\item[MMBK(2) = NL
]Total number of links, NL < 64000
\item[MMBK(3) = NS
]Number of structural links, NS |< NL
\newline (not counting the 3 links next, up, and origin)
\index{link!next}
\index{link!up}
\index{link!origin}
\item[MMBK(4) = ND
]Number of data words
\item[MMBK(5) = NIO
]IO characteristic, describing the type of the data words given as:
\newline - An I/O characteristic itself, as returned by MZIOCH
\newline - The index of the I/O characteristic, as returned by MZFORM
\newline - An immediate value, if the whole bank is of the same type:
\begin{DL}{MMMMM}
\item[ 0
]Undefined data type (the bank cannot be transported between
computers)
\item[ 1
]The whole bank is of type {\bf\it bit string}
\item[ 2
]The whole bank is of type {\bf\it integer}
\item[ 3
]The whole bank is of type {\bf\it floating point}
\item[ 4
]The whole bank is of type {\bf\it double precision}
\item[ 5
]The whole bank is of type {\bf\it Hollerith}
\item[ 7
]The whole bank is {\bf\it self describing}
\item[ 9
]Retrieve the I/O characteristic by scanning the system
bank created by MZFORM using the IDH identifier.
\item[ 11
]Take the I/O characteristic of any bank in the
target linear structure, if this is empty act as for 9.
\end{DL}
\end{DL}
\item[NZERO
]Controls whether and how much of the data-part
of the bank is preset to zero:
\begin{DL}{MMMMM}
\item[-1
]No presetting
\item[ 0
]The whole bank is cleared
\item[>0
]The first N words are preset
\end{DL}
\newline The links of the bank are always cleared to zero.
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[L*
]Address of the created bank.
\item[*LSUP*
]Address of the supporting bank.
\end{DL}
\end{DL}
%??.cc 50>
\subsection{Settings of bank parameters after bank creation}
\subsubsection{Division}}}}}
\par The division in which the bank has to be created can be specified by
the first calling sequence parameter IXDIV, which then corresponds
to the index of a specific division.
The user is, however, not obliged to do so, as he can ask
ZEBRA to create the bank in the same division as the other banks of the
surrounding data structure. This is done by giving as the first parameter
the index of the store only, which in the case of the primary store is
simply zero. Then, when no specific division is specified, the
rules for selecting the division in which the bank will be created
are as follows:
\begin{UL}
\item If the bank is to be part of a non-empty linear
structure, then it will be created
in the same division where the other banks reside.
\item
If this linear structure is empty, the bank will be created in the
same division as its supporting bank.
\item
If there is no supporting bank (JBIAS=1 or 2) division 2 of the given
store will be selected.
\end{UL}
\par {\bf\it Note:}
All banks in a linear structure must reside in the same division, i.e.
link zero of any bank is not allowed to point
outside the division of that bank.
\subsubsection{Input-output characteristic}}}}}
\par The I/O characteristic describes the nature of the data of a bank to
ZEBRA. This information is needed for sending the data across
different computers, and also for interpretation dumps. The I/O
characteristic can be specified directly with MZBOOK/MZLIFT,
or it can be created with MZFORM. A detailed discussion
is given on page on Page~\pageref{MZFORM FORM=PAGEONLY}.
\subsubsection{The numeric and Hollerith bank identifiers}}}}}
\par Each bank has a numeric and a Hollerith
identifier IDN and IDH, which are stored respectively
at IQ(L-5) and IQ(L-4). The IDH is specified explicitly
in the calling sequences to MZBOOK (CHIDH) or MZLIFT (first element
of the MMBK vector) while the bank numberic identifier
is set at bank creation as follows:
\begin{UL}
\item If the bank after creation has a 'next' bank, its IDN is taken
and incremented by one.
\item If the bank is created at the end of a linear structure, the IDN
of its last bank is taken and incremented by one.
\item If no such bank exits, the link number
of the supporting link is taken.
\item If there is no supporting bank IDN is set to one.
\end{UL}
In general banks in a linear structure will have the same IDH
and different IDN. The user can change IDN,
if he so wishes, by simply putting a new value into IQ(L-5).
%??.cc 50>
\subsection{Examples of MZBOOK}
\subsubsection{Top level bank}}}}}
\begin{verbatim}
      CALL MZFORM('MAST',CHFORM,IOMAST)       -- at initialization
 
      CALL MZBOOK(0,L,LMAST,1,'MAST',5,3,10,IOMAST,0)
\end{verbatim}
\par Create in division 2 of the primary store
a bank supported by the link LMAST, which must be part of a
link area. The bank identifier is 'MAST' and the bank
consists of 5 links, of
which 3 are structural and 10 data words. The format of
the latter is described by the I/O index IOMAST (as calculated
by MZFORM) and all data words are to be preset to zero.
The value of IDN will be set equal to 1.
\par Supposing LMAST to be zero initially, this will give the situation in
Figure~\ref{MZBOOK1}.
\begin{figure}\label{MZBOOK1 FRAME=BOX PLACE=INLINE>
\caption{The creation of a top level bank}
\epsffile{FMZBOK1 }%CENTER WIDTH=6.0cm DEPTH=3.2cm>
\end{figure}
%??.cc 20>
\subsubsection{First dependent bank}}}}}
\begin{verbatim}
      CALL MZBOOK(0,L,LMAST,-3,'DOWN',0,0,16,3,0)
\end{verbatim}
\par Create in the primary store and in the same division as 'MAST'
a bank called 'DOWN', which should be attached as the third
structural link to LMAST (created in 1 above). It has zero links
and 16 data words all of type floating.
All data words are to be preset to zero.
The bank at LDOWN is said to be a ``down' bank of MAST; its address could
later be reobtained as LDOWN = LQ(LMAST-3).
The IDN will be set equal to 3. Supposing link 3 of the bank at
LMAST to be zero initially, this will give the picture of
Figure~\ref{MZBOOK2}.
\index{link!down}
\begin{figure}\label{MZBOOK2 FRAME=BOX PLACE=INLINE>
\caption{The creation of a first dependent bank}
\epsffile{FMZBOK2 }%CENTER WIDTH=7.0cm DEPTH=5.5cm>
\end{figure}
%??.cc 20>
\subsubsection{Further dependent banks}}}}}
\begin{verbatim}
      CALL MZBOOK(0,L,LMAST,-3,'DOWN',0,0,16,3,0)
\end{verbatim}
creates a new bank in the primary store and in the same division
as 'DOWN' and inserts it in the linear in front of the 'DOWN' bank
of example 2.
Its address could be obtained as LDOWN4 = LQ(LMAST-3),
while the address of the
bank 'DOWN' created in example 2 could be obtained as LDOWN = LQ(LDOWN4).
The IDN will be set equal to 4 (see Figure~\ref{MZBOOK3}).
\begin{figure}\label{MZBOOK3 FRAME=BOX PLACE=INLINE>
\caption{The creation of further dependent banks}
\epsffile{FMZBOK3 }%CENTER WIDTH=10.0cm DEPTH=5.5cm>
\end{figure}
%??.cc 20>
\subsubsection{Add to end of linear structure}}}}}
\begin{verbatim}
C--     Calculate address of last bank in linear chain
      L = LZLAST(0,LMAST-3)
 
      CALL MZBOOK(0,L,L,0,'DOWN',0,0,16,3,0)
\end{verbatim}
creates a next bank in the primary store and in the same division
as the other 'DOWN' banks.
This bank has the same characteristics as bank
'DOWN' created in 2 above. It is inserted in the linear chain
behind bank 'DOWN' of example 2.
The IDN will be set equal to 4 (see Figure~\ref{MZBOOK4}).
\begin{figure}\label{MZBOOK4 FRAME=BOX PLACE=INLINE>
\caption{The creation of banks at the end of a linear structure}
\epsffile{FMZBOK4 }%CENTER WIDTH=14.0cm DEPTH=5.5cm>
\end{figure}
%??.cc 9>
\subsubsection{Stand alone bank}}}}}
\begin{verbatim}
      CALL MZBOOK(0,LSEUL,0,2,'SEUL',0,0,30,2,-1)
\end{verbatim}
books a bank in division 2 of the primary store,
which is addressable only via the address LSEUL as returned by
routine MZBOOK. It is not inserted in any data structure.
No presetting of the 30 integer data words is requested.
This can be useful for getting very short term working banks or for
building complex data structures starting from individual unrelated
banks, which are afterwards inserted into an
existing data structure using routine ZSHUNT.
The bank number will be set equal to zero.
\index{MZ!ZSHUNT}
%??.cc 40>
\subsection{Examples of MZLIFT}
\par The same examples described above with MZLIFT would look like this:
\subsubsection{Top level bank}}}}}
\begin{verbatim}
C--     During initialization
      COMMON /BANK/  MMMAST(7),MMDOWN(5),MMSEUL(5)
 
      DATA  IMAST /4HMAST/
      DATA MMDOWN /4HDOWN,0,0,16,3/
      DATA MMSEUL /4HSEUL , 0 , 0 , 30 , 2/
 
      MMMAST(1) = IMAST
      MMMAST(2) = 5
      MMMAST(3) = 3
      MMMAST(4) = 10
      CALL MZIOBK (MMMAST,7,'format')
 
C--     During execution
      COMMON /LINKS/ L , LDOWN , LMAST , LSEUL
      COMMON /BANK/  MMMAST(7)
      CALL MZLIFT (0,L,LMAST,1,MMMAST,0)
\end{verbatim}
\subsubsection{First dependent (down) bank}}}}}
\par
\begin{verbatim}
      CALL MZLIFT (0,L,LMAST,-3,MMDOWN,0)
\end{verbatim}
\subsubsection{Further dependent banks}}}}}
\par
\begin{verbatim}
      CALL MZLIFT (0,L,LMAST,-3,MMDOWN,0)
\end{verbatim}
\subsubsection{Insert bank in linear structure}}}}}
\par
\begin{verbatim}
C--
C--     Calculate address of last bank in linear chain
      L = LZLAST(0,LMAST-3)
 
      CALL MZLIFT (0,L,L,0,MMDOWN,0)
\end{verbatim}
\subsubsection{Stand alone bank}}}}}
\begin{verbatim}
      CALL MZLIFT (0,LSEUL,0,2,MMSEUL,-1)
\end{verbatim}
%??.cc 50>
\section{Alter the size of a bank}
\index{division!forward}
\index{division!reverse}
\par The size of a bank can be increased or decreased by using MZPUSH.
Decreasing the size of a bank is done in situ. Increasing the data
part of the last bank in a forward division, as well as increasing
the link part of the first bank in a reverse division, is also done
in situ.
In all other cases a new bank with increased dimensions is lifted
to receive a copy of the data from the original bank, which is then
dropped. The new link and data words acquired are preset to zero.
In general the operation of MZPUSH requires a relocation pass over all
the links to update any link pointing to the bank for its new position.
If the user knows that no such link exists, except for the immediate
system links around this bank, he can signal this to MZPUSH with the
'I' option, thus saving the relocation pass.
\Subr{CALL MZPUSH (IXSTOR,*L*,INCNL,INCND,CHOPT)}
\index{relocation}
\index{MZ!MZPUSH}
\index{bank!size increase}
\index{bank!size decrease}
\index{bank!size change}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store with the bank whose size has to be changed
\item[*L*
]Address of the bank whose size has to be changed
\item[INCNL
]Number of additional links;
zero for no change, negative for decrease.
\newline Additional links will be given type ``reference',
unless the original bank has only structural links.
\item[INCND
]Number of additional data words;
zero for no change, negative for decrease.
\item[CHOPT
]Character variable specifying the relocation strategy
\begin{DL}{MMMMM}
\item[' '
]Default - Any link may point to the bank
\item['R'
]No link points into the abandoned bank region
(in case of bank reduction)
\item['I'
]Isolated case (especially efficient).
No link other than the supporting
structural link, the link passed in the parameter L,
and the reverse links in the first level dependents,
point to this bank.
In this case the immediate links will be updated explicitly
and the relocation pass will be saved.
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*L*
]Relocated address of the bank whose size has been changed
\end{DL}
\end{DL}
\par The new link and data words acquired by the bank
are cleared to zero.
%??.cc 50>
\section{Dropping complete divisions}
\Subr{CALL MZWIPE (IXWIPE)}
\index{MZ!MZWIPE}
\index{division!wipe}
\par A call tp MZWIPE deletes the
contents of complete divisions.
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXWIPE
]Index of the divisions in a particular store which have
to be wiped out.
\newline A value of zero means wipe all short term divisions in the primary
store.
\end{DL}
\end{DL}
\par IXWIPE may be any of the three possible forms of a division index:
\begin{OL}
\item A specific division index, as returned by MZDIV
\item A generic division index, [IXSTOR+] n with
\begin{DL}{MMMMM}
\item[n = 21
]all user short term divisions
\item[n = 22
]all user long  term divisions
\item[n = 23
]all package divisions
\end{DL}
\item A compound division index, as created by MZIXCO,
see page on Page~\pageref{MZIXCO FORM=PAGEONLY} for details.
\end{OL}
Wiping divisions resets the divisions to be empty
(but without reducing the space reserved for them),
followed by a relocation pass to reset to zero all links
pointing into the wiped divisions.
Included in this pass are the links of all link areas,
of the working space and of all divisions which are declared
to point to the divisions in question
(all of this for one particular store only, of course).
\par Wiping several divisions should be done by a single call to MZWIPE
rather than by several calls in succession,
to save the time of multiple relocation passes,
each of which would take longer than the single pass.
\subsection{Examples}
\subsubsection{Division 1}}}}}
\begin{verbatim}
 
      CALL MZWIPE (1)
\end{verbatim}
\subsubsection{Last event}}}}}
\begin{verbatim}
 
      CALL MZWIPE (21)          or          CALL MZWIPE (0)
\end{verbatim}
\subsubsection{All user's divisions}}}}}
\begin{verbatim}
 
      IX = MZIXCO (21,22,0,0)
      CALL MZWIPE (IX)
\end{verbatim}
\subsubsection{Divisions IX1, IX2, IX3, IX4, and IX5}}}}}
\begin{verbatim}
 
      IX = MZIXCO (IX1,IX2,IX3,IX4)
      IX = MZIXCO (IX,IX5,0,0)
      CALL MZWIPE (IX)
\end{verbatim}
%??.cc 50>
\section{User requested garbage collection}
\par Garbage collection is triggered by the system if there is not
enough space to satisfy an MZWORK, MZBOOK/MZLIFT or MZPUSH request
(although this should not normally occur).
Thus the user does not have to worry about initiating
garbage collection to gain space in the dynamic store.
To remove the last event from the store,
the user calls MZWIPE which is much more efficient
than dropping the banks of the event followed by garbage collection.
\par He may, however, occasionally want to force a garbage collection
in order to tidy up his data,
particularly during the initialization phase of his program.
Again, as in MZWIPE, if there are several divisions to be tidied up,
this should be done by {\bf\it one} call to MZGARB. Also,
if one or several divisions are to be wiped out at the same time,
this should be included into the call to MZGARB;
a single relocation pass can handle wiping
and garbage collection simultaneously.
\Subr{CALL MZGARB (IXGARB,IXWIPE)}
\index{MZ!MZGARB}
\index{division!garbage collection}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXGARB
]Index of the divisions in a given store where a garbage collection
is requested (none if 0).
\item[IXWIPE
]Index of the divisions in a particular store
to be wiped (none if 0).
\end{DL}
\end{DL}
\par
Both IXGARB or IXWIPE may be any of the three possible forms
of a division index as described for MZWIPE on page
on Page~\pageref{MZWIPE FORM=PAGEONLY}.
%??.cc 50>
\section{Compound division index creation}
\par A compound division index permits an indication of several divisions
of the same store in a single word,
as used with MZWIPE for example.
\Func{IXC = MZIXCO (IX1,IX2,IX3,IX4)}
\index{MZ!MZIXCO}
\index{division!compound index}
\par Function MZIXCO joins up to four division indices into a compound:
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXi
]Index of the divisions in the same store which are to be
combined.
\newline If less than 4 indices are to be joined trailing zeros
should be given.
\newline If more than 4 indices are to be joined this is done by
repeated calls.
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXC*
]The combined division index (function value).
\end{DL}
\end{DL}
\par IXi can be one of the following forms of a division index:
\begin{OL}
\item A specific division index, as returned by MZDIV
\item A generic division index, [IXSTOR+] n with
\begin{DL}{MMMMM}
\item[n = 21
]all user short term divisions
\item[n = 22
]all user long  term divisions
\item[n = 23
]all package divisions
\end{DL}
\item A compound division index, as created by previous call to MZIXCO.
\end{OL}
%??.cc 20>
\subsection{Examples}
\subsubsection{Divisions 1 and 2:}}}}}
\begin{verbatim}
 
      IXCO = MZIXCO (1,2,0,0)
\end{verbatim}
\subsubsection{Divisions 1, 2, and IXHITS:}}}}}
\begin{verbatim}
 
      IXCO = MZIXCO (1,2,IXHITS,0)
\end{verbatim}
\subsubsection{All short term divisions and IXCUMU:}}}}}
\begin{verbatim}
 
      IXCO = MZIXCO (21,IXCUMU,0,0)
\end{verbatim}
\subsubsection{All user divisions of store IXSTOR}}}}}
\begin{verbatim}
 
      IXCO = MZIXCO (IXSTOR+21,IXSTOR+22,0,0)
\end{verbatim}
%??.cc 50>
\section{Set the cross-reference matrix between divisions}
\par To save time when wiping a given division (or divisions),
and also on garbage collection,
ZEBRA will relocate the links of only those divisions
which reference the division(s) being changed.
To know which division may have links pointing
to which other division,
ZEBRA keeps internally a cross-reference matrix;
the entry for a given division is intialized by MZDIV
and this may be modified by the user calling MZXREF.
\Subr{CALL MZXREF (IXFROM,IXTO,CHOPT)}
\index{MZ!MZXREF}
\index{division!cross-references}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXFROM
]Index of the division which contains links
pointing to the divisions indicated by IXTO;
this must be the index of one particular division.
\item[IXTO
]Index of the division(s) which are referenced
\item[CHOPT
]Character variable specifying the options
\begin{DL}{MMMMM}
\item[' '
]Normal - Set reference(s), i.e. overwrite the previous
content of the matrix entry
\item['A'
]Add reference(s), i.e. add to the matrix entry,
keeping what was there before.
\item['C'
]Contained division, i.e. clear the matrix entry
(C over-rules A and R)
\item['R'
]Remove reference(s), i.e. take the references
out from the matrix entry, but keep the others (R over-rules A)
\end{DL}
\end{DL}
\end{DL}
\par
IXTO can be one of the following forms of a division index:
\begin{OL}
\item A specific division index, as returned by MZDIV
\item A generic division index, [IXSTOR+] n with
\begin{DL}{MMMMM}
\item[n = 21
]all user short term divisions
\item[n = 22
]all user long  term divisions
\item[n = 23
]all package divisions
\item[n = 24
]the system division
\end{DL}
\item A compound division index, as created by previous call to MZIXCO.
\end{OL}
When a division is created, the matrix row for this division
is initialized by MZDIV
as follows (unless the C option is given to MZDIV):
\begin{DL}{MMMMM}
\item[User division
]References all other user divisions.
\item[Package division
]No references at all.
\end{DL}
%??.cc 24>
\subsection{Examples}
\par
\begin{OL}
\item Suppose the user's division IXTHIS may reference
all other user divisions:
\par
         nothing needs to be done, this is the default assumption
\par
\item Suppose division IXTHIS references
only banks in division 2:
\begin{verbatim}
      CALL MZXREF (IXTHIS, 2, '.')
\end{verbatim}
\item Suppose division IXTHIS references only,
but maybe all, the short term divisions:
\begin{verbatim}
      CALL MZXREF (IXTHIS, 21, '.')
\end{verbatim}
\item Suppose division IXTHIS references all short term
divisions and also the long term division IXLONG:
\begin{verbatim}
      CALL MZXREF (IXTHIS, 21, '.')
      CALL MZXREF (IXTHIS, IXLONG, 'A')
\end{verbatim}
\item Suppose division IXTHIS references all short term
divisions except division IXSH:
\begin{verbatim}
      CALL MZXREF (IXTHIS, 21, '.')
      CALL MZXREF (IXTHIS, IXSH, 'R')
\end{verbatim}
\end{OL}
%??.cc 50>
\section{Handle the bank I/O characteristic}
\subsection{Bank format}
\index{MZ!MZBOOK}
\index{MZ!MZLIFT}
\par The nature of the contents of any bank which is to be transported
from one computer to another one has to be indicated to ZEBRA,
so that it can carry out the necessary transformations.
The bank format is also used for printing purposes by the DZ package.
In the simplest case that all the data words of a bank are
of the same type, this can be indicated by specifying a value between 0
and 5 for the parameter NIO of MZBOOK/MZLIFT.
For anything more complicated the user specifies the ``format'
of the bank by calling MZIOBK or MZFORM which encode the format
into a variable number of words to be included into each bank
in the system part as the ``I/O characteristic'.
Thus the content description is carried by each bank,
and complicated bank formats require a relative large number
of extra system words.
This could represent a substantial overhead on memory
or file space occupation,
which the user can avoid in the design of his bank formats.
Thus ZEBRA cannot handle arbitrary bank formats,
but by using the concept of the ``self-describing' sector (see below)
the user can indeed store any combination in a bank
and transport it from one computer to another one.
\index{bank!I/O characteristic}
\index{bank!sector}
\par The basic element for setting up a bank descriptor is the
{\bf\it sector},
which is a number of consecutive words in the bank which are
all of the same type.
A sector is described in the ``format' parameter to MZFORM et al.
as a combination of its word-count
{\bf\it 'c'} and its data type {\bf\it 't': 'ct'}.
For example
{\tt '24F'}
is a sector of 24 single precision floating-point
numbers, and {\tt '1I'}
is a sector of one integer word.
\index{bank!data type identifier}
\par The possible types for the data type identifier 't'
are listed in Table~\ref{MZFORMT}.
\begin{center}\begin{tabular}{|l|l|}
\caption{MZFORM data type identifier syntax}
\label{MZFORMT}
\hline
B&bit string of 32 bits, right justified in a machine word\\
I&integer\\
F&floating-point\\
D&double precision\\
H&4-character Hollerith\\
S&self-describing sector (see below)\\ \hline
\end{tabular}\end{center}
\index{bank!sector!static}
\par A {\bf static} sector is a sector of a fixed number of words,
such as the {\tt '24F'} in the example above.
\index{bank!sector!static}
\index{bank!sector!indefinite-length}
\par An {\bf indefinite-length}
sector is a sector whose end is defined
by the end of the bank.
This is written as {\bf\it -t}, for example
{\tt '-F'} signals that the rest
of the bank is all floating-point words.
\index{bank!sector!dynamic}
\par A {\bf dynamic} sector is
a sector which is preceded in the bank
by a single positive integer word indicating the sector length;
if this number is zero this means that the rest of
the bank is currently unused.
This is written as  {\bf\it *t}, for example
{\tt '*F'} indicates a dynamic sector of type floating.
\index{bank!sector!self-describing}
\par A {\bf self-describing} sector is a dynamic sector whose type
is also encoded into the word preceding the sector as follows:
{\bf 16*NW + IT}, where {\bf NW} is the length of the
sector and {\bf IT}, is a numeric descriptor of the type of
data, as defined in Table~\pageref{MZFORMS}
(cf. MZBOOK and MZLIFT).
\index{MZ!MZBOOK}
\index{MZ!MZLIFT}
\begin{center}\begin{tabular}{|cl|cl|}
\caption{Numeric representation of data type in self-describing sector header word}
\label{MZFORMS
\hline
{\bf 1}&bit string (as 'B')&{\bf 2}&integer (as 'I')\\
{\bf 3}&C>floating-point (as 'F')&{\bf 4}&C>double precision (as 'D')\\
{\bf 5}&C>4-character Hollerith (as 'H')&{\bf 6}&C>reserve\\
{\bf 7}&special&&\\ \hline
\end{tabular}\end{center}
The word-count {\bf\it 'c'} for a sector,
which must {\bf\it always} be specified, can take the forms
given in Table~\pageref{MZFORMC}.
It has to be stressed that this parameter {\bf\it c} is in units of
``ZEBRA words', hence 4 double precision data items,
occupying 8 machine words, have to be specified as {\bf\it '8D'},
and a string of 17 Hollerith characters as {\bf\it '5H'}.
\index{bank!word-count}
\begin{center}\begin{tabular}{|l|l|}
\caption{MZFORM word count syntax}
\label{MZFORMC}
n&C>numeric, n words: static length sector\\
>-&C>all remaining words: indefinite length sector\\
>*&C>dynamic length sector (see text)\\
/&C>signals the start of the trailing part of a bank format (see text)
\\ \hline
\end{tabular}\end{center}
Note that the form {\tt 'nS'} is meaningless;
that the form {\tt '*S'}
indicates one particular sector while
{\tt '-S'}is {\bf\it special} and
indicates that the rest of the bank is filled
with self-describing sectors,
as many as there may be.
\par Looking at the bank as a whole,
we divide it into a ``leading' part and a ``trailing' part,
either of which may be empty.
\index{bank!leading part}
\par The {\bf\it leading}
part consists of one region of maybe several sectors,
occurring once at the beginning of the bank.
This leading region may end with an indefinite-length sector,
in which case the trailing part is empty.
\index{bank!trailing part}
\par The {\bf\it trailing} part of the bank may be empty or it may consist
of an indefinite number of ``regions' which
{\bf\it all have the same structure},
such that the same format description is valid for all of them.
\index{bank!region}
\par
The symbol {\bf\it '/'} marks the break between the leading region
and the trailing regions in the format parameter to MZFORM et al.
\subsection{Specifying the bank format}
\par Three routines are provided as an interface for the user to
specify the bank format in a readable form.
The I/O characteristic is included in any bank at creation time.
\Subr{CALL MZIOCH (IOWDS*,NWIO,CHFORM)}
\index{MZ!MZIOCH}
\par Routine {\bf\it MZIOCH} analyses the format CHFORM to convert
and pack it into the output vector IOWDS.
This is the basic routine,
but it is usually called by the user only to specify formats
of objects other than banks
(e.g. the user header vector in the FZ routines).
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[NWIO
]The maximum size of IOWDS
\item[CHFORM
]Character variable specifying the format
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[IOWDS*
]A vector dimensioned to NWIO which is to receive the I/O characteristic
\end{DL}
\end{DL}
%??.CC 15>
\Subr{CALL MZIOBK (MMBK*,NWMM,CHFORM)}
\index{MZ!MZIOBK}
\par Routine {\bf\it MZIOBK} is provided in the context of MZLIFT;
like MZIOCH it analyses the format CHFORM,
but it stores the result as part of the bank-description vector
MMBK for MZLIFT.
\index{MZ!MZLIFT}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[NWMM
]The maximum size of MMBKS
\item[CHFORM
]Character variable specifying the format
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[MMBK*
]The bank description vector for MZLIFT, dimensioned to NWMM.
The resulting I/O characteristic will be stored
in the vector starting at MMBK(5).
The IDH contained in MMBK(1) will be used if diagnostics are necessary.
\end{DL}
\end{DL}
%??.CC 20>
\Subr{CALL MZFORM (CHIDH,CHFORM,IXIO*)}
\index{MZ!MZFORM}
\par Routine {\bf\it MZFORM} analyses the format CHFORM,
but it does not return the result to the user.
Instead,
it stores the I/O characteristic in a system data structure,
returning to the user only the index to the characteristic
in the system.
The user may then either pass this index to MZBOOK (or MZLIFT)
at bank creation time,
or alternatively he may request MZBOOK (or MZLIFT) to search
the system data structure for the I/O characteristic
associated with the Hollerith identifier IDH of the bank to be
created.
\index{bank!I/O characteristic}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHIDH
]Character variable specifying the Hollerith identifier of the
bank whose data part is described by the given format
\item[CHFORM
]Character variable specifying the format of the data
part of a bank with name identifier CHNAM.
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[IXIO*
]The encoded index of the I/O characteristic stored in a system
data structure.
This index can be passed to MZBOOK/MZLIFT, in which case it must
not be modified
\end{DL}
\end{DL}
\subsubsection{CHFORM examples}}}}}
\begin{DL}{MMMMM}
\item[Banks with an empty trailing part:
]
\begin{DL}{MMMMM}
\item['-F'
]Whole bank is floating
\item['3I -F'
]First 3 words are integer, the rest is F
\item['*I -F'
]First word n=IQ(L+1) is a positive integer,
words 2 to n+1 are integers, the rest is F
\item['3B *I -F'
]First sector consists of 3 words bit-string,
the second sector is dynamic of type integer,
the rest of the bank is floating
\end{DL}
\item[Banks with a leading as well as a trailing part:
]
\begin{DL}{MMMMM}
\item['3B 7I / 2I 4F 16D'
]Leading region has 3 B and 7 I words,
each trailing region consists of
2 integer words, followed by 4 F words,
followed by 16 D words, i.e. 8 double-precision numbers
\item['4I / *H'
]Bank starts with 4 integer words,
the rest is filled with dynamic Hollerith sectors
\item['*I / 2I *F'
]Leading region is one dynamic I sector,
each trailing region consists of 2 integers
followed by a dynamic F sector
(i.e. 3 integers plus a number of floating-point words,
this number being indicated by the third integer)
\end{DL}
\item[Banks with an empty leading part:
]
\begin{DL}{MMMMM}
\item['/ *H'
]Bank is filled with dynamic Hollerith sectors
\item['/ 4I 29F'
]4 integers and 29 floating-point numbers alternate
\item['/ *S' or '-S'
]Data of the whole bank are self-describing
\end{DL}
\end{DL}
%??.* ZEBRA Utilities  5 Aug 1989 mg>
\chapter{Utilities}
\section{Operations on data structures}
\subsection{Dropping a bank and its dependents}
\par MZDROP allows one to drop either the {\bf bank}
or the {\bf linear structure} at L ('L' option).
Dropping a bank implies dropping also the whole partial
data structure which depends on this bank downwards.
\par Dropped banks stay in memory with the drop status bit set,
links pointing to them continue to do so,
except for the immediate structural link indicated via the
origin link of the bank at L, which is bridged or reset to zero,
whichever is appropriate.
\Subr{CALL MZDROP (IXSTOR,L,CHOPT)}
\index{MZ!MZDROP}
\index{bank!drop}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store containing the bank to be dropped
\item[L
]Address of the bank or linear structure to be dropped
\item[CHOPT
]Character variable specifying the action desired:
\begin{DL}{MMMMM}
\item[''
]Default - Drop the bank at L and its vertical dependents
\newline i.e. the next link of this bank is not followed.
\item['L'
]Drop the linear structure pointed to by L
\newline i.e. the next link of the bank at L is followed until
all the banks in the linear structure and its dependents have been
dropped.
\item['V'
]Drop only the partial data structure
dependent vertically on the bank at L, but not the the bank itself.
\end{DL}
\end{DL}
\end{DL}
%??.cc 50>
\subsection{Set one of the status bits in the bank of a data structure}
\par By following the structural links,
MZFLAG sets the selected status bit into the status words
of all the banks of the data structure supported
by the vertical links of the specified start bank.
Optionally it can include in the marking
also the banks of the linear structure supported
by link 0 of the start bank and all their dependents.
The start bank itself may or may not be marked.
\Subr{CALL MZFLAG (IXSTOR,L,IBIT,CHOPT)}
\index{MZ!MZFLAG}
\index{bank!status bit}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store containing the bank to be flagged
\item[L
]Address of the start bank supporting the partial
data structure.
\newline No action if L=0.
\item[IBIT
]The bit number of the status bit to be set (using the convention that
the least significant bit in a word is identified with the number 1).
\item[CHOPT
]Character variable specifying the action desired:
\begin{DL}{MMMMM}
\item[''
]Default - Flag the bank at L (and its vertical dependents),
but the next link of this bank is not followed.
\item['L'
]Flag the linear structure pointed to by L,
i.e. the next link of the bank at L is followed.
\item['V'
]Flag only the the partial data structure dependent vertically
on the bank at L, but not the bank itself.
\item['Z'
]Set to zero the status bit IBIT in each bank to be marked.
\newline In the default case bit IBIT in the status word is set to one.
\end{DL}
\end{DL}
\end{DL}
\subsubsection{Example:}}}}}
\begin{verbatim}
      CALL MZFLAG (0,LQMAIN,IQDROP,'L')
\end{verbatim}
drops the complete 'Main' data structure, and is equivalent to
\begin{verbatim}
      CALL MZDROP (0,LQMAIN,'L'),
\end{verbatim}
except that it does not alter the contents of LQMAIN.
%??.cc 50>
\subsection{Change structural relations}
\par Because of the presence of the reverse pointers,
the operation of moving a bank by relinking from one data structure
to another one is a non trivial operation.
The routine ZSHUNT is provided to execute such an operation.
\par ZSHUNT may be used to modify the links associated with
either a single bank (IFLAG=0)
or a whole linear structure (IFLAG=1), using information provided
by the parameters
LSUP and JBIAS, which have the same significance as in MZLIFT.
\Subr{CALL ZSHUNT (IXSTOR,LSH,LSUP,JBIAS,IFLAG)}
\index{MZ!ZSHUNT}
\index{data structure!change}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store containing the bank to be shunted
\newline IXDIV, the index of the division containing
the bank to be shunted, may be given instead
\item[LSH
]The address of the data structure to be shunted
\item[LSUP
]if JBIAS < 0:  the address of the new supporting up bank
\newline if JBIAS = 0:  the address of the new supporting previous bank
\newline if JBIAS = 1:  the new supporting link
\item[JBIAS
]if JBIAS < 1:  the link bias in the new supporting bank
\newline if JBIAS = 1: the origin link in bank LSH will point to link LSUP
\newline if JBIAS = 2:  detach without insertion
\item[IFLAG
]if IFLAG = 0:  shunt the one single bank at LSH
\newline if IFLAG = 1:  shunt the whole linear structure pointed to by LSH
\end{DL}
\end{DL}
\par If the bank or the structure to be relinked is in fact inserted
or added into an existing linear structure,
both must be contained in the same division.
%??.cc 50>
\subsubsection{Examples}}}}}
\begin{figure}\label{FSHUNT1 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - The original data structures}
\epsffile{FSHUNT1 }%CENTER WIDTH=11.0cm DEPTH=11.0cm>
\end{figure}
\par Originally we have the data structures shown in
Figure~\pageref{FSHUNT1}, where any bank may support further
dependent partial data structures since
the corresponding vertical structural links are not changed by ZSHUNT.
\par In what follows the notation {\tt Lxx}is used to designate
a link pointing to bank {\tt xx}.
\par Each example below
refers to the starting situation described in Figure~\pageref{FSHUNT1}.
\begin{figure}\label{FSHUNT2 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - Add bank (and dependents) to front of linear structure}
\epsffile{FSHUNT2 }%CENTER WIDTH=14.0cm DEPTH=7.0cm>
\end{figure}
\begin{verbatim}
      CALL ZSHUNT (0,LA2,LUN,-7,0)
\end{verbatim}
\par This moves a single bank (with is dependents, if any) out of
a linear structure, and inserts it at the head of the linear
structure supported by link -7 of the bank UN.
\begin{figure}\label{FSHUNT3 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - Move part of linear structure in front of another one}
\epsffile{FSHUNT3 }%CENTER WIDTH=17.0cm DEPTH=7.0cm>
\end{figure}
\begin{verbatim}
      CALL ZSHUNT (0,LA2,LUN,-7,1)
\end{verbatim}
\par This is the same as in Figure~\pageref{FSHUNT2},
except that the (partial) linear
structure starting with bank A2 is relinked.
\begin{figure}\label{FSHUNT4 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - Move bank into a linear structure}
\epsffile{FSHUNT4 }%CENTER WIDTH=14.0cm DEPTH=7.0cm>
\end{figure}
\begin{verbatim}
      CALL ZSHUNT (0,LA2,LN2,0,0)
\end{verbatim}
\par This is again the same as in Figure~\pageref{FSHUNT2},
but the bank is inserted inside the linear structure,
rather than at its front.
\begin{figure}\label{FSHUNT5 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - Move a bank to a top level structure}
\epsffile{FSHUNT5 }%CENTER WIDTH=14.5cm DEPTH=2.8cm>
\end{figure}
\begin{verbatim}
      CALL ZSHUNT (0,LA2,LQMAIN,1,0)
\end{verbatim}
\par This re-links bank A2 to be the first in the top-level linear
structure supported by LQMAIN.
\begin{figure}\label{FSHUNT6 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - Attach a linear structure to a top level link}
\epsffile{FSHUNT6 }%CENTER WIDTH=11.0cm DEPTH=2.8cm>
\end{figure}
\begin{verbatim}
      CALL ZSHUNT (0,LA1,LHEAD,1,1)
\end{verbatim}
\par Supposing LHEAD=0 initially; this connects the linear structure
to the (structural) link LHEAD, i.e.
the origin link of the header bank A1
points back to the location of LHEAD.
\begin{figure}\label{FSHUNT7 FRAME=BOX PLACE=INLINE>
\caption{ZSHUNT - Detach a linear structure}
\epsffile{FSHUNT7 }%CENTER WIDTH=11.0cm DEPTH=5.0cm>
\end{figure}
\begin{verbatim}
      CALL ZSHUNT (0,LA1,0,2,1)
\end{verbatim}
\par This removes the linear structure from its old position
without inserting it into a new one.
This should only be temporary; one should insert the floating
structure into a new position by a second call to ZSHUNT
soon after.
%??.cc 50>
\section{Copy a data structure}
\par A data structure can be copied from memory to memory by using
routine MZCOPY. The data structure can be in one or more divisions
in one store or in ``stand-alone' memory and can be copied to a division
in the same store, a different one or to ``stand-alone' memory.
\par The case of ``stand-alone' or ``flat'
memory copies is intended for communication
between separate processes running on the same computer through sharable
memory (formally FORTRAN common blocks). The information must belong to
a single data structure
(see the ZEBRA reference manual for more details).
\Subr{CALL MZCOPY (IXDVFR,LENTRY,IXDVTO,*LSUP*,JBIAS,CHOPT)}
\index{MZ!MZCOPY}
\index{data structure!copy}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDVFR
]Index of division(s) containing the data structure to be copied
\item[LENTRY
]Address of the data structure to be copied
\item[IXDVTO
]Index of the {\bf particular}
division into which the data structure has to be copied.
\item[*LSUP*
]
\item[JBIAS
]JBIAS < 1: LSUP is the supporting bank in the target division
and JBIAS is the link bias specifying where the data structure has to be
introduced into this bank, i.e. the data structure will be connected
to LQ(LSUP+JBIAS).
\newline JBIAS = 1: LSUP is the supporting link, i.e. the data structure
is connected to LSUP (top level data structure)
\newline JBIAS = 2: Stand alone data structure, no connection.
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[Data structure
]
\begin{DL}{MMMMM}
\item[default
]Copy the data structure at LENTRY (the next link is not followed).
\item['D'
]Copy complete division(s)
\newline default: Dropped banks are squeezed out
\newline          (slower but maybe more economic than 'DI')
\item['DI'
]Immediate dump of divisions with dropped banks included
\item['L'
]Copy the data structure supported by the
linear structure at LENTRY (the next link of LENTRY is followed)
\item['S'
]Copy the single bank at LENTRY.
linear structure at LENTRY (the next link of LENTRY is followed)
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[others
]
\begin{DL}{MMMMM}
\item['N'
]No link, i.e. linkless handling
\newline By default link are significant
\item['P'
]Permit error returns
\newline By default an error exit with CALL ZR TELL (15,1) is generated.
\item['Z'
]Zero all links pointing outside the data structure.
\newline This is implied if origin and target stores are different.
\end{DL}
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*LSUP*
]For JBIAS = 1 or 2, LSUP receives
the entry address to the data structure
\end{DL}
\end{DL}
\par For a discussion of the cases of ``stand alone' memory, the user is
referred to the ZEBRA reference manual.
\index{stand alone memory}
%??.cc 10>
\subsection{MZCOPY return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[ 0
]Normal completion
\item[ 1
]LENTRY invalid
\item[ 2
]Bank chaining clobbered in the input data structure
\item[ 3
]Not enough space for the input data structure
\item[ 4
]The data structure is larger than the target space
\item[ 5
]Teh data structure to be copied is empty
\item[ 6
]Bank chaining clobbered in the output data structure
\end{DL}
\end{DL}
\subsection{Examples}
\begin{verbatim}
      CALL MZCOPY (0,LENTRY,IXDIV,LTOP,1,' ')
\end{verbatim}SCALE=AUTO WIDTH=72>
copies the data structure at LENTRY in the primary store into division
IXDIV. The copied data structure will be addressable via the
top level link LTOP.
\begin{verbatim}
      CALL MZCOPY (IXDVFR,LENTRY,IXDVTO,LSUP,-1,'D')
\end{verbatim}
copies the division identified by the identifier IXDVFR to the division
specified by IXDVTO squeezing out unused space.
The entry address into the
data structure in division IXDVFR is LENTRY. In the target division
with index IXDVTO this data structure will be attached to link -1
in bank LSUP and be addressable as {\tt
LCOPY = LQ2(LSUP-1)}
%??.cc 50>
\section{Sort the banks of a linear structure}
\par The routines described below
re-arrange the horizontal linking
within a given linear structure such that the values of the
keywords contained in
each bank increase monotonically when moving through the linear
structure with L=LQ(L).
For equal keyword values the original order is preserved.
\par Key-words may be either floating-point, integer or Hollerith.
For Hollerith sorting a collating sequence
inherent in the representation is used,
thus the results will depend on the machine.
\par Sorting may be done either for a
{\bf single keyword} in every bank
or for a {\bf key vector} in every bank:
\index{linear structure!sort}
\Subr{CALL ZSORT(IXSTOR,LLS,JKEY)}
\par Sorts banks according to a single floating-point keyword
\index{MZ!ZSORT}
\Subr{CALL ZSORTI(IXSTOR,LLS,JKEY)}
\par Sorts banks according to a single integer keyword
\index{MZ!ZSORTI}
\Subr{CALL ZSORTH(IXSTOR,LLS,JKEY)}
\par Sorts banks according to a single Hollerith keyword
\index{MZ!ZSORTH}
\par
\Subr{CALL ZSORV(IXSTOR,LLS,JKEY,NKEYS)}
\index{MZ!ZSORV}
\par Sorts banks according to a floating-point key vector
\Subr{CALL ZSORVI(IXSTOR,LLS,JKEY,NKEYS)}
\index{MZ!ZSORVI}
\par Sorts banks according to an integer key vector
\Subr{CALL ZSORVH(IXSTOR,LLS,JKEY,NKEYS)}
\index{MZ!ZSORVH}
\par Sorts banks according to a Hollerith key vector
\par All these routines have the following {\bf input} parameters:
\begin{DL}{MMMMM}
\item[IXSTOR
]Store index
\item[JKEY
]Q(L+JKEY) - The key word or the first word of the key vector,
\item[NKEYS
]Number of words in the key vector,
\item[LLS
]Address of the first bank of the linear structure.
\end{DL}
\par The execution time taken by these routines is a function
of the reordering which needs to be done.
For perfect order the operation is a simple verification pass
through the structure.
The maximum time is taken if the banks are arranged with
decreasing keywords.
\par Sorting relinks the banks such that the keywords are in
increasing order.
If one needs them in decreasing order one can use routine ZTOPSY
(see below).
%??.cc 50>
\section{Operations on linear structures}
\par The routines described in this section perform service operations
on linear structures.
The parameter {\bf LLS} is the address of the first bank
of the linear structure.
\index{linear structure!reverse order}
\index{MZ!ZTOPSY}
\Subr{CALL ZTOPSY (IXSTOR,LLS)}
\par This routine reverses the order of the banks in the linear structure,
i.e. the first bank becomes the last, and the last the first,
for traversing the structure with L=LQ(L).
\index{linear structure!bridging}
\index{MZ!ZPRESS}
\Subr{CALL ZPRESS (IXSTOR,LLS)}
\par This routine removes, by bridging, dead banks still present
in the linear structure pointed to by LLS.
%??.cc 40>
\section{Interrogate a linear structure}
\par These routines perform service functions for linear structures.
The parameter {\bf LLS} is the address of the first bank
of the linear structure.
\index{linear structure!interrogate}
\index{MZ!LZLAST}
\Func{LFCALL = LZLAST (IXSTOR,LLS)}
\par This function ssearches the linear structure pointed to by LLS
for its end.
It returns in LF the address of the last bank in the structure.
LF = 0 is returned if the structure is empty.
\index{MZ!LZFIND}
\Func{LFCALL = LZFIND (IXSTOR,LLS,IT,JW)}
\par This function searches the linear structure pointed to by LLS
for the first bank containing IT in word JW;
it returns its address in LF.
If none:  LF=0.
\index{MZ!LZLONG}
\Func{LFCALL = LZLONG (IXSTOR,LLS,N,IT,JW)}
\par Same functionality as function LZFIND,
but IT is a vector of N words expected
in words JW to JW+N-1 of the bank.
\index{MZ!LZBYT}
\Func{LFCALL = LZBYT (IXSTOR,LLS,IT,JBIT,NBITS)}
\par Similar to function LZFIND,
but it looks for a bank having IT in the byte of the status word
starting at JBIT and with a width of NBITS bits.
\index{MZ!LZFVAL}
\Func{LFCALL = LZFVAL (IXSTOR,LLS,VAL,TOL,JW)}
\par Same functionality as function LZFIND,
but it looks for a bank having in word JW a floating point number
which is equal to VAL within the tolerance TOL.
\index{MZ!NZBANK}
\Func{NCALL = NZBANK (IXSTOR,LLS)}
\par Function which counts the number of banks in the linear
structure pointed to by LLS.
\index{MZ!NZFIND}
\Func{NCALL = NZFIND (IXSTOR,LLS,IT,JW)}
\par Function similar to LZFIND but for all banks.
It returns the number of such banks in N
and stores the addresses of the first 100 such banks into IQUEST,
starting at IQUEST(1) in common /QUEST/.
\index{QUEST!IQUEST}
\index{MZ!NZLONG}
\Func{NCALL = NZLONG (IXSTOR,LLS,N,IT,JW)}
\par Function similar to LZLONG but for all banks.
It returns the number of such banks in N
and stores the addresses of the first 100 such banks into IQUEST,
starting at IQUEST(1) in common /QUEST/.
\index{QUEST!IQUEST}
%??.cc 50>
\section{Locate a bank in a division}
\par
The routines of this section do not operate on data structures as such,
but they perform a sequential search on the banks in a division.
\subsection{Sequential scan by Hollerith identifier}
\par
Function LZFIDH performs a sequential scan over the banks of a specified
division, starting with the bank following the specified bank,
and returns
the address of the first bank with the specified Hollerith identifier.
\Func{LFCALL = LZFIDH (IXDIV,IDH,LGO)}
\index{MZ!LZFIDH}
\index{division!scan}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]The index of the division to be scanned
\item[IDH
]The 4 character {\bf\it Hollerith} identifier (NOT a CHARACTER
variable).
\item[LGO
]The address of the bank {\bf\it after} which the scan has to start.
\newline LGO = 0 means start with the first bank in the division.
\end{DL}
\end{DL}
\subsection{Sequential scan by Hollerith and numeric identifier}
\par
Function LZFID performs a sequential scan over the banks of a specified
division, starting with the bank following the specified bank and returns
the address of the first bank with the specified Hollerith/numeric
identifier pair.
\Func{LFCALL = LZFID (IXDIV,IDH,IDN,LGO)}
\index{MZ!LZFID}
\index{division!scan}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]The index of the division to be scanned
\item[IDH
]The 4 character {\bf\it Hollerith} identifier (NOT a CHARACTER
variable).
\item[IDN
]The numeric identifier
\item[LGO
]The address of the bank {\bf\it after} which the scan has to start.
\newline LGO = 0 means start with the first bank in the division.
\end{DL}
\end{DL}
\subsection{Division scan by bank identifier}
\par Starting at the first bank in the specified division,
function LZLOC performs a sequential scan through the
division, and returns
the address of the {\bf\it first bank} with the specified
Hollerith/numeric bank identifier pair.
\Func{LFCALL = LZLOC (IXDIV,CHIDH,IDN)}
\index{MZ!LZLOC}
\index{division!scan}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]The index of the division to be scanned
\item[CHIDH
]Character variable containing the Hollerith identifier
\item[IDN
]The numeric identifier
\end{DL}
\end{DL}
%??.cc 13>
\subsection{Number of words available in a division}
\par The number of words available in a division can be obtained
by issueing a call to MZNEED.
If desired (option 'G') a garbage collection can be preformed to
get the needed number of words.
\Subr{CALL MZNEED (IXDIV,NWNEED,CHOPT)}
\index{MZ!MZNEED}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]The index of the division where the free space is needed
\item[NWNEED
]The number of words needed in the division
\item[CHOPT
]Character variable specifying the desired option
\begin{DL}{MMMMM}
\item[default
]Do not garbage collect the division to free space
\item['G'
]Garbage collect the division to increase the space
\end{DL}
\end{DL}
\end{DL}
\subsection{Note}
\index{QUEST!IQUEST}
\par Variable IQUEST(11) in common QUEST contains the space
available with the words needed already substracted,
i.e. a negative value in IQUEST(11) signals that there are
no NWNEED words available in the given division.
%??.cc 50>
\section{Global operation aids}
\subsection{Set the program phase}
\par Primarily to avoid recovery to ``next event' at the wrong moment,
ZEBRA needs to know in which phase the user program is at any
given moment. This is accomplished with the routine ZPHASE,
described in the ZEBRA reference manual.
\index{program!phase}
\index{MZ!ZPHASE}
\protect\label{ZEND}NormalCALL program termination}
\index{MZ!ZEND}
\par The routine
{\bf\it ZEND} is defined to be the entry-point for normal run
termination. This routine is normally {\bf\it provided by the user}
to close files and print accumulated results.
It is important that all termination operations are
done through this routine,
if the user wants them to happen even in abnormal run termination.
\par It would normally look like this:
\index{program!termination!normal}
\begin{verbatim}
       SUBROUTINE ZEND
 
       CALL ZPHASE (-3)           -- start termination
       . . .                      -- any user termination code
       CALL MZEND
       STOP
       END
\end{verbatim}
\index{MZ!MZEND}
\subsection{CALL MZEND}
\par MZEND is a ZEBRA routine which prints statistics about
the usage of all divisions.
\par A user routine similar to ZEND is defined for taking over control
of fatal error termination. Its name is ZABEND and it is
described in the next paragraph.
This should perform any extra operations needed
for fatal termination and then it should transfer
to ZEND for termination.
\subsection{Abnormal program termination}
\par To cope with situations where the program ends abnormally,
an entry point {\bf\it ZFATAL} is defined.
\index{program!termination!abnormal}
\index{MZ!ZFATAL}
\index{MZ!ZFATAM}
\par A second routine {\bf\it ZFATAM} is identical to ZFATAL,
except that it prints a message,
given as a character string to the routine.
\par The routines ZFATAL and ZFATAM are {\bf\it supplied by the system}.
They are protected against recovery loops, and they must
{\bf\it NOT} be supplied by the user.
They should be called only when the run cannot usefully continue.
If the application program discovers such a fatal condition,
it too should call ZFATAL or ZFATAM,
preceded with some diagnostic printing or
with loading to IQUEST in common /QUEST/ some clue to the trouble.
\index{QUEST!IQUEST}
\par The calling sequences are, for example:
\begin{verbatim}
      CALL ZFATAL                         or
      CALL ZFATAM ('MY ERROR MESSAGE')
\end{verbatim}
\index{MZ!ZABEND}
\par Routine {\bf\it ZABEND}
receives control from ZFATAL to handle fatal run termination.
This routine may be supplied by the user.
\par The ZEBRA system contains the standard routine as follows:
\begin{verbatim}
      SUBROUTINE ZABEND
+CDE,ZSTATE                  -- Specifies NQPHAS, the program phase
 
      CALL ZPOSTM('TCWM')    -- Print a DZSNAP in 'TCWM' mode
                             --  for the faulty store
      IF (NQPHAS.LT.0) STOP  -- Immediate stop if 'initialization'
                             --  or 'termination' phase
      NQPHAS = -2            -- Set 'termination' phase
      CALL ZEND
      END
\end{verbatim}
\par This ZABEND routine is not just a dummy; it generates
an optimal post-mortem
dump, including a subroutine trace-back, followed by any normal
user output programmed in ZEND. Transfer to ZEND takes place if
the break-down happened during normal operation, but not if the
program is still in the initialization phase or if it is already under
ZEND control.
\par The parameter to ZPOSTM is passed from there to DZSNAP to select the
options for dumping the dynamic store
(see page on Page~\pageref{DZSNAP FORM=PAGEONLY}
for details).
\index{DZ!DZSNAP}
\subsection{Recovery through ZTELL-ZTELUS}
\par During normal operation any request from the user for space
with MZWORK, MZBOOK/MZLIFT, MZDIV and MZPUSH is satisfied,
after garbage collection if that is necessary and possible.
If, however, the request cannot be satisfied,
the normal course of the program must be changed.
To relieve the user of the burden of checking for success
after each space request,
the garbage collector will normally send control to the user at the
entry-point QNEXT (via ZTELL and the KERNLIB routine QNEXTE),
to skip the current event and to continue
by processing the next one.
\index{MZ!QNEXT}
\index{MZ!ZTELL}
\index{KERNLIB}
\index{QNEXTE}
\par Other ZEBRA packages, apart from MZ, and the user code, may
have similar problems.
Therefore a general trouble-control routine ZTELL has been
included in ZEBRA.
This is a switching routine with several modes of continuation
controlled by the user routine ZTELUS,
one of which is to send control to QNEXT.
\index{program!recovery}
\index{MZ!ZTELL}
\index{MZ!ZTELUS}
\par For more details about the recovery facilities in ZEBRA, the user
is referred to the ZEBRA reference manual.
%??.* FZ part Last mod  6 Aug 1989  12.00  mg>
\chapter{FZ: The sequential Input-Output Package}
\section{Principles}
\par The aim of the FZ package
is to transfer ZEBRA data structures from and to a sequential file,
i.e. disk or tape, or to another part of memory.
It should fit both online and offline processing requirements.
Speed is important in both cases,
but is more critical in the online context.
For this it must be possible to write large areas of memory
to a file, without the need to insert control information
during the transfer; all control information needed
should be grouped at the begining.
Also, since ZEBRA may not be running on the online machine,
the format should be such that it is easy to program in other systems.
\subsection{Native and exchange I/O modes}
\index{FZ!mode!native}
\index{FZ!mode!exchange}
\par Files written in {\bf native} mode can be read only on machines
of the same kind as the writing machine.
The logical records are written with ordinary unformatted WRITE
statements,
directly transferring the memory areas to the file.
Hence the representation of the data in the file is the same as
the internal representation of the machine;
the blocking of the logical records and the addition of
system control words
is done by the operating system,
and is of no concern to ZEBRA.
\par {\bf Exchange} mode enables transfer of files between different
machines. The input/output routines, of which there is
one set for each machine, have to handle two things:
one is the blocking of the logical records into physical records,
the other is the translation of every word from the internal
to the exchange representation,
according to the nature of the word
(floating-point, integer, Hollerith, bit pattern).
\subsection{Logical records structure}
\par The unit of information to be written or read is one data structure,
which in the simplest case may consist of zero or one bank.
A data structure on a file is represented by two,
or possibly several,
{\bf logical records.}
\index{FZ!record!logical}
\footnote{
The format of logical records and of the files written
are described in the ZEBRA reference manual.
}
The first record, called the ``pilot record',
\index{FZ!record!pilot}
contains context information about the data structure which follows,
such that the program can set up everything necessary before
initiating a read to receive the data structure
at the right place in memory.
Amongst other things,
this specifies the amount of memory required to hold
the data structure and the table to drive the relocation
of all the links in the structure.
The pilot record also contains a user-defined identification
and characteristic of the data structure, the so-called
{\bf user header vector}.
It permits selective reading without expanding unwanted
data structures into memory.
\par The second logical record (and subsequent ones, if any)
contain the dump of the memory area occupied by the banks
making up the data structure;
these records are called the {\bf bank material records}.
\index{FZ!record!bank material}
\par Banks of a data structure on a recording medium
are interconnected by links,
and the relocation table contained in the pilot record provides
the description of how to convert these links to their new values
in memory.
\par Data structures follow each other on the recording medium
in a sequential manner.
\newline
A series of data structures is often called an {\bf event}.
Events are seperated by {\bf start-of-event} and
{\bf end-of-event} system markers.
\index{FZ!event}
\index{FZ!marker!start-of-event}
\index{FZ!marker!end-of-event}
\newline
Events can be grouped in a {\bf run}. On the file these are
separated by {\bf start-of-run} and {\bf end-of-run}
marker records, which can also contain user information.
\index{FZ!marker!end-of-run}
\index{FZ!marker!start-of-run}
\newline
To avoid problems with hardware end-of-files,
a software simulation is provided by ZEBRA {\bf end-of-file}
records, which can carry user information.
\index{FZ!marker!end-of-file}
%??.cc 50>
\section{File operations}
\Subr{CALL FZFILE (LUN,LREC,CHOPT)}
\par This routine should be called to declare a file to ZEBRA.
\index{FZ!FZFILE}
\index{FZ!input!declare file}
\index{FZ!output!declare file}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\item[LREC
]Record length (in {\bf words})
\newline {\bf Native} file format - maximum logical record length
<SL COMPACT>
\item {\bf =0:} Standard length: 2440 words
\item {\bf >0:} User defined length
</SL>
\newline {\bf Exchange} file format - physical record length
<SL COMPACT>
\item {\bf =0:} Standard length: 900 words
\item {\bf >0:} User defined length (must be a multiple of 90 words).
</SL>
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[medium
]'' Disk (default)
\newline 'M' Memory
\newline 'T' Magnetic tape
\item[file format
]'' Native (default)
\newline 'A' Exchange format, ASCII mapping
\newline 'X' Exchange format, binary
\item[data format
]for medium {\bf disk or tape:}
\begin{DL}{MMMMM}
\item[''
]default - {\it 'native'} for {\it native} file format
\newline    or    {\it 'exchange'} for {\bf exchange} file format
\item['N'
]Native data format
\end{DL}
\newline for medium {\bf memory}
\begin{DL}{MMMMM}
\item[''
]default - 'native'
\item['X'
]exchange data format
\end{DL}
\item[processing
]default - Input only
\item[direction
]
\begin{DL}{MMMMM}
\item['I'
]Input enabled
\item['O'
]Output enabled
\item['IO'
]Input/output enabled
\end{DL}
\item[EoF handling
]
\begin{DL}{MMMMM}
\item[''
]default - Chosen dependent on file and machine
\item['0'
]No hardware file marks
\item['1'
]Hardware file mark only for level 2 EoF.
\item['2'
]Hardware file marks both for level 1 and 2 EoFs.
\end{DL}
\item[various
]
\begin{DL}{MMMMM}
\item['R'
]Initial rewind
\item['Q'
]Quiet, print error messages only
\newline (log level -2 with FZLOGL, see below).
\item['P'
]Permissive, enable error return
\newline (valid only if the user code checks the error status).
\end{DL}
\end{DL}
\end{DL}
\end{DL}
%??.cc 13>
\subsection{FZFILE return code}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)=0
]Everything is all right
\item[IQUEST(1)=1
]The file has already been initialized with FZFILE
\item[IQUEST(1)=2
]LUN invalid
\item[IQUEST(1)=3
]The requested format is not yet available on the given machine
\end{DL}
\subsection{Notes:}
\par Non-zero error returns are only enabled with the 'P' option,
otherwise control goes to ZFATAL. If the 'P' option is selected
\index{MZ!ZFATAL}
the status must imperatively be checked by the user.
\par FZFILE does NOT itself execute a FORTRAN OPEN statement in
order to leave the latter under the control of the user.
\subsection{Set the log level for an I/O unit number}
\par The logging level
(i.e. the verboseness of the messages of the ZEBRA system) can be
controlled for each input/output unit by a call to FZLOGL.
\Subr{CALL FZLOGL (LUN,LOGLEV)}
\index{FZ!FZLOGL}
\index{FZ!logging level}
\index{logging level}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Number of the input/output unit
for which the logging level has to be set
\item[LOGLEV
]Logging level
\begin{DL}{MMMMM}
\item[-3
]Suppress all messages
\item[-2
]Print error messages only
\item[-1
]Terse mode
\item[ 0
]Normal mode
\item[ 1
]Normal mode and details of conversion problems
\item[ 2
]Print to monitor calls to the FZ routines
\item[ 3
]Short diagnostics
\newline Short dumps to debug user-written output routines
\item[ 4
]Full diagnostics
\newline Full dumps to debug user-written output routines
\end{DL}
\end{DL}
\end{DL}
\par
As indicated above, each declaration of an input/output file via FZFILE
associates a logging level equal to the system-wide logging level
set be MZEBRA.
\index{MZ!MZEBRA}
\index{FZ!FZFILE}
At any point in a program the logging level can be reset to a new
value by calling FZLOGL with the appropriate parameters.
%??.cc 30>
\subsection{Limit the size of an output file}
\par The size of an output file can be limited by issuing a call to FZLIMI.
\par
The reason for having this facility is the fact that ``end-of-tape'
is a problem which cannot be solved satisfactorily in general.
To assist the user in controling reel switching,
ZEBRA counts the total number of words written,
and checks after every data structure written out
(but not for start-of-run, end-of-run, end-of-file)
whether the limit specified has been reached.
If so, it returns the ``pseudo end-of-tape' condition (cf. FZOUT)
for every data structure output until a new request is made
with ALIMIT=0. Thus the user can switch tape, call
{\tt FZLIMI(LUN,0.)},
and continue to write another tape,
again waiting for the ``end-of-tape' signal.
\Subr{CALL FZLIMI (LUN,ALIMIT)}
\index{FZ!FZLIMI}
\index{FZ!limit output}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\item[ALIMIT
]Floating point number giving the limit in mega-words
\begin{DL}{MMMMM}
\item[>0
]User defined limit
\item[=0
]Increase the limit by the amount specified in a previous call
with ALIMIT > 0
\item[<0
]Unlimited (as initialized by FZFILE)
\end{DL}
\end{DL}
\end{DL}
\subsection{Examples:}
\par Set the file-size to 12.75 Mwords for unit 21
\begin{verbatim}
      CALL FZLIMI (21,12.75)
\end{verbatim}
Set the file-size to be the current data-volume plus 12.75 Mwords
\begin{verbatim}
      CALL FZLIMI (21,0.)
\end{verbatim}
%??.cc 20>
\Subr{CALL FZRUN (LUN,NRUN,NUH,IUHEAD)}
\par writes a start-of-run or end-of-run record.
\index{FZ!FZRUN}
\index{FZ!start-of-run}
\index{FZ!end-of-run}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\item[NRUN
]>0: The run number
\newline =0: Increment the run number by 1
\newline <0: End-of-run record
(ignored if the run is already terminated)
\item[NUH
]Length of the user information vector (length can be zero)
\item[IUHEAD
]Vector of length NUH containing the user information (integers only).
\end{DL}
\end{DL}
%??.cc 15>
\Subr{CALL FZENDI (LUN,CHOPT)}
\par Terminates one or several input files.
\index{FZ!FZENDI}
\index{FZ!input!close file}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\newline If zero: All FZ input files
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item['O'
]Switch to output,
\newline Permit write after read
\newline Needed in case the file
has been positioned for output by reading
\item['Q'
]Quiet, suppress printing of file statistics
\item['R'
]Final rewind
\item['T'
]Terminate, drop control-bank for this file
and print file statistics
\item['U'
]Unload file
\end{DL}
\end{DL}
\end{DL}
\Subr{CALL FZENDO (LUN,CHOPT)}
\par Terminates one or several output files and by default
will write an end-of-run, will flush the output buffer in
exchange mode, and will leave the file positioned for further output.
\index{FZ!FZENDO}
\index{FZ!output!close file}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\newline If zero: All FZ output files
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item['E'
]Write end-of-file (unless done)
\item['E2'
]Write end-of-data (unless done)
\item['F'
]Flush the buffer only
\item['I'
]Switch to input,
\newline Write end-of-data and rewind (if not yet done)
\newline Cancel the output permission
\newline Useful for reading back a file just written
\item['Q'
]Quiet, suppress printing of file statistics
\item['R'
]Rewind (unless done)
\item['T'
]Terminate: write end-of-run (if not yet done)
\newline Print the file statistics (unless done)
\newline Drop the control-bank for this file
\item['U'
]Unload file
\end{DL}
\end{DL}
\end{DL}
%??.cc 50>
\section{Output a data structure}
\Subr{CALL FZOUT (LUN,IXDIV,LENTRY,IEVENT,CHOPT,IOD,NUH,IUHEAD)}
\par Writes one data structure.
\index{FZ!FZOUT}
\index{FZ!output!data structure}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\item[IXDIV
]Index of the store/division containing the data structure.
\newline May be a compound index (see MZIXCO
on page on Page~\pageref{MZIXCO FORM=PAGEONLY}
for more details) if the 'D' option is selected.
\index{MZ!MZIXCO}
\item[LENTRY
]Entry address of the data structure
\newline May be zero if the 'Z' option is selected
\item[IEVENT
]Start-of-event flag (only values 0 and 1 are allowed)
\newline  0  for event continued
\newline  1  for new event
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[default
]The data structure supported by the bank at LENTRY is written out
\newline (the next link is not followed)
\item['D'
]Complete division(s)
\newline default: Dropped banks are squeezed out
\newline              (slower but maybe more economic than 'DI')
\item['DI'
]Immediate dump of divisions with dropped banks included
\item['L'
]Write the data structure supported by the linear structure at LENTRY
\newline (the next link is followed)
\item['N'
]No links, i.e. linkless handling
\newline default: Links are significant
\item['S'
]Single bank at LENTRY
\item['Z'
]Zero banks, i.e. empty data structure, header only
\end{DL}
\item[IOD
]Description of the nature of the user header vector
\newline either immediate type descriptors (see Table~\pageref{MZFORMS})
or an I/O characteristic obtained by MZIOCH
\index{I/O characteristic}
(see page on Page~\pageref{MZIOCH FORM=PAGEONLY})
\index{MZ!MZIOCH}
\item[NUH
]Number of words in the user header vector (may be zero)
\item[IUHEAD
]The user header vector
\end{DL}
\end{DL}
%??.cc 20>
\subsection{FZOUT return codes}
\par FZOUT returns the write status in the QUEST vector as follows:
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Operation status code
\begin{DL}{MMMMM}
\item[+1
]``pseudo end-of-tape' (cf. FZLIMI)
\item[ 0
]normal completion
\item[-1
]first attempt to write after end-of-data
\item[-2
]error return
\end{DL}
\par
\item[IQUEST(11)
]NWBK, number of words of bank material
\item[IQUEST(12)
]NWTB, size of the relocation tables
\item[IQUEST(13)
]number of pilot records written so far
\item[IQUEST(14)
]number of words written (in millions)
\item[IQUEST(15)
]number of words (up to 1 million) written so far
\item[IQUEST(16)
]number of logical records written so far
\item[IQUEST(17)
]Number of physical records written so far (exchange mode only)
\end{DL}
%??.cc 50>
\section{Input a data structure}
\par To read the next data structure one calls FZIN.
The return code in the user communication vector
\index{QUEST!IQUEST}
IQUEST(1) will tell the caller whether
the READ operation was free of error, and whether the
object read was a data structure, or a start-of-run,
or an end-of-run,
or an end-of-file signal.
FZIN may be asked to skip to and then read the next start-of-event
data structure or the next start-of-run record.
\subsection{Read a single data structure}
\par In the simplest case (opt = '.' or blank) FZIN will read the next
data structure into the division indicated by the parameter IXDIV,
at the same time delivering the user header vector to the
parameter IQHEAD.
\par The selective read has been provided to rapidly skip unwanted
data structures without expansion into memory and without relocation
of the links:
calling FZIN with opt='S' causes reading of the next pilot record
only, returning to the user the header vector for taking a
decision to read or skip the ``pending data structure'.
Skipping is done by asking for the next data structure;
accepting is done by calling FZIN with opt='A'.
\par {\bf Remember
that every call to FZIN has to be checked for the success of
the operation by testing on IQUEST(1).}
\subsection{Read a data structure by segment}
\par In the cases described so far the complete data structure is
read and is deposited into one particular division.
It is however possible to steer individual data segments of
the data structure into particular divisions,
or to cause them to be ignored.
(see the ZEBRA reference manual for more details)
\par The parameters LSUP and JBIAS in the calling sequence below
describe how the data structure should be inserted into
an already existing data structure. Their meaning
is similar to that for routine MZLIFT on page
on Page~\pageref{MZLIFT FORM=PAGEONLY}.
\index{MZ!MZLIFT}
%??.cc 50>
\Subr{CALL FZIN (LUN,IXDIV,*LSUP*,JBIAS,CHOPT,*NUH*,IUHEAD*)}
\index{FZ!FZIN}
\index{FZ!input!data structure}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number
\item[IXDIV
]Index of the division to receive the data structure
\newline IXDIV = 0 means division 2 of the primary store
\item[*LSUP*
]
\item[JBIAS
]{\bf JBIAS < 1:} LSUP is the supporting bank
and JBIAS is the link bias specifying where the data structure has to be
introduced into this bank, i.e. the data structure will be connected
to LQ(LSUP+JBIAS).
\newline {\bf JBIAS = 1:}
LSUP is the supporting link, i.e. the data structure
is connected to LSUP (top level data structure)
\newline {\bf JBIAS = 2:} Stand alone data structure, no connection.
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[Event
]
\begin{DL}{MMMMM}
\item[''
]default - go to next data structure
\item['E'
]go for next start-of-event data structure
\item['R'
]go for next start-of-run record
\end{DL}
\item[Select
]
\begin{DL}{MMMMM}
\item[''
]Default - Read the next header and its data structure
\newline (may mean: skip pending data structure or current event)
\item['A'
]Accept, read the pending data structure
\newline (NUH and IUHEAD are not used)
\item['S'
]Select, read the next header only
\newline (may mean: skip pending data structure or current event)
\newline (LSUP and JBIAS are not used)
\end{DL}
\end{DL}
\item[*NUH*
]Maximum size available for header vector IUHEAD
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*LSUP*
]For JBIAS = 1 or 2, LSUP receives
the entry address to the data structure
\newline In any case IQUEST(13) returns the entry address
into the data structure
\item[*NUH*
]Useful size of the header vector stored in IUHEAD
\item[IUHEAD*
]User header vector
\end{DL}
\end{DL}
%??.cc 50>
\subsection{FZIN return codes}
\par FZIN returns the read status, either normal or error completion,
in the QUEST vector as follows:
\index{QUEST!IQUEST}
\subsubsection{Normal read status returns are:}}}}}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Operation status code
\begin{DL}{MMMMM}
\item[<0
]error, see below
\item[ 0
]normal completion
\item[ 1
]start-of-run record
\item[ 2
]end-of-run record
\item[ 3
]ZEBRA end-of-file
\item[ 4
]system end-of-file  (level 1 EoF)
\item[ 5
]system end-of-data  (level 2 EoF)
\item[ 6
]first attempt to read beyond EoD
\end{DL}
\item[IQUEST(2)
]number of logical records read so far
\item[IQUEST(3)
]number of physical records read so far (exchange mode)
\par
\item[IQUEST(11)
]for IQUEST(1)=0: 1 or 0 for yes/no start new event
\newline for IQUEST(1)=1: run number for start-of-run
\item[IQUEST(12)
]zero
\item[IQUEST(13)
]LENTRY, the entry address into the data structure
\newline zero means: empty data structure
\newline (not yet a valid address if return from 'S' option)
\item[IQUEST(14)
]NWBK, the number of words occupied by the data structure in memory
\newline zero means: empty data structure
\item[IQUEST(20)
]NWIOCH, size of the IO characteristic
\item[IQUEST(21)...
]NWIOCH words of IO characteristic for the user header vector
\end{DL}
\subsubsection{Error status returns are:}}}}}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[-8
]  . . .
\item[-7
]for 3 consecutive errors
\item[-6
]for 2 consecutive errors
\item[-5
]read error
\item[-4
]bad constructs, probably not a file written by FZOUT
\item[-3
]bad data
\item[-2
]break in block sequence number (exchange mode only)
\item[-1
]faulty call: A option given, but no pending data structure
\end{DL}
\item[IQUEST(2)
]number of logical records read so far
\item[IQUEST(3)
]number of physical records read so far (exchange mode)
\end{DL}
%??.* Chapter  RZ direct-access >
%??.* last mod  6 Aug 1989 15:50 mg >
\chapter{Direct access input-output}
\section{Main goals}
\subsection{General}
\par The RZ package of ZEBRA is written on top of the memory manager MZ,
and uses routines in full correspondence with the sequential I/O
package FZ. It provides a convenient user interface for devices
allowing direct access.
Facilities for transporting RZ files to different computer systems
are included, using sequential files and the FZ exchange format.
RZ files can be accessed by several users simultaneously,
even across networks.
\par The RZ package is {\bf not} trying to be a full blown
data base management system, but is an access method finding multiple
applications around High Energy Physics (and probably outside).
\subsection{Structure of Pathnames}
\par The basic unit of information addressed in an RZ file
is a ZEBRA data structure, in the simplest case a single ZEBRA bank.
We call this an RZ
{\bf data object}.
Each data object is referred to by
a unique object name. Its main part is called the
{\bf pathname}
carrying a mnemonic meaning and showing relations
between different objects.
\par An interrelated group of objects is addressed from a
{\bf directory}, which may be a {\bf subdirectory}
if it is itself referred to in a directory,
or a {\bf top directory}
otherwise. Directories are themselves objects addressed by a pathname.
The totality of available objects (data objects and directories)
is arranged in a {\bf naming tree},
of which an example is shown in Figure~\pageref{NAMTREE}.
\par The highest level component of a pathname is called the
{\bf root}.
\begin{figure}\label{NAMTREE FRAME=RULE>
\caption{An example of an RZ naming tree}
\begin{verbatim}
     +DDDDD+                         +KKKKK+
     |     |  Directory              |     |  Key
     |     |  entry                  |     |  Entry
     +DDDDD+                         +KKKKK+
 
 ROOT                            //
                                  |
                   +-----------------------------+
                   |              |              |
 TOP            +DDDD+          +DDDD+         +DDDD+
 Directories    | F1 |          | F2 |         | F3 |
                +DDDD+          +DDDD+         +DDDD+
                                  |
                    +---------------------------+
                    |             |             |
                 +DDDD+         +DDDD+        +KKKK+
                 | D1 |         | D2 |        | K1 |
                 +DDDD+         +DDDD+        +KKKK+
 Directories                      |
 and                +---------------------------+
 Key Entries        |             |             |
                 +KKKK+         +DDDD+        +KKKK+
                 | K2 |         | D3 |        | K3 |
                 +KKKK+         +DDDD+        +KKKK+
                                  |
                        +-------------------+
                        |                   |
                      +KKKK+              +KKKK+
                      | K4 |              | K5 |
                      +KKKK+              +KKKK+
\end{verbatim}
\end{figure}
\par The naming tree includes all RZ files and directories open to ZEBRA at
a given moment.
\par The top directory is not part of the pathname such as written onto
external files. Associating different top directories to files at
file declaration with RZMAKE or RZFILE
\index{RZ!RZMAKE}
\index{RZ!RZFILE}
allows the simultaneous availability of files,
which can contain objects with identical pathname.
\index{RZ!object}
\index{RZ!naming tree}
\subsection{Keys and Cycles}
\par Data objects are identified beyond the pathname by a {\bf key},
which may be a single word of information
(integer, bit string or Hollerith)
or a vector of such words. The key is not part of the pathname and cannot
be set in a directory.
\par Successive versions of objects with identical
pathname/key combination may exist simultaneously.
They are distinguished by a {\bf cycle number},
which is incremented automatically upon creation of successive data
objects. Cycles may be referred to explicitly,
the usual default is the highest cycle number.
\subsection{Pathname Environment}
\par The high level components of pathnames are
frequently constant in a given context,
they can therefore be set as an environment:
\newline
The currently valid environment of directories is built up by successive
calls to routines of the RZ package. The sequence of calls defines
standard directories for frequent use, the
{\bf current working directory (CWD)}
and the {\bf naming directory}.
Most calls to RZ routines will refer to the CWD
thus allowing for omission or abbreviation of pathnames.
The double slash '//' at the top of the naming tree refers to the root,
the CWD will not be assumed to precede such a name.
A pathname given with a starting slash will append only the root from the
CWD. Other symbols in giving pathnames are given in the table below.
\par At any moment the directory where the RZ system searches for object
names can be set by defining the {\bf working directory}
(routine RZCDIR). Just after opening a file,
the CWD is set to the top directory corresponding to the
file just initialized.
\par The {\bf naming directory}, which is initially set to the CWD
after RZMAKE is called (i.e. the top directory),
can be set equal to any directory
which the user wants to refer frequently.
\index{RZ!directory naming}
\par A {\bf parent} directory is the directory above the CWD.
\index{RZ!directory parent}
\par A pathname describes the path to be used to get from some
\index{RZ!pathname}
starting point in the naming tree to a destination object.
A pathname begins with the starting point's name and includes every
directory name between the starting point and the destination object,
ending with the destination object's name. Slashes separate
names within a pathname.
\par The concept of structured name has been inspired by
the UNIX hierarchical
\index{UNIX}
file structure. Cycles for successive versions of data objects with
identical names are taken from the VAX/VMS operating system.
\index{VAX}
\index{VMS}
Unlike UNIX, however, RZ pathnames are NOT case sensitive, i.e.
upper and lower case are both treated as upper case.
\par The meaning of some special characters in pathnames is summarized in
Table~\pageref{PATHSYM}.
\begin{tabular}{c}\label{PATHSYM
\caption{RZ pathname starting point symbols}
<THD>
&C>Starting symbol of pathname
&C>Directory where name search starts
</THD>
<TFT>
&C>
</TFT>
\\
&C>//
&C>Top directory
\\
&C>/
&C>Top directory of naming directory
\\
&C>\~
&C>Naming directory
\\
&C>$\backslash$
&C>Parent directory
\\
&C>other symbol
&C>Current working directory (CWD)
\end{tabular}
\index{RZ!directory working}
\index{RZ!CWD}
\par RZ directories are declared by a call to RZMDIR.
\par To illustrate the access mechanism let us look at two simple examples:
\begin{OL}
\item An RZ direct
access file of an experiment contains (among other things) the
parameters of several thousands of lead glass blocks.
The pathname of the information could be
{\tt //LEP/ECAL/LGB} and the key a single
integer (NWKEY = 1), identifying each lead glass block.
\item
A direct access file contains events to be scanned.
A possible choice for its pathname and key vector could be:
\begin{verbatim}
C-- The pathname
       CHPATH = '//LEP/DST/P5A'
C-- The KEY vector is a 2 word array (NWKEY = 2) of integers with
       KEY(1) = IRUN             -- run    number
       KEY(2) = IEVENT           -- event  number
\end{verbatim}
\end{OL}
\subsection{A detailed example}
\par To further clarify the actions of the various RZ routines, throughout
the present chapter a random access file describing the structure of
an high energy physics laboratory, in the example CERN, will be used.
Let us suppose that the information of
each laboratory is in a separate file, as in
Figure~\pageref{RZFIG01}, where each laboratory corresponds to a top
directory, addressed as
{\tt //DESY/sub, //FNAL/sub, //IHEP/sub, //CERN/sub}
and where {\tt /sub}
following the top directory name, stands for the tree of sub-directories.
\begin{figure}\label{RZFIG01 FRAME=RULE PLACE=INLINE>
\caption{A RZ based HEP file base}
%<ARTWORK DEPTH=5cm label='here should come the figure'>
\end{figure}
\par
Taking CERN as a more explicit example, a file base containing all CERN
employees is constructed. Each CERN staff member is identified in this
file by one integer number (his identification code), which will be used
as the key in RZ terminology. The precise administrative dependence of
each individual should be clear from the file,
so that the layout in Figure~\pageref{RZFIG02} can be used.
\begin{figure}\label{RZFIG02 FRAME=RULE PLACE=INLINE>
\caption{The layout of the RZ file base for CERN}
%<ARTWORK DEPTH=7cm label='here should come the figure'>
\end{figure}
\par
In the structure each individual is attached to one of the administrative
sections, where he is identified by his ID code, e.g. the staff
member with identification code ID {\tt 17452} is in the
directory defined by the full pathname
{\tt //CERN/RESEARCH/DD/EE/X1}
where he is addressed by the key
{\tt 17452}.
The information record associated with each key entry can contain one
ZEBRA bank or a whole data structure (or even one or more complete
divisions if desired). In the present case the entry could contain
a bank with the individual's name, age, marital status, grade,
job description, entry date at CERN, phone number,...
\par If somebody is assigned to more than one section (or division), then
either the information can be repeated in different places (inefficient)
or it can be entered at a higher level in the tree, at a node which
is a parent of the subnodes which the entry refers to (non-homogeneous
solution) or, most efficiently, the information is entered once into
one subdirectory only, and in all other relevant directories a
reference is set up, which points to the data record containing
the information in question.
\begin{figure}\label{RZFIG03 FRAME=RULE PLACE=INLINE>
\caption{The layout of the DD subdirectory}
%<ARTWORK DEPTH=10cm label='here should come the figure'>
\end{figure}
\par Referring to Figure~\pageref{RZFIG03}, where we have set the working
directory to {\tt //CERN/RESEARCH/DD}
and where only the subtree for the working directory is drawn,
the information for key {\tt 17452}
is entered only into subdirectory {\tt EE/X1}
while in subdirectory {\tt US/PL}
a data record referencing the data in {\tt EE/X1}
is introduced.
\par It must be emphasized that at each level data
and subdirectories can be introduced at the same time, so that for
instance a record containing, for example,
the divisional budget or terminal pool, can be added at a divisional
node or subnode, e.g. {\tt EE/APOLLO}
could contain a record describing the APOLLO hardware associated to
the section EE of division DD.
%??.cc 30>
\subsection{Use of the RZ package}
The RZ package can be used in various situations:
\begin{OL}
\item The direct access file is temporary (created for the
duration of a single job). In this case there is no need to worry about
directories, multiple access, etc. The only important issue is efficiency.
\item
The direct access file is used in an interactive environment. In this
case special attention must be paid to be able always to recover from
possible interrupts, such as user breaks, system crashes and the like.
\item
The direct access file represents a central pool of data, which
is read by many users at the same time (e.g. from batch jobs).
Several users can have write access to information in the file at the
same time, as long as the information is located in different
directories (i.e. one has 1 write-access per (sub)directory, as
long as one of the latter is not yet locked at a higher level, see
RZLOCK and RZFREE).
\end{OL}
\par The direct access file can be kept on {\bf disk} or in
{\bf memory}.
The latter case is interesting in an online data acquisition environment
where e.g. histograms or events are generated by microprocessors
(servers) in a large memory buffer, which can also be accessed by a
another machine (the presenter).
The presenter reads the information prepared by the
microprocessors for display or storage purposes as though it was
a random access file.
\par The directory and data part of an RZ file are stored separately. Hence
changes in the directory structure do not necessarily
imply a rearrangement of the data. This is important for future
video disk applications, where the directories, which can change
frequently, are written on a Winchester hard disk, while the several
gigabyte data storage medium is the video disk, which is most of the time
read-only.
\par Since the same key can have several cycles, and thanks to the fact
that, as explained above, the pointers to the physical information are
kept in the directory, several users can work on an RZ file at the same
time, and be sure that their data references remain valid throughout
their working session. Thus long=running production jobs can execute
at the same time as users modify the data base, by adding new cycles
to the latter. Care must however be taken not to physically delete
(by using e.g. RZDELK, RZPURG,..) information from the file, since
that space can be reused by other applications, thus
invalidating the directory-pointer association for executing jobs.
If a deletion of information in the data base becomes necessary it is
wise to get exclusive access to the file or directory or to
run the application programs in 'U' mode (see RZFILE), which might
\index{RZ!RZFILE}
not always be desirable.
\par Two file modes are provided:
\begin{OL}
\item {\bf Native}
mode where the format of the information on the file corresponds to
that of the machine which is treating the data.
Hence no data conversion is needed.
\item {\bf Exchange}
mode when one machine is reading data from another machine, e.g. through
a network. In particular at CERN one could envisage that
events to be scanned, or
histograms and calibration files are stored on the IBM file base.
Physicists, however, could scan their events
or edit their histograms on a VAX or an APOLLO.
In this case, whenever
they want to display the next event or histogram, or when they want to
use some calibration constants,
they access the information interactively directly through CERNET,
Ethernet,..
In exchange mode data conversion according to type is needed, and the
standard ZEBRA facilities built into the FZ package and based on
the I/O characteristic are used.
\index{bank!I/O characteristic}
\end{OL}
\par The RZ package is relatively small in scope and should thus not
be compared with (relational) data base management
systems like ORACLE. Its functionality, however, corresponds to
the needs of most people when they analyze high-energy physics
data. Since the package is fully integrated with the ZEBRA
data manager it runs on any system where ZEBRA is implemented.
Due to the presence of the I/O characteristic in ZEBRA,
which allows the description of the type of data present in the banks,
standard tools (RZTOFZ and RZFRFZ) can be provided to transport direct
access files between different computer systems in a transparent way.
\par The RZ package is a second level system, which provides
the functionality needed to develop higher level
documentation tools, calibration
data bases, interactive menu processors, histograming, plotting and
graphic editing interfaces.
%??.cc 50>
\section{Declare a direct access file}
\par When one wants to use an RZ
direct-access file one should first call RZMAKE, if the file has to be
created, or RZFILE, if the file already exists.
\subsection{Create a new RZ file}
\par Subroutine RZMAKE declares to ZEBRA that unit number
LUN will be used in direct access mode and that the file has to be
created.
\index{RZ!initialization}
\Subr{CALL RZMAKE (LUN,CHDIR,NWKEY,CHFORM,CHTAG,NREC,CHOPT)}
\index{RZ!RZMAKE}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number associated with the RZ file.
A FORTRAN OPEN statement must precede the call to RZMAKE.
\newline Starting address of the memory area which will contain the
RZ information ('M' option)
\item[CHDIR
]Character variable specifying the name of the top directory to be
associated with unit LUN(up to 16 characters).
\item[NWKEY
]Number of words associated to a key {\bf (maximum 9)}
\item[CHFORM
]Character variable describing each element of the key vector
\begin{DL}{MMMMM}
\item['B'
]Bit string but not zero
\item['H'
]Hollerith (4 characters)
\item['A'
]Same as H except for RZLDIR (see RZLDIR)
\item['I'
]Integer (nonzero)
\end{DL}
\item[CHTAG
]Character array defined as CHARACTER*8 CHTAG(NWKEY).
\newline
Each element of the array allows the description of the corresponding
element in the key vector with a tag of up to 8 characters.
\item[NREC
]Number of physical records for the primary allocation
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[medium
]
\begin{DL}{MMMMM}
\item[default
]Disk
\item['M'
]Memory - The user must allocate at least NREC*LUN words
of memory starting at address LUN if he uses this option.
\end{DL}
\item[mode
]
\begin{DL}{MMMMM}
\item[default
]Native mode
\item['X'
]Exchange mode (not yet implemented in version 3.53)
\end{DL}
\end{DL}
\end{DL}
\end{DL}
\subsection{Example:}
\par On the VAX the following sequence can be used
to declare a new random access file to RZ, whose top directory contains
three words per key, the first one being an integer (the year) and the
two others being Hollerith (the month and the day).
A total of 5000 records of length 4096 bytes are requested.
\begin{verbatim}
      CHARACTER CHTAG(3)*8
      DATA CHTAG/'Year','Month','Day'/
 
      OPEN (UNIT=LUN,FILE='RZTEST.DAT',ACCESS='DIRECT',STATUS='NEW',
     X      FORM='UNFORMATTED',RECL=1024,ERR=999)
      CALL RZMAKE(LUN,'Top_Dir',3,'IHH',CHTAG,5000,' ')
 
  999 PRINT *,' ERROR at FORTRAN OPEN statement'
\end{verbatim}
%??.cc 50>
\subsection{Access an existing RZ file}
\par Subroutine RZFILE declares to ZEBRA that unit number
LUN will be used in direct access mode for an already existing random
access RZ file.
\index{RZ!access}
\Subr{CALL RZFILE (LUN,CHDIR,CHOPT)}
\index{RZ!RZFILE}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number associated with the RZ file.
A FORTRAN OPEN statement must precede the call to RZFILE.
\item[CHDIR
]Character variable specifying the name of the top directory to be
associated with unit LUN.
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[medium
]
\begin{DL}{MMMMM}
\item[default
]Disk
\end{DL}
\item[mode
]
\begin{DL}{MMMMM}
\item[default
]Read mode
\item['S'
]Shared mode
\item['U'
]Update mode
\item['1'
]Update mode and only one user (no LOCKs necessary)
\item['L'
]List current LOCK identifiers
\item['D'
]Reset "locking" word of the file (after program crash !)
\end{DL}
\end{DL}
\end{DL}
\end{DL}
\index{RZ!file-mode shared}
\index{RZ!file-mode update}
\begin{tabular}{c}\label{RFILOPT
mindepth=p5 align='c l' HP='2 0'>
\caption{RZFILE mode combinations and their meaning}
<THD>
&C>Mode
&C>Description
</THD>
<TFT>
&C>
</TFT>
\\
&C>''
&C>{\bf Read access}. Directory changes by other processes are not
visible to the current process.
\\
&C>'S'
&C>{\bf Read access}. Directory changes by other processes are
visible to the current process.
\\
&C>'U'
&C>{\bf Exclusive write access}.
The current process has exclusive control
to change the RZ file and no other process can reference it.
\\
&C>'SU'
&C>{\bf Shared write access}.
The current process competes with other
processes to update the RZ file. Hence care must be taken to each
time lock the directory with RZLOCK before introduces any changes.
\end{tabular}
\index{RZ!RZLOCK}
\index{RZ!directory working}
\index{RZ!CWD}
\subsection{RZFILE and RZMAKE return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Status information
\begin{DL}{MMMMM}
\item[ 0
]Everything is all right
\item[ 1
]The file is already open
\end{DL}
\end{DL}
\subsection{Example:}
\par The following FORTRAN code can be used
to obtain exclusive access in update mode
to an existing RZ random access file (e.g. the one created in the
previous section).
\begin{verbatim}
      OPEN (UNIT=LUN,FILE='RZTEST.DAT',ACCESS='DIRECT',STATUS='OLD',
     X      FORM='UNFORMATTED',ERR=999)
 
      CALL RZFILE(LUN,'Top_Dir','U')
 
  999 PRINT *,' ERROR at FORTRAN OPEN statement'
\end{verbatim}
%??.cc 25>
\section{Set the logging level}
\par The logging level
(i.e. the verboseness of the messages of the ZEBRA system) can be
controlled for a given RZ unit number by a call to RZLOGL.
\Subr{CALL RZLOGL (LUN,LOGLEV)}
\index{RZ!RZLOGL}
\index{RZ!logging level}
\index{logging level}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUN
]Logical unit number for which the logging level has to be set
\item[LOGLEV
]Logging level
\begin{DL}{MMMMM}
\item[-3
]Suppress all messages
\item[-2
]Error messages only
\item[-1
]Terse logging
\item[ 0
]Normal logging: RZFILE, RZMAKE, RZEND
\item[ 1
]Log to watch rare events
\item[ 2
]Log to monitor calls
\item[ 3
]Short dumps to debug user-written output routines
\item[ 4
]Full dumps to debug user-written output routines
\end{DL}
\end{DL}
\end{DL}
\par Each declaration of an RZ file via RZMAKE or RZFILE
associates a default logging level of 0 to the file.
\index{RZ!RZFILE}
\index{RZ!RZMAKE}
At any point in a program the logging level can be reset to a new
value by calling RZLOGL with the appropriate parameters.
%??.cc 13>
\section{Close a direct access file}
\par A direct access file, identified by a top directory name,
is closed by a call to RZEND.
The directories present in memory,
when they have been changed,
are copied to the file and then deleted from memory, else
the directories in memory are simply deleted.
\index{RZ!file close}
\Subr{CALL RZEND (CHDIR)}
\index{RZ!RZEND}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHDIR
]Character variable specifying the name of the top directory of the
file to be closed.
\end{DL}
\end{DL}
%??.cc 12>
\section{Save the modified directories}
\par All directories which have been modified in memory
and the current output buffer are written to the output file by a call
to RZSAVE. This routine is called
automatically by the system when using RZCDIR, RZEND or
RZFREE. In an interactive environment it may save to call RZSAVE from
time to time.
\index{RZ!save modified directory}
\section{\protect\label{RZSAVE}CALL RZSAVE}
\index{RZ!RZSAVE}
%??.cc 30>
\section{Operations on RZ directories}
\subsection{Define the naming directory}
\par When one is working with many different directories, and has to
refer frequently the same directory, then the latter can be defined
as the {\bf naming directory}, designated by the symbol '\~' in
pathnames.
A typical example would be an application where subdirectories have
to be created in user routines in which the complete pathname of the
naming directory is unknown.
To set the naming directory a call to RZNDIR must be made.
\index{RZ!naming directory}
\Subr{CALL RZNDIR (*CHPATH*,CHOPT)}
\index{RZ!RZNDIR}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[*CHPATH*
]Character variable specifying the complete pathname of the
naming directory ('S' option)
\item[CHOPT
]Character variable specifying the option
\begin{DL}{MMMMM}
\item[default
]Set the naming directory to the path specified in CHPATH
\item['P'
]Print the naming directory
\item['R'
]Read the naming directory pathname into CHPATH
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*CHPATH*
]Character variable containing the complete pathname of the
naming directory ('R' option).
\end{DL}
\end{DL}
\subsection{RZNDIR return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[ 0
]Normal completion
\item[ 1
]'S' (default) option and the pathname CHPATH is invalid
\end{DL}
\end{DL}
%??.cc 50>
\subsection{Define the current working directory}
\par All operations of RZ routines manipulating keys
(i.e. RZIN, RZOUT, RZRDIR, RZKEYS, RZPURG, RZDELK, RZDELT, RZQUOT,
RZPASS) refer to objects in
the "Current Working Directory" or CWD for short. The CWD is set equal
\index{RZ!current working directory}
\index{RZ!CWD}
to the top directory after a call to RZMAKE.
The CWD is set by a call to RZCDIR.
\Subr{CALL RZCDIR (*CHPATH*,CHOPT)}
\index{RZ!RZCDIR}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[*CHPATH*
]Character variable specifying the pathname of the CWD (default
option).
\newline CHPATH = '' means the CWD (useful with the 'U' option)
\newline
Unless several RZ files are open at the same time, the path name can
be specified either as a path starting with the character '/', in
which case an absolute pathname is intended for the given top directory.
When several RZ files are open, an absolute pathname must start with a
double slash '//' and the top directory.
When the pathname does not start with a '/', the pathname is prefixed
with the path of the CWD.
\item[CHOPT
]Character variable specifying the option
\begin{DL}{MMMMM}
\item[default
]Set the CWD
\item['P'
]Print the CWD
\item['R'
]Read the CWD pathname into CHPATH
\item['U'
]The same as the default but the time stamp in the
directory in memory is checked against the one on the file and if
needed the directory in memory is brought up to date.
This option should be used when the user expects that directories can be
changed concurrently by another user and he wants to use the latest
version.
\item['K'
]Keep the Current Directory in memory. By default, space occupied
by the Current Directory may be released in case there is not enough
space to accomodate the new directory.
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*CHPATH*
]Character variable containing the complete pathname of the
CWD ('R' option)
\end{DL}
\end{DL}
\subsection{RZCDIR return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[ 0
]Normal completion
\item[ 1
]The pathname CHPATH is invalid (default option)
\end{DL}
\par
\item[IQUEST(7)
]NKEYS, number of keys in the directory
\item[IQUEST(8)
]NWKEY, number of words in a key
\item[IQUEST(9)
]Number of directories below CWD.
\item[IQUEST(10)
]NQUOTA, the record quota for the CWD tree.
\end{DL}
\subsection{Examples:}
\par It is not necessary to specify {\tt //Top_dir} in a pathname
unless several RZ files are open simultaneously.
If only one RZ file is declared, the following two calls
are equivalent:
\begin{verbatim}
      CALL RZCDIR('//top_dir/dira/dirb/dirc',' ')
and
      CALL RZCDIR('/dira/dirb/dirc',' ')
\end{verbatim}
\par If the CWD was already set to {\tt /dira/dirb}
one can further abbreviate
the calling sequence to
\begin{verbatim}
      CALL RZCDIR('dirc',' ')
\end{verbatim}
\par To go one level up in the directory tree one can use '$\backslash$', e.g.
if the CWD is {\tt /dira/dirb/dirc}
then the two following calls are equivalent:
\begin{verbatim}
      CALL RZCDIR('$\backslash$',' ')
and
      CALL RZCDIR('/dira/dirb',' ')
\end{verbatim}
To set the CWD to the Naming directory one uses:
\begin{verbatim}
      CALL RZCDIR('\~',' ')
\end{verbatim}
%??.cc 50>
\subsection{Creation of a directory}
\par A directory below the current "working directory" (see RZCDIR)
can be created by a call to RZMDIR.
\index{RZ!directory creation}
\Subr{CALL RZMDIR (CHDIR,NWKEY,CHFORM,CHTAG)}
\index{RZ!RZMDIR}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHDIR
]Character variable with a maximum of 16 characters (for the given
level), specifying the name of the directory to be
created. All characters, but {\bf /, $\backslash$, *, \~ or ?}
are allowed in a directory name.
\item[NWKEY
]Number of words associated to a key {\bf (maximum 9)}
\item[CHFORM
]Character variable describing each element of the key vector
(a blank is equivalent to 'I').
\begin{DL}{MMMMM}
\item['B'
]Bit string but not zero
\item['H'
]Hollerith (4 characters)
\item['A'
]same as 'H' (see RZLDIR)
\item['I'
]Integer (nonzero)
\end{DL}
\item[CHTAG
]Character array defined as CHARACTER*8 CHTAG(NWKEY).
\newline
Each element of the array allows the description of the corresponding
element in the key vector with a tag of up to 8 characters.
\end{DL}
\end{DL}
\subsection{Example 1: The HBOOK histogramming package}
\par HBOOK histograms can be identified by the pathname
{\tt //Top_dir/dira/..}
and a KEY where {\tt NWKEY=1}
and where the KEY is ID, the identifier
of the histogram
\subsection{Example 2: Creating the geometry file of a LEP experiment}
\par To create a geometry file for the OPAL detector
the data base for the experiment has as top directory called
{\tt //OPAL}.
A directory called {\tt Geometry} is created, which will contain
the names of the 12 main detectors of OPAL.
\begin{verbatim}
      CHARACTER TAGS(2)*8
      INTEGER   KEY(2)
 
      CALL RZMDIR('Geometry',1,'H','Detector')
      CALL RZCDIR('Geometry',' ')
      TAGS(1)='Volume'
      TAGS(2)='Number'
      CALL RZMDIR('CDET',2,'HI',TAGS)
      CALL RZMDIR('ECAL',2,'HI',TAGS)
      CALL RZMDIR('HCAL',2,'HI',TAGS)
      CALL RZMDIR('FDET',2,'HI',TAGS)
      CALL RZMDIR('MUON',2,'HI',TAGS)
              .......
\end{verbatim}
As we now want to introduce information into the CDIR directory,
we put our working directory equal to the latter by a call to RZCDIR:
\begin{verbatim}
      CALL RZCDIR('CDET',' ')
\end{verbatim}
which is equivalent to
\begin{verbatim}
      CALL RZCDIR('//OPAL/Geometry/CDET'),' ')
\end{verbatim}
%??.cc 50>
\subsection{Example 3: Using the geometry file of a LEP experiment}
\par Logical records can then be entered corresponding to the parameters
of each of the 24 sectors of the Jet chamber of the Central detector,
of the vertex detector and of the Z chambers
(routine RZOUT is described below).
\begin{verbatim}
C--     Write the information for the 24 Jet chamber sectors
      CALL UCTOH('SECT',KEY,4,4)
      DO 10 ISECT=1,24
          KEY(2)=ISECT
          CALL RZOUT(IXSTOR,LQ(LCDET-ISECT),KEY,ICYCLE,' ')
   10 CONTINUE
C--     Write the information for the vertex chamber
      CALL UCTOH('VERT',KEY,4,4)
      KEY(2)=1
      CALL RZOUT(IXSTOR,LVERT,KEY,ICYCLE,' ')
C--     Write the information for the Z chambers
      CALL UCTOH('ZCHA',KEY,4,4)
      CALL RZOUT(IXSTOR,LZCHA,KEY,ICYCLE,' ')
\end{verbatim}
Update records for the geometry of each detector can be foreseen, e.g.
by creating a directory 'Updates' below 'CDET'
\begin{verbatim}
      CALL RZMDIR('Updates',1,'I','RUN')
\end{verbatim}
The Logical records in the 'Updates' directory will contain the
detector's identification as well as update parameters. KEY(1) could be
the RUN number from which the given corrections should be applied.
The procedure to build the geometry data structure could be the following:
\begin{UL}
\item Read the standard parameters in directory 'CDET'
\item Set the CWD to 'Updates' and check if there are corrections
to be applied for that run,etc.
\end{UL}
%??.cc 20>
\subsection{Get the key definitions for the current working directory}
\par Information about the key definitions, as declared by RZMDIR,
for the CWD can be obtained be a call to RZKEYD:
\index{RZ!CWD key definition}
\index{RZ!RZMDIR}
\Subr{CALL RZKEYD (NWKEY*,CHFORM*,CHTAG*)}
\index{RZ!RZKEYD}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[NWKEY*
]Number of words associated to a key in the CWD
\item[CHFORM*
]Character variable describing each element of the key vector
(see RZMDIR)
\item[CHTAG*
]Character array defined as CHARACTER*8 CHTAG(NWKEY).
\newline Each element of the array describes the corresponding
element in the key vector.
\end{DL}
\end{DL}
%??.cc 40>
\subsection{Lock and unlock a directory}
\par When an RZ random access file is declared mode 'SU' (shared/update)
with RZFILE , then care must be taken to propagate the changes made
\index{RZ!file-mode shared}
\index{RZ!file-mode update}
to the file to other processes, which are accessing the file
concurrently. Therefore, whenever the
\index{RZ!RZFILE}
directory structure or the data part of the CWD has to be changed by
calling one of the following routines:
RZMDIR, RZCOPY, RZDELT, RZDELK, RZFRFZ, RZOUT, RZPURG, RZQUOT, RZRENK,
\index{RZ!directory locking}
\index{RZ!directory unlocking}
then, before using the first time any of these routines,
the CWD must be locked by a calling routine RZLOCK.
To use this routine the write
password must have been specified if one has been defined.
Once a directory is locked, all
subdirectories become unavailable for locking. Hence when the top
directory is locked, the complete file is locked.
\par Note that two or more branches of a directory can be modified
concurrently
by different users (each one making a call to RZLOCK), as long as
for any given directory to be locked there is no higher level
directory already in a locked state.
\Subr{CALL RZLOCK (CHLOCK)}
\index{RZ!RZLOCK}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHLOCK
]Character variable(up to 8 characters)identifying the owner
of the lock (e.g.
specifying the name of the user, his computer identifier,...)
This parameter is used to avoid two users, who have both the
write password for a directory, trying to change it at the same time.
CHLOCK is also useful in the case of a system crash while a directory
was locked.
\end{DL}
\end{DL}
\par Once all modifications to a directory are performed, it must
be unlocked by a call to RZFREE. This routine outputs the updated
directories and provides them with a time stamp, so that other users
can determine whether they want to update the copy of the directories
they are working with.
\Subr{CALL RZFREE (CHLOCK)}
\index{RZ!RZFREE}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHLOCK
]Character variable identifying the owner of the lock.
\end{DL}
\end{DL}
%??.cc 15>
\subsection{Set the space quota for the current working directory}
\par Routine RZQUOT allows the user to define a
space quota for the CWD and all its subdirectories.
\index{RZ!directory quota}
\Subr{CALL RZQUOT (NQUOTA)}
\index{RZ!RZQUOT}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[NQUOTA
]The maximum number of records which can be used by the CWD and its
subdirectories
\newline By default NQUOTA is equal to the minimum of the total number of
records allowed for the complete file (parameter NREC in RZMAKE) and
the quota of the parent directory.
\end{DL}
\end{DL}
%??.cc 25>
\subsection{List the contents of a directory}
\par The keys and the subdirectory names belonging to a given pathname can
be listed by a call to RZLDIR.
\index{RZ!list directory}
\Subr{CALL RZLDIR (CHPATH,CHOPT)}
\index{RZ!RZLDIR}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHPATH
]Character variable specifying the directory pathname.
\begin{DL}{MMMMM}
\item[default
]List information for the CWD.
\item['//'
]List all the RZ files.
\end{DL}
\item[CHOPT
]Character variable specifying the options
\newline 'A' list all keys created with option 'A' by RZOUT or RZVOUT.
\newline By default such keys are not listed.
\end{DL}
\end{DL}
\par If keys have been defined by RZMAKE or RZMDIR with format 'H',
they are listed each with 4 characters. If keys have been defined
with format 'A', they are listed without separators.
%??.cc 40>
\subsection{Retrieve the contents of a directory}
\par The list of NDIR directories attached to the CWD can be
retrieved and stored into a character array.
\index{RZ!directory retrieve}
\Subr{CALL RZRDIR (MAXDIR,CHDIR*,NDIR*)}
\index{RZ!RZRDIR}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[MAXDIR
]Length of the character array CHDIR
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[CHDIR*
]Character array which will contain the directory names attached to
the CWD. If the length of the directory name is greater then the length
of one element of CHDIR (as obtained by the LEN function), only
as many characters as will fit in the array element are returned, and
an error code will be set in IQUEST(1).
\item[NDIR*
]Actual number of subdirectories attached to the CWD
\newline If this number is greater than MAXDIR, only the first MAXDIR
directory names will be returned in CHDIR (see IQUEST(11))
\end{DL}
\end{DL}
\par
\subsection{RZRDIR return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[0
]Normal completion
\item[1
]More entries present in the directory than returned in CHDIR
(see NDIR and IQUEST(11)).
\end{DL}
\par
\item[IQUEST(11)
]Actual number of subdirectories
\end{DL}
%??.cc 40>
\subsection{Set the password of the current working directory}
\par Each directory of an RZ file can have its own write password.
When an RZ file is first initialized with RZMAKE there is
no write password set.
Routine RZPASS can be used to specify
or change the password of the CWD.
\index{RZ!CWD}
\par By default, when a directory is created (RZMDIR), the write
password is set equal to the one of the parent directory.
If a password is set, a call to RZPASS is necessary to be able
to write a new key, create a new directory or delete a key or directory.
The password specified using RZPASS is
checked against the one encrypted in the RZ directory referenced.
\Subr{CALL RZPASS (CHPASS,CHOPT)}
\index{RZ!RZPASS}
\index{RZ!current password}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHPASS
]Character string specifying the password.
\item[CHOPT
]Character string specifying the options desired:
\begin{DL}{MMMMM}
\item[default
]Specify a password
\item['S'
]Set or change a password (to change a password a previous call to
RZPASS specifying the old password must have been made).
\end{DL}
\end{DL}
\end{DL}
\par {\bf examples}
\begin{verbatim}
      CALL RZPASS('password',' ')          -- specifies a write password
 
      CALL RZPASS('New_password,'S')       -- changes or sets a password
\end{verbatim}
%??.cc 40>
\section{Write a bank or data structure}
\par To write the information associated to a bank,
a data structure or a complete division to an RZ file and enter the
associated key
into the current working directory, a call to RZOUT should be made.
If the key is not yet present in the directory, a cycle number of
one is returned, while in any other case the cycle number is the old
one present on the file increased by one.
\Subr{CALL RZOUT(IXDIV,LSUP,KEY,*ICYCLE*,CHOPT)}
\index{RZ!RZOUT}
\index{RZ!output data structure}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]Index of the division(s)
\newline May be zero if the 'D' option is not selected
\newline May be a compound index
(see MZIXCO on page on Page~\pageref{MZIXCO FORM=PAGEONLY})
if the 'D' option is selected
\index{MZ!MZIXCO}
\item[LSUP
]Supporting address
of the data structure (may be zero if the 'D' option is selected)
\item[KEY
]Keyword vector of length NWKEY as specified by RZMDIR.
\item[ICYCLE
]Cycle number ('A' option only)
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[data structure
]
\begin{DL}{MMMMM}
\item[default
]The data structure supported by the bank at
LSUP is written out (the next link is not followed)
\index{link!next}
\item['D'
]Complete division(s)
\newline default: Dropped banks are squeezed out
\newline          (slower but maybe more economic than 'DI')
\item['DI'
]Immediate dump of divisions with dropped banks included
\item['L'
]Write the data structure supported by the linear structure at LSUP
(the next link is followed)
\index{link!next}
\item['S'
]Single bank at LSUP
\end{DL}
\item[mode
]
\begin{DL}{MMMMM}
\item[default
]Keep banks available after output
\item['N'
]No links, i.e. linkless handling
\item['W'
]Drop data structure or wipe division(s) after output
\item['A'
]Key will not be visible by RZLDIR
\end{DL}
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[ICYCLE
]Cycle number associated to the key entered
\newline ICYCLE is 1 if KEY was not already present in the directory, and
one larger than the previous cycle associated to the key otherwise.
\end{DL}
\end{DL}
%??.cc 50>
\subsection{RZOUT return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[0
]Normal completion
\item[1
]The directory quota is exhausted, no more space
- nothing has been written
\end{DL}
\item[IQUEST(2)
]Number of physical records written
\item[IQUEST(3)
]Record number of the first record written
\item[IQUEST(4)
]Offset of the information inside the first record
\item[IQUEST(5)
]Record number of the continuation record
\item[IQUEST(6)
]Cycle number of the data structure written
\item[IQUEST(7)
]Number of keys in the directory
\item[IQUEST(8)
]NWKEY, the number of words per key
\item[IQUEST(9)
]Number of records still available in the current subdirectory
\par
\item[IQUEST(11)
]NWBK, number of words of bank material
\end{DL}
%??.cc 30>
\section{Output an array}
\par The contents of a FORTRAN array can be written
into an RZ file and associated with a key in the CWD
by a call to a call to RZVOUT.
The convention for the cycle number is the same as for RZOUT.
\Subr{CALL RZVOUT(VECT,NOUT,KEY,*ICYCLE*,CHOPT)}
\index{RZ!RZVOUT}
\index{RZ!output an array}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[VECT
]Array to be output onto the RZ file
\newline VECT should be dimensioned at least to NOUT
\item[NOUT
]number of words of array VECT to be output
\item[KEY
]Keyword vector of length NWKEY as specified by RZMDIR.
\item[ICYCLE
]Cycle number ('A' option only)
\item[CHOPT
]Character variable specifying the selected options.
\begin{DL}{MMMMM}
\item[format
]
\begin{DL}{MMMMM}
\item[default
]The array contains floating point data
\item['B'
]The array contains bitted data
\item['H'
]The array contains Hollerith data
\item['I'
]The array contains integer data
\item['A'
]Key will not be visible by RZLDIR
\end{DL}
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[ICYCLE
]Cycle number associated to the key entered
\newline ICYCLE is 1 if KEY was not already present in the directory, and
one larger than the previous cycle associated to the key otherwise.
\end{DL}
\end{DL}
%??.cc 50>
\section{Read a bank or data structure}
\par When one wants to read a bank, data structure or division from
a direct access file into memory one calls RZIN or RZINPA.
The information identified by a given KEY and cycle in the CWD are
input. If the cycle specified is not present on the file, the information
associated with the highest cycle of the given key will be used.
\Subr{CALL RZIN(IXDIV,*LSUP*,JBIAS,KEY,ICYCLE,CHOPT)}
\index{RZ!RZIN}
\index{RZ!input data structure}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXDIV
]Index of the division to receive the data structure
\newline IXDIV = 0 means division 2 of the primary store
\item[*LSUP*
]
\item[JBIAS
]{\bf JBIAS < 1:} LSUP is the supporting bank
and JBIAS is the link bias specifying where the data structure has to be
introduced into this bank, i.e. the data structure will be connected
to LQ(LSUP+JBIAS).
\newline {\bf JBIAS = 1:}
LSUP is the supporting link, i.e. the data structure
is connected to LSUP (top level data structure)
\newline {\bf JBIAS = 2:} Stand alone data structure, no connection.
\item[KEY
]Keyword vector of the information to be read (default)
\newline sequential number of the key vector in the directory if 'S' option
\item[ICYCLE
]Cycle number of the key to be read
\newline ICYCLE $>$ highest cycle number means read the highest cycle
\newline ICYCLE = 0 means read the lowest cycle
\item[CHOPT
]Character variable specifying the options selected.
\begin{DL}{MMMMM}
\item[data structure
]
\begin{DL}{MMMMM}
\item[''
]Default - Same as 'D' below
\item['C'
]Provide information about the cycle numbers associated with KEY.
\newline The total number of cycles and the cycle number identifiers
of the 19 highest cycles are returned in IQUEST(50) and IQUEST(51..89)
respectively
\item['D'
]Read the data structure with the (KEY,ICYCLE) pair specified.
\item['N'
]Read the neighbouring
\footnote{
Directory entries are stored in ``historical' order so that it
makes sense to talk of neighbouring records.
This can be used, e.g. to update records of calibration
constants or to scan files with events, where the keys correspond to
event or run numbers.
}
keys (i.e. those preceding and following KEY).
\newline The key-vectors of the previous and next key are available
respectively as IQUEST(31..35) and IQUEST(41..45), see below.
\item['R'
]Read data into existing bank at LSUP,JBIAS. Note that the bank
must have the same size as the one stored in the file.
\item['S'
]KEY(1) contains the sequential number of the key vector
in the current directory (No search required).
\end{DL}
\end{DL}
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*LSUP*
]For JBIAS = 1 or 2, LSUP contains
the entry address to the data structure
\newline In any case IQUEST(11) returns the entry address
\end{DL}
\end{DL}
\par
When one wants to read information from a key associated to a directory
which is not the CWD, then a call to RZINPA can be made.
This routine has a supplementary character type argument CHPATH, which
specifies the pathname
of the directory where the information has to read.
\Subr{CALL RZINPA(CHPATH,IXDIV,*LSUP*,JBIAS,KEY,ICYCLE*,CHOPT)}
\index{RZ!RZINPA}
\index{RZ!input data structure}
%??.cc 15>
\subsection{RZIN return codes}
\par RZIN returns the read status, either normal or error completion,
in the QUEST vector as follows:
\index{QUEST!IQUEST}
\par {\bf Normal read status returns are:}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Operation status code
\begin{DL}{MMMMM}
\item[ 1
]key/cycle pair not present in the CWD
\item[ 0
]normal completion
\end{DL}
\item[IQUEST(2)
]number of physical records read
\item[IQUEST(3)
]Record number of the first record read
\item[IQUEST(4)
]Offset of the start of the information in the first record.
\item[IQUEST(5)
]Record number of the continuation record (0 if not 'A' option).
\item[IQUEST(6)
]ICYCLE: cycle number of information returned.
\item[IQUEST(7)
]Number of keys in the directory
\item[IQUEST(8)
]NWKEY, the number of words per key
\par
\item[IQUEST(11)
]LSUP, the entry address into the data structure
\newline zero means: empty data structure
\item[IQUEST(12)
]NWBK, the number of words occupied by the data structure in memory
\newline zero means: empty data structure
\item[IQUEST(14)
]Time stamp of the information(compressed). In order to get
the unpacked date and time (integers), one can use the RZ internal
routine RZDATE: CALL RZDATE(IQUEST(14),IDATE,ITIME,1).
\item[IQUEST(20)
]Key serial number in the directory
\item[IQUEST(21...20+NWKEY)
]KEY(1)...KEY(NWKEY) if 'S' option given
\par
\item[IQUEST(30)
]NWKEY or zero if no previous key is present ('N' option)
\item[IQUEST(31..35)
]The key vector for the element preceding KEY (if IQUEST(30) > 0)
\newline Only IQUEST(31..30+NWKEY) are significant
\par
\item[IQUEST(40)
]NWKEY or zero if no previous key is present ('N' option)
\item[IQUEST(41..45)
]The key vector for the element following KEY (if IQUEST(40) > 0)
\newline Only IQUEST(41..40+NWKEY) are significant
\par
\item[IQUEST(50)
]Number of cycles present for KEY
('C' option)
\item[IQUEST(51..69)
]The cycle number identifiers associated with KEY
\newline If IQUEST(50) |< 19 then only IQUEST(51..50+IQUEST(50))
are meaningful
\newline If IQUEST(50) > 19 then IQUEST(51..69) contain the 19 highest
cycle number identifiers for KEY
\item[IQUEST(71..89)
]The time stamp information corresponding to each of the
initialized cycle numbers in IQUEST(51..69)
\end{DL}
\par If the pair (KEY,ICYCLE) is not present in the CWD (IQUEST(1) = 1) and
the 'N' option is given, then IQUEST(30...) and IQUEST(40...) will
contain, respectively, the "lowest" and "highest" key vectors present.
%??.cc 40>
\section{Input an array from an RZ file}
\par The information associated with a (key,cycle) pair on an RZ file can
be read into an array by a call to RZVIN.
The same conventions used by RZIN for KEY and cycle in the CWD are used.
\Subr{CALL RZVIN (VECT*,NDIM,NFILE*,KEY,ICYCLE,CHOPT)}
\index{RZ!RZVIN}
\index{RZ!input array}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[NDIM
]Number of words available in array VECT (e.g. declared dimension)
\item[KEY
]Keyword vector of the information to be read
\item[ICYCLE
]Cycle number of the key to be read
\newline ICYCLE $>$ highest cycle number means read the highest cycle
\newline ICYCLE = 0 means read the lowest cycle
\item[CHOPT
]Character variable specifying the options selected(see RZIN).
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[VECT*
]FORTRAN array to contain the information input
\newline The array VECT should be at least dimensioned to NDIM words
\item[NFILE*
]Actual length of the array on the file
\end{DL}
\end{DL}
\subsection{RZVIN return codes}
\par RZVIN returns the read status, either normal or error completion,
in the QUEST vector in a way similar to RZIN.
\index{QUEST!IQUEST}
%??.cc 40>
\section{Operations on keys and cycles}
\subsection{Purge old cycles}
\par All but the last NKEEP cycles of all
key are deleted from the CWD by a call to RZPURG.
\index{VAX}
\index{VMS}
\index{RZ!key purge}
(cf. the PURGE command on the VAX/VMS system)
\Subr{CALL RZPURG (NKEEP)}
\index{RZ!RZPURG}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[NKEEP
]Number of cycles which must be kept for the given key
\newline If NKEEP < 1 then NKEEP is taken to be 1 and only the highest
cycle is kept
\end{DL}
\end{DL}
\subsection{RZPURG return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(9)
]Number of records still available in the current subdirectory
\par
\item[IQUEST(11)
]Maximum number of cycles purged
\item[IQUEST(12)
]Number of words freed
\item[IQUEST(13)
]Number of records freed
\end{DL}
%??.cc 10>
\subsection{Delete a subtree from the current working directory}
\par A subtree of the CWD can be deleted by a call to RZDELT
\index{RZ!directory delete subtree}
\Subr{CALL RZDELT (CHDIR)}
\index{RZ!RZDELT}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHDIR
]Character variable specifying the directory name of the subtree of
the CWD.
\end{DL}
\end{DL}
\subsection{RZDELT return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[ 0
]Normal completion
\item[ 1
]Invalid directory subtree name
\end{DL}
\end{DL}
%??.cc 40>
\subsection{Delete a key from the current working directory}
\par When a key-cycle pair has to be deleted from the
CWD a call to RZDELK must be made
\index{RZ!key deletion}
\Subr{CALL RZDELK (KEY,ICYCLE,CHOPT)}
\index{RZ!RZDELK}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[KEY
]Key array of dimension NWKEY (see RZMDIR)
\item[ICYCLE
]Cycle number of the key to be deleted
\newline ICYCLE $>$ highest cycle number means delete the highest cycle
\newline ICYCLE = 0 means delete the lowest cycle
\newline ICYCLE = -1, -2,... means delete the highest cycle -1, -2,...
\item[CHOPT
]Character variable specifying the options selected.
\begin{DL}{MMMMM}
\item[default
]Delete the explicitly specified cycle ICYCLE only.
\newline If cycle ICYCLE does not exist, no action is taken.
\item['C'
]Delete ALL cycles corresponding to key (ICYCLE not used)
\item['K'
]Delete all keys in the CWD (ICYCLE and KEY not used)
\item['S'
]Delete all cycles smaller than cycle ICYCLE for the given key-vector
\end{DL}
\end{DL}
\end{DL}
\subsection{RZDELK return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Operation status code
\begin{DL}{MMMMM}
\item[ 1
]No entry for key/cycle pair specified
\item[ 0
]normal completion
\end{DL}
\par
\item[IQUEST(11)
]Maximum number of cycles deleted
\item[IQUEST(12)
]Number of words freed
\item[IQUEST(13)
]Number of records freed
\end{DL}
\subsection{Examples}
\begin{verbatim}
      CALL RZDELK(KEY,2,' ')
\end{verbatim}
deletes the information associated with key KEY and cycle number 2 in
the CWD
\begin{verbatim}
      CALL RZDELK(KEY,4,'S')
\end{verbatim}
deletes all information associated with key KEY
and a cycle number smaller than 4 in the CWD.
\begin{verbatim}
      CALL RZDELK(0,0,'K')
\end{verbatim}
deletes all cycles of all keys in the CWD.
%??.cc 40>
\subsection{Rename a key in the current working directory}
\par A key in the CWD can be renamed by a call to RZRENK
\index{RZ!key rename}
\Subr{CALL RZRENK (KEYOLD,KEYNEW)}
\index{RZ!RZRENK}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[KEYOLD
]Key array of dimension NWKEY containing the old key vector
\item[KEYNEW
]Key array of dimension NWKEY containing the new key vector
\end{DL}
\end{DL}
\subsection{Return codes}
\index{QUEST!IQUEST}
\par
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Operation status code
\begin{DL}{MMMMM}
\item[ 1
]No entry for KEYOLD in the CWD
\item[ 0
]normal completion
\end{DL}
\end{DL}
%??.cc 50>
\subsection{Retrieve the keys associated to the current working directory}
\par Subroutine RZKEYS returns the list of keys created in the CWD.
The keys are returned in historical order.
\index{RZ!key retrieve}
\Subr{CALL RZKEYS (MAXDIM,MAXKEY,KEYS*,NKEYS*)}
\index{RZ!RZKEYS}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[MAXDIM
]The actual first dimension of output array KEYS.
It should in principle be at least equal to the number of key elements
NWKEY as declared to RZMDIR.
\item[MAXKEY
]The actual second dimension of output array KEYS
\end{DL}
\end{DL}
\begin{DL}{MMMMM}
\item[Output:
]
\begin{DL}{MMMMM}
\item[KEYS*
]A 2-dimensional array dimensioned KEYS(MAXDIM,MAXKEY).
It will contain the key vectors associated with the CWD.
\newline Its first index runs over the key elements for a given key, while
its second index runs over the different keys.
\item[NKEYS*
]Number of keys returned in array KEYS.
\end{DL}
\end{DL}
\subsection{Return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[0
]Normal completion
\item[1
]The keys have a length NWKEY > MAXKEY
\newline  or more entries present in the directory than returned in KEYS
(see IQUEST(11)).
\end{DL}
\par
\item[IQUEST(11)
]Actual number of keys in the CWD.
\item[IQUEST(12)
]NWKEY, number of words characterizing a key vector element for the
CWD (as defined on page
on Page~\pageref{RZMDIR FORM=PAGEONLY} for RZMDIR).
\end{DL}
\subsection{Examples}
\par For the lead glass blocks file in the example in
section 1, we could write:
\begin{verbatim}
      INTEGER KEYS(5000)
 
      CALL RZKEYS(1,5000,KEYS,NKEYS)
\end{verbatim}
For the events to be scanned we could have:
\begin{verbatim}
      INTEGER KEYS(2,500)                      -- Up to 500 keys vectors
 
      CALL RZKEYS(2,500,KEYS,NKEYS)
\end{verbatim}
%??.cc 40>
\section{Copy a data structure from one directory to the CWD}
\par A directory tree identified by its
pathname CHPATH can be copied
to the CWD with the help of subroutine RZCOPY.
Routine RZCOPY can also be used to merge two RZ files.
\index{RZ!copy directory}
\Subr{CALL RZCOPY (CHPATH,KEYIN,ICYCIN,KEYOUT,CHOPT)}
\index{RZ!RZCOPY}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHPATH
]The pathname of the directory tree which has to be copied
to the CWD
\item[KEYIN
]Key-vector of the object to be copied from CHPATH.
\item[ICYCIN
]Cycle number of the key to be copied
\item[KEYOUT
]Key array of the object in the CWD after the copy
\item[CHOPT
]Character variable specifying the options selected.
\begin{DL}{MMMMM}
\item[default
]Copy the object from (KEYIN,ICYCIN) from CHPATH to the CWD
\newline If KEYOUT already exists, a new cycle is created.
\item['C'
]Copy all cycles for the specified key (ICYCIN not used)
\item['K'
]Copy all keys in the CWD (ICYCIN and KEYIN not used)
\newline
Given together with the 'C' option it copies all cycles of all keys.
\item['T'
]Not yet implemented. Copy the complete tree CHPATH.
By default only the highest cycles are copied.
\newline Given together with the 'C option all cycles are copied.
\end{DL}
\end{DL}
\end{DL}
\par Note that the input and output keys KEYIN and KEYOUT may be identical.
In this case, if KEYOUT already exists in the CWD, a new cycle (or
several) is created.
\subsection{Return codes}
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(1)
]Error status
\begin{DL}{MMMMM}
\item[ 1
]Invalid pathname
\item[ 0
]Normal completion
\end{DL}
\end{DL}
%??.cc 50>
\section{Copy information associated to a directory from and to a sequential file}
\par In order to provide
easy transportability of data between different computer
systems information stored in an RZ directory tree can
be written to or read from a sequential file.
All keys in the tree associated with the CWD can be copied
to an FZ sequental file by using RZTOFZ.
The sequential file must be opened with FZFILE prior to
the call to RZTOFZ and thus the transport mode (native or exchange)
is determined by the mode declared to FZFILE.
\index{FZ!FZFILE}
\index{FZ!mode exchange}
\index{FZ!mode native}
The data structures are read into the system division of the
primary store before their transfer to the output file.
\index{RZ!Random to sequential}
\index{FZ!Random to sequential}
\Subr{CALL RZTOFZ (LUNFZ,CHOPT)}
\index{RZ!RZTOFZ}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUNFZ
]Logical unit number of the FZ sequential access file
\item[CHOPT
]Character variable specifying the options selected.
\begin{DL}{MMMMM}
\item[default
]Write the highest cycle of the keys in the CWD to the FZ file
\item['C'
]Write all cycles of the keys in the CWD to the FZ file
\end{DL}
\end{DL}
\end{DL}
\index{RZ!Random from sequential}
\index{FZ!Random from sequential}
\par A directory tree can be read
from an FZ sequential file
into the CWD using the routine RZFRFZ.
If a sub-directory with the same name as the one read in is already
present in the CWD, then a new cycle is created for the introduced keys.
The sequential file must be opened with FZFILE prior to the call to RZFRFZ
and hence the transport format (native or exchange)
is determined by the mode declared to FZFILE.
\Subr{CALL RZFRFZ (LUNFZ,CHOPT)}
\index{RZ!RZFRFZ}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[LUNFZ
]Logical unit number of the FZ sequential access file
\item[CHOPT
]Character variable specifying the options selected.
\begin{DL}{MMMMM}
\item[default
]Read all cycles of the keys present on the FZ file into the CWD
\item['H'
]Read the highest cycle of the keys present on the FZ file into
the CWD
\end{DL}
\end{DL}
\end{DL}
%??.cc 20>
\section{Retrieve statistics about a given RZ directory}
\par Routine RZSTAT provides information about the usage statistics
of an RZ direct access file associated with a given directory,
as specified by its pathname.
The routine can be used in two ways,
namely to print the global statistics at the end of a run, or
to retrieve, at any given moment, useful data about the space usage
(e.g. to verify whether there is
still enough space left to add another record).
The information is returned in the ZEBRA communication vector IQUEST.
\index{QUEST!IQUEST}
\index{RZ!statistics}
\Subr{CALL RZSTAT (CHPATH,NLEVELS,CHOPT)}
\index{RZ!RZSTAT}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHPATH
]The pathname of the directory about which information
has to be provided.
\item[NLEVELS
]Number of levels below CHPATH about which space information has
to be accumulated.
\item[CHOPT
]Character variable specifying the options desired
\begin{DL}{MMMMM}
\item[default
]Print the statistics
\item['Q'
]Return the statistics in the user communication vector IQUEST
\newline (not yet implemented)
\end{DL}
\end{DL}
\end{DL}
%??.*****************************************************************>
%??.* ZEBRA User's Guide - Chapter DZ                               *>
%??.*  Last Mod.    6 Aug 1989  17.40   mg                          *>
%??.*****************************************************************>
\chapter{DZ: The debug and dump package}
\section{Display routines}
\subsection{Display of a bank or a data structure}
\par DZSHOW displays the contents of a bank or a data structure in a store.
The output format of the data part is controlled by the internal
or external I/O characteristic.
\Subr{CALL DZSHOW (CHTEXT,IXSTOR,LBANK,CHOPT,ILNK1,ILNK2,IDAT1,IDAT2)}
\index{DZ!DZSHOW}
\index{display!data structure}
\index{display!bank}
\index{bank!display}
\index{data structure!display}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
together with the display (truncated to 50 characters).
\item[IXSTOR
]Index of the store containing the bank or data structure.
\item[LBANK
]Address of bank or entry address to the data structure
which is to be displayed.
\item[CHOPT
]Character variable specifying option desired.
\begin{DL}{MMMMM}
\item['B'
]Print the single bank at LBANK (default).
\item['D'
]Print the bank contents from top to bottom Downwards
with five elements per line.
\item['S'
]Print the bank contents from left to right Sideways
with up to ten elements per line (default).
\item['L'
]Print the linear structure supported by LBANK.
\item['V'
]Print the vertical (down) structure supported by LBANK.
\item['Z'
]Print the data part of each bank in hexadecimal format
(i.e. ignoring the I/O characteristic).
\index{bank!I/O characteristic}
\end{DL}
\item[ILNK1
]Index of the first link in a bank which will be printed.
\item[ILNK2
]Index of the last link in a bank which will be printed.
\item[IDAT1
]Index of the first data word in a bank which will be printed.
\item[IDAT2
]Index of the last data word in a bank which will be printed.
\end{DL}
\end{DL}
\subsection{Example:}
\begin{verbatim}
      CALL DZSHOW ('Display banks',IXSTOR,LQMAIN,'BLV',3,7,0,0)
\end{verbatim}
The complete (both down and next links are to be followed)
\index{link!next}
\index{link!down}
structure supported by the bank
at address LQMAIN in  store IXSTOR is to
be displayed (both down and next links are to be followed).
\index{link!next}
\index{link!down}
Links 3 to 7 and all data words of each bank are to be printed.
\subsection{NOTES:}
\par
\begin{OL}
\item When ILNK2$<$ILNK1 (IDAT2$<$IDAT1) no links (data) are output.
\item When ILNK2=ILNK1=0 (IDAT2=IDAT1=0) all links (data) are output.
\item When ILNKi or IDATi are outside bounds for a given bank,
the actual values for the bank in question are taken.
\item The explanation of the first output line printed for each bank
is given in section "Bank information"
under the heading "First line (General information)" in the
description of routine DZSNAP.
\end{OL}
%??.CC 50>
\subsection{Output examples}
\begin{figure}
\begin{figure}
\begin{verbatim}
 DZSHOW --- Dump EV structure                                                                      OPTIONS:                 BDLV
 
  DZSHOW  +++++ LEVEL     0++++++++++             Store nb. 0 = //       Division nb. 2 = QDIV2     ++++++++++
  EV  .     1     9580(00065734) SY/US/IO 0001/00000/2153 NL/NS/ND    7/    7/      10 N/U/O/@O       0/       0/       1/    9580
 STRUCTURAL links                                          --------------------
\index{link!structural}
           1    VX        9379     3                 0     5                 0     7                 0
           2                 0     4                 0     6                 0
 DATA part of bank                                         --------------------
           1     "        EV       3     "        VX       5                 5     7     7.0000000         9     9.0000000
           2     "        TK       4                 4     6                 6     8     8.0000000        10     10.000000
 DZSHOW  +++++ LEVEL     1++++++++++             Store nb. 0 = //       Division nb. 2 = QDIV2     ++++++++++
  VX  .     3     9379(00065410) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9452/    9580/    9579/    9379
 STRUCTURAL links                                          --------------------
           1    TK        9328
 DATA part of bank                                         --------------------
           1                31     4     34.000000         7     37.000000        10     40.000000
           2                32     5     35.000000         8     38.000000        11     41.000000
           3                33     6     36.000000         9     39.000000        12     42.000000
 DZSHOW  +++++ LEVEL     2++++++++++             Store nb. 0 = //       Division nb. 2 = QDIV2     ++++++++++
  TK  .     2     9328(00065344) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9353/    9379/    9378/    9328
 DATA part of bank                                         --------------------
           1     231.00000         4     234.00000         7     237.00000        10     240.00000        13     243.00000
           2     232.00000         5     235.00000         8     238.00000        11     241.00000        14     244.00000
           3     233.00000         6     236.00000         9     239.00000        12     242.00000        15     245.00000
\end{verbatim}
\end{figure}
\begin{figure}
\begin{figure}
\begin{verbatim}
 DZSHOW --- Dump EV structure                                                                      OPTIONS:                 BSLV
 
  DZSHOW  +++++ LEVEL     0++++++++++             Store nb. 0 = //       Division nb. 2 = QDIV2     ++++++++++
  EV  .     1     9580(00065734) SY/US/IO 0001/00000/2153 NL/NS/ND    7/    7/      10 N/U/O/@O       0/       0/       1/    9580
 --------  LINK part of bank  --------
       1 /        9379           0           0           0           0           0           0
 --------  DATA part of bank  --------
       1 /       "EV         "TK         "VX             4           5           6   7.000       8.000       9.000       10.00
 DZSHOW  +++++ LEVEL     1++++++++++             Store nb. 0 = //       Division nb. 2 = QDIV2     ++++++++++
  VX  .     3     9379(00065410) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9452/    9580/    9579/    9379
 --------  LINK part of bank  --------
       1 /        9328
 --------  DATA part of bank  --------
       1 /          31          32          33   34.00       35.00       36.00       37.00       38.00       39.00       40.00
      11 /   41.00       42.00
 DZSHOW  +++++ LEVEL     2++++++++++             Store nb. 0 = //       Division nb. 2 = QDIV2     ++++++++++
  TK  .     2     9328(00065344) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9353/    9379/    9378/    9328
 --------  DATA part of bank  --------
       1 /   231.0       232.0       233.0       234.0       235.0       236.0       237.0       238.0       239.0       240.0
      11 /   241.0       242.0       243.0       244.0       245.0
\end{verbatim}
\end{figure}
%??.cc 10>
\subsection{Print the format of a bank}
\par DZFORM prints the format of the data part of a bank.
It uses the I/O characteristic stored in the bank, decodes the
information and prints it in a format which is compatible with the
input of MZFORM.
\Subr{CALL DZFORM(IXSTOR,LBANK)}
\index{DZ!DZFORM}
\index{bank!format display}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[IXSTOR
]Index of the store where the bank resides.
\item[LBANK
]Print the I/O characteristic for the bank at address LBANK.
\newline If LBANK = 0 all I/O characteristics declared with MZFORM are
printed
\index{MZ!MZFORM}
\end{DL}
\end{DL}
%??.CC 40>
\subsection{Display of a ZEBRA store}
\par DZSTOR displays the structure of the ZEBRA store identified by IXSTOR.
The routine outputs the parameters
characterizing the store, followed by a
list of all divisions and all link areas associated with the store in
question.
\Subr{CALL DZSTOR (CHTEXT,IXSTOR)}
\index{DZ!DZSTOR}
\index{store!display}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
together with the dump (truncated to 50 characters).
\item[IXSTOR
]Index of store to be displayed.
\end{DL}
\end{DL}
\subsection{Output example}
\par The store parameters give the store sequence number (id), name and
absolute address, followed by the useful length, the number of fence,
structural, permanent and working space link words, the minimal and
actual number of words in the reserve area between divisions 1 and 2,
the minimal offset of the upper end of default division 2 and the
number of short term and long term user divisions.
\begin{figure}
\caption{Example of DZSTOR output for the blank common}
\begin{verbatim}
 DZSTOR --- Dump of store //
  --- Store Parameters ---
 Id    Name    Abs.addr.  Length   Fence      NS      NL      WS  Min.Resv.  Act.Resv.   Min(1+2)   Low  High
  0  //        0005C188     9998       2       1       0       0       1600       9325       2000     2     0
  --- Division parameters ---
    DIVISION    START    END       MAX    KIND   MODE  WIPES  GARB.  GARB. PUSHES      LIVE BANKS  DROPPED BANKS    BANKS TOTAL
  NB.   NAME   ADDRESS ADDRESS  LENGTH                        SYST.   FREE          NUMB.   LENGTH NUMB.   LENGTH NUMB.   LENGTH
==================================================================================================================================
   1  QDIV1          2       1       0 U/EVENT  FORWD      0      0      0      0       0        0     0        0     0        0
   2  QDIV2       9327    9598       0 U/EVENT  REVRS      0      0      0      0      11      272     0        0    11      272
  20  QDIVSYST    9750    9998       0  SYSTEM  REVRS      0      0      0      0       6      249     0        0     6      249
  --- Link area parameters ---
 QWSP     PERMANENT LIST AREA      is at absolute 0005C188 NL/NS     1    1     status   ACTIVE
 QLASYST  PERMANENT LIST AREA      is at absolute 00079E50 NL/NS    20   10     status   ACTIVE
\end{verbatim}
\end{figure}
%??.CC 25>
\subsection{Display of a link area}
\par DZAREA displays the contents of a ZEBRA link area.
\Subr{CALL DZAREA (CHTEXT,IXSTOR,CHLA,LLA,CHOPT)}
\index{DZ!DZAREA}
\index{link area!display}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable with text to be printed with the
dump (truncated to 50 characters).
\item[IXSTOR
]Index of store to which link area is associated.
\item[CHLA
]Character variable specifying the name of the link area to be mapped.
\newline If CHLA='  ' all link areas associated with the store are printed
('N' option only)
\item[LLA
]One of the links of the link area to be printed ('A' option only)
\item[CHOPT
]Character variable specifying option desired
\begin{DL}{MMMMM}
\item['A'
]Use the link parameter LLA to identify the link area (default)
\item['N'
]Use the name parameter CHLA to identify the link area
\end{DL}
\end{DL}
\end{DL}
\subsection{Example}
\begin{verbatim}
      CALL DZAREA ('Display of link area TRACK',IXCOMM,'TRACK',0,'N')
\end{verbatim}
A list of the addresses in the link area TRACK associated
with store IXCOMM will be given.
%??.CC 20>
\subsection{Survey of a ZEBRA data structure}
\par DZSURV displays the survey of a ZEBRA data structure.
All horizontal (NEXT) as well as all vertical (DOWN) structural
\index{link!next}
links of a ZEBRA (sub)structure are followed.
Illegal structural links cause transfer to ZFATAL.
\Subr{CALL DZSURV (CHTEXT,IXSTOR,LBANK)}
\index{DZ!DZSURV}
\index{data structure!survey}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
together with the dump (truncated to 50 characters).
\item[IXSTOR
]Index of store where the data structure resides.
\item[LBANK
]Address of the bank supporting the data (sub)structure for which
the survey is desired.
\end{DL}
\end{DL}
If the structure is legal, printed output is produced.
Each line contains the following information:
\begin{UL}
\item The cumulative number of words occupied by all banks so far
\item The total number of words occupied by all banks at this level
\item The length of the longest bank at this level
\item The number of banks at this level (any identifier)
\item Structural relation
\item Bank identifier(s)
\end{UL}
\subsection{Example:}
\begin{verbatim}
      CALL DZSURV ('Summary of the EV data structure',IXSTOR,LEV)
\end{verbatim}
\begin{figure}
\begin{figure}
\begin{verbatim}
DZSURV --- Survey of the EV data structure                    ST= //        LSTART=     9580
  NWCUM     NW   WBK  NBK    IDENTIFIER(S)
 
     27     27    27    1      EV
     96     69    23    3        -1 VX
    271    175    25    7             -1 TK
 
DZSURV --- The structure supported by bank EV   at       9580 in store //       occupies        271 words  in     11 banks
\end{verbatim}
\end{figure}
where:
\begin{DL}{MMMMM}
\item[NWCUM
]Cumulated NW to allow easy calculation of
the memory occupancy of the sub-structures
\item[NW
]Total number of words occupied by these NBK banks,
including system words.
\item[WBK
]Words per bank (if the NBK banks are not all
of the same length, the longest is given).
\item[NBK
]Number of banks on this level
\item[IDENTIFIER
]Name(s) of the banks at this level
\newline Several names are given if all names
in a linear structure are not identical
\end{DL}
\par In this example
the supporting bank 'LEV' is in common // at address
9580 pointed to by the link LEV.
\newline
It supports a linear structure of 3 VX banks via link -7.
The VX banks all
have a length of 23 words, and thus occupy 69 words of storage.
Each VX bank supports a linear chain of
TK banks via link -1.
\newline
There are 7 TK banks in memory, all of 25 words
(i.e. they occupy 25x7=175 words).
\newline
The total structure contains 11 banks and occupies 271 words.
%??.CC 50>
\section{Map and checks on the division level}
\subsection{Snap of one or more divisions}
\par DZSNAP provides a snapshot of one or more divisions in a ZEBRA store.
The kind of information provided is controlled by CHOPT.
\Subr{CALL DZSNAP (CHTEXT,IXDIV,CHOPT)}
\index{DZ!DZSNAP}
\index{division!snap}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
together with the snap (truncated to 50 characters).
\item[IXDIV
]Index of the division(s) to be snapped.
\newline For combining division indices, function MZIXCO can be used.
\index{MZ!MZIXCO}
\newline If no explicit division identifiers are specified
all user divisions are snapped.
\item[CHOPT
]Character variable specifying the snap options desired.
\begin{DL}{MMMMM}
\item['C' ritical
]Dump any active bank with status bit IQCRIT set;
bit IQCRIT will be reset to zero in each bank
(option C is implied by option T)
\item['D' ump
]Dump any active bank with status bit IQMARK set;
bit IQMARK will be reset to zero in each bank
\item['E' xtend
]Extend map entry to dump all links of each bank
(otherwise only as many links as will fit on a line)
\item['F' ull
]Dump all active banks, links and data
\item['K' ill
]Dropped banks to be treated as active
(dropped banks are not normally dumped under D or F option)
\item['L' ink
]Dump all link areas associated with the store
\item['M' ap
]Print map entry for each bank
\item['T' erminal
]Terminal type dump, used for the post-mortem dump
mainly to mark "critical" directly accessible banks
\item['W' ork
]Dump the working space, links and data
\item['Z'
]Dump the information in hexadecimal.
\end{DL}
\end{DL}
\end{DL}
%??.CC 20>
\subsubsection{Store information}}}}}
\par The first part of the output generated by DZSNAP refers to the store.
The following information is provided:
\begin{DL}{MMMMM}
\item[NAME
]Name of the store
\item[lQSTOR
]Absolute address -1 of the store
\item[NQSTRU
]Number of structural links at the beginning of the store
\item[NQREF
]Number of permanent links at the beginning of the store
\item[NQLINK
]Number of permanent + working space links
\item[NQMINR
]Minimum size of the reserve area between divisions 1 and 2
\item[LQ2END
]Lower limit for the upper and of division 2
\item[JQDVLL
]Index of the most recent short-range divisions
\item[JQDVSY
]Index of the system division
\item[NQFEND
]Number of fence words
\item[LOW-1/N
]Start and end address of division 1
\item[HIGH-1/N
]Start and end address of division 2
\item[SYST-1/N
]Start and end address of the system division
\item[END
]Address of the last user word in the store
\end{DL}
%??.CC 50>
\subsubsection{Bank information}}}}}
\par A map output in DZSNAP (selected by the option letter M)
\index{division!MAP bank display}
\index{DZ!DZSNAP}
gives a comprehensive overview of all banks in
the one or more divisions in a ZEBRA dynamic store.
One or two (MAP-)line(s) are printed per bank.
They contain the following information:
\subsubsection{First line (General information)}}}}}
\begin{OL}
\item The 4 character Hollerith bank identifier preceded by a (
if the bank has been dropped.
\item The bank numeric identifier
\item The address of the bank (status word) relative to the beginning of
the store and as an absolute address (in octal or hexadecimal)
\item The contents of the system and user part of the status word of the
of the bank (bits 19-32 and 1-18) and of its I/O characteristic.
\item Number of links (NL)/ of structural links (NS)/ of data words (ND)
\item The contents of the next (N)/up (U)/and origin (O)
\index{link!next}
links of the bank,
as well as of the contents of the address pointed to by the origin link
\index{link!origin}
(@O), which should contain
the address of the bank itself (hence allowing an easy cross-check).
When an inconsistency is detected the
faulty address is preceded by a minus sign (-).
\end{OL}
\subsubsection{Second line (Links) (present only when there are non-zero links)}
\begin{OL}
\item a two character flag:
\begin{DL}{MMMMM}
\item[**
]the bank is dropped (also signaled by a left parenthesis '('
on the first line)
\item[.
]the bank is active, all non-zero links are printed
\item[+
]the bank is active, not all non-zero links are printed
\item[F
]in position 2 flags a bank with potentially dangerous
contents in the links printed. This could be either:
\begin{UL}
\item illegal link content
\item dropped bank supporting an active bank (not via NX link)
\item active bank pointing to a dropped bank
\end{UL}
\end{DL}
\item links 1,2....N are printed in this order with N the smaller of the
the following 2 numbers:
\begin{UL}
\item N1, the last non-zero link of this bank;
\item N2, the number of links which can be printed on one line (typically 9)
\end{UL}
If the link points to a correct bank-address, the ID of that
bank is also printed, preceded by '(' if this bank has been dropped.
If the link does not point to a status word, then a '-' or
'****' is printed against it for legal or illegal link content.
\end{OL}
\par Normally, the map is at the same time a printout of the more
interesting links in the banks.
However, banks may have more than the N2 links,
the maximum printed in the map.
If it is desired to print all the links,
the option letter E should be given and
then an internal  call to DZSHOW is generated.
\par To avoid confusion about the FORMAT of a data word,
an extra symbol may be printed on its left:
\begin{DL}{MMMMM}
\item[   O
]for octal
\item[   Z
]for hexadecimal,
\item[   "
]for BCD.
\end{DL}
%??.CC 50>
\begin{figure}
\begin{figure}
\begin{verbatim}
 DZSNAP --- Snap of //                                                                             OPTIONS:                    M
   NAME       LQSTOR NQSTRU  NQREF NQLINK LQMINR LQ2END JQDVLL JQDVSY NQFEND  LOW-1  LOW-N HIGH-1 HIGH-N SYST-1 SYST-N    END
  //      (0005C188)      1      1      1   1600   2001      2     20      2      2      1   9327   9598   9750   9998   9998
0DZSNAP.   -----  Store nb. 0 = //       Division nb. 2 = QDIV2                       --------------------
  TK  .     2     9328(00065344) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9353/    9379/    9378/    9328
  TK  .     1     9353(000653A8) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9379/    9328/    9353
  VX  .     3     9379(00065410) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9452/    9580/    9579/    9379
      . LINKS:    9328 TK
  TK  .     2     9401(00065468) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9426/    9452/    9451/    9401
  TK  .     1     9426(000654CC) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9452/    9401/    9426
  VX  .     2     9452(00065534) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9550/    9580/    9379/    9452
      . LINKS:    9401 TK
  TK  .     3     9474(0006558C) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9499/    9550/    9549/    9474
  TK  .     2     9499(000655F0) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9524/    9550/    9474/    9499
  TK  .     1     9524(00065654) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9550/    9499/    9524
  VX  .     1     9550(000656BC) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O       0/    9580/    9452/    9550
      . LINKS:    9474 TK
  EV  .     1     9580(00065734) SY/US/IO 0001/00000/2153 NL/NS/ND    7/    7/      10 N/U/O/@O       0/       0/       1/    9580
      . LINKS:    9379 VX
\end{verbatim}
\end{figure}
%??.CC 25>
\subsection{Verify one or more ZEBRA divisions}
\par DZVERI checks the structure of one or more divisions in a ZEBRA store.
The verification detail depends on the settings in CHOPT.
\Subr{CALL DZVERI (CHTEXT,IXDIV,CHOPT)}
\index{DZ!DZVERI}
\index{division!verification}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
together with the verification (truncated to 50 characters).
\newline CHTEXT='  ': No message is output unless an error is detected.
In the latter case a message detailing the problem is
{\bf\it always} output, irrespective of CHTEXT.
\item[IXDIV
]Index of the division(s) to be verified.
\newline For a combination of divisions the MZ function MZIXCO should
be used
\newline If no explicit division identifiers are specified
all user divisions are verified.
\index{MZ!MZIXCO}
\item[CHOPT
]Character variable specifying level of checks desired.
\begin{DL}{MMMMM}
\item['C'
]Check chaining of banks only (DEFAULT)
\item['F'
]Errors are considered fatal and generate a call to ZFATAL
\index{MZ!ZFATAL}
\item['L'
]Check validity of the structural links in the banks
\index{link!structural}
(implies 'C')
\item['S'
]Check the store parameters
\item['U'
]Check the validity of the up and origin links in the banks
\index{link!up}
\index{link!origin}
(implies 'C')
\end{DL}
\end{DL}
\end{DL}
\par
When an error is detected the variable IQUEST(1) in common /QUEST/
\index{QUEST!Error reporting}
will be non zero. When everything is correct it will contain zero.
%??.CC 12>
\subsubsection{Example}
\begin{verbatim}
     CALL DZVERI('Check store layout',IXSTOR,'S')
\end{verbatim}
only checks the store parameters for store IXSTOR, while
\begin{verbatim}
     CALL DZVERI('Check everything',IXDIVI,'CFLSU')
\end{verbatim}
checks the store parameters of the store containing
the divisions IXDIVI
verifies the chaining of the banks and the correctness of all
links (structural, next, up and origin links). When an error is
\index{link!structural}
\index{link!up}
\index{link!origin}
\index{link!next}
detected an exit is forced via ZFATAL.
%??.CC 20>
\subsubsection{Error return codes}}}}}
\par
When DZVERI detects an error then it fills the IQUEST vector as follows:
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(11)
]JQSTOR, the store identifier
\item[IQUEST(12)
]JQDIVI, the division identifier
\par
\item[ -----  'C' option only -- For each faulty bank
]
\par
\item[IQUEST(13)
]LN, its start address
\item[IQUEST(14)
]IQLS, its status word
\item[IQUEST(15)
]IQNL, its total number of links
\item[IQUEST(16)
]IQNS, its number of structural links
\item[IQUEST(17)
]IQNS, its number of data words
\par
\item[ ----- 'L' option only (check structural links in banks)
]
\par
\item[IQUEST(18)
]L, the address of the link being verified
\item[IQUEST(19)
]LQ(L), its contents
\par
\item[ ----- 'U' option only (check origin and up links in banks)
]
\par
\item[IQUEST(20)
]LUP, the value of the UP link
\item[IQUEST(21)
]LORIG, the value of the ORIGIN link
\end{DL}
%??.CC 50>
\section{Monitor changes inside a ZEBRA store or bank.}
\subsection{Calculate the checksum of a vector in a ZEBRA store}
\par
DZCHVC calculates the checksum of the vector (interval) [LBEGIN,LEND]
in a given ZEBRA store and returns the checksum result in a 2-word
user vector.
\Subr{CALL DZCHVC (CHTEXT,IXSTOR,LBEGIN,LEND,CHOPT,*ISUM*)}
\index{DZ!DZCHVC}
\index{checksum!store}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
(truncated to 50 characters).
\item[IXSTOR
]Index of the store where the checksum has to be calculated.
\item[LBEGIN
]First word of the interval for which the checksum
has to be calculated
which is to be displayed.
\item[LEND
]Last word of the interval for which the checksum
has to be calculated
\item[CHOPT
]Character variable specifying option desired.
\begin{DL}{MMMMM}
\item['C'
]Calculate the checksum for the desired interval (default)
\item['V'
]Verify - Compare the newly calculated value of the checksum with the
one given on input in the array ISUM
\end{DL}
\item[*ISUM*
]'V' option only- Two word integer array containing the checksum
calculated by a previous call to DZCHVC. This value has to be compared
with the newly calculated checksum for the given interval.
\end{DL}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*ISUM*
]Two word integer array containing the calculated checksum.
\newline This vector can be used as input to a subsequent call to DZCHVC
for the same interval or can be tested for modifications by the
user himself.
\end{DL}
\end{DL}
\par When the 'V' option is set and a difference is detected between the
input and output values of ISUM, then a non-zero value will be
returned in IQUEST(1), otherwise IQUEST(1) will be zero.
\index{QUEST!Error reporting}
\index{QUEST!IQUEST}
\subsection{Important remark}
\par Since the checksum algorithm
sums the contents of the vector [LBEGIN,LEND]
bit by bit, not all possible changes can be detected (e.g. inversions
in the sequence of the elements will go undetected).
%??.CC 50>
\subsection{Monitor changes in a ZEBRA bank}
\par DZCHST monitors changes in the banks of ZEBRA data structure.
It uses routine DZCHVC.
The data, system and link part of the banks are monitored separately.
\Subr{CALL DZCHST (CHTEXT,IXSTOR,LBANK,CHOPT,*ISUM*)}
\index{DZ!DZCHST}
\index{checksum!bank}
\begin{DL}{MMMMM}
\item[Input:
]
\begin{DL}{MMMMM}
\item[CHTEXT
]Character variable specifying the text to be printed
(truncated to 20 characters).
\item[IXSTOR
]Index of the store where the bank to be monitored resides.
\item[LBANK
]Address of the bank to be monitored.
\item[CHOPT
]Character variable specifying option desired.
\begin{DL}{MMMMM}
\item['B'
]Bank - Consider the checksum of the single bank at LBANK (default)
\item['C'
]Calculate the checksum for the desired banks(s) (default)
 checksum for the desired bank parts
\item['D'
]Consider the checksum of the
structure supported by LBANK, but do not follow the next link.
\index{link!next}
\item['L'
]Consider the checksum of the
structure supported by LBANK, also following the next link.
\index{link!next}
\item['V'
]Verify - Compare the newly calculated value of the checksums with the
ones given on input in the array ISUM
\end{DL}
\item[*ISUM*
]'V' option only - Six word integer array containing the checksums
calculated by a previous call to DZCHST. These values have to be compared
with the newly calculated checksums for the different
parts of the bank(s) in the data structure.
\end{DL}
\item[Output:
]
\begin{DL}{MMMMM}
\item[*ISUM*
]Six word integer array containing the calculated checksums
for the different parts of the bank as follows:
\begin{DL}{MMMMM}
\item[1-2
]Checksum of the {\bf data} part
\item[3-4
]Checksum of the {\bf link} part
\item[5-6
]Checksum of the {\bf system} part
\end{DL}
\newline This array should be used as input to a subsequent call to DZCHST
for the same bank or can be tested for modifications by the
user himself.
\end{DL}
\end{DL}
\par
When the 'V'erify option is active and a difference is detected
then the variable IQUEST(1) in common /QUEST/
\index{QUEST!Error reporting}
will be non zero. When everything is correct it will contain zero.
\subsection{Error return codes}
\par
When DZCHST detects an error then it fills the IQUEST vector as follows:
\index{QUEST!IQUEST}
\begin{DL}{MMMMM}
\item[IQUEST(11)
]0 : Data part OK
\newline 1 : Data part faulty
\item[IQUEST(12)
]0 : Link part OK
\newline 1 : Link part faulty
\item[IQUEST(13)
]0 : System part OK
\newline 1 : System part faulty
\end{DL}
</BODY>
<APPENDIX>
%??.*****************************************************************>
%??.* ZEBRA User's Guide - Appendix Diagnostics                     *>
%??.*  Last Mod.    6 Aug 1989  18.20   mg                          *>
%??.*****************************************************************>
\chapter{Diagnostics}
\section{General information}
\par Zebra has been programmed to be as helpful as reasonably
possible in the task of detecting and diagnosing errors.
Depending on the kind of the error,
three different approaches are used:
for the convenience of the user we have made it a general rule
that he does not have to test on the success of a request to Zebra,
the return from the CALL to Zebra implies successful completion.
\par For example: if the user calls MZLIFT he can be sure that
the bank has been created if he receives control on the next
FORTRAN statement;
\par MZLIFT is in trouble, either because the parameters supplied
by the user are faulty,
or because there is no free memory left,
Zebra will not return to the calling routine,
but take an escape road,
by calling ZFATAL in the first case to stop the program with
diagnostics,
or by calling ZTELL in the second case to allow the user
to re-gain control at the top-level to handle the problem.
\par The exceptions to this general rule are again dictated by the
convenience of usage,
since there are cases where it is necessary to be able to
handle errors in-line to the code as a matter of routine.
\subsection{Return-status codes}
\par This approach is used in all instances where errors are part of
the normal processing.
The obvious example is the routine FZIN which must allow the
user to handle read errors in particular, exceptions in general.
\par The status-return code is always in the word IQUEST(1) of
the common block /QUEST/IQUEST(100).
This word is zero if the request has been completed successfully;
a non-zero value indicates an exception.
The value is positive for a normal exception (such as end-of-file),
the value is negative for errors (such as read errors);
the particular value indicates which exception has occurred.
The significance of the status-return code is part of the
specifications of the routine.
\par For an error status, other words in /QUEST/ carry more
information to identify the problem,
the exact details are found in the present paper
under the name of the routine in question.
\subsection{Exit to ZTELL}
\par This approach is used in the instances where Zebra cannot
satisfy a request, without the program being really at fault.
The obvious example is a request for memory, such as with MZLIFT,
which cannot be satisfied even after garbage collection.
The exit to ZTELL allows the user at the high level to take
control away from the failing low level of his program.
The first parameter to ZTELL is an integer identifying the
cause of the problem; this ID is 99 for 'no memory'.
Under the heading 'ZTELL' in the present paper a list of
the Zebra routines which call ZTELL is given,
together with their identifiers;
further details are found under the name of the calling routine.
%??.cc 25>
\subsection{Exit to ZFATAL}
\par This approach is used to catch programming mistakes,
such as faulty parameters in a Zebra call.
Also, some Zebra routine may detect that the user has overwritten
some system information in a bank,
thereby destroying the sequential chaining from one bank in
memory to the physically next bank
('bank chaining clobbered').
\par Any error of this kind is trapped as soon as it is detected,
information to localize the problem is loaded into
/QUEST/ and control is transferred to ZFATAL.
ZFATAL will print the name of the routine which has called it
(if ZFATAL is reached by in an internal transfer within Zebra)
and the diagnostic information,
whose significance is found in the present paper under
the name of the routine which catches the error.
\par The routine which detects the problem is not necessarily the
routine actually called by the user.
For example: the user may call MZLIFT which in turn may need to
call the garbage collector;
one of its routines may discover that the memory is invalid,
and it will transfer control to ZFATAL.
ZFATAL will print its name, which the user may never have
heard of.
In order to be able to tell the user which routine he
actually called,
Zebra keeps an internal trace-back stack which is printed by ZFATAL.
If the FORTRAN trace-back is available on a particular
machine, this will also be printed as it contains information
very useful to localize the problem.
\subsection{Further diagnostics}
\par Further diagnostic tools are provided by the DZ part of Zebra,
in particular the user may call during bug hunting the routine
DZVERI to verify the integrity of the data in the dynamic store.
\section{Explicit list of messages (see the ZEBRA DIA reference guide)}
%??.*****************************************************************>
%??.* ZEBRA User's Guide - Appendix Glossary                        *>
%??.*  Last Mod.    6 Aug 1989  18.20   mg                          *>
%??.*****************************************************************>
\chapter{\protect\label{NUTSHEL}ZEBRA Glossary}
\begin{DL}{MMMMM}
\item[Bank
]Unit of logically independent block of data
\item[Division
]Stores are divided into disjoint parts (divisions)
for reasons of efficiency or logical separation.
Up to 20 divisions per store are allowed.
\item[Garbage collection
]Process whereby dispersed unused space
inside a division is recovered by moving all banks which are still
in use (active) such that they become contiguous in memory.
\item[Link
]Part of a ZEBRA bank or link area, where pointers to objects
in ZEBRA stores are kept.
\item[Link area
]Vector inside a store or in a COMMON block which contains a
series of (structural or reference) links associated with that store.
\item[List
]Set of structural links containing
pointers to active banks inside a store.
\item[Pointer
]Variable containing an address with respect to the beginning of
a ZEBRA store, which allows to access information inside that store.
\item[Reference link
]Link containing a pointer to information {\bf anywhere}
inside a ZEBRA store.
This link, as opposed to a structural link, does not describe
any hierarchical inter\dependence between two (or more) ZEBRA objects.
It merely offers the possibility to store in a convenient way
pointers to information, which has to be referenced often,
without having to recalculate the latter each time they are needed.
\item[Structural link
]Link containing a pointer to an object in a ZEBRA store,
describing at the same time the structural inter\dependence
between the ZEBRA objects being referenced.
\item[Structure
]Hierarchical tree which expresses the logical relations
between ZEBRA objects (banks or other structures).
\item[Store
]Vector inside a COMMON block where data items (banks) are dynamically
stored. Up to 16 different stores are allowed.
\item[Wipe
]Process whereby a division is emptied of its bank contents
and all references to addresses inside the division are eliminated (zeroed).
\item[ZEBRA
]Data manager which allows the user to build a graph
expressing structural and logical relations between data units (banks).
</GL>
%??.*****************************************************************>
%??.* ZEBRA User's Guide - Calling Sequences                        *>
%??.*  Last Mod.    6 Aug 1989  18.30   mg                          *>
%??.*****************************************************************>
\chapter{ZEBRA subroutine calling sequences}
\begin{figure}
DZAREA(CHTEXT,IXSTOR,CHLA,LLA,CHOPT)
DZCHST(CHTEXT,IXSTOR,LBANK,CHOPT,*ISUM*)
DZFORM(IXSTOR,LBANK)
DZSHOW(CHTEXT,IXSTOR,LBANK,CHOPT,ILNK1,ILNK2,IDAT1,IDAT2)
DZSNAP(CHTEXT,IXDIV,CHOPT)
DZSTOR(CHTEXT,IXSTOR)
DZSURV(CHTEXT,IXSTOR,LBANK)
DZVERI(CHTEXT,IXSTOR,CHOPT)
\end{figure}
\begin{figure}
FZENDx(LUN,CHOPT)
FZIN(LUN,IXDIV,*LSUP*,JBIAS,CHOPT,*NUH*,IUHEAD*)
FZLOGL(LUN,LOGLEV)
FZLIMI(LUN,ALIMIT)
FZFILE(LUN,LREC,CHOPT)
FZOUT(LUN,IXDIV,LENTRY,IEVENT,CHOPT,IOX,NUH,IUHEAD)
FZRUN(LUN,NRUN,NUH,IUHEAD)
\end{figure}
\begin{figure}
LF*= LZBYT(IXSTOR,LLS,IT,JBIT,NBITS)
LF*= LZFID(IXDIV,IDH,IDN,LGO)
LF*= LZFIDH(IXDIV,IDH,LGO)
LF*= LZFIND(IXSTOR,LLS,IT,JW)
LF*= LZFVAL(IXSTOR,LLS,VAL,TOL,JW)
LF*= LZLAST(IXSTOR,LLS)
LF*= LZLOC(IXDIV,CHIDH,IDN)
LF*= LZLONG(IXSTOR,LLS,N,IT,JW)
\end{figure}
\begin{figure}
MZBOOK(IXDIV,L*,*LSUP*,JB,CHIDH,NL,NS,ND,NIO,NZERO)
MZCOPY(IXFROM,LFROM,IXDVTO,*LSUP*,JBIAS,CHOPT)
MZDIV(IXSTOR,IXDIV*,NAME,NW,NWMAX,CHOPT)
MZDROP(IXSTOR,L,CHOPT)
MZEBRA(LIST)
MZEND
MZFLAG(IXSTOR,L,IBIT,CHOPT)
MZFORM(CHIDH,CHFORM,IXIO*)
MZGARB(IXGARB,IXWIPE)
MZIOBK(MMBK*,NWMM,CHFORM)
MZIOCH(IOWDS*,NWIO,CHFORM)
IXC*= MZIXCO(IX1,IX2,IX3,IX4)
MZLIFT(IXDIV,L*,*LSUP*,JB,MMBK,NZERO)
MZLINK(IXSTOR,NAME,LAREA,LREF,LREFL)
MZLINT(IXSTOR,NAME,LAREA,LREF,LREFL)
MZLOGL(IXSTOR,LOGLEV)
MZNEED(IXDIV,NWNEED,CHOPT)
MZPUSH(IXSTOR,*L*,INCNL,INCND,CHOPT)
MZSTOR(IXSTOR*,NAME,CHOPT,FENCE,LQ(1),LQ(LR),LQ(LW),LQ(LIM2),LQ(LAST))
MZWIPE(IXWIPE)
MZWORK(IXSTOR,DFIRST,DLAST,IFLAG)
MZXREF(IXFROM,IXTO,CHOPT)
N*= NZBANK(IXSTOR,LLS)
N*= NZFIND(IXSTOR,LLS,IT,JW)
N*= NZLONG(IXSTOR,LLS,N,IT,JW)
\end{figure}
\begin{figure}
RZCDIR(*CHPATH*,CHOPT)
RZCOPY(CHPATH,KEYIN,ICYCIN,KEYOUT,CHOPT)
RZDELT(CHDIR)
RZDELK(KEY,ICYCLE,CHOPT)
RZEND(CHDIR)
RZFILE(LUN,CHDIR,CHOPT)
RZFREE(CHLOCK)
RZFRFZ(LUNFZ,CHOPT)
RZIN(IXDIV,*LSUP*,JBIAS,KEY,ICYCLE,CHOPT)
RZINPA(CHPATH,IXDIV,*LSUP*,JBIAS,KEY,ICYCLE*,CHOPT)
RZKEYD(NWKEY*,CHFORM*,CHTAG*)
RZKEYS(MAXDIM,MAXKEY,KEYS*,NKEYS*)
RZLDIR(CHPATH,CHOPT)
RZLOCK(CHLOCK)
RZLOGL(LUN,LOGLEV)
RZMAKE(LUN,CHDIR,NWKEY,CHFORM,CHTAG,NREC,CHOPT)
RZMDIR(CHDIR,NWKEY,CHFORM,CHTAG)
RZNDIR(*CHPATH*,CHOPT)
RZOUT(IXDIV,LSUP,KEY,*ICYCLE*,CHOPT)
RZPASS(CHPASS,CHOPT)
RZPURG(NKEEP)
RZQUOT(NQUOTA)
RZRDIR(MAXDIR,CHDIR*,NDIR*)
RZRENK(KEYOLD,KEYNEW)
RZSAVE
RZSTAT(CHPATH,NLEVELS,CHOPT)
RZTOFZ(LUNFZ,CHOPT)
RZVIN(VECT*,NDIM,NFILE*,KEY,ICYCLE,CHOPT)
RZVOUT(VECT,NOUT,KEY,*ICYCLE*,CHOPT)
\end{figure}
\begin{figure}
ZEND
ZFATAL
ZFATAM(CHTEXT)
ZPHASE(NPH)
ZPOSTM(CHOPT)
ZPRESS(IXSTOR,LLS)
ZSHUNT(IXSTOR,LSH,LSUP,JB,IFLAG)
ZSORT(IXSTOR,LLS,JKEY)
ZSORTH(IXSTOR,LLS,JKEY)
ZSORTI(IXSTOR,LLS,JKEY)
ZSORV(IXSTOR,LLS,JKEY,NKEYS)
ZSORVH(IXSTOR,LLS,JKEY,NKEYS)
ZSORVI(IXSTOR,LLS,JKEY,NKEYS)
ZTELL(ID,IFLAG)
ZTOPSY(IXSTOR,LLS)
\end{figure}
%??.pa>
\begin{figure}
on Page~\pageref{DZAREA}
on Page~\pageref{DZCHST}
on Page~\pageref{DZFORM}
on Page~\pageref{DZSHOW}
on Page~\pageref{DZSNAP}
on Page~\pageref{DZSTOR}
on Page~\pageref{DZSURV}
on Page~\pageref{DZVERI}
\end{figure}
\begin{figure}
on Page~\pageref{FZENDI}
on Page~\pageref{FZENDO}
on Page~\pageref{FZIN}
on Page~\pageref{FZLOGL}
on Page~\pageref{FZLIMI}
on Page~\pageref{FZFILE}
on Page~\pageref{FZOUT}
on Page~\pageref{FZRUN}
\end{figure}
\begin{figure}
on Page~\pageref{LZBYT}
on Page~\pageref{LZFID}
on Page~\pageref{LZFIDH}
on Page~\pageref{LZFIND}
on Page~\pageref{LZFVAL}
on Page~\pageref{LZLAST}
on Page~\pageref{LZLOC}
on Page~\pageref{LZLONG}
\end{figure}
\begin{figure}
on Page~\pageref{MZBOOK}
on Page~\pageref{MZCOPY}
on Page~\pageref{MZDIV}
on Page~\pageref{MZDROP}
on Page~\pageref{MZEBRA}
on Page~\pageref{MZEND}
on Page~\pageref{MZFLAG}
on Page~\pageref{MZFORM}
on Page~\pageref{MZGARB}
on Page~\pageref{MZIOBK}
on Page~\pageref{MZIOCH}
on Page~\pageref{MZIXCO}
on Page~\pageref{MZLIFT}
on Page~\pageref{MZLINK}
on Page~\pageref{MZLINT}
on Page~\pageref{MZLOGL}
on Page~\pageref{MZNEED}
on Page~\pageref{MZPUSH}
on Page~\pageref{MZSTOR}
on Page~\pageref{MZWIPE}
on Page~\pageref{MZWORK}
on Page~\pageref{MZXREF}
on Page~\pageref{NZBANK}
on Page~\pageref{NZFIND}
on Page~\pageref{NZLONG}
\end{figure}
\begin{figure}
on Page~\pageref{RZCDIR}
on Page~\pageref{RZCOPY}
on Page~\pageref{RZDELT}
on Page~\pageref{RZDELK}
on Page~\pageref{RZEND}
on Page~\pageref{RZFILE}
on Page~\pageref{RZFREE}
on Page~\pageref{RZFRFZ}
on Page~\pageref{RZIN}
on Page~\pageref{RZINPA}
on Page~\pageref{RZKEYD}
on Page~\pageref{RZKEYS}
on Page~\pageref{RZLDIR}
on Page~\pageref{RZLOCK}
on Page~\pageref{RZLOGL}
on Page~\pageref{RZMAKE}
on Page~\pageref{RZMDIR}
on Page~\pageref{RZNDIR}
on Page~\pageref{RZOUT}
on Page~\pageref{RZPASS}
on Page~\pageref{RZPURG}
on Page~\pageref{RZQUOT}
on Page~\pageref{RZRDIR}
on Page~\pageref{RZRENK}
on Page~\pageref{RZSAVE}
on Page~\pageref{RZSTAT}
on Page~\pageref{RZTOFZ}
on Page~\pageref{RZVIN}
on Page~\pageref{RZVOUT}
\end{figure}
\begin{figure}
on Page~\pageref{ZEND}
on Page~\pageref{ZFATAL}
on Page~\pageref{ZFATAM}
on Page~\pageref{ZPHASE}
on Page~\pageref{ZPOSTM}
on Page~\pageref{ZPRESS}
on Page~\pageref{ZSHUNT}
on Page~\pageref{ZSORT}
on Page~\pageref{ZSORTH}
on Page~\pageref{ZSORTI}
on Page~\pageref{ZSORV}
on Page~\pageref{ZSORVH}
on Page~\pageref{ZSORVI}
on Page~\pageref{ZTELL}
on Page~\pageref{ZTOPSY}
\end{figure}
\chapter{Examples}
\section{Initializing ZEBRA in the main program}
\par ZEBRA must be initialized by a call to MZEBRA.
This is most conveniently placed in the main program.
\par
The first example ZTESTQ shows how to build a linear structure in the default
store (the first one initiated, in this case the blank common). Maximum use is
made of ZEBRA's default settings and the banks are created with MZLIFT using
the bank name vector facility initialized at the beginning of the subroutine.
\par
The second example ZTESTG teaches how a structure similar to the one in ZTESTQ
can be constructed with fanout banks. The use of a link area, several
divisions and the way of describing the type of the data part of the banks
with MZFORM is shown.
\par Example ZTESTA shows how to specify complex I/O descriptors.
\par The last example ZTESTF writes the structures built in the previous three
examples in machine-dependent format to disk, then reads them back into
the same store, outputs them again all together in a 'division' write
to a different output unit and finally re-reads the division in again
as one piece, locating the entry addresses to the different structures
using the LZLOC routine as described on page
on Page~\pageref{LZLOC FORM=PAGEONLY}.
\par
In all examples the use of the DZ debug package routines is also shown.
\begin{figure}\label{ZEBEXA0 FRAME=BOX PLACE=INLINE>
\caption{The main program for running the ZEBRA examples}
\begin{verbatim}
      PROGRAM ZEXAM
 
      CALL MZEBRA(0)
 
C--     Build linear structures in the default store
 
      CALL ZTESTQ
 
C--     Build fanout structures in a secondary store
 
      CALL ZTESTG
 
C--     Describe a few complicated I/O characteristics with MZFORM
 
      CALL ZTESTA
 
C--     Use the structures built up to now, and write and read them
 
      CALL ZTESTF
 
C--     Print the end of run statistics
 
      CALL MZEND
 
      END
\end{verbatim}
\end{figure}
%??.pa>
\section{Linear structures}
\subsection{Building a data structure with vertices and tracks}
\par
In example ZTESTQ a structure similar to the one in section ``Using data
structures' in chapter 1 is built.
To simplify matters only default
settings for the ZEBRA routine parameters are used. Since the store in
ZTESTQ is the first one declared its store index is 0 and its default
divisions will have indices 1 and 2. Not specifying the division index
to MZLIFT will create all banks in the present example in division 2.
\par After creation of the ``mother' bank at LEV, a double DO loop creates
first 3 VX (vertex) banks
as down banks, and then attaches respectively 3, 2 and 2 TK
(track) banks to the VX banks as downs. All VX banks and the TK banks
connected to a given vertex
are grouped together in a linear structure.
The data part of each bank is filled with information of a type specified
in the calls to MZFORM.
\par At the end of the routine
the complete tree of the EV data structure is printed,
followed by a map of division 2. Finally a detailed verification
of the same division is made.
\begin{figure}\label{ZEBEXA1 PLACE=INLINE>
\caption{Example of the creation of a linear structure in the default store}
\begin{verbatim}
      SUBROUTINE ZTESTQ
 
      COMMON//IFENCE(2),LEV,BLVECT(10000)
      DIMENSION LQ(999),IQ(999)
      DIMENSION  Q(999)
      EQUIVALENCE (IQ(1),Q(1),LQ(9)),(LQ(1),LEV)
 
      DIMENSION MMEV(5),MMTK(5),MMVX(5)
      DIMENSION NTK(3)
 
      DATA MMEV/4HEV  ,7,7,10,0/
      DATA MMTK/4HTK  ,0,0,15,3/
      DATA MMVX/4HVX  ,1,1,12,0/
 
      DATA NTK/3,2,2/ , NVX/3/
 
C--     Initialize store in blank common //
 
      CALL MZSTOR(IXBLST,'//',' ',IFENCE,LEV,BLVECT(1),BLVECT(1),
     X            BLVECT(2000),BLVECT(10000)                )
 
C--     Create a structure in the default division (2)
 
      CALL MZFORM('EV  ','3H 3I -F',MMEV(5))
      CALL MZFORM('VX  ','3I -F',MMVX(5))
 
      CALL MZLIFT(0,LEV,LEV,1,MMEV,0)
 
      IQ(LEV+1) = MMEV(1)
      IQ(LEV+2) = MMTK(1)
      IQ(LEV+3) = MMVX(1)
      DO 1 I=4,6
    1 IQ(LEV+I) = I
      DO 2 I=7,MMEV(4)
    2 Q(LEV+I) = FLOAT(I)
 
C--     Create the vertex (VX) banks
 
      DO 20 IVX=1,NVX
          CALL MZLIFT(0,LVX,LEV,-1,MMVX,0)
          DO 7 I=1,3
    7     IQ(LVX+I) = 10*IVX+I
          DO 8 I=4,MMVX(4)
    8     Q(LVX+I) = FLOAT(10*IVX+I)
 
C--     Create the track (TK) banks associated to a given VX bank
 
          DO 10 ITK=1,NTK(IVX)
              CALL MZLIFT(0,LTK,LVX,-1,MMTK,0)
              DO 9 I=1,MMTK(4)
    9         Q(LTK+I) = FLOAT(100*ITK+10*IVX+I)
              JB  = 0
   10     CONTINUE
   20     CONTINUE
 
C--     Print the complete structure and the store, then verify complete
 
      CALL DZSHOW('Dump EV structure',0,LEV,'BDLV',0,0,0,0)
      CALL DZSHOW('Dump EV structure',0,LEV,'BSLV',0,0,0,0)
      CALL DZSTOR('Dump of store //',0)
      CALL DZSURV('Survey of the EV data structure',0,LEV)
      CALL DZSNAP('Snap of //',2,'M')
      CALL DZVERI('Verify default division in //',2,'CFLSU')
 
      END
\end{verbatim}
\begin{verbatim}
 MZSTOR.  ZEBRA table base TAB(0) in /MZCC/ at adr      130537    0001FDE9 HEX
 MZSTOR.  Initialize Store  0  in //
          with Store/Table at absolute adrs      100007      130537
                                        HEX    000186A7    0001FDE9
                                        HEX    FFFF89AA    00000000
                              relative adrs      -30294           0
          with     1 Str. in     1 Links in   2001 Low words in   10001 words.
          This store has a fence of    2 words.
 DZSHOW --- Dump EV structure                                                                       OPTIONS : BDLV
 DZSHOW  +++++ LEVEL     0 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  EV  .     1     9580(QDIV2   ) SY/US/IO 0001/00000/2153 NL/NS/ND    7/    7/      10 N/U/O/@O       0/       0/       1/    9580
 STRUCTURAL links               ********************************************************************************************************************************************************************************************************************************
***************************************************************************************************************************************************************************************************************************************************************
********************************* 6     8     8.0000000        10     10.000000
 DZSHOW  +++++ LEVEL     1 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  VX  .     3     9379(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9452/    9580/    9579/    9379
 STRUCTURAL links                                          --------------------
           1    TK        9328
 DATA part of bank                                         --------------------
 DATA      1                31     4     34.000000         7     37.000000        10     40.000000
           2                32     5     35.000000         8     38.000000        11     41.000000
           3                33     6     36.000000         9     39.000000        12     42.000000
 DZSHOW  +++++ LEVEL     2 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  TK  .     2     9328(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9353/    9379/    9378/    9328
 DATA part of bank                                         --------------------
 DATA      1     231.00000         4     234.00000         7     237.00000        10     240.00000        13     243.00000
           2     232.00000         5     235.00000         8     238.00000        11     241.00000        14     244.00000
           3     233.00000         6     236.00000         9     239.00000        12     242.00000        15     245.00000
  TK  .     1     9353(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9379/    9328/    9353
 DATA part of bank                                         --------------------
 DATA      1     131.00000         4     134.00000         7     137.00000        10     140.00000        13     143.00000
           2     132.00000         5     135.00000         8     138.00000        11     141.00000        14     144.00000
           3     133.00000         6     136.00000         9     139.00000        12     142.00000        15     145.00000
 DZSHOW  +++++ LEVEL     1 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  VX  .     2     9452(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9550/    9580/    9379/    9452
 STRUCTURAL links                                          --------------------
           1    TK        9401
 DATA part of bank                                         --------------------
 DATA      1                21     4     24.000000         7     27.000000        10     30.000000
           2                22     5     25.000000         8     28.000000        11     31.000000
           3                23     6     26.000000         9     29.000000        12     32.000000
 DZSHOW  +++++ LEVEL     2 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  TK  .     2     9401(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9426/    9452/    9451/    9401
 DATA part of bank                                         --------------------
 DATA      1     221.00000         4     224.00000         7     227.00000        10     230.00000        13     233.00000
           2     222.00000         5     225.00000         8     228.00000        11     231.00000        14     234.00000
           3     223.00000         6     226.00000         9     229.00000        12     232.00000        15     235.00000
  TK  .     1     9426(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9452/    9401/    9426
 DATA part of bank                                         --------------------
 DATA      1     121.00000         4     124.00000         7     127.00000        10     130.00000        13     133.00000
           2     122.00000         5     125.00000         8     128.00000        11     131.00000        14     134.00000
           3     123.00000         6     126.00000         9     129.00000        12     132.00000        15     135.00000
 DZSHOW  +++++ LEVEL     1 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  VX  .     1     9550(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O       0/    9580/    9452/    9550
 STRUCTURAL links                                          --------------------
           1    TK        9474
 DATA part of bank                                         --------------------
 DATA      1                11     4     14.000000         7     17.000000        10     20.000000
           2                12     5     15.000000         8     18.000000        11     21.000000
           3                13     6     16.000000         9     19.000000        12     22.000000
 DZSHOW  +++++ LEVEL     2 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  TK  .     3     9474(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9499/    9550/    9549/    9474
 DATA part of bank                                         --------------------
 DATA      1     311.00000         4     314.00000         7     317.00000        10     320.00000        13     323.00000
           2     312.00000         5     315.00000         8     318.00000        11     321.00000        14     324.00000
           3     313.00000         6     316.00000         9     319.00000        12     322.00000        15     325.00000
  TK  .     2     9499(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9524/    9550/    9474/    9499
 DATA part of bank                                         --------------------
 DATA      1     211.00000         4     214.00000         7     217.00000        10     220.00000        13     223.00000
           2     212.00000         5     215.00000         8     218.00000        11     221.00000        14     224.00000
           3     213.00000         6     216.00000         9     219.00000        12     222.00000        15     225.00000
  TK  .     1     9524(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9550/    9499/    9524
 DATA part of bank                                         --------------------
 DATA      1     111.00000         4     114.00000         7     117.00000        10     120.00000        13     123.00000
           2     112.00000         5     115.00000         8     118.00000        11     121.00000        14     124.00000
           3     113.00000         6     116.00000         9     119.00000        12     122.00000        15     125.00000
 DZSHOW --- Dump EV structure                                                                       OPTIONS : BSLV
 DZSHOW  +++++ LEVEL     0 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  EV  .     1     9580(QDIV2   ) SY/US/IO 0001/00000/2153 NL/NS/ND    7/    7/      10 N/U/O/@O       0/       0/       1/    9580
 --------  LINK part of bank  --------
       1 /        9379           0           0           0           0           0           0
 --------  DATA part of bank  --------
       1 /        "EV          "TK          "VX             4           5           6   7.000       8.000       9.000       10.00
 DZSHOW  +++++ LEVEL     1 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  VX  .     3     9379(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9452/    9580/    9579/    9379
 --------  LINK part of bank  --------
       1 /        9328
 --------  DATA part of bank  --------
       1 /          31          32          33   34.00       35.00       36.00       37.00       38.00       39.00       40.00
      11 /   41.00       42.00
 DZSHOW  +++++ LEVEL     2 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  TK  .     2     9328(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9353/    9379/    9378/    9328
 --------  DATA part of bank  --------
       1 /   231.0       232.0       233.0       234.0       235.0       236.0       237.0       238.0       239.0       240.0
      11 /   241.0       242.0       243.0       244.0       245.0
  TK  .     1     9353(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9379/    9328/    9353
 --------  DATA part of bank  --------
       1 /   131.0       132.0       133.0       134.0       135.0       136.0       137.0       138.0       139.0       140.0
      11 /   141.0       142.0       143.0       144.0       145.0
 DZSHOW  +++++ LEVEL     1 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  VX  .     2     9452(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9550/    9580/    9379/    9452
 --------  LINK part of bank  --------
       1 /        9401
 --------  DATA part of bank  --------
       1 /          21          22          23   24.00       25.00       26.00       27.00       28.00       29.00       30.00
      11 /   31.00       32.00
 DZSHOW  +++++ LEVEL     2 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  TK  .     2     9401(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9426/    9452/    9451/    9401
 --------  DATA part of bank  --------
       1 /   221.0       222.0       223.0       224.0       225.0       226.0       227.0       228.0       229.0       230.0
      11 /   231.0       232.0       233.0       234.0       235.0
  TK  .     1     9426(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9452/    9401/    9426
 --------  DATA part of bank  --------
       1 /   121.0       122.0       123.0       124.0       125.0       126.0       127.0       128.0       129.0       130.0
      11 /   131.0       132.0       133.0       134.0       135.0
 DZSHOW  +++++ LEVEL     1 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  VX  .     1     9550(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O       0/    9580/    9452/    9550
 --------  LINK part of bank  --------
       1 /        9474
 --------  DATA part of bank  --------
       1 /          11          12          13   14.00       15.00       16.00       17.00       18.00       19.00       20.00
      11 /   21.00       22.00
 DZSHOW  +++++ LEVEL     2 ++++++++++            Store  //       at absolute address 00061AA0      ++++++++++
  TK  .     3     9474(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9499/    9550/    9549/    9474
 --------  DATA part of bank  --------
       1 /   311.0       312.0       313.0       314.0       315.0       316.0       317.0       318.0       319.0       320.0
      11 /   321.0       322.0       323.0       324.0       325.0
  TK  .     2     9499(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9524/    9550/    9474/    9499
 --------  DATA part of bank  --------
       1 /   211.0       212.0       213.0       214.0       215.0       216.0       217.0       218.0       219.0       220.0
      11 /   221.0       222.0       223.0       224.0       225.0
  TK  .     1     9524(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9550/    9499/    9524
 --------  DATA part of bank  --------
       1 /   111.0       112.0       113.0       114.0       115.0       116.0       117.0       118.0       119.0       120.0
      11 /   121.0       122.0       123.0       124.0       125.0
 DZSTOR --- Dump of store //
  --- Store Parameters ---
 Id    Name    Abs.addr.  Length   Fence      NS      NL      WS  Min.Resv.  Act.Resv.   Min(1+2)   Low  High
  0  //        00061AA0     9998       2       1       0       0        164       9325       2000     2     0
  --- Division parameters ---
    DIVISION    START    END       MAX    KIND   MODE  WIPES  GARB.  GARB. PUSHES      LIVE BANKS  DROPPED BANKS    BANKS TOTAL
  NB.   NAME   ADDRESS ADDRESS  LENGTH                        SYST.   FREE         NUMB.   LENGTH NUMB.   LENGTH NUMB.   LENGTH
 ==============================================================================================================================
   1  QDIV1          2       1       0 U/EVENT  FORWD      0      0      0      0       0        0     0        0     0        0
   2  QDIV2       9327    9598       0 U/EVENT  REVRS      0      0      0      0      11      272     0        0    11      272
  20  QDIVSYST    9750    9998       0  SYSTEM  REVRS      0      0      0      0       6      249     0        0     6      249
  --- Link area parameters ---
 QWSP     PERMANENT LIST AREA      is at absolute 00061AA0 NL/NS     1    1     status   ACTIVE
 QLASYST  PERMANENT LIST AREA      is at absolute 0007F7E8 NL/NS    20   10     status   ACTIVE
 DZSURV --- Survey of the EV data structure                                                         ST= //        LSTART=     9580
   NWCUM     NW   WBK  NBK    IDENTIFIER(S)
      27     27    27    1     EV
      96     69    23    3       -1 VX
     271    175    25    7            -1 TK
 
  DZSURV --- The structure supported by bank EV   at       9580 in store //       occupies        271 words in     11 banks
  DZSNAP --- Snap of //                                                                              OPTIONS : M
   NAME       LQSTOR NQSTRU  NQREF NQLINK LQMINR LQ2END JQDVLL JQDVSY NQFEND  LOW-1  LOW-N HIGH-1 HIGH-N SYST-1 SYST-N    END
  //      (00061AA0)      1      1      1    164   2001      2     20      2      2      1   9327   9598   9750   9998   9998
 DZSNAP.   -----  Store nb. 0 = //       Division nb. 2 = QDIV2                       --------------------
  TK  .     2     9328(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9353/    9379/    9378/    9328
  TK  .     1     9353(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9379/    9328/    9353
  VX  .     3     9379(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9452/    9580/    9579/    9379
      . LINKS    9328
  TK  .     2     9401(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9426/    9452/    9451/    9401
  TK  .     1     9426(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9452/    9401/    9426
  VX  .     2     9452(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O    9550/    9580/    9379/    9452
      . LINKS    9401
  TK  .     3     9474(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9499/    9550/    9549/    9474
  TK  .     2     9499(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O    9524/    9550/    9474/    9499
  TK  .     1     9524(QDIV2   ) SY/US/IO 0000/00000/0003 NL/NS/ND    0/    0/      15 N/U/O/@O       0/    9550/    9499/    9524
  VX  .     1     9550(QDIV2   ) SY/US/IO 0000/00000/01A3 NL/NS/ND    1/    1/      12 N/U/O/@O       0/    9580/    9452/    9550
      . LINKS    9474
  EV  .     1     9580(QDIV2   ) SY/US/IO 0001/00000/2153 NL/NS/ND    7/    7/      10 N/U/O/@O       0/       0/       1/    9580
      . LINKS    9379
 
  DZVERI --- Verify default division in //                                                           OPTIONS : CFLSU          OK
\end{verbatim}
\end{figure}
\theindex
\end{document}
