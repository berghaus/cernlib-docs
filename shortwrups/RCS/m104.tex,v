head	1.2;
access;
symbols;
locks;


1.2
date	95.02.28.08.32.21;	author goossens;	state Exp;
branches;
next	1.1;

1.1
date	94.04.02.16.46.54;	author goossens;	state Exp;
branches;
next	;


desc
@Initial entry
@


1.2
log
@ Version of Feb. 28th
@
text
@%  20 feb 1995  ksk
\Version {SORCHA}              \Routid{M104}
\Keywords{ARRAY CHARACTER SORT IN-SITU ITSELF}
\Author{H. Renshall}          \Library{KERNLIB}
\Submitter{}                     \Submitted{27.11.1984}
\Language{Fortran}  %\Revised{}
\Cernhead {Sort One-Dimensional Character Array into Itself}
{\tt SORCHA} does a slow linear sort of a type {\tt CHARACTER} array
into itself in
either ascending or descending order. The sort is done on any user
specified substring of the elements in a {\tt CHARACTER} array.
\Structure
{\tt SUBROUTINE} subprogram \\
User Entry Names: \Rdef{SORCHA}
\Usage
\begin{verbatim}
    CALL SORCHA(A,ICH1,ICH2,NPOINT,ITYPE)
\end{verbatim}
\begin{DLtt}{12345678}
\item [A] ({\tt CHARACTER}) One-dimensional array of dimension
{\tt NPOINT} to be sorted into itself. The maximum length of the
elements in {\tt A} is 256 characters.
\item [ICH1] ({\tt INTEGER}) Variable or constant giving the first
character position in each element of {\tt A} of the substring upon which
the array shall be sorted. {\tt ICH1} should be 1 if the whole length of
the elements of {\tt A} is to be used.
\item [ICH2] ({\tt INTEGER}) Variable or constant giving the last
character position analogously to {\tt ICH1} above. {\tt ICH2} should
be equal to the length of the elements of {\tt A} if the sort should be
on the entire length of the elements of {\tt A}.
\item [NPOINT]({\tt INTEGER}) Variable or constant. The first
{\tt NPOINT} elements of {\tt A} will be sorted.
\item [ITYPE] ({\tt INTEGER}) Variable or constant controlling the type
of the sort. It is possible to sort in ascending or descending order;
in addition it is possible to use either the Fortran collation
sequence ordering via the {\tt LLE} and {\tt LGE} functions, or the
machine internal relational sequence ordering via the {\tt LE} and
{\tt GE} relations (see {\bf Notes}). \\
$\mathtt{= 1:}$ Ascending sort, i.e. {\tt A(1)} will be lower than
{\tt A(2)}, using collation sequence. \\
$\mathtt{= 2:}$ Descending sort, i.e. {\tt A(2)} will be lower than
{\tt A(1)}, using collation sequence. \\
$\mathtt{= 3:}$ Ascending sort, i.e. {\tt A(1)} will be lower than
{\tt A(2)}, using relational sequence. \\
$\mathtt{= 4:}$ Descending sort, i.e. {\tt A(2)} will be lower than
{\tt A(1)}, using relational sequence.
\end{DLtt}
\Notes
On the  machines and compilers tested
(CDC with {\tt FTN5}, VAX VMS with Fortran, ND500 with
{\tt FORT-5}, IBM with VS-Fortran and Siemens compilers)
the collating sequence orders are the same and give blank less than
numbers and numbers less than letters (this matches the {\tt ASCII}
internal representations).
\par
On IBM with both compilers the relational sorts give blank less
than letters and letters less than numbers (the {\tt EBCDIC} sequence).
\par
On CDC, VAX and ND500 collation and relational orders are the same.
\par
On all machines the relational sort is faster than the collation
sequence sort.
\\ $\bullet$
@


1.1
log
@Initial revision
@
text
@d1 1
d6 1
a6 1
\Language{CDC: Compass, IBM: Fortran}  %\Revised{}
@
