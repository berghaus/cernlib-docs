% 27 May mg
\Version {BITBYT}                   \Routid{M421}
\Keywords{MANIPULATION HANDLING BIT BYTE}
\Author{C. Letertre, J. Zoll}       \Library{KERNLIB}
\Submitter{}                        \Submitted{28.01.1971}
\Language{Fortran or Assembler}     \Revised{12.06.1987}
\Cernhead{Package for Handling Bits and Bytes}
This package manipulates individual bits and bytes in a word.
\par
A {\it bit} in a word is specified by giving its position {\tt J}
\texttt{(=1,2,\ldots,32[,\ldots,64])} in the word,
bit {\tt 1} being the least significant bit.
\par
A {\it byte} in a word is a group of {\tt NBITS} consecutive bits.
The byte is specified by giving {\tt NBITS} and the bit position {\tt J}
of the least significant bit of the byte.
\Structure
{\tt SUBROUTINE} and {\tt FUNCTION} subprograms \\
User Entry Names:
\begin{htmlonly}
\begin{tabular}{lllllll}
\end{htmlonly}
%begin{latexonly}
\begin{tabular}[t]{l*{7}{@{\hspace{4pt}}l}}
%end{latexonly}
\Rdef{JBIT},   & \Rdef{SBIT0},  & \Rdef{SBIT1},  & \Rdef{SBIT},   &
\Rdef{MSBIT0}, & \Rdef{MSBIT1}, & \Rdef{MSBIT},  \\
\Rdef{JBYT},   & \Rdef{SBYT},   & \Rdef{MSBYT},  & \Rdef{CBYT},   &
\Rdef{MCBYT},  & \Rdef{JBYTET}, & \Rdef{JBYTOR}, \\
\Rdef{SBYTOR}, & \Rdef{MBYTOR}, & \Rdef{MBYTET}, & \Rdef{JRSBYT}
\end{tabular}
\Usage
\begin{htmlonly}
\begin{tabular}{ll}
\end{htmlonly}
%begin{latexonly}
\begin{tabular}{@{\hspace*{3mm}}ll}
%end{latexonly}
{\tt IX = JBIT(IW,J)}
& returns \texttt{IX=0} or \texttt{1}, the value of bit {\tt J} in
{\tt IW}.\\
{\tt CALL SBIT0(IX,J)}
& sets {\tt 0} into bit {\tt J} of {\tt IX}.\\
{\tt CALL SBIT1(IX,J)}
& sets {\tt 1} into bit {\tt J} of {\tt IX}.\\
{\tt CALL SBIT(IA,IX,J)}
& copies bit {\tt 1} of {\tt IA} into bit {\tt J} of {\tt IX}.\\
{\tt IX = MSBIT0(IW,J)}
& returns {\tt IW} in {\tt IX} with bit {\tt J} set to {\tt 0}.\\
{\tt IX = MSBIT1(IW,J)}
& returns {\tt IW} in {\tt IX} with bit {\tt J} set to {\tt 1}.\\
{\tt IX = MSBIT(IA,IW,J)}
& returns {\tt IW} in {\tt IX} with bit {\tt J} set to the value of bit
{\tt 1} in {\tt IA}. \\
{\tt IX = JBYT(IW,J,NBITS)}
& returns in {\tt IX} right-justified the byte at {\tt J} in {\tt IW}.\\
{\tt CALL SBYT(IA,IX,J,NBITS)}
& copies the byte at {\tt 1} of {\tt IA} into the byte at {\tt J} of
{\tt IX}. \\
{\tt IX = MSBYT(IA,IW,J,NBITS)}
& returns {\tt IW} in {\tt IX} with the byte at {\tt J} replaced by the
byte at \\
& {\tt 1} of {\tt IA}. \\
{\tt CALL CBYT(IA,JA,IX,J,NBITS)}
& copies the byte at {\tt JA} of {\tt IA} into the byte at {\tt J} of
{\tt IX}. \\
{\tt IX = MCBYT(IA,JA,IW,J,NBITS)}
& returns {\tt IW} in {\tt IX} with the byte at {\tt J} replaced by the
byte at \\
& {\tt JA} of {\tt IA}. \\
{\tt IX = JBYTET(IA,IW,J,NBITS)}
& returns in {\tt IX} the logical {\tt AND} of {\tt IA} and the byte at
{\tt J} of {\tt IW} \\
& right-justified. \\
{\tt IX = JBYTOR(IA,IW,J,NBITS)}
& returns in {\tt IX} the logical {\tt OR} of {\tt IA} and the byte at
{\tt J} of {\tt IW} \\
& right-justified. \\
{\tt CALL SBYTOR(IA,IX,J,NBITS)}
& replaces the byte at {\tt J} in {\tt IX} by the logical {\tt OR} of
this byte \\
& and the byte at {\tt 1} of {\tt IA}. \\
{\tt IX = MBYTOR(IA,IW,J,NBITS}
& returns {\tt IW} in {\tt IX} with the byte at {\tt J} replaced by the
logical \\
& {\tt OR} of this byte and the byte at {\tt 1} of {\tt IA}. \\
{\tt IX = MBYTET(IA,IW,J,NBITS)}
& returns {\tt IW} in {\tt IX} with the byte at {\tt J} replaced by the
logical \\
& {\tt AND} of this byte and the byte at {\tt 1} of {\tt IA}. \\
{\tt IY = JRSBYT(IA,IX,J,NBITS)}
& read and reset byte; equivalent to \\
& {\tt IY = JBYT(IX,J,NBITS)} \\
& {\tt CALL SBYT(IA,IX,J,NBITS)}. \\
\end{tabular}
%\Rdef{BLAAAAAAAAAAAAA}
\Notes
The subroutines
\begin{verbatim}
SBIT0   SBIT1   SBIT    SBYT    CBYT   SBYTOR
\end{verbatim}
are duplicated by the functions
\begin{verbatim}
MSBIT0  MSBIT1  MSBIT   MSBYT   MCBYT   MBYTOR
\end{verbatim}
to allow implementation by statement functions.
Such implementations can be picked up from the ZEBRA CDE Pam-file for
different machines as sequence definitions
\begin{verbatim}
Q$JBIT    :   JBIT,   JBYT
Q$SBIT    :   MSBIT0, MSBIT1, MSBIT
Q$SBYT    :   MSBYT
Q$CBYT    :   MCBYT
Q$JBYTET  :   JBYTET, JBYTOR, MBYTET, MBYTOR
\end{verbatim}
$\bullet$
