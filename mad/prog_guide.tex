% -*- LaTeX -*-

\documentstyle[11pt,bezier,twoside,a4p,makeidx]{report}

\def\documentlabel#1{\gdef\@documentlabel{#1}}
\makeindex
\gdef\@documentlabel{\tt Preliminary draft}

\documentlabel{CERN/SL/93-?? (AP)}

%==============================================================================
 
% Allow large floats to be interspersed with the text
\renewcommand{\topfraction}{1.}
\renewcommand{\bottomfraction}{1.}
\renewcommand{\textfraction}{0.05}
\setcounter{topnumber}{10}
\setcounter{bottomnumber}{10}
\setcounter{totalnumber}{20}
 
\def\histor{{\sl Historian$^{Plus}$}} \def\bigbra{$\smash{\Bigg\}}$}
 
\pagestyle{headings}
 
% heading for the \chapter command.
\makeatletter
\def\@makechapterhead#1{{
   \parindent 0pt\raggedright\LARGE \bf
   \ifnum \c@secnumdepth >\m@ne
      \@chapapp{} \thechapter.\ \ \fi
   #1\par\nobreak\vskip 20pt
}}
 
% heading for the \chapter* command.
\def\@makeschapterhead#1{{
   \parindent 0pt\raggedright\LARGE \bf
   #1\par\nobreak\vskip 20pt
}}
 
% titles for the lists of figures and tables:
\def\listoffigures{
   \section*{List of Figures}
   \@starttoc{lof}
}
\def\listoftables{
   \section*{List of Tables}
   \@starttoc{lot}
}
 
\makeatother
 
% description lists:
\def\mylist{\list{}{
   \setlength{\labelwidth}{2.3cm}
   \setlength{\leftmargin}{2.5cm}
   \let\makelabel\mylabel}
}
 
\let\endmylist\endlist
 
\def\mylabel#1{#1\hfill}
 
% automatic indexing of keywords:
\def\emindex#1{{\em #1\/}\index{#1}}
\def\emitem#1{\item[{\em #1}]}
\def\bfitem#1{\item[{\bf #1}]}
\def\ttitem#1{\item[{\tt #1}]\index{#1@{\tt #1}}}
\def\ttindex#1{{\tt #1}\index{#1@{\tt #1}}}
\def\ttnindex#1{\index{#1@{\tt #1}}}
 
% MAD command specifications:
\newcommand{\mybox}[1]{
   \begin{quote}
      \tt
      \fbox{
         \begin{minipage}{0.95\textwidth}
            \begin{tabbing}
               #1
            \end{tabbing}
         \end{minipage}
      }
   \end{quote}
}
 
% MAD command examples:
\newcommand{\myxmp}[1]{
   \begin{quote}
      \tt
      \begin{tabbing}
         #1
      \end{tabbing}
   \end{quote}
}

% Some Mathematical Symbols and Operators
\def\ad{{\sl Ad\/}}
\def\adphsp{$\{{:}f{:}\}$}
\def\eqdef{\stackrel{def}{=}}
\def\gappeq{\stackrel{>}{\approx}}
\def\lieop#1{{:}{#1}{:}}
\def\lieseries#1{\sum_{n=0}^{\infty} e^{{:}{#1_{n}}{:}}}
\def\lieseriesN#1{\sum_{n=0}^{N} e^{{:}{#1_{n}}{:}}}
\def\lietran#1{e^{{:}{#1}{:}}}
\def\map#1{$\cal #1$}
\def\numclass#1{{\rm \bf #1}}
\def\order{{\sl order}}
\def\phsp{\{Z\}}
\def\pbkt#1#2{\sum_{k=1}^3\left(
  {\partial #1\over\partial q_k}{\partial #2\over\partial p_k} -
  {\partial #1\over\partial p_k}{\partial #2\over\partial q_k}
\right)}

\def\[#1\]{$$\leftline{\indent$\displaystyle{#1}$}$$}

%==============================================================================

\begin{document}
\setlength{\evensidemargin}{\oddsidemargin}

\begin{titlepage}
\begin{center}\normalsize
EUROPEAN ORGANIZATION FOR NUCLEAR RESEARCH
\end{center}
\vskip 0.7cm
\begin{flushright}
\@documentlabel                      % document label
\end{flushright}
\vskip 2.3cm
\begin{center}\LARGE                 % document title
{\bf The MAD Program}\\
(Methodical Accelerator Design)\\
Version 8.10\\
{\bf Programmer's Reference Manual}
\end{center}
\vskip 1.5em
\begin{center}                       % authors
Hans Grote\\
F. Christoph Iselin
\vskip 2em
{\large \bf Abstract}
\end{center}
\begin{quotation}
MAD is a tool for charged-particle optics in
alternating-gradient accelerators and beam lines.
It can handle from very large to very small accelerators,
and solve various problems on such machines.
 
This document outlines the data structures used in MAD.
It intends to help programmers to add new features to the program.
\end{quotation}
\vfill
\begin{center}
Geneva, Switzerland\\
\today
\end{center}
\end{titlepage}

\begin{center}
The MAD program contains the following copyright note:
\end{center}
\vspace{1em}
\framebox[\textwidth]{
\begin{minipage}{0.97\textwidth}\tt
\vspace{1em}
\begin{center}
CERN\\
\vspace{1em}
EUROPEAN ORGANIZATION FOR NUCLEAR RESEARCH
\end{center}
\vspace{1em}
\begin{tabular}{ll}
Program name: &MAD --- Methodical Accelerator Design\\
\\
CERN program library entry:&T5001\\
\\
Authors or contacts:&Hans Grote, F. Christoph Iselin\\
                    &SL Division\\
                    &CERN\\
                    &CH-1211 GENEVA 23\\
                    &SWITZERLAND\\
                    &Tel. [0041] (022) 767 36 57\\
                    &FCI at CERNVM.BITNET\\
\end{tabular}
\vspace{1em}
\begin{raggedright}\par
Copyright CERN, Geneva 1990 - Copyright and any other
appropriate legal protection of this computer program and
associated documentation reserved in all countries of the
world.
\vspace{1cm}\par
Organizations collaborating with CERN
may receive this program and
documentation freely and without charge.
\vspace{1cm}\par
CERN undertakes no obligation for the maintenance of this
program, nor responsibility for its correctness,
and accepts no liability whatsoever resulting from its use.
\vspace{1cm}\par
Program and documentation are provided solely for the use of
the organization to which they are distributed.
\vspace{1cm}\par
This program may not be copied or otherwise distributed
without permission. This message must be retained on this and
any other authorized copies.
\vspace{1cm}\par
The material cannot be sold. CERN should be given credit in
all references.
\end{raggedright}
\vfill
\end{minipage}}
\clearpage

%==============================================================================

\chapter*{Preface}
 
The MAD framework should make it easy to add new features
in the form of program modules.
The authors of MAD hope that such modules will also be contributed
and documented by others.
The contributions of other authors are acknowledged in the relevant
chapters.
 
Misprints and obscurity are almost inevitable in a manual
of this size.
Comments from readers are therefore most welcome.
They may also be sent to one of the following BITNET addresses:
\begin{verbatim}
FCI   at CERNVM.CERN.CH.bitnet
HANSG at CERNVM.CERN.CH.bitnet
KEIL  at CERNVM.CERN.CH.bitnet
\end{verbatim}

%==============================================================================

\cleardoublepage
\tableofcontents
\listoffigures
\listoftables
\cleardoublepage
\pagenumbering{arabic}

%==============================================================================

\part{Introduction}

%==============================================================================

\chapter{A Short Introduction to ZEBRA}
\index{ZEBRA}
\section{Why Use ZEBRA?}
\index{FORTRAN 77}
For various reasons MAD \cite{MAD} is written in the FORTRAN 77 language.
While this language offers certain advantages,
it suffers from its lack of dynamic data structuring facilities.
\index{dynamic!data structure}
The only data structures available are arrays of fixed length,
and common blocks for shared data.
There is no standard way for allocating arrays dynamically or to
\index{dynamic!allocation}
change their length at run time.
 
To overcome this defect, the ZEBRA system \cite{ZEBRA}
has been designed and written at CERN.
It allows the management of large amounts of data in a computer
by providing the functions required to construct a logical graph
of the data and their interrelations.
The data are stored in FORTRAN common blocks, called {\em stores}.
\index{store}
Each store can be subdivided into up to 20 {\em divisions}.
\index{division}
Relations between the basic units of data, or {\em banks},
\index{bank}
are expressed by linking banks to form more complex structures.
A bank is accessed by specifying its address in a given store.
Such addresses (called {\em links}\index{link}) are kept inside the
banks or in {\em link areas} inside common blocks.
\index{link!area}
 
\begin{itemize}
\item
The memory management part of ZEBRA is handled by the \ttindex{MZ} package.
Utilities are available for allocating, reorganizing,
sorting and deleting banks and data structures.
\item
Individual banks, data structures or complete divisions
can be output with the \ttindex{FZ} package.
\item
Direct access files for data structures and the management
of the data by keywords are provided by the \ttindex{RZ} package.
This part of ZEBRA is presently not used in MAD.
\item
Dumps and verification of ZEBRA structures and documentation tools
are available in the \ttindex{DZ} package.
\end{itemize}
The following sections give a short introduction to the details
of ZEBRA which are required for understanding MAD's data structure.
 
\section{Logical Data Structures}
\subsection{The Bank}
\index{bank}
\index{data!bank}
Assume that we wish to store the data related to a given
\emindex{object}, say an element (magnet) definition, containing
details about its {\em attributes}\index{attribute}
(length, strength, etc.).
Using a call to the ZEBRA routine \ttindex{MZBOOK},
we can allocate a contiguous area of storage with a given length.
The location of this area is returned by \ttindex{MZBOOK} as a
\emindex{base address} which has to be used in any \emindex{reference}
\index{bank!address}                       
\index{address}
to that area.
The unit of storage is called a \emindex{bank},
and in FORTRAN code it will be referenced as in
\myxmp{
Q(L+MELEN), Q(L+MEK1Q), ...
}
where \ttindex{Q}, by convention, is the name of the FORTRAN array
underlying the data store,
and \ttindex{L} is the base address, provided by \ttindex{MZBOOK}.
It is the index into the store of the word preceding
the first data word of the bank.
 
ZEBRA banks may contain data of different types.
Thus we can address other data words in the bank
for example as integers:
\myxmp{
IQ(L+MBAT), IQ(L+MBSP)
}
For structuring purposes ZEBRA requires no knowledge of the
actual contents of a bank.
The internal details of data in a bank are the responsibility
of the user,
and it is vital to maintain an adequate documentation of the
bank contents.
However,
for input and output ZEBRA has to know the type of the bank contents.
For this purpose it uses {\em format codes}\index{format code},
explained later.
 
\subsection{The Linear Structure}
\index{linear structure}
\index{linked list}
The number of element definitions in MAD is variable and may
be very large.
To realize sets of objects of the same kind,
MAD uses the ZEBRA construct of a \emindex{linear structure}.
A linear structure consists of a series of linked banks,
with each bank holding a reserved system word,
called the \emindex{next link},
i.~e. the base address of the next bank in the set.
The next link of the last bank in a linear structure is zero,
indicating that there is no next bank.
The {\em address of a linear structure}
\index{address!of a linear structure} is simply the address of
its first bank.
 
A linear structure may be visualized as in Figure~\ref{Flins}.
Note that the first bank in the chain has been booked last.
\begin{figure}[ht]
\centering
\begin{picture}(300,20)
\setlength{\unitlength}{1pt}
\put(0,10){\vector(1,0){50}}
\put(50,0){\framebox(50,20){bank$_3$}}
\put(100,10){\vector(1,0){50}}
\put(125,15){\makebox(0,0)[b]{next}}
\put(150,0){\framebox(50,20){bank$_2$}}
\put(200,10){\vector(1,0){50}}
\put(225,15){\makebox(0,0)[b]{next}}
\put(250,0){\framebox(50,20){bank$_1$}}
\end{picture}
\caption{A Linear Structure containing Element Definitions}
\label{Flins}
\end{figure}
 
The next link is stored in the word {\tt LQ(LCELM)} of the bank,
with the vector \ttindex{LQ} displaced by {\tt EQUIVALENCE} with respect
to the vectors \ttindex{Q} and \ttindex{IQ}.
The elements of the set can then be accessed in their order by
a loop of the form:
\myxmp{
XXXXXX\=XXX\=\kill
      \>LCELM = LFIRST\\
10    \>IF (LCELM .NE. 0) THEN\\
      \>   \>...\\
      \>   \>GO TO 10\\
      \>ENDIF
}
 
Banks are connected dynamically at run time.
\index{dynamic!link}
Because each bank has one word set apart to connect it
to the rest of the structure,
an arbitrary number of objects can be linked to the set.
The order of the banks in the set may or may not have significance,
and the user is allowed to change it if required.
 
\subsection{The General Data Structure}
\index{data!structure}
In the general case, more complex structures are needed.
Often the address of a bank or of a linear structure is stored
in another bank.
It is then called a \emindex{down link}.
A given bank may have many down links,
and it can depend on a logically yet higher bank through
a down link in that bank.
The down links thus allow to construct a tree,
\index{tree}
and at each node there may be a single bank or a linear structure.
 
In MAD, for example, all command keywords form a linear structure that
depends on the bank describing the master keyword \ttindex{KEYWORD}.
All elements of a given type form a linear structure
that depends on the bank describing the corresponding
element keyword; it is shown schematically in Figure~\ref{Fgens}.
\begin{figure}[ht]
\centering
\setlength{\unitlength}{1pt}
\begin{picture}(440,140)(30,0)
\put(30,120){\framebox(80,20){\tt KEYWORD}}
\put(50,120){\vector(0,-1){40}}
\put(55,100){\makebox(0,0)[l]{down}}
\put(30,60){\framebox(40,20){key$_3$}}
\put(50,60){\vector(0,-1){40}}
\put(55,40){\makebox(0,0)[l]{down}}
\put(30,0){\framebox(40,20){el$_3$}}
\put(70,10){\vector(1,0){20}}
\put(80,15){\makebox(0,0){n}}
\put(90,0){\framebox(40,20){el$_2$}}
\put(130,10){\vector(1,0){20}}
\put(140,15){\makebox(0,0){n}}
\put(150,0){\framebox(40,20){el$_1$}}
\put(70,70){\vector(1,0){160}}
\put(150,75){\makebox(0,0)[b]{next}}
 
\put(230,60){\framebox(40,20){key$_2$}}
\put(250,60){\vector(0,-1){40}}
\put(255,40){\makebox(0,0)[l]{down}}
\put(230,0){\framebox(40,20){el$_2$}}
\put(270,10){\vector(1,0){20}}
\put(280,15){\makebox(0,0){n}}
\put(290,0){\framebox(40,20){el$_1$}}
\put(270,70){\vector(1,0){100}}
\put(320,75){\makebox(0,0)[b]{next}}
 
\put(370,60){\framebox(40,20){key$_1$}}
\put(390,60){\vector(0,-1){40}}
\put(395,40){\makebox(0,0)[l]{down}}
\put(370,0){\framebox(40,20){el$_2$}}
\put(410,10){\vector(1,0){20}}
\put(420,15){\makebox(0,0){n}}
\put(430,0){\framebox(40,20){el$_1$}}
\end{picture}
\caption{Example of a General Data Structure}
\index{data!structure}
\label{Fgens}
\end{figure}
 
All links described so far are stored by ZEBRA as part of the bank
concerned.
The down and next links are referred to collectively as
{\em structural links}\index{structural link},
as they represent the basic connections of the data structure.
 
\subsection{Reverse Links}
\index{reverse link}
Each ZEBRA bank contains a link pointing to the bank on which
the whole linear structure of which it is a member depends.
This link is called an \emindex{up link}.
The value of the up link is zero if the bank is at the top of
the tree structure.
The up link is useful for moving towards the root of the tree.
 
Each bank also has an \emindex{origin link}, which points to
the structural link supporting the bank.
The origin link is usually of no interest to the user,
its purpose is to free the user from having to remember the
supporting link.
 
The up link and the origin link are known as {\em reverse links}
\index{reverse link}.
A summary of the four types of links is given in Figure~\ref{Frevl}.
\begin{figure}[ht]
\centering
\setlength{\unitlength}{1pt}
\begin{picture}(450,80)
\put(0,60){\framebox(50,20){key$_1$}}
\put(10,60){\line(0,-1){55}}
\put(10,5){\vector(1,0){90}}
\put(5,40){\makebox(0,0)[r]{down}}
\put(100,15){\line(-1,0){70}}
\put(30,15){\vector(0,1){45}}
\put(35,40){\makebox(0,0)[l]{origin}}
\put(100,0){\framebox(50,20){el$_3$}}
\put(125,20){\line(0,1){45}}
\put(125,65){\vector(-1,0){75}}
\put(130,40){\makebox(0,0)[l]{up}}
\put(200,0){\makebox(0,0)[t]{next}}
\put(150,5){\vector(1,0){100}}
\put(250,15){\vector(-1,0){100}}
\put(200,20){\makebox(0,0)[b]{origin}}
\put(250,0){\framebox(50,20){el$_2$}}
\put(275,20){\line(0,1){50}}
\put(275,70){\vector(-1,0){225}}
\put(280,40){\makebox(0,0)[l]{up}}
\put(350,0){\makebox(0,0)[t]{next}}
\put(300,5){\vector(1,0){100}}
\put(400,15){\vector(-1,0){100}}
\put(350,20){\makebox(0,0)[b]{origin}}
\put(400,0){\framebox(50,20){el$_1$}}
\put(425,20){\line(0,1){55}}
\put(425,75){\vector(-1,0){375}}
\put(430,40){\makebox(0,0)[l]{up}}
\end{picture}
\caption{Schematic Overview of ZEBRA Links}
\label{Frevl}
\end{figure}
 
\subsection{Reference Links}
\index{reference!link}
The links described above are an integral part of the data structure.
ZEBRA also permits the program to establish links between various
banks which are not part of the structure,
but which may represent relations between banks.
\index{relation}
These links are known as {\em reference links}\index{reference!link}.
A bank may contain many reference links,
and their use is at the discretion of the user.
ZEBRA merely has the task to change their values in the case
that banks are moved in memory for whatever reason. 

Reference links, in contrast to the links mentioned so far,
may point to any place inside a bank and not only to its
{\em status word}\index{status!word} (see Figure~\ref{Fbank}).
 
\section{Physical Storage}
\label{Sstor}
The banks just described must be mapped onto the physical storage
of the computer.
In MAD a common block is declared for this purpose by the statements
\myxmp{
XXXXXX\=XXXXXXXXXXXXXXXXXX\=\kill
      \>PARAMETER         \>(MEMMIN = 100 000)\\
      \>PARAMETER         \>(MEMLEN = 500 000)\\
      \>COMMON /MEMORY/   \>FENCE, LQ(MWFLT*MEMLEN)\\
      \>SAVE              \>/MEMORY/\\
      \>INTEGER           \>IQ(MWFLT*MEMLEN)\\
      \>REAL              \>FENCE(2), Q(MWFLT*MEMLEN)\\
      \>DIMENSION         \>DQ(MEMLEN)\\
      \>EQUIVALENCE       \>(IQ(1), Q(1), DQ(1), LQ(9))\\
      \>EQUIVALENCE       \>(LROOT, LQ(1)), (LLUMP, LQ(2))
}
\ttnindex{MEMORY}
\ttnindex{MEMMIN}
\ttnindex{MEMLEN}
\ttnindex{FENCE}
\ttnindex{IQ}
\ttnindex{LQ}
\ttnindex{DQ}
\ttnindex{Q}
\ttnindex{LROOT}
\ttnindex{LLUMP}
\ttnindex{MWFLT}

It is made known to ZEBRA by calling the routine \ttindex{MZSTOR}
(Section~\ref{MZSTOR}).
The area \ttindex{FENCE} is required by ZEBRA.
It helps detecting out-of-bound indices.
We note that the effect of the {\tt EQUIVALENCE} statement is to
offset the arrays \ttindex{IQ} and \ttindex{Q} with respect to
\ttindex{LQ} by eight words.
This permits a simple form of subscripts in the references to
data words and to links.
The $n^{th}$~data word is addressed as {\tt Q(L+n)} or
{\tt IQ(L+n)}, and the $m^{th}$~link as {\tt LQ(L-m)}.
The first 8~words of the array \ttindex{LQ} are reserved for permanent
links.
At present only two of them are used as explained later.
 
Every bank allocated by ZEBRA has the layout shown
in Figure~\ref{Fbank}.
\begin{figure}[ht]
\centering
\setlength{\unitlength}{1pt}
\begin{picture}(450,440)
\thicklines
\put(100,0){\framebox(100,440){}}
\thinlines
\put(0,430){\makebox(0,0)[l]{\tt LQ(L-NL-NIO-1)}}
\put(117,430){\makebox(0,0){\tt IOCB}}
\put(134,420){\line(0,1){20}}
\put(167,430){\makebox(0,0){\tt NL+NIO+12}}
\put(220,430){\makebox(0,0)[l]{I/O control byte, offset of bank centre}}
\put(100,420){\line(1,0){100}}
 
\put(0,410){\makebox(0,0)[l]{\tt LQ(L-NL-NIO)}}
\put(150,410){\makebox(0,0){I/O option {\tt 1}}}
\put(0,390){\makebox(0,0)[l]{$\ldots$}}
\put(150,390){\makebox(0,0){$\ldots$}}
\put(220,397){%
  \makebox(0,0)[l]{Extra I/O descriptors, $0\le{\tt NIO}\le 16$}}
\put(220,383){\makebox(0,0)[l]{(Maintained by ZEBRA)}}
\put(0,370){\makebox(0,0)[l]{\tt LQ(L-NL-1)}}
\put(150,370){\makebox(0,0){I/O option {\tt NIO}}}
\put(100,360){\line(1,0){100}}
 
\put(0,350){\makebox(0,0)[l]{\tt LQ(L-NL)}}
\put(150,350){\makebox(0,0){link {\tt NL}}}
\put(0,330){\makebox(0,0)[l]{$\ldots$}}
\put(150,330){\makebox(0,0){$\ldots$}}
\put(220,330){\makebox(0,0)[l]{Reference links}}
\put(0,310){\makebox(0,0)[l]{\tt LQ(L-NS-1)}}
\put(150,310){\makebox(0,0){link {\tt NS+1}}}
\put(100,300){\line(1,0){100}}
 
\put(0,290){\makebox(0,0)[l]{\tt LQ(L-NS)}}
\put(150,290){\makebox(0,0){link {\tt NS}}}
\put(0,270){\makebox(0,0)[l]{$\ldots$}}
\put(150,270){\makebox(0,0){$\ldots$}}
\put(220,270){\makebox(0,0)[l]{Structural (down) links}}
\put(0,250){\makebox(0,0)[l]{\tt LQ(L-1)}}
\put(150,250){\makebox(0,0){link {\tt 1}}}
\thicklines
\put(100,240){\line(1,0){100}}
\thinlines
 
\put(0,230){\makebox(0,0)[l]{\tt LQ(L)}}
\put(150,230){\makebox(0,0){next link}}
\put(220,230){\makebox(0,0)[l]{Address of next bank in linear structure}}
\put(100,220){\line(1,0){100}}
 
\put(0,210){\makebox(0,0)[l]{\tt LQ(L+1)}}
\put(150,210){\makebox(0,0){up link}}
\put(220,210){\makebox(0,0)[l]{Address of supporting bank}}
\put(100,200){\line(1,0){100}}
 
\put(0,190){\makebox(0,0)[l]{\tt LQ(L+2)}}
\put(150,190){\makebox(0,0){origin link}}
\put(220,190){\makebox(0,0)[l]{Address of supporting link}}
\put(100,180){\line(1,0){100}}
 
\put(0,170){\makebox(0,0)[l]{\tt IQ(L-5)}}
\put(150,170){\makebox(0,0){\tt IDN}}
\put(220,170){\makebox(0,0)[l]{Numeric bank identifier}}
\put(100,160){\line(1,0){100}}
 
\put(0,150){\makebox(0,0)[l]{\tt IQ(L-4)}}
\put(150,150){\makebox(0,0){\tt IDH}}
\put(220,150){\makebox(0,0)[l]{Hollerith bank identifier (4 characters)}}
\put(100,140){\line(1,0){100}}
 
\put(0,130){\makebox(0,0)[l]{\tt IQ(L-3)}}
\put(150,130){\makebox(0,0){\tt NL}}
\put(220,130){\makebox(0,0)[l]{Total number of links}}
\put(100,120){\line(1,0){100}}
 
\put(0,111){\makebox(0,0)[l]{\tt IQ(L-2)}}
\put(150,110){\makebox(0,0){\tt NS}}
\put(220,110){\makebox(0,0)[l]{Number of structural links}}
\put(100,100){\line(1,0){100}}
 
\put(0,90){\makebox(0,0)[l]{\tt IQ(L-1)}}
\put(150,90){\makebox(0,0){\tt ND}}
\put(220,90){\makebox(0,0)[l]{Number of data words}}
\put(100,80){\line(1,0){100}}
 
\put(0,70){\makebox(0,0)[l]{\tt IQ(L)}}
\put(150,70){\makebox(0,0){Status word}}
\put(220,70){\makebox(0,0)[l]{Status bits: 1-18 user, 19-32 system}}
\thicklines
\put(100,60){\line(1,0){100}}
\thinlines
 
\put(0,50){\makebox(0,0)[l]{\tt IQ(L+1)}}
\put(150,50){\makebox(0,0){Data word {\tt 1}}}
\put(0,30){\makebox(0,0)[l]{$\ldots$}}
\put(150,30){\makebox(0,0){$\ldots$}}
\put(220,30){\makebox(0,0)[l]{Data words}}
\put(0,10){\makebox(0,0)[l]{\tt LQ(L+ND)}}
\put(150,10){\makebox(0,0){Data word {\tt ND}}}
\put(100,0){\line(1,0){100}}
\end{picture}
\caption{Layout of a ZEBRA Bank}
\index{bank!layout}
\label{Fbank}
\end{figure}
 
The central part of the bank starts with the next link,
accessed as {\tt LQ(L)}.
The up link at {\tt LQ(L+1)} points to the bank supporting the
linear structure of which the bank is a member.
It is zero if the bank is at the root of the tree.
The origin link  at {\tt LQ(L+2)} points to the link through which
the bank is reached.
These three links are present in every bank and are not counted in
{\tt NL} and {\tt NS}.
 
The two words {\tt IQ(L-5)} and {\tt IQ(L-4)} contain the
numeric and Hollerith bank identifiers,
{\tt IDN} and {\tt IDH}. 
Usually all banks of a linear structure have the same {\tt IDH},
but different {\tt IDN}'s to permit identification of a particular
bank.
{\tt IDN} is assigned by ZEBRA according to given rules,
but the user may freely change it after bank creation.
Words {\tt IQ(L-3)} and {\tt IQ(L-2)} hold the total number of
links ({\tt NL}) and the number of structural links ({\tt NS})
respectively, and the word {\tt IQ(L-1)} holds the number of data
words ({\tt ND}). 
The status word at {\tt IQ(L)} provides bits~1 to~18 for user
status bits, while bits~19 to~32 are reserved for ZEBRA.
 
With this format the smallest possible bank ({\tt NL=NS=ND=0})
occupies 10~words.
The store size can be changed by altering
the parameters \ttindex{MEMLEN} and \ttindex{MEMMIN},
or by selecting one of the \histor\ flags \ttindex{BIG} or
\ttindex{SMALL} when compiling MAD.
\ttindex{MWFLT} is used to double the storage capacity for the version
in \emindex{double precision}.
 
\subsection{Divisions}
\index{division}
The dynamic store may be physically divided into {\em divisions}.
When \ttindex{MZSTOR} initializes a store,
it automatically creates three divisions,
one for ZEBRA, and two for the user.
MAD uses division~1 for short-lived data,
and division~2 for data which must be kept over longer times.
It uses no further divisions.
The {\em dynamic store}\index{dynamic!store} itself is referred to by
the number~0.
 
\subsection{Link Areas}
\index{link!area}
The user can store bank addresses or links, for ease of manipulation,
in a user-defined area, or {\em link area}.
Link areas must be kept in common blocks,
and declared to ZEBRA with a call to \ttindex{MZLINK}.
ZEBRA will automatically update these links if banks must be moved.
 
\subsection{Double Precision Data}
\index{double precision}
There is no certitude that double precision data are properly aligned
when stored in banks.
If double precision data must be stored in a bank,
they must therefore be moved between the bank and local double
precision variables by calls to \ttindex{UCOPY} (Section~\ref{kernlib}),
and accessed from the local variables.
 
\subsection{Character Data}
\index{character!data}
The FORTRAN standard does not allow equivalencing of character
data with numeric data.
ZEBRA however supports the data type \emindex{Hollerith}.
Such data can be moved between a bank and local \ttindex{CHARACTER}
variables by calls to \ttindex{UCTOH} and \ttindex{UHTOC}
(Section~\ref{kernlib}), and accessed from the local variables.
There must be enough words reserved in the bank to accommodate
the desired number of characters.
 
\subsection{Working Space}
\label{work}
\index{working space}
Often program modules of MAD require temporary working space.
MAD uses two methods for this purpose:
\begin{enumerate}
\item
Working space is allocated in banks in division~1.
This mechanism is used when working space contains no double-precision
data. 
After execution of the program module the whole division~1
is wiped out by a call to \ttindex{MZWIPE}.
\item
\index{double precision}
Working space is allocated in a stack-like fashion using
\ttindex{MZWORK}.
This method is used by modules requiring double-precision data.
The actual working array is the vector \ttindex{DQ},
declared as \ttindex{REAL} or \ttindex{DOUBLE PRECISION} according to the
program version, 
and equivalenced to \ttindex{IQ}.
During execution of the module MAD maintains two indices in the
common block
\myxmp{
XXXXXX\=\kill
      \>COMMON /WSTACK/ IWORK, NWORK
}
\ttnindex{WSTACK}
\ttindex{IWORK} is the index into \ttindex{DQ}
of the last work used for working storage,
and \ttindex{NWORK} is the index into \ttindex{DQ} of the last word
allocated by the latest call to \ttindex{MZWORK}.
Assuming that a subroutine wants to allocate an array of length
{\tt ISIZE}, it executes the following code sequence upon entry:
\myxmp{
XXXXXX\=XXX\=\kill
      \>ISAVE = IWORK\\
      \>ITEMP = IWORK\\
      \>IWORK = IWORK + ISIZE\\
      \>IF (IWORK .GT. NWORK) THEN\\
      \>   \>CALL MZWORK(0, DQ(1), DQ(NWORK+1), 0)\\
      \>   \>NWORK = IWORK\\
      \>ENDIF
}
It may then use the area from {\tt DQ(ITEMP+1)} to
{\tt DQ(ITEMP+ISIZE)} freely. 
Before exit it executes the code
\myxmp{
XXXXXX\=\kill
      \>IWORK = ISAVE
}
This does not free the working space for bank allocation,
but it makes it available as working space for other subroutines.
When the program module has finished, it executes the sequence
\myxmp{
XXXXXX\=\kill
      \>IWORK = 0\\
      \>NWORK = 0\\
      \>CALL MZWORK(0, DQ(1), DQ(1), -1)
}
to free the whole working space.
This method minimizes the number of calls to \ttindex{MZWORK},
and thus the time overhead for managing the working storage.
\end{enumerate}
Since a call to \ttindex{MZWORK} also wipes out division~1,
the two methods cannot be mixed.
 
\section{Dropping Banks and Garbage Collection}
\label{Sdrop}
\index{drop}
\index{garbage collection}
Initially the dynamic store contains only a few banks in the
system division.
As banks are created,
the occupied space increases and the free space decreases.
By calling \ttindex{MZDROP} the user may \emindex{drop} banks
which are no longer needed.
\ttindex{MZDROP} logically removes banks, or whole sub-structures,
from the surrounding structure and marks the banks as dropped.
The dropped banks remain intact in storage and reference links
pointing to them continue to point to valid information.
 
If free space is not sufficient to satisfy a further request
for creating a bank,
ZEBRA will recuperate the space occupied by dropped banks.
This process, called \emindex{garbage collection},
moves all active banks to form one contiguous area for each division,
and updates all links.
Links pointing to active banks are changed to point to the
new positions,
Any {\em reference link}\index{reference!link} pointing to a
dropped bank is reset to zero.
Garbage collection is triggered automatically,
but the user may also request it by a call to \ttindex{MZGARB}.
 
For garbage collection to function ZEBRA has to know {\em all}
links used by the program.
It is essential that the user keeps all bank addresses in
locations known to ZEBRA, either in the {\em link part}
\index{link!part of bank} of banks,
or in a {\em link area}\index{link!area}.
Link areas are created in common blocks by calls to \ttindex{MZLINK}.
Any link kept elsewhere will be obsolete after garbage collection.

%==============================================================================

\chapter{MAD Data Structures}
\section{Conventions}
\label{Sconv}
 
\begin{description}
\item[ZEBRA Data Types:]
\index{ZEBRA!data type}
\index{data!type}
For structuring purposes ZEBRA requires no knowledge of the
actual contents of a bank.
The internal details of data in a bank are the responsibility of the
user, and it is vital to maintain an adequate documentation of the
bank contents. 
However, for input and output ZEBRA needs to know the type of the bank
contents. 
Some banks in MAD contain data words which have all the same type.
In this case the data type is declared to ZEBRA in the booking
\ttindex{MZBOOK} call. 
 
Often the types of data words are declared explicitly on a word by
word basis. 
In this case MAD declares the bank to be of type~7
(\emindex{self-defining})
and stores {\em format codes}\index{format code}
along with the data.
These have the form~$16*l+t$, where~$l$ is the number of words
and~$t$ is the ZEBRA data type for the following data.
Permissible data type codes are listed in Table~\ref{Tzebt}.
 
\begin{table}[ht]
\caption{ZEBRA Data Types}
\index{ZEBRA!data type}
\index{data!type}
\label{Tzebt}
\centering
\vspace{1ex}
\begin{tabular}{*3{|r|l|}}
\hline
0 &unknown data type &1 &bit string       &2 &integer\\
3 &single precision  &4 &double precision &5 &Hollerith\\
7 &self-defining    &&               &&\\
\hline
\end{tabular}
\end{table}
 
\item[Links:]
\index{link}
Following the ZEBRA conventions all links have names beginning
with an {\tt L}.
Links residing in ZEBRA banks are called \ttindex{LQ}.
In graphical representations of data structures this manual shows
structural links (supporting links) as solid lines;
\index{structural link}
\index{supporting link}
reference links are shown as dashed lines.
\index{reference!link}
Reverse links are not shown in the figures.
Solid boxes represent data banks or parts thereof;
dashed boxes indicate substructures described elsewhere.
 
\item[Parameters:]
Many constant integers have been defined in MAD by FORTRAN
\ttindex{PARAMETER} 
statements to allow easy change.
The names of these parameters all begin with an \ttindex{M}.
Most parameters are documented together with the data structures
they describe.
The following parameters, defined in the comdeck \ttindex{IMPLICIT},
are available to all subroutines:
\begin{mylist}
\ttitem{MWFLT}
\index{precision}
\index{single precision}
\index{double precision}
Number of ZEBRA words needed to store a real value,
it has the value 1~(single precision) or 2~(double precision).
\ttitem{MREAL}
\index{precision}
\index{single precision}
\index{double precision}
ZEBRA data type code for a MAD real,
it has the value 3~(single precision) or 4~(double precision).
\ttitem{MCWRD}
\index{character}
Number of characters that can be stored in a word,
it is 8~(single precision) or 4~(double precision).
\ttitem{MCNAM}
\index{identifier}
Number of characters allowed in an identifier (normally 16).
\ttitem{MWNAM}
Number of words required to store an identifier
({\tt MCNAM/MCWRD}).
\end{mylist}
\end{description}
\clearpage
 
\section{The Root Bank}
\label{Sroot}
\index{root bank}
 
The entire data structure of MAD forms a single tree
\index{data!structure}
\index{tree}
in ZEBRA division~2.
This allows the complete data structure to be dumped on disk
or reloaded with a single ZEBRA call.
The root of the tree is the \emindex{root bank}.
Its address \ttindex{LROOT} is stored in common block
\ttindex{MEMORY}.
 
The root bank has  20 structural and 20 reference links,
but no data words.
Links used are listed in Table~\ref{Troot}.
Parameters defining the root bank structure are set in comdeck
\ttindex{STRGROUP}.
Unused links are available to program modules of MAD,
provided they are freed upon exit.
\begin{table}[ht]
\caption{Structure of the Root bank}
\label{Troot}
\centering
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LROOT-MDKEY)  &\\
$\ldots$             &\bigbra links for the keyword
                      directory (Section~\ref{Sdir})\\
\tt LQ(LROOT-MDKEY-3)&\\
\hline
\tt LQ(LROOT-MDBNK)  &\\
$\ldots$             &\bigbra links for the data bank
                      directory (Section~\ref{Sdir})\\
\tt LQ(LROOT-MDBNK-3)&\\
\hline
\tt LQ(LROOT-MDEXP)  &link for the expression table
                      (Section~\ref{Sexp})\\
\hline
\tt LQ(LROOT-MDVAR)  &link for the variable reference table
                      (Section~\ref{Sexp})\\
\hline
\tt LQ(LROOT-MRKEY)  &link for the keyword tree
                      (Section~\ref{Stree})\\
\hline
\tt LQ(LROOT-MCSEQ)  &link for the current beam line expansion
                      (Section~\ref{Sbeam})\\
\hline
\hline
$\ldots$             &central part of the bank\\
\hline
\end{tabular}
\end{table}
\clearpage
 
\section{Keyword and Command Tree}
\label{Stree}
\index{keyword!tree}

The first action of MAD is to build the command keyword
\ttindex{KEYWORD}, known as the \emindex{master keyword}.
The \ttindex{KEYWORD} bank is supported by the link \ttindex{MRKEY}
in the root bank.
While reading the command dictionary,
the master keyword serves as a template.
Each new \emindex{keyword} bank built is linked to the linear
structure supported by link~1 of the master keyword bank.
 
When a command or definition is decoded,
it is linked to the linear structure supported by link~1
of the corresponding keyword bank.
Definition banks are always kept unless redefined.
If a command bank is labeled or if it belongs to a subroutine,
it is kept in store;
otherwise it is dropped after execution.
 
Some command attributes need additional banks to hold their values.
\index{attribute}
For the $i^{th}$~attribute such a bank is linked to the $i^{th}$~link
of the {\em command bank}\index{command!bank} as described in
Section~\ref{Smadt}.
Command attributes can take their values from three sources:
 
\begin{enumerate}
\item
If the attribute is not entered at all,
the so-called \emindex{first default} is used.
\index{default!first}
For values used refer to Table~\ref{Tmadt}.
\item
If the attribute name is entered, but without a value,
the so-called \emindex{second default}\index{default!second} is used.
This value is normally specified in the command dictionary.
It is stored in a bank having the same format as a command bank, 
supported by link~2 of the keyword bank.
\item
If the attribute value is entered by position,
or together with its name, the value is used as entered.
\end{enumerate}
 
Link~3 of an {\em element definition}\index{element!definition}
keyword (e.~g. {\tt QUADRUPOLE}) points to the generic
{\em class object}\index{class!object} of the same name.
This object is built when the keyword is decoded.
Note that the up link {\tt LQ(L)} of a command or definition bank
points to the relevant keyword.
 
The tree obtained is called {\em keyword tree}\index{keyword!tree}.
A simplified example is depicted in Figure~\ref{Ftree}.
 
\begin{figure}[b]
\centering
\setlength{\unitlength}{1pt}
\begin{picture}(440,240)(30,0)
\put(30,220){\framebox(80,20){\tt KEYWORD}}
 
\put(40,220){\vector(0,-1){40}}
\put(35,215){\makebox(0,0){1}}
\put(30,160){\framebox(40,20){\tt DRIFT}}
\put(40,160){\vector(0,-1){100}}
\put(35,155){\makebox(0,0){1}}
\put(30,40){\framebox(40,20){\tt D3}}
\put(70,50){\vector(1,0){20}}
\put(90,40){\framebox(40,20){\tt D2}}
\put(130,50){\vector(1,0){20}}
\put(150,40){\framebox(40,20){\tt D1}}
 
\put(50,160){\line(0,-1){70}}
\put(50,90){\vector(1,0){30}}
\put(45,155){\makebox(0,0){2}}
\put(80,80){\framebox(40,20){default}}
 
\put(60,160){\line(0,-1){30}}
\put(60,130){\vector(1,0){20}}
\put(55,155){\makebox(0,0){3}}
\put(80,120){\framebox(40,20){class}}
 
\put(70,170){\vector(1,0){160}}
\put(230,160){\framebox(40,20){\tt QUAD}}
\put(240,160){\vector(0,-1){100}}
\put(235,155){\makebox(0,0){1}}
\put(230,40){\framebox(40,20){\tt QF}}
\put(270,50){\vector(1,0){20}}
\put(290,40){\framebox(40,20){\tt QD}}
 
\put(250,160){\line(0,-1){70}}
\put(250,90){\vector(1,0){30}}
\put(245,155){\makebox(0,0){2}}
\put(280,80){\framebox(40,20){default}}
\put(260,160){\line(0,-1){30}}
\put(260,130){\vector(1,0){20}}
\put(255,155){\makebox(0,0){3}}
\put(280,120){\framebox(40,20){class}}
 
\put(270,170){\vector(1,0){100}}
\put(370,160){\framebox(40,20){\tt TWISS}}
\put(380,40){\vector(0,-1){20}}
\put(375,155){\makebox(0,0){1}}
\put(370,40){\framebox(40,20){twiss$_1$}}
\put(345,0){\framebox(40,20){expr$_1$}}
\put(400,40){\vector(0,-1){20}}
\put(395,0){\framebox(40,20){expr$_2$}}
 
\put(380,160){\vector(0,-1){100}}
\put(390,160){\line(0,-1){70}}
\put(390,90){\vector(1,0){30}}
\put(385,155){\makebox(0,0){2}}
\put(420,80){\framebox(40,20){default}}
\end{picture}
\caption{Structure of the Keyword Tree}
\index{keyword!tree}
\label{Ftree}
\end{figure}

\clearpage
\section{Keyword Banks}
\index{keyword!bank}
Keyword banks have the structure shown in Table~\ref{Tkey}.
Structure parameters are found in the comdecks \ttindex{BANKHEAD}
and \ttindex{KEYGROUP}.
 
\begin{table}[ht]
\caption{Structure of Keyword Bank}
\label{Tkey}
\centering
(\ttindex{LCKEY} is the address of the keyword bank)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LCKEY-3)     &supports the generic class object\\
  &(For element definitions only, Section~\ref{Scmnd})\\
\tt LQ(LCKEY-2)     &supports the banks containing the second defaults\\
  &(Same format as a command bank, Section~\ref{Scmnd})\\
\tt LQ(LCKEY-1)     &supports the linear structure of commands or
  definitions of this class\\
\hline
\hline
$\ldots$            &central part of the bank\\
\hline
\hline
\tt IQ(LCKEY+\ttindex{MBFRM}) &format code: 4 integers ($4 * 16 + 2$)\\
\tt IQ(LCKEY+\ttindex{MBNAM}) &directory index in keyword directory 
  (Section~\ref{Sdir})\\
\tt IQ(LCKEY+\ttindex{MBPR})  &process code (Section~\ref{Sprsp})\\
\tt IQ(LCKEY+\ttindex{MBSP})  &subprocess code (Section~\ref{Sprsp})\\
\tt IQ(LCKEY+\ttindex{MBAT})  &number of keyword attributes \ttindex{NKAT},\\
  &counting arrays as a single attribute\\
\hline
\tt IQ(LCKEY+MBAT+1)&\\
$\ldots$ &\bigbra Keyword attribute groups (Table~\ref{Tkeya})\\
\tt IQ(LCKEY+MBAT+\ttindex{NKAT}*\ttindex{MKSIZ}) &\\
\hline
\end{tabular}
\end{table}
 
\subsection{Keyword Attributes}
\index{keyword!attribute}
\index{attribute}
The structure of a keyword attribute group is shown
in Table~\ref{Tkeya}.
Structure parameters are defined in comdeck \ttindex{KEYGROUP}.
 
\begin{table}[ht]
\caption{Structure of Keyword Attribute Group}
\label{Tkeya}
\index{keyword!attribute}
\index{attribute}
\centering
({\tt LL=LCKEY+MBAT+(N-1)*MKSIZ} points to the word preceding the
attribute group)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt IQ(LL+\ttindex{MKF1})   &format code: 4 integers ($4 * 16 + 2$)\\
\tt IQ(LL+\ttindex{MKTYPE}) &attribute type
                   (MAD data type code, Table~\ref{Tmadt})\\
\tt IQ(LL+\ttindex{MKDIM1}) &first dimension of attribute\\
\tt IQ(LL+\ttindex{MKDIM2}) &second dimension of attribute\\
\tt IQ(LL+\ttindex{MKDIM3}) &third dimension of attribute\\
\tt IQ(LL+\ttindex{MKF2})   &format code: 1 name ({\tt MCNAM}*16+5)\\
\tt IQ(LL+\ttindex{MKNAME}) &Attribute name ({\tt MCNAM} words)\\
\tt IQ(LL+\ttindex{MKSIZ})  &Next keyword attribute group\\
\hline
\end{tabular}
\end{table}

\clearpage
\section{Process and Subprocess Codes}
\label{Sprsp}
\index{process!code}
\index{subprocess code}
The MAD commands are distinguished by two numeric codes,
the process code and the subprocess code.
The process code serves as a switch to select a program module,
\index{program!module}
\index{module}
and the subprocess code selects the action to be performed by the
\index{program!action}
\index{action}
program module.
The two codes are defined for each command in the command dictionary.
\index{command!dictionary}
\index{dictionary}
Table~\ref{Tprsp} summarizes the codes used at time of writing
of this manual.
Process code parameters are defined in comdeck \ttindex{PRCGROUP}.
 
\begin{table}[ht]
\caption{Process and Subprocess Codes}
\label{Tprsp}
\index{process!code}
\index{subprocess code}
\centering
\vspace{1ex}
\begin{tabular}{*2{|r|r|p{3.5cm}|}}
\hline
\multicolumn{6}{|c|}{\bf keyword definitions}\\
\hline
process &subprocess &keyword &process &subprocess &keyword\\
\hline
\ttindex{MPKEY} &1 &\ttindex{KEYWORD} &\ttindex{MPKEY} &2 &
   \ttindex{KEYEDIT}\\
\hline
\hline
\multicolumn{6}{|c|}{\bf parameter and constant definitions}\\
\hline
process &subprocess &keyword &process &subprocess &keyword\\
\hline
\ttindex{MPPAR} &1 &\ttindex{CONSTANT} &\ttindex{MPPAR} &2 &
  \ttindex{PARAMETER}\\
\hline
\hline
\multicolumn{6}{|c|}{\bf element definitions}\\
\hline
process &subprocess &keyword &process &subprocess &keyword\\
\hline
\ttindex{MPELM} &1 &\ttindex{DRIFT} &\ttindex{MPELM} &2 &
  \ttindex{SBEND}\\
 &3 &\ttindex{RBEND} &&4 &\ttindex{MATRIX}\\
 &5 &\ttindex{QUADRUPOLE} &&6 &\ttindex{SEXTUPOLE}\\
 &7 &\ttindex{OCTUPOLE} &&8 &\ttindex{MULTIPOLE}\\
 &9 &\ttindex{SOLENOID} &&10 &\ttindex{RFCAVITY}\\
 &11 &\ttindex{ELSEPARATOR} &&12 &\ttindex{SROTATION}\\
 &13 &\ttindex{YROTATION} &&14 &\ttindex{HKICKER}\\
 &15 &\ttindex{KICKER} &&16 &\ttindex{VKICKER}\\
 &17 &\ttindex{HMONITOR} &&18 &\ttindex{MONITOR}\\
 &19 &\ttindex{VMONITOR} &&20 &\ttindex{ECOLLIMATOR}\\
 &21 &\ttindex{RCOLLIMATOR} &&22 &\ttindex{BEAMBEAM}\\
 &23 &\ttindex{LUMP} &&24 &\ttindex{INSTRUMENT}\\
 &25 &\ttindex{MARKER} &&&\\
\hline
\hline
\multicolumn{6}{|c|}{\bf beam line and list definitions}\\
\hline
process&subprocess&keyword&process&subprocess&keyword\\
\hline
\ttindex{MPLIN}&1&\ttindex{LINE}&\ttindex{MPLIN}&2 &
  \ttindex{SEQUENCE}\\
&3&\ttindex{LIST}&&&\\
\hline
\hline
\multicolumn{6}{|c|}{\bf subroutines}\\
\hline
process&subprocess&keyword&process&subprocess&keyword\\
\hline
\ttindex{MPSUB}&1&\ttindex{DO} &\ttindex{MPSUB}&2 &
  \ttindex{ENDDO}\\
&3&\ttindex{STORE}&&4&\ttindex{ENDSTORE}\\
&5&\ttindex{SUBROUTINE}&&6&\ttindex{ENDSUBROUTINE}\\
&7&\ttindex{CALLSUBROUTINE}&&&\\
\hline
\end{tabular}\\
\vspace{1ex}
(continued on next page)
\end{table}
\clearpage
\begin{table}[p]
\centering
Table \ref{Tprsp}: Process and Subprocess Codes (continued)\\
\vspace{1ex}
\begin{tabular}{*2{|r|r|p{3.5cm}|}}
\hline
\multicolumn{6}{|c|}{\bf executable commands}\\
\hline
process&subprocess&keyword&process&subprocess&keyword\\
\hline
\ttindex{MPSRV}&1&\ttindex{PACKMEMORY}&\ttindex{MPSRV}&2&\ttindex{OPTION}\\
&3&\ttindex{STOP}&&4&\ttindex{SET}\\
&5&\ttindex{VALUE}&&&\\
\hline
\ttindex{MPFIL}&1&\ttindex{ARCHIVE}&\ttindex{MPFIL}&2&\ttindex{RETRIEVE}\\
&3&\ttindex{ASSIGN}&&4&\ttindex{CALL}\\
&5&\ttindex{RETURN}&&6&\ttindex{EXCITE}\\
&7&\ttindex{INCREMENT}&&8&\ttindex{POOLDUMP}\\
&9&\ttindex{POOLLOAD}&&10&\ttindex{SAVE}\\
&11&\ttindex{STATUS}&&12&\ttindex{SYSTEM}\\
&13&\ttindex{HELP}&&14&\ttindex{SHOW}\\
\hline
\ttindex{MPENV}&1&\ttindex{BEAM}&\ttindex{MPENV}&2&\ttindex{BETA0}\\
&3&\ttindex{PRINT}&&4&\ttindex{SAVEBETA}\\
&5&\ttindex{TITLE}&&6&\ttindex{USE}\\
&7&\ttindex{SELECT}&&8&\ttindex{SPLIT}\\
\hline
\ttindex{MPPLT}&1&\ttindex{PLOT}&\ttindex{MPPLT}&2&\ttindex{SETPLOT}\\
\hline
\ttindex{MPSUR}&1&\ttindex{SURVEY}&&&\\
\hline
\ttindex{MPTWS}&1&\ttindex{TWISS}&\ttindex{MPTWS}&2&\ttindex{OPTICS}\\
&3&\ttindex{BMPM}&&4&\ttindex{IBS}\\
\hline
\ttindex{MPMAT}&1&\ttindex{MATCH}&\ttindex{MPMAT}&2&\ttindex{CELL}\\
&3&\ttindex{ENDMATCH}&&4&\ttindex{MIGRAD}\\
&5&\ttindex{SIMPLEX}&&6&\ttindex{CONSTRAINT}\\
&7&\ttindex{COUPLE}&&8&\ttindex{FIX}\\
&9&\ttindex{LEVEL}&&10&\ttindex{VARY}\\
&11&\ttindex{WEIGHT}&&12&\ttindex{LMDIF}\\
&13&\ttindex{RMATRIX}&&14&\ttindex{TMATRIX}\\
\hline
\ttindex{MPTRK}&1&\ttindex{TRACK} &\ttindex{MPTRK}&2&\ttindex{ENDTRACK}\\
&3&\ttindex{RUN}&&4&\ttindex{CONTINUE}\\
&5&\ttindex{START}&&6&\ttindex{NOISE}\\
\hline
\ttindex{MPHAR}&1&\ttindex{HARMON}&\ttindex{MPHAR}&2&\ttindex{ENDHARMON}\\
&3&\ttindex{HRESONANCE}&&4&\ttindex{HCHROMATICITY}\\
&5&\ttindex{HFUNCTIONS}&&6&\ttindex{HTUNE}\\
&7&\ttindex{HVARY}&&8&\ttindex{HCELL}\\
&9&\ttindex{HWEIGHT}&&10&\ttindex{HLEVEL}\\
\hline
\ttindex{MPERR}&1&\ttindex{EALIGN}&\ttindex{MPERR}&2&\ttindex{EFIELD}\\
&3&\ttindex{EOPTION}&&4&\ttindex{EPRINT}\\
&5&\ttindex{ESAVE}&&6&\ttindex{EFCOMP}\\
\hline
\ttindex{MPCOR}&1&\ttindex{CORRECT}&\ttindex{MPCOR}&2&\ttindex{GETORBIT}\\
&3&\ttindex{PUTORBIT}&&4&\ttindex{GETKICK}\\
&5&\ttindex{PUTKICK}&&6&\ttindex{MICADO}\\
\hline
\ttindex{MPLIE}&1&\ttindex{DYNAMIC}&\ttindex{MPLIE}&2&\ttindex{STATIC}\\
&3&\ttindex{NORMAL}&&&\\
\hline
\ttindex{MPEDI}&1&\ttindex{SEQEDIT}&\ttindex{MPEDI}&2&\ttindex{INSTALL}\\
&3&\ttindex{MOVE}&&4&\ttindex{REMOVE}\\
&5&\ttindex{ENDEDIT}&&&\\
\hline
\ttindex{MPPOL}& \multicolumn{5}{|c|}{reserved}\\
\hline
\end{tabular}
\end{table}

\clearpage
\section{Command Banks}
\label{Scmnd}
\index{command!bank}
 
For each command or definition read,
\index{command}
\index{definition}
MAD creates a command bank and links it to the corresponding keyword.
Command have the structure shown in Table~\ref{Tcmnd}.
Structure parameters are defined in comdeck \ttindex{BANKHEAD};
\ttindex{MCSIZ} is defined in comdeck \ttindex{CMDGROUP}.
 
\begin{table}[ht]
\caption{Structure of Command Bank}
\label{Tcmnd}
\index{command!bank}
\centering
(\ttindex{LCCMD} is the address of the command bank)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LCCMD-NCAT) &bank for {\tt NCAT}$^{th}$~attribute, if required\\
\tt $\ldots$       &$\ldots$\\
\tt LQ(LCCMD-1)    &bank for $1^{st}$~attribute, if required\\
\hline
\hline
$\ldots$           &central part of the bank\\
\hline
\hline
\tt IQ(LCCMD+\ttindex{MBFRM}) &format code: 4 integers ($4 * 16 + 2$)\\
\tt IQ(LCCMD+\ttindex{MBNAM}) &directory index for name in data object
  directory\\ &(Section \ref{Sdir})\\
\tt IQ(LCCMD+\ttindex{MBLN})  &input line number of last definition\\
\tt IQ(LCCMD+\ttindex{MBPR})  &process code (Section~\ref{Sprsp})\\
\tt IQ(LCCMD+\ttindex{MBSP})  &subprocess code (Section~\ref{Sprsp})\\
\tt IQ(LCCMD+\ttindex{MBAT})  &number of attributes \ttindex{NCAT},\\
  &counting each component of an array individually\\
\hline
\tt IQ(LCCMD+MBAT+1)          &\\
$\ldots$                      &\bigbra Attribute groups (Table~\ref{Tcmda})\\
\tt IQ(LCCMD+MBAT+\ttindex{NCAT}*\ttindex{MCSIZ}) &\\
\hline
\end{tabular}
\end{table}
 
\subsection{Command Attributes}
\label{Smadt}
\index{command!attribute}
\index{attribute}
 
For each attribute of a command an {\em attribute data group}
\index{attribute!data group}
is allocated in the command bank with the structure shown in
Table~\ref{Tcmda}.
Structure parameters are defined in comdeck \ttindex{CMDGROUP}.
 
\begin{table}[ht]
\caption{Structure of Command Attribute Group}
\label{Tcmda}
\index{command!attribute}
\index{attribute}
\centering                                  
({\tt LL = LCCMD+MBAT+(N-1)*MCSIZ} points to the word preceding the
  attribute group)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt IQ(LL+\ttindex{MCF1})  &format code: 1 integer ($1 * 16 + 2$)\\
\tt IQ(LL+\ttindex{MCTYP}) &data type code: Ten times the MAD data type\\
  &(Table~\ref{Tmadt}) plus a flag value\\
\tt IQ(LL+\ttindex{MCF2})  &format code: \ttindex{MWNAM} words\\
  &({\tt MWNAM}*16+{ZEBRA data type})\\
\tt IQ(LL+\ttindex{MCVAL}) &data value or empty, depending on data type\\
\hline
\end{tabular}
\end{table}
 
MAD defines its own data types listed in Table~\ref{Tmadt}.
\index{MAD data type}
\index{data!type}
Note that the data type codes are different from the ZEBRA type codes.
\begin{table}[ht]
\caption{MAD Data Types}
\label{Tmadt}
\centering
\vspace{1ex}
\begin{tabular}{|c|c|c|l|c|}
\hline
\multicolumn{3}{|c|}{data type code} &meaning &default value\\
dictionary &keyword bank &command bank &&\\
\hline
N&1 &10 &unspecified name &blank\\
& &11 &known name &\\
\hline
I&2 &20 &unspecified integer value &0\\
& &21 &integer constant &\\
\hline
R&3 &30 &unspecified real value &0.0\\
& &31 &real constant &\\
& &32 &real expression &\\
\hline
D&4 &30 &unspecified real value &0.0\\
& &31 &real constant &\\
& &32 &real expression &\\
& &33 &deferred expression &\\
\hline
L&5 &50 &unspecified logical value &false\\
& &51 &known logical value &\\
\hline
S&6 &60 &unspecified string &unspecified\\
& &61 &known string &\\
\hline
B&7 &70 &unspecified beam line  &unspecified\\
& &71 &beam line name &\\
& &72 &beam line name with arguments &\\
& &73 &beam line list &\\
\hline
P&8 &80 &unspecified range reference &unspecified\\
& &81 &known range reference &\\
\hline
C&9 &90 &unspecified constraint &unspecified\\
& &91 &known constraint &\\
\hline
V &10 &100 &unspecified variable reference &unspecified\\
& &101 &known variable reference &\\
\hline
\end{tabular}
\end{table}
 
The space reserved in the value part of the attribute group
is sufficient to store attribute values of most types.
Some other data types require an additional bank for their value.
For each attribute data group there is a corresponding
{\em attribute link}\index{attribute!link},
designed to support such a bank.
More details about how attributes are stored can be found
by consulting subroutine \ttindex{DCATTR} and its subordinates.
 
\subsection{Name Attributes}
\index{name!attribute}
A name attribute value occupies all \ttindex{MWNAM} words
of the value part as a Hollerith string.
 
\subsection{Integer Attributes}
\index{integer attribute}
An integer attribute is stored in the first word
of the value part.
 
\subsection{Real Attributes or Deferred Expressions}
\label{Sexp}
A \emindex{real attribute} or the value of a
\emindex{deferred expression} is stored in the first one or two words
of the value part.
If the value is defined as an expression
(MAD data type code 32~or~33),
the expression is encoded in \emindex{postfix notation},
and each operation gives rise to one {\em expression group}
\index{expression!group} whose structure is shown in Table~\ref{Texp}.
The encoded expression is stored in an {\em expression bank}
\index{expression!bank} supported by the corresponding attribute link.
The length of each expression group is \ttindex{MXSIZ}.
Structure parameters are defined in comdeck \ttindex{EXPGROUP}.
For each expression group the expression bank has a corresponding
structural link which may support a {\em variable reference bank}
\index{variable!reference bank}.
 
\begin{table}[p]
\caption{Structure of Expression Bank}
\label{Texp}
\centering
(\ttindex{LCEXP} is the expression bank address,\\
{\tt LL = LCEXP+(N-1)*MXSIZ} points to the word preceding the
  expression group)
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LCEXP-IQ(LCEXP-2))&\\
$\ldots$            &\bigbra Variable reference banks (Section \ref{Svar})\\
\tt LQ(LCEXP-1)     &\\
\hline
\hline
$\ldots$            &central part of the bank\\
\hline
\hline
\tt IQ(LL+\ttindex{MXF1})     &format code: 1 integer ($1 * 16 + 2$)\\
\tt IQ(LL+\ttindex{MXOP})     &operation code (Table~\ref{Texpop})\\
\tt IQ(LL+\ttindex{MXF2})     &format code: 1 vale (1*16+\ttindex{MREAL})\\
\tt IQ(LL+\ttindex{MXVAL})    &constant value, if needed\\
\hline
\end{tabular}
 
\caption{Operation codes in Expression Bank}
\label{Texpop}
\index{operation code}
\index{expression!bank}
\centering
\vspace{1ex}
\begin{tabular}{|p{0.1\textwidth}|p{0.8\textwidth}|}
\hline
-4&Load position from beam line sequence.
  The bank pointer is link~1 of a {\em variable reference bank}
  \index{variable!reference bank} supported by the expression bank
  (section~\ref{Svar}).
  The bias in the bank is stored in that same bank.\\
\hline
-2&Load attribute or parameter. The bank pointer is link~1 of a
  \emindex{variable reference bank} supported by the expression bank
  (Section~\ref{Svar}). The attribute number to be loaded is stored in that
  same bank.\\
\hline
-1&Load constant value. The value is taken from {\tt IQ(LX+LXVAL)}.\\
\hline
\ 0&Store result. The bank is given by the up~link at {\tt LQ(LCEXP+1)},
  and the bias in the bank is stored in {\tt IQ(LX+MXVAL)}.\\
\hline
\ 1&binary plus ({\tt X + Y})\\
\ 2&binary minus ({\tt X - Y})\\
\ 3&multiply ({\tt X * Y})\\
\ 4&divide ({\tt X / Y})\\
\ 5&unary plus ({\tt + X})\\
\ 6&unary minus ({\tt - X})\\
\hline
\ 7&square root (\ttindex{SQRT(X)})\\
\ 8&logarithm (\ttindex{LOG(X)})\\
\ 9&exponential (\ttindex{EXP(X)})\\
10&sine (\ttindex{SIN(X)})\\
11&cosine (\ttindex{COS(X)})\\
12&absolute value (\ttindex{ABS(X)})\\
13&tangent (\ttindex{TAN(X)})\\
14&arc sine (\ttindex{ASIN(X)})\\
\hline
15&maximum of two values (\ttindex{MAX(X,Y)})\\
16&minimum of two values (\ttindex{MIN(X,Y)})\\
\hline
17&uniform distribution in [0..1] (\ttindex{RANF()})\\
18&gaussian distribution with $\sigma = 1$ (\ttindex{GAUSS()})\\
19&user-defined random generator (\ttindex{USER0()})\\
20&truncated gaussian (\ttindex{TGAUSS(X)})\\
21&user-defined random generator (\ttindex{USER1(X)})\\
21&user-defined random generator (\ttindex{USER2(X,Y)})\\
\hline
\end{tabular}
\end{table}
 
Before a command is executed, expressions of type~32 are evaluated.
Expressions of type~33 must be evaluated before using them by a call
to \ttindex{EXEVAL}.
A call to \ttindex{UTGFLT} will also ensure that a new value is available.
 
\subsection{Logical Attributes}
\index{logical attribute}
A logical attribute is encoded as an integer stored in the first word
of the value part.
Zero represents false, one represents true.
 
\subsection{String Attributes}
\index{string attribute}
The number of characters is stored in the first word of the value part.
The actual string is stored in a bank supported by the corresponding
attribute link.
 
\subsection{Beam Line References}
\index{beam!line!attribute}
If a beam line is referred to by name,
the directory index (relative to the data object directory)
for its name is stored in the first word of the value part.
If there is an actual argument list,
it is encoded like a beam line definition,
and its bank is supported by the corresponding attribute link.
 
If a beam line reference has the form of a literal list,
the list is encoded as a beam line and referred to like a named line.
The format of a {\em beam line reference}\index{beam!line!reference}
bank is the same as for a beam line bank (Section~\ref{Sline}).
 
\subsection{Range References}
\index{range!attribute}
A range reference requires an extra {\em range reference bank}
\index{range!reference bank}
with six integer data words linked to the attribute link.
The meaning of the six integers is summarized in Table~\ref{Trang}.
 
\begin{table}[hb]
\caption{Structure of Range Reference Bank}
\label{Trang}
\centering
(\ttindex{LCATTR} is the address of the range reference bank)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
bias &meaning\\
\hline
\tt IQ(LCATTR+1) &\ttindex{ICODE1}, code for beginning of range:\\
     &1: beginning of line ({\tt \#S})\\
     &2: end of line ({\tt \#E})\\
     &3: numeric index of the form {\tt \#index1}\\
     &4: name, optionally with occurrence:\\
     &\qquad ({\tt name1} or {\tt name1[index1]})\\
     &5: selected elements only ({\tt name1[index1/index2]})\\
\hline
\tt IQ(LCATTR+2) &Value of {\tt index1} for {\tt ICODE1}${}\ge3$\\
\hline
\tt IQ(LCATTR+3) &Directory index for {\tt name} for {\tt ICODE1}${}\ge4$\\
\hline
\tt IQ(LCATTR+4) &\ttindex{ICODE2}, code for end of range:\\
     &1: beginning of line ({\tt \#S})\\
     &2: end of line ({\tt \#E})\\
     &3: numeric index of the form {\tt \#index2}\\
     &4: name, optionally with occurrence:\\
     &\qquad ({\tt name} or {\tt name[index]})\\
     &5: selected elements only ({\tt name[index1/index2]})\\
\hline
\tt IQ(LCATTR+5) &value of {\tt index2} for {\tt ICODE2}${}\ge3$\\
\hline
\tt IQ(LCATTR+6) &directory index for {\tt name2} for {\tt ICODE2}${}\ge4$\\
\hline
\end{tabular}
\end{table}
\clearpage
  
\subsection{Constraints}
\index{constraint!attribute}
A constraint requires an extra {\em constraint bank}
\index{constraint!bank} whose structure is show in Table~\ref{Tcons}.
The two real attribute data groups have the same format as a real value.
If they contain expressions, the expression banks are linked to
the links~1 or~2 respectively of the constraint bank.

\begin{table}[h]
\caption{Structure of Constraint Bank}
\label{Tcons}
\centering
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
$\ldots$ &central part of the bank\\
\hline
\hline
\tt IQ(LCATTR+1) &code for the type of constraint:\\
     &1: minimum specified ({\tt > value})\\
     &2: maximum specified ({\tt < value})\\
     &3: minimum and maximum specified\\
     &4: equality specified ({\tt = value})\\
\hline
\tt IQ(LCATTR+2) &\\
$\ldots$ &\bigbra real attribute data group for minimum or value\\
\tt IQ(LCATTR+MCSIZ+1) &\\
\hline
\tt IQ(LCATTR+MCSIZ+2) &\\
$\ldots$ &\bigbra real attribute data group for maximum\\
\tt IQ(LCATTR+2*MCSIZ+1) &\\
\hline
\end{tabular}
\end{table}
 
\subsection{Variable References}
\label{Svar}
A {\em variable reference}\index{variable reference} requires an extra
{\em variable reference bank}\index{variable!reference!bank}.
Its structure is shown in Table~\ref{Tvar}.
Structure parameters are defined in comdeck \ttindex{VARGROUP}.
 
\begin{table}[h]
\caption{Structure of Variable Reference Bank}
\label{Tvar}
\centering
(\ttindex{LCVAR} is the address of the variable reference bank)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LCVAR-1)     &reference link, points to bank referred to\\
\hline
\hline
$\ldots$         &central part of the bank\\
\hline
\hline
\tt IQ(LCVAR+\ttindex{MVF1})  &format code: 2 names ({\tt 2*MWNAM*16+5})\\
\tt IQ(LCVAR+\ttindex{MVBANK})&name of bank in which attribute resides\\
\tt IQ(LCVAR+\ttindex{MVATTR})&name of attribute referred to\\
\tt IQ(LCVAR+\ttindex{MVF2})  &format code: 5 integers ({\tt 5*16+2})\\
\tt IQ(LCVAR+\ttindex{MVSEEN})&type of reference: 1=parameter, 2=attribute\\
\tt IQ(LCVAR+\ttindex{MVIND1})&first index\\
\tt IQ(LCVAR+\ttindex{MVIND2})&second index \bigbra for dimensioned
  attributes\\
\tt IQ(LCVAR+\ttindex{MVIND3})&third index\\
\tt IQ(LCVAR+\ttindex{MVBIAS})&bias of attribute in its bank\\
\hline
\end{tabular}
\end{table}
\clearpage

\section{Beam Line Banks}
\label{Sline}
\index{beam!line}
\index{replacement list}
Beam lines and replacement lists are stored as doubly linked lists.
The structure of a beam line bank is shown in Table~\ref{Tline}.

The structure of the list cells is represented in Table~\ref{Tcell}.
The pointers ``last'', ``first'', ``next'', ``previous'', and
``sublist head'' contain the bias in the beam line bank of the
list cell referred to.
This avoids to declare them as links, and to give ZEBRA the burden
of updating them when banks are moved.
The field ``dir.~index'' refers to a position in the
{\em data object directory}\index{data!object directory}.
The field ``repeat'' contains the repeat count, as defined in the
beam line or replacement list definition (one, if not specified).
 
The stack pointers and the stack area in list cells are used during
expansion of a beam line by subroutine LNXPND.
They are of no concern to the program user.

\begin{table}[h]
\caption{Structure of Beam Line List}
\label{Tline}
\index{beam!line}
\index{replacement list}
\centering
({\tt LCCMD} is the address of the beam line list bank)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LCCMD-3) &\\
&\bigbra stack pointers used during expansion of the beam line\\
\tt LQ(LCCMD-2) &\\
\tt LQ(LCCMD-1) &formal parameter bank ({\tt MWNAM} words per name)\\
\hline
\hline
$\ldots$ &central part of the bank\\
\hline
\hline
\tt IQ(LCCMD+\ttindex{MBFRM})&format code: 4 integers ($4 * 16 + 2$)\\
\tt IQ(LCCMD+\ttindex{MBNAM})&directory index for beam line name\\
\tt IQ(LCCMD+\ttindex{MBPR}) &process code \ttindex{MPLIN} (Section~\ref{Sprsp})\\
\tt IQ(LCCMD+\ttindex{MBSP}) &subprocess code (Section~\ref{Sprsp})\\
\tt IQ(LCCMD+\ttindex{MBAT}) &number of attributes {\tt NCAT = 0}\\
\tt IQ(LCCMD+\ttindex{MLFM}) &format code: Rest of bank is integer (2)\\
\tt IQ(LCCMD+\ttindex{MLHD}) &offset in this bank of list header:\\ 
  &{\tt IQ(LCCMD+IQ(LCCMD+MLHD))}\\
\tt IQ(LCCMD+\ttindex{MLF1}) &{\tt LINE}: bias of first dummy list for
  formals:\\
  &first formal begins at {\tt IQ(LCCMD+IQ(LCCMD+MLF1))}\\
               &{\tt LIST}: stack area used during line expansion\\
\tt IQ(LCCMD+\ttindex{MLF2}) &{\tt LINE}: bias of last dummy list for
  formals:\\   &last formal begins at {\tt IQ(LCCMD+IQ(LCCMD+MLF2))}\\
               &{\tt LIST}: stack area used during line expansion\\
\tt IQ(LCCMD+MLF2+1)&\\
$\ldots$ &\bigbra list cells (6 words each, Table~\ref{Tcell})\\
\tt IQ(LCCMD+IQ(LCCMD-1)) &\\
\hline
\end{tabular}
\end{table}
\clearpage

\begin{table}[h]
\caption{Beam Line List Cells}
\label{Tcell}
\centering
\vspace{1ex}
\begin{tabular}{|p{0.3\textwidth}|l|l|l|l|l|l|}
\hline
cell usage &\multicolumn{6}{c|}{c e l l\ \ \ c o n t e n t s}\\
\hline
      &\tt MLTYP&\tt MLPRV&\tt MLNXT&\tt MLREF&\tt MLREP&\tt MLACT\\
\hline
Header of main list, or header of actual arguments list.
  &1 &last  &first &\multicolumn{3}{c|}{stack area}\\
\hline
Header of a sublist or of a dummy list replaced by name
  &2 &last  &first &\multicolumn{3}{c|}{stack area}\\
\hline
Header of a dummy list replaced by a sublist.
  &3 &last  &first &\multicolumn{3}{c|}{stack area}\\
\hline
Cell refers to a sublist of the same beam line.
  &4 &previous&next&sublist head&repeat&unused\\
\hline
Cell refers to a sublist of another beam line, that is to an actual
argument which is a sublist.
  &5 &previous&next&sublist head&repeat&unused\\
\hline
Cell refers to a name without actual arguments.
  &6 &previous&next&dir. index&repeat&unused\\
\hline
Cell refers to a name with actual arguments.
  &7 &previous&next&dir. index&repeat&actual\\
\hline
\end{tabular}
\end{table}

\section{Beam Sequences}
For space reasons, a \ttindex{SEQUENCE} has a somewhat special structure.
It consists of two banks.
The first bank contains the positions and has the structure shown
in Table~\ref{Tspos}.
The second bank contains the directory indices and has the structure shown
in Table~\ref{Tsdir}.

Walking through the members of the sequence implies a loop for
$I = 2 \ldots N$.
The directory index for the member is then found at {\tt IQ(L2+I)},
while the position value is stored in position
{\tt IQ(L1+MBAT+(I-2)*MWFLT+2)}.
If there is an expression bank for the position,
it is linked to link {\tt LQ(L1-I)}.

\begin{table}[h]
\caption{Structure of the First Bank of a Beam Line Sequence}
\label{Tspos}
({\tt L1} is the address of the first sequence bank)\\
\centering
\vspace{1ex}
\begin{tabular}{|p{0.38\textwidth}|p{0.52\textwidth}|}
\hline
\tt LQ(L1-NEL1EM) &\\
$\ldots$          &\bigbra pointers to any expression banks for positions\\
\tt LQ(L1-2)      &\\
\tt LQ(L1-1)      &pointer to the second bank for the \ttindex{SEQUENCE}\\
\hline           
\hline
$\ldots$          &central part of the bank\\
\hline
\hline
\tt IQ(L1+\ttindex{MBFRM}) &format code: 4 integers ($4 * 16 + 2$)\\
\tt IQ(L1+\ttindex{MBNAM}) &directory index for sequence name\\
\tt IQ(L1+\ttindex{MBPR})  &process code \ttindex{MPLIN} (Section~\ref{Sprsp})\\
\tt IQ(L1+\ttindex{MBSP})  &subprocess code (Section~\ref{Sprsp})\\
\tt IQ(L1+\ttindex{MBAT})  &number of attributes {\tt NCAT = 1}\\
\hline
\tt IQ(L1+MBAT+1)         &\\
$\ldots$                  &\bigbra attribute group for \ttindex{REFER}\\
\tt IQ(L1+MBAT+MCSIZ)     &\\
\hline
\tt IQ(L1+MBAT+MCSIZ+1)        &format code: rest of bank is real\\
\tt IQ(L1+MBAT+MCSIZ+2)        &\\
$\ldots$                       &\bigbra Positions ($N-1$~real values)\\
\tt IQ(L1+MBAT+MCSIZ+N*MWFLT+1)&\\
\hline
$\ldots$     &free space\\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\caption{Structure of the Second Bank of a Beam Line Sequence}
\label{Tsdir}
({\tt L2} is the address of the second sequence bank)\\
\centering
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
$\ldots$    &central part of the bank\\
\hline
\hline
\tt IQ(L2+1) &Number of members plus 1\\
\tt IQ(L2+2) &\\
$\ldots$     &\bigbra $N-1$~directory indices\\
\tt IQ(L2+N) &\\
$\ldots$     &free space\\
\hline
\end{tabular}
\end{table}

\section{Directories}
\label{Sdir}
\index{directory}

\subsection{Directory Structures}
MAD uses two directories to keep track of names.
Each directory consists of four banks, supported by four links
in the root bank.
The two directories serve the following purposes:
\begin{description}
\item[keyword directory:]
\index{keyword!directory}
Holds all keyword definitions.
The four banks of the keyword directory are supported
by the links \ttindex{MDKEY} through {\tt MDKEY+3} in the root bank.
For accessing the keyword directory an array of reference links
\ttindex{LDKEY} is provided in common \ttindex{REFER}
(Section~\ref{Srefer}).
\item[data object directory:]
\index{data!object directory}
Holds all data object definitions.
The four banks for the data object directory are supported
by the links \ttindex{MDBNK} through {\tt MDBNK+3} in the root bank.
For accessing the keyword directory an array of reference links
\ttindex{LDBNK} is provided in common \ttindex{REFER}
(Section~\ref{Srefer}).
\end{description}
 
The two arrays \ttindex{LDKEY} and \ttindex{LDBNK} may be thought of as
{\em directory handles}\index{directory!handle} for easy access to the
two directories.
The four banks of a directory have the following functions:
 
\begin{description}
\item[index bank:]
\index{index bank}
This bank has no links.
Its data part contains an ordering vector (one word per entry)
permitting access to names in alphabetical order and binary search.
\item[name bank:]
\index{name!bank}
This bank has no links.
Its data part contains a 16-character object name per entry.
This requires two or four words per entry for the single precision
and double precision version of MAD respectively.
\item[bank pointers:]
\index{pointer bank}
This bank has one reference link per entry,
pointing to the data structure containing the defined object.
If an object has been referred to, but not defined,
the corresponding link is zero.
The single data word contains the number of used entries.
\item[occurrence count bank:]
\index{occurrence count bank}
This bank has no links.
The data part has one word per entry used during beam line expansion
to keep track of occurrence counts for sublines and beam elements.
\end{description}
The structure of a directory can be depicted as in Figure~\ref{Fdir}.
\begin{figure}[ht]
\centering
\setlength{\unitlength}{1pt}
\begin{picture}(460,180)
\put(0,160){\makebox(100,20)[r]{\tt LDKEY(1)}}
\multiput(100,170)(4,0){6}{\line(1,0){2}}
\put(124,170){\vector(1,0){6}}
\put(130,160){\framebox(200,20){index bank}}
\put(360,170){\vector(-1,0){30}}
\put(360,160){\makebox(100,20)[l]{\tt LQ(LROOT-MDKEY)}}
 
\put(0,120){\makebox(100,20)[r]{\tt LDKEY(2)}}
\multiput(100,130)(4,0){6}{\line(1,0){2}}
\put(124,130){\vector(1,0){6}}
\put(130,120){\framebox(200,20){name bank}}
\put(360,130){\vector(-1,0){30}}
\put(360,120){\makebox(100,20)[l]{\tt LQ(LROOT-MDKEY-1)}}
 
\put(0,80){\makebox(100,20)[r]{\tt LDKEY(3)}}
\multiput(100,90)(4,0){6}{\line(1,0){2}}
\put(124,90){\vector(1,0){6}}
\put(130,80){\framebox(200,20){pointer bank}}
\put(360,90){\vector(-1,0){30}}
\put(360,80){\makebox(100,20)[l]{\tt LQ(LROOT-MDKEY-2)}}
 
\multiput(130,40)(100,0){2}{\framebox(80,20){keyword bank}}
\multiput(140,80)(0,-4){4}{\line(0,-1){2}}
\multiput(240,80)(0,-4){4}{\line(0,-1){2}}
\put(140,64){\vector(0,-1){4}}
\put(240,64){\vector(0,-1){4}}
 
\put(0,0){\makebox(100,20)[r]{\tt LDKEY(4)}}
\multiput(100,10)(4,0){6}{\line(1,0){2}}
\put(124,10){\vector(1,0){6}}
\put(130,0){\framebox(200,20){occurrence count bank}}
\put(360,10){\vector(-1,0){30}}
\put(360,0){\makebox(100,20)[l]{\tt LQ(LROOT-MDKEY-3)}}

\end{picture}
\caption{Structure of Keyword Directory}
\label{Fdir}
\end{figure}
 
When MAD sees a new name, it creates a new {\em directory entry}
\index{directory!entry}.
It assigns it a fixed {\em directory index}\index{directory!index},
namely the next free position in the name, pointer,
and occurrence count bank of the directory.
All later references to the same name use this index.
This makes later redefinition easy by simply replacing the bank pointer.
The index bank is updated to permit addressing the name bank
in alphabetical order.
 
\section{Beam Line Expansions}
\label{Sbeam}
For each reference to a beam line or sequence,
MAD creates a tree describing the beam line's expansion.
If the reference occurs in a \ttindex{USE} command,
its topmost bank is supported by link \ttindex{MCSEQ} of the root bank.
For faster access this link is duplicated in \ttindex{LCSEQ},
stored in common block \ttindex{REFER}.
When a \ttindex{LINE} attribute occurs in a \ttindex{MATCH} or
\ttindex{TWISS} command,
this beam line expansion is only required as long as the program
module is active.
Its supporting link becomes local to a link area of the relevant
program module.
 
The structure of a beam line expansion is shown in Table~\ref{Tbexp}
and Figure~\ref{Fbexp}.
Structure parameters are defined in comdeck \ttindex{SEQGROUP}.
The various banks all contain an entry for each \emindex{position}
in the machine, i.~e. for each physical element and for the entrance
and exit of each beam line.
 
\subsection{Flag Words}
\label{Sflag}
 
The format of the flag words is given in Table~\ref{Tflag},
and its parameters are defined in comdeck \ttindex{SEQFLAG}.
Packing and unpacking may be done using the CERN program library
routines \ttindex{SBIT0}, \ttindex{SBIT1}, \ttindex{SBYT}, \ttindex{JBIT}
and \ttindex{JBYT} (Chapter~\ref{C-misc}).

\begin{table}[hb]
\caption{Flag Words in Beam Line Expansions}
\label{Tflag}
\centering
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
bit position(s) &meaning\\
\hline
  &1: exit of a physical element\\
\tt 1...\ttindex{MCODE} &2: beginning of a beam line\\
  &3: end of a beam line\\
\hline
\tt \ttindex{MFRST} &dump flag for subroutine \ttindex{TMFRST}\\
\hline
\tt \ttindex{MLUMP} &dump flag for subroutine \ttindex{LMLUMP}\\
\hline             
\tt \ttindex{MREFE} &dump flag for subroutine \ttindex{TMREFE}\\
\hline
\tt \ttindex{MSCND} &dump flag for subroutine \ttindex{TMSCND}\\
\hline
\tt \ttindex{MOPTC} &output flag for \ttindex{OPTICS}\\
\hline
\tt \ttindex{MPRNT} &print flag for \ttindex{TWISS} or \ttindex{SURVEY}\\
\hline
\tt \ttindex{MTRAK} &print flag for \ttindex{TRACK}\\
\hline
\tt \ttindex{MOCC1}...\ttindex{MOCC2} &occurrence counter for the element
  or line in this position\\
\hline
\end{tabular}
\end{table}
 
\begin{table}[p]
\caption{Structure of Beam Line Expansion}
\label{Tbexp}
\centering
(\ttindex{LCSEQ} is the address of the expansion for the main beam line)\\
\vspace{1ex}
\begin{tabular}{|p{0.32\textwidth}|p{0.58\textwidth}|}
\hline
\tt LQ(LCSEQ-\ttindex{MSELM}) &
Reference link: list of quadrupoles and sextupoles affecting
dispersion in the beam line (Section~\ref{Scorr}).
In each bank reference link~1 points to the next item.\\
\hline
\tt LQ(LCSEQ-\ttindex{MSMON}) &
Reference link: list of monitors in the beam line
(Section~\ref{Scorr}).
In each bank reference link~1 points to the next item.\\
\hline
\tt LQ(LCSEQ-\ttindex{MSCOR}) &
Reference link: list of orbit correctors in the beam line
(Section~\ref{Scorr}).
In each bank reference link~1 points to the next item.\\
\hline\hline
\tt LQ(LCSEQ-\ttindex{MSLIE}) &
This link supports a linear structure with Lie-algebraic
maps for the line, one bank for each map order used.
See subroutine \ttindex{LMLUMP} for the bank format.\\
\hline
\tt LQ(LCSEQ-\ttindex{MSMAP}) &
This link supports a linear structure with TRANSPORT maps
for the line, one bank for each value of $\delta p / p$ used.
See subroutine \ttindex{TMTURN} for the bank format.\\
\hline
\tt LQ(LCSEQ-\ttindex{MSCOM}) &
The bank supported by this link holds the supporting links for the
banks in the lists pointed at by the links \ttindex{MSELM}, \ttindex{MSMON},
\ttindex{MSMON}. (Section~\ref{Scorr}).\\
\hline
\tt LQ(LCSEQ-\ttindex{MSNUM}) &
The bank supported by this link contains
the number of physical elements preceding the position.\\
\hline
\tt LQ(LCSEQ-\ttindex{MSFLD}) &
This link supports a bank supporting the field error banks for all
positions which have errors (Section~\ref{Serr}).\\
\hline
\tt LQ(LCSEQ-\ttindex{MSALI}) &
This link supports a bank supporting the alignment error banks for
all positions which have errors (Section~\ref{Serr}).\\
\hline
\tt LQ(LCSEQ-\ttindex{MSFLG}) &
This link supports a bank containing a flag word for each position
(Table~\ref{Tflag}).\\
\hline
\tt LQ(LCSEQ-\ttindex{MSDIR}) &
This link supports a bank containing the directory indices (relative
to the data object directory) for the element or beam line of each
position.\\
\hline
\hline
$\ldots$           &central part of the bank\\
\hline
\hline
\tt IQ(LCSEQ+\ttindex{MSF1}) &format code: 4 integers ($4 * 16 + 2$)\\
\tt IQ(LCSEQ+\ttindex{MSR1}) &first position in range\\
\tt IQ(LCSEQ+\ttindex{MSR2}) &last position in range\\
\tt IQ(LCSEQ+\ttindex{MSYM}) &symmetry code\\
\tt IQ(LCSEQ+\ttindex{MSUP}) &number of superperiods\\
\tt IQ(LCSEQ+\ttindex{MSF2}) &format code: Hollerith follows ($0 * 16 + 5$)\\
\tt IQ(LCSEQ+\ttindex{MSBN}) &name of beam line (\ttindex{MCNAM} words)\\
\tt IQ(LCSEQ+\ttindex{MSRN}) &encoded range name (\ttindex{MCRNG} words)\\
\hline
\end{tabular}
\end{table}
\clearpage 

\begin{figure}[p]
\centering
\setlength{\unitlength}{0.95pt}
\begin{picture}(450,624)
\thicklines
\put(120,0){\framebox(20,672){}}
\put(120,128){\line(1,0){20}}
\put(120,144){\line(1,0){20}}
\put(120,528){\line(1,0){20}}
\thinlines
\multiput(120,16)(0,16){7}{\line(1,0){20}}
\multiput(120,192)(0,48){7}{\line(1,0){20}}
\multiput(120,576)(0,48){2}{\line(1,0){20}}
 
\put(0,8){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSRN})}}
\put(150,8){\makebox(0,0)[l]%
{encoded range name (\ttindex{MCRNG} characters)}}
 
\put(0,24){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSBN})}}
\put(150,24){\makebox(0,0)[l]{line name (\ttindex{MCNAM} characters)}}
 
\put(0,40){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSF2})}}
\put(150,40){\makebox(0,0)[l]{format code: Hollerith follows}}
 
\put(0,56){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSUP})}}
\put(150,56){\makebox(0,0)[l]{number of superperiods}}
 
\put(0,72){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSYM})}}
\put(150,72){\makebox(0,0)[l]{0: no symmetry, 1: symmetry}}
 
\put(0,88){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSR2})}}
\put(150,88){\makebox(0,0)[l]{last position in range}}
 
\put(0,104){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSR1})}}
\put(150,104){\makebox(0,0)[l]{first position in range}}
 
\put(0,120){\makebox(0,0)[l]{\tt IQ(LCSEQ+\ttindex{MSF1})}}
\put(150,120){\makebox(0,0)[l]{format code: 4 integers follow}}
 
\put(0,136){\makebox(0,0)[l]{$\cdots$}}
\put(150,136){\makebox(0,0)[l]{central part of the bank}}
 
\put(0,168){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSDIR})}}
\put(140,168){\vector(1,0){40}}
\put(180,160){\framebox(120,16){directory indices}}
\multiput(320,168)(-4,0){4}{\line(-1,0){2}}
\put(304,168){\vector(-1,0){4}}
\put(328,168){\makebox(0,0)[l]{\ttindex{LSDIR}}}
 
\put(0,216){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSFLG})}}
\put(140,216){\vector(1,0){40}}
\put(180,208){\framebox(120,16){position flags}}
\multiput(320,216)(-4,0){4}{\line(-1,0){2}}
\put(304,216){\vector(-1,0){4}}
\put(328,216){\makebox(0,0)[l]{\ttindex{LSFLG}}}
 
\put(0,264){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSALI})}}
\put(140,264){\vector(1,0){40}}
\put(180,256){\framebox(120,16){alignment errors}}
\multiput(320,264)(-4,0){4}{\line(-1,0){2}}
\put(304,264){\vector(-1,0){4}}
\put(328,264){\makebox(0,0)[l]{\ttindex{LSALI}}}
\multiput(188,256)(60,0){2}{\line(0,-1){16}}
\multiput(188,240)(60,0){2}{\vector(1,0){16}}
\multiput(204,232)(60,0){2}{\framebox(32,16){}}
 
\put(0,312){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSFLD})}}
\put(140,312){\vector(1,0){40}}
\put(180,304){\framebox(120,16){field errors}}
\multiput(320,312)(-4,0){4}{\line(-1,0){2}}
\put(304,312){\vector(-1,0){4}}
\put(328,312){\makebox(0,0)[l]{\ttindex{LSFLD}}}
\multiput(204,304)(60,0){2}{\line(0,-1){16}}
\multiput(204,288)(60,0){2}{\vector(1,0){16}}
\multiput(220,280)(60,0){2}{\framebox(32,16){}}
 
\put(0,360){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSNUM})}}
\put(140,360){\vector(1,0){40}}
\put(180,352){\framebox(120,16){element numbers}}
\multiput(320,360)(-4,0){4}{\line(-1,0){2}}
\put(304,360){\vector(-1,0){4}}
\put(328,360){\makebox(0,0)[l]{\ttindex{LSNUM}}}
 
\put(0,408){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSMAP})}}
\multiput(140,408)(80,0){2}{\vector(1,0){40}}
\multiput(180,400)(80,0){2}{\framebox(40,16){}}
\put(308,408){\makebox(0,0)[l]{TRANSPORT maps}}
 
\put(0,456){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSLIE})}}
\multiput(140,456)(80,0){2}{\vector(1,0){40}}
\multiput(180,448)(80,0){2}{\framebox(40,16){}}
\put(308,456){\makebox(0,0)[l]{Lie algebraic maps}}
 
\put(0,504){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSCOM})}}
\put(140,504){\vector(1,0){40}}
\put(180,496){\framebox(120,16){orbit correction}}
\put(190,512){\line(0,1){36}}
\put(190,556){\vector(0,1){36}}
\put(210,512){\line(0,1){28}}
\put(210,564){\line(0,1){24}}
\put(210,612){\vector(0,1){28}}
\put(230,512){\vector(0,1){32}}
\put(250,512){\line(0,1){36}}
\put(250,556){\vector(0,1){36}}
\put(270,512){\line(0,1){28}}
\put(270,564){\line(0,1){24}}
\put(270,612){\vector(0,1){28}}
\put(290,512){\vector(0,1){32}}
 
\put(0,552){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSCOR})}}
\multiput(140,552)(4,0){14}{\line(1,0){2}}
\put(196,552){\vector(1,0){4}}
\multiput(240,552)(4,0){4}{\line(1,0){2}}
\put(256,552){\vector(1,0){4}}
\multiput(200,544)(60,0){2}{\framebox(40,16){}}
\put(308,552){\makebox(0,0)[l]{corrector strengths}}
 
\put(0,600){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSMON})}}
\multiput(140,600)(4,0){9}{\line(1,0){2}}
\put(176,600){\vector(1,0){4}}
\multiput(220,600)(4,0){4}{\line(1,0){2}}
\put(236,600){\vector(1,0){4}}
\multiput(180,592)(60,0){2}{\framebox(40,16){}}
\put(308,600){\makebox(0,0)[l]{monitor readings}}
 
\put(0,648){\makebox(0,0)[l]{\tt LQ(LCSEQ-\ttindex{MSELM})}}
\multiput(140,648)(4,0){14}{\line(1,0){2}}
\put(196,648){\vector(1,0){4}}
\multiput(240,648)(4,0){4}{\line(1,0){2}}
\put(256,648){\vector(1,0){4}}
\multiput(200,640)(60,0){2}{\framebox(40,16){}}
\put(308,648){\makebox(0,0)[l]{quadrupoles/sextupoles}}
\put(210,624){\vector(0,1){16}}
\put(270,624){\vector(0,1){16}}

\end{picture}
\caption{Structure of Beam Line Expansion}
\index{beam!line!expansion}
\label{Fbexp}
\end{figure}
          
\clearpage
 
\subsection{Machine Imperfections}
\label{Serr}
 
If any misalignment errors exist in the working beam line,
\index{misalignment}
a pointer bank is linked to the link at \ttindex{LSALI)}.
The misalignment errors for an element at position~$n$ are stored in a
{\em misalignment bank}\index{misalignment!bank} supported by link~$n$
in this pointer bank.
The misalignment error bank contains six or ten real or
double-precision values in the following order:
\begin{enumerate}
\item
Horizontal displacement (\ttindex{DX}),
\item
Vertical displacement (\ttindex{DY}),
\item
Longitudinal displacement (\ttindex{DS}),
\item
Rotation angle about $y$-axis (\ttindex{DTHETA}),
\item
Rotation angle about $x$-axis (\ttindex{DPHI}),
\item
Rotation angle about $s$-axis (\ttindex{DPSI}),
\item
Horizontal orbit error (\ttindex{MREX}, for monitors only),
\item
Vertical orbit error (\ttindex{MREY}, for monitors only).
\item
Horizontal dispersion error (\ttindex{MREDX}, for monitors only),
\item
Vertical dispersion error (\ttindex{MREDY}, for monitors only).
\end{enumerate}
Whole beam lines may also be misaligned, and the errors are linked
to their entrance.
To facilitate handling the error banks are duplicated for the exit.
 
Field errors are stored as absolute errors,
\index{field error}
even when entered as relative values.
The {\em field error bank} for an element in position~$n$ is
linked to link~$n$ of the pointer bank at \ttindex{LSFLD}.
Lines or lumps may not have field errors.
The field error banks contain pairs of real or double precision values
in ascending multipole order, beginning at~$0$ with no gaps.
The first value of each pair is the integrated normal multipole,
and the second the integrated skew multipole.
The following elements may have field errors:
 
\begin{description}
\item[Dipole:]
stores and uses dipole through octupole components.
\item[Orbit Corrector:]
stores and uses dipole component only.
\item[Quadrupole:]
stores dipole and quadrupole, uses quadrupole only.
\item[Sextupole:]
stores dipole through sextupole, uses sextupole only.
\item[Octupole:]
stores dipole through octupole, uses octupole only.
\item[Thin Multipole:]
truncates at order~\ttindex{MAXMUL},
stores all orders from zero to the highest non-zero component,
uses all stored error components.
\end{description}
 
\subsection{Element, Corrector and Monitor Tables}
\label{Scorr}
\index{quadrupole table}
\index{sextupole table}
\index{corrector!table}
\index{monitor!table}
\index{corrector!strength}
\index{monitor!reading}
The orbit correction module ``CO'' requires space to store lattice
functions, kicks, quadrupole and sextupole strengths, and orbit
readings.
For this purpose it sets up three lists, pointed at by reference links
{\tt LQ(LCSEQ-MSELM)}, {\tt LQ(LCSEQ-MSCOR)}, and
{\tt LQ(LCSEQ-MSMON)} respectively.
\ttnindex{MSELM}\ttnindex{MSCOR}\ttnindex{MSMON}
The structural links to the banks in these lists are stored in a bank
at {\tt LQ(LCSEQ-MSCOM)}\ttnindex{MSCOM},
and the ``next'' links is stored in each bank in reference link~1.
Walking through one of these structures enables reference to all correctors
or all monitors in order of occurrence, e.~g. for printing purposes.
 
Each bank in these lists contains the following real or double
precision values:
\begin{enumerate}
\item
Horizontal kick (corrector) or orbit reading (monitor),
\item
Vertical kick (corrector) or monitor reading (monitor),
\item
Horizontal dispersion reading (monitor),
\item
Vertical dispersion reading (monitor),
\item
Longitudinal position~$s$,
\item
Horizontal $\beta_x$,
\item
Vertical $\beta_y$,
\item
Horizontal phase $\mu_x$,
\item
Vertical phase $\mu_y$,
\item
Quadrupole strength (quadrupole) or sextupole strength times
dispersion (sextupole).
\end{enumerate}

The corrector and monitor banks are eacg marked with the six status
bits listed in table~\ref{T-com}
\begin{table}[ht]
\centering
\caption{Status bits in Corrector and Monitor Banks}
\label{T-com}
\centering
\begin{tabular}{|r|p{0.8\textwidth}|}
\hline
 &Correctors:\\
\hline
1&Corrector has horizontal action\\
2&Corrector has vertical action\\
3&Corrector has been set by MICADO for horizontal correction\\
4&Corrector has been set by MICADO for vertical correction\\
5&Corrector is activated for horizontal correction\\
6&Corrector is activated for vertical correction\\
\hline
 &Monitors:\\
\hline
1&Monitor reads horizontal plane\\
2&Monitor reads vertical plane\\
3&Monitor is valid for horizontal orbit reading\\
4&Monitor is valid for vertical orbit reading\\
5&Monitor is valid for horizontal dispersion reading\\
6&Monitor is valid for vertical dispersion reading\\
\hline
\end{tabular}
\end{table}

\section{Bank Status Bits}
\label{Smark}
\index{bank!status}
\index{status!bits}
ZEBRA uses a the upper 14~bits of the status word of each bank for 
status information.
The lower 18~bits are available for the user program.
MAD uses eight of these bits to keep track of events.
The definitions for these bits can be found in comdeck \ttindex{MARKBITS}:
\begin{mylist}
\ttitem{MXDRP} Drop bit (Section \ref{AADROP}),
\index{drop bit}
\ttitem{MXORD} Order bit (Section \ref{EXORDR}),
\index{order bit}
\ttitem{MXDEF} Defer bit (Section \ref{EXORDR}),
\index{defer bit}
\ttitem{MXCLS} Class bit (Section \ref{clsmark}),
\index{class!bit}
\ttitem{MXALS} Alias bit (Section \ref{clsmark}),
\index{alias bit}
\ttitem{MXLMP} Recursion bit (Section \ref{AAPMOD}),
\index{recursion bit}
\ttitem{MXKNW} Known bit (Section \ref{AAPMOD}),
\index{known bit}
\ttitem{MXMOD} Modify bit (Section \ref{AAPMOD}).
\index{modify bit}
\end{mylist}

%==============================================================================

\chapter{Global Common Blocks}
\index{common blocks}

\section{Common Block /REFER/}
\label{Srefer}

MAD keeps the most used ZEBRA reference links in a common block
\ttindex{REFER}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>COMMON /REFER/ \>LREF1,\\
\>+\>               \>LCALI, LCATT, LCCLS, LCCMD, LCCOM, LCDEF, LCELM,\\
\>+\>               \>LCEXP, LCFLD, LCKEY, LCSEQ, LCSPL, LCSRC, LCVAR,\\
\>+\>               \>LDBNK(4), LDKEY(4),\\
\>+\>               \>LSALI, LSCOM, LSDIR, LSFLD, LSFLG, LSNUM, LSSPL,\\
\>+\>               \>LREF2\\
\> \>SAVE           \>/REFER/
}
There are service routines to fill these reference links,
and the ZEBRA system keeps them normally up to date.
\begin{mylist}
\ttitem{LCALI}
Misalignments for the current element (Section~\ref{Serr}).
\index{misalignment!pointer} 
\ttitem{LCATT}
\index{attribute!pointer}
Current attribute bank.
\ttitem{LCCLS}
\index{class!pointer}
Current class bank. 
\ttitem{LCCMD}
\index{command!pointer}
Current command or element being decoded.
\ttitem{LCCOM}
\index{corrector!pointer}
\index{monitor!pointer}
Current corrector or monitor bank.  
\ttitem{LCDEF}
\index{default!pointer}
Current default values bank.
\ttitem{LCELM}
\index{element!pointer}
Current beam element during optics or tracking calculation.
\ttitem{LCEXP}
\index{expression!pointer}
Current expression bank.
\ttitem{LCFLD}
\index{field error!pointer}
Field errors for the current element (Section~\ref{Serr}).
\ttitem{LCKEY}
\index{keyword!pointer}
Keyword for current command.
\ttitem{LCSEQ}
\index{main beam line!pointer}
Current main beam line sequence. 
\ttitem{LCSPL}
\index{split pointer}
Current split pointer.  
\ttitem{LCSRC}
\index{source pointer}
Current source bank for copy or defaults.   
\ttitem{LCVAR}
\index{variable! pointer}
Current variable reference bank.
\ttitem{LDBNK(4)}
Data object directory (see~Section~\ref{Sdir}).
\ttitem{LDKEY(4)}
Keyword directory (see~Section~\ref{Sdir}).
\ttitem{LSALI}
\index{misalignment!bank}
Bank for misalignment pointer sequence. 
\ttitem{LSCOM}
\index{corrector!and monitor bank}
Bank for corrector and monitor table.   
\ttitem{LSDIR}
\index{sequence!index bank}
Bank for directory index sequence.  
\ttitem{LSFLD}
\index{sequence!pointer bank}
Bank for field error pointer sequence.  
\ttitem{LSFLG}
\index{sequence!flag bank}
Bank for position flag sequence.
\ttitem{LSNUM}
\index{sequence!occurrence bank}
Bank for occurrence numbers.
\ttitem{LSSPL}
\index{sequence!split bank}
Bank holding split pointers.
\end{mylist}
 
\section{Common block BEAM and BEAM bank}
\label{Sbdata}
When MAD sees a \ttindex{BEAM} command,
it builds a special command bank with the name \ttindex{BEAM}
to hold the information read on the \ttindex{BEAM} command.
This command bank holds also any information about the
circulating beam which has been computed by the program.
For faster access the beam description is duplicated in comdeck
\ttindex{BEAM}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>COMMON /BEANAM/   \>PRTNAM\\
     \> \>COMMON /BEAFLT/   \>AMASS, CHARGE, ENERGY, PC, GAMMA,\\
     \>+\>                  \>EX, EXN, EY, EYN, ET, SIGT, SIGE,\\
     \>+\>                  \>BUNCH, PARNUM, CURRNT, SIGX, SIGY,\\
     \>+\>                  \>FREQ0, BETA, U0, ARAD, PDAMP(3)\\
     \> \>COMMON /BEAINT/   \>IETFLG, IPNFLG\\
     \> \>COMMON /BEALOG/   \>FBCH, FRAD\\
     \> \>SAVE              \>/BEANAM/, /BEAFLT/, /BEAINT/, /BEALOG/\\
     \> \>LOGICAL           \>FBCH, FRAD\\
     \> \>CHARACTER*(MCNAM) \>PRTNAM
}
Here are the data entered with the \ttindex{BEAM} command:
\begin{mylist}
\ttitem{PRTNAM}
\index{particle!name}
Name of the beam particles in character format,
\ttitem{AMASS}
\index{mass}\index{particle!mass}
Mass of the beam particles in $GeV /c^2$,
\ttitem{CHARGE}
\index{charge}\index{particle!charge}
Charge of the beam particles in elementary charges,
\ttitem{ENERGY}
\index{energy}\index{particle!energy}
Nominal energy of a beam particle in $GeV$,
\ttitem{PC}
\index{momentum}\index{particle!momentum}
Nominal momentum of a beam particle in $GeV/c$,
\ttitem{GAMMA}
\index{relativistic}
Relativistic parameter $\gamma = E / m_0$,
\ttitem{EX}
\index{emittance!horizontal}\index{horizontal!emittance}
Horizontal emittance (Courant-Snyder invariant) in~$m$,
\ttitem{EXN}
Normalized horizontal emittance $E_{xn} = 4 \beta \gamma E_x$,
\ttitem{EY}
\index{emittance!vertical}\index{vertical!emittance}
Vertical emittance (Courant-Snyder invariant) in~$m$,
\ttitem{EYN}
Normalized vertical emittance $E_{yn} = 4 \beta \gamma E_y$,
\ttitem{ET}
\index{emittance!longitudinal}\index{longitudinal emittance}
Longitudinal emittance $E_t = c \sigma_t \sigma_E$,
\ttitem{SIGT}
\index{bunch!length}
Bunch length $c \sigma_t$,
\ttitem{SIGE}
\index{energy!spread}
Energy spread $\sigma_E$,
\ttitem{BUNCH}
Number of bunches,
\ttitem{PARNUM}
\index{particle!per bunch}
Number of particles per bunch,
\ttitem{CURRNT}
\index{bunch!current}\index{current per bunch}
Bunch current in~$A$,
\ttitem{FBCH}
\index{bunch!flag}
If {\tt .TRUE.}, the beam is bunched.
\ttitem{FRAD}
\index{radiation!flag}
\index{synchrotron!radiation flag}
If {\tt .TRUE.}, synchrotron radiation is considered.
\end{mylist}
The following values are computed and stored by MAD:
\begin{mylist}
\ttitem{FREQ0}
\index{revolution frequency}
The revolution frequency in {\sl MHz}.
\ttitem{SIGX}
\index{beam!size}
Horizontal beam size $\sigma_x$,
\ttitem{SIGY}
Vertical beam size $\sigma_y$,
\ttitem{BETA}
\index{beta}
Relativistic parameter $\beta = v / c$,
\ttitem{U0}
\index{radiation!loss}
Synchrotron radiation loss per turn in~$GeV$,
\ttitem{ARAD}
\index{electron radius}
\index{particle!radius}
Classical particle radius (electron radius for electrons),
\ttitem{PDAMP(3)}
\index{damping partition numbers}
Damping partition numbers.
\ttitem{IETFLG}
\index{emittance flag}
Tells which value was given to specify the longitudinal emittance:
\begin{description}
\item[0:] None given,
\item[1:] \ttindex{ET} given,
\item[2:] \ttindex{SIGT} given,
\item[3:] \ttindex{SIGE} given.
\end{description}
\ttitem{IPNFLG}
\index{particle!number flag}
Tells which value was given to specify the number of particles:
\begin{description}
\item[0:] None given,
\item[1:] \ttindex{BCURRENT} given,
\item[2:] \ttindex{NPART} given,
\end{description}
\end{mylist}
Before each command executed, MAD calls subroutine \ttindex{ENGET}
(Section~\ref{ENGET})
to copy the contents of the \ttindex{BEAM} bank into this block.
 
To store something into the beam bank,
one has to store the information in the \ttindex{BEAM} common,
and then to call \ttindex{ENPUT} (Section~\ref{ENPUT}) to copy the data
to the \ttindex{BEAM} bank.
 
\section{Keyword Data}
\label{Skywd}
\index{keyword!data}
Simple access to the contents of a keyword definition is possible
by using the comdeck \ttindex{KEYWORD}:
\myxmp{
XXXXXX\=XXXXXXXXXXXXXXXXXX\=\kill
      \=PARAMETER         \=(MAXAT = 100)\\
      \=COMMON /KEYWDI/   \=IATYPE(MAXAT),IADIM1(MAXAT),IADIM2(MAXAT),IADIM3(MAXAT)\\
      \=COMMON /KEYWDC/   \=KATNAM(MAXAT)\\
      \=SAVE              \=/KEYWDI/, /KEYWDC/\\
      \=CHARACTER*(MCNAM) \=KATNAM
}
It can be loaded from a keyword bank by calling \ttindex{KWGET}
(Section~\ref{KWGET}).
The variables used above have the following meaning:
\begin{mylist}
\ttitem{MAXAT}
A parameter defining the maximum number of arguments,
counting arrays for one argument.
\ttitem{IATYPE(i)}
\index{MAD data type}
The MAD data type for the $i^{th}$~attribute.
\ttitem{IADIM1(i)}
\index{dimension}
The first dimension for the $i^{th}$~attribute.
\ttitem{IADIM2(i)}
The second dimension for the $i^{th}$~attribute.
\ttitem{IADIM3(i)}
\index{dimension}
\ttitem{KATNAM(i)}
\index{attribute!name}
The name of the $i^{th}$~attribute.
\end{mylist}
 
\section{TRANSPORT Map for Current Element}
\label{Smape}
\index{TRANSPORT map}
The subroutine \ttindex{TMMAP} (Section~\ref{TMMAP}) returns the TRANSPORT
map for an element in the common block \ttindex{MAPELM}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>COMMON /MAPELM/   \>RE(6,6), TE(6,6,6)\\
     \> \>SAVE              \>/MAPELM/
}
with the arrays
\begin{mylist}
\ttitem{RE}
\index{transfer!matrix}
the first-order transfer matrix for the element.
\ttitem{TE}
\index{second-order}
The second-order terms of the TRANSPORT map.
\end{mylist}
 
\section{TRANSPORT Map for one Turn}
\label{Smapt}
\ttindex{TMREFE} (Section~\ref{TMREFE}), 
\ttindex{TMFRST} (Section~\ref{TMFRST}),
and \ttindex{TMSCND} (Section~\ref{TMSCND})
return the linear transfer matrix or the TRANSPORT map for one turn
in the common block \ttindex{MAPTRN}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>COMMON /MAPTRN/   \>RT(6,6), TT(6,6,6), RTP(6,6)\\
     \> \>SAVE              \>/MAPTRN/
}
with the arrays
\begin{mylist}
\ttitem{RT}
\index{transfer!matrix}
the first-order transfer matrix for one turn.
\ttitem{TT}
\index{second-order}
The second-order terms of the TRANSPORT map for one turn
(not for \ttindex{TMREFE}).
\ttitem{RTP}
Some routines of the Twiss module use this array to store the first
derivative of the linear transfer matrix with respect
to the relative energy error.
\end{mylist}
 
\section{Lattice Functions for Beginning of Line}
\label{Sopt0}
\index{lattice function}
The initial values for the lattice functions are kept in the common
block \ttindex{OPTIC0}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>COMMON /OPTIC0/   \>BETX0, ALFX0, AMUX0, BETY0, ALFY0, AMUY0,\\
     \>+\>                  \>ORBIT0(6), DISP0(6),\\
     \>+\>                  \>WX0, PHIX0, DMUX0, WY0, PHIY0, DMUY0,\\
     \>+\>                  \>DDISP0(6), CIRC, R0MAT(2,2)\\
     \> \>SAVE              \>/OPTIC0/
}
It contains the variables
\begin{mylist}
\ttitem{BETX0}
$\beta_x$ or, for coupled machines, $\beta_1$.
\ttitem{ALFX0}
$\alpha_x$ or, for coupled machines, $\alpha_1$.
\ttitem{AMUX0}
$\mu_x$ or, for coupled machines, $\mu_1$.
\ttitem{BETY0}
$\beta_y$ or, for coupled machines, $\beta_2$.
\ttitem{ALFY0}
$\alpha_y$ or, for coupled machines, $\alpha_2$.
\ttitem{AMUY0}
$\mu_y$ or, for coupled machines, $\mu_2$.
\ttitem{ORBIT0(6)}
closed orbit position ($x$, $p_x$, $y$, $p_y$, $ct$, $\delta E/p_0$).
\ttitem{DISP0(6)}
dispersion vector, i.e. derivative of closed orbit with respect to
the relative energy error.
\ttitem{WX0}
The chromatic amplitude $W_x$.
\ttitem{PHIX0}
The chromatic phase $\Phi_x$.
\ttitem{DMUX0}
The derivative of $\mu_x$ with respect to the relative energy error.
\ttitem{WY0}
The chromatic amplitude $W_y$.
\ttitem{PHIY0}
The chromatic phase $\Phi_y$.
\ttitem{DMUY0}
The derivative of $\mu_y$ with respect to the relative energy error.
\ttitem{DDISP0(6)}
The second derivative of the closed orbit vector with respect to
the relative energy error.
\ttitem{CIRC}
The machine circumference.
\ttitem{R0MAT(2,2)}
The coupling matrix,
defined as $R \tan \phi$ in the formalism by L.~C.~Teng~\cite{TENG}.
\end{mylist}
 
\section{Lattice Functions for Current Position}
\label{Sopt1}
\index{lattice function}
The values of the lattice functions are stored in common block
\ttindex{OPTIC1},
which is organized in the same way as \ttindex{OPTIC0}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>COMMON /OPTIC1/   \>BETX, ALFX, AMUX, BETY, ALFY, AMUY,\\
     \>+\>                  \>ORBIT(6), DISP(6),\\
     \>+\>                  \>WX, PHIX, DMUX, WY, PHIY, DMUY,\\
     \>+\>                  \>DDISP(6), SUML, RMAT(2,2)\\
     \> \>SAVE              \>/OPTIC1/
}
It contains the variables
\begin{mylist}
\ttitem{BETX}
$\beta_x$ or, for coupled machines, $\beta_1$.
\ttitem{ALFX}
$\alpha_x$ or, for coupled machines, $\alpha_1$.
\ttitem{AMUX}
$\mu_x$ or, for coupled machines, $\mu_1$.
\ttitem{BETY}
$\beta_y$ or, for coupled machines, $\beta_2$.
\ttitem{ALFY}
$\alpha_y$ or, for coupled machines, $\alpha_2$.
\ttitem{AMUY}
$\mu_y$ or, for coupled machines, $\mu_2$.
\ttitem{ORBIT(6)}
closed orbit position ($x$, $p_x$, $y$, $p_y$, $ct$, $\delta E/p_0$).
\ttitem{DISP(6)}
dispersion vector, i.e. derivative of closed orbit with respect to
the relative energy error.
\ttitem{WX}
The chromatic amplitude $W_x$.
\ttitem{PHIX}
The chromatic phase $\Phi_x$.
\ttitem{DMUX}
The derivative of $\mu_x$ with respect to the relative energy error.
\ttitem{WY}
The chromatic amplitude $W_y$.
\ttitem{PHIY}
The chromatic phase $\Phi_y$.
\ttitem{DMUY}
The derivative of $\mu_y$ with respect to the relative energy error.
\ttitem{DDISP(6)}
The second derivative of the closed orbit vector with respect to
the relative energy error.
\ttitem{SUML}
The length accumulated at the current position.
\ttitem{RMAT(2,2)}
The coupling matrix,
defined as $R \tan \phi$ in the formalism by L.~C.~Teng~\cite{TENG}.
\end{mylist}
 
\section{Option Flags}
\label{Sopt}
\index{option}
Execution of MAD is controlled by flags which may be set by
the user.
These flags are set by the \ttindex{OPTION} command and reside in
the common block \ttindex{OPTION}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill                             
     \> \>COMMON /OPTFLT/\>OPTFLT(10)\\
     \> \>EQUIVALENCE    \>(COFACT, OPTFLT( 1))\\
     \> \>COMMON /OPTINT/\>OPTINT(10)\\
     \> \>INTEGER        \>OPTINT\\
     \> \>INTEGER        \>ICMDFL, IDEFFL, IEXPFL, IKEYFL, ILINFL\\
     \> \>EQUIVALENCE    \>(ICMDFL, OPTINT(1)), (IDEFFL, OPTINT(2))\\
     \> \>EQUIVALENCE    \>(IEXPFL, OPTINT(3)), (IKEYFL, OPTINT(4))\\
     \> \>EQUIVALENCE    \>(ILINFL, OPTINT(5))\\
     \> \>COMMON /OPTLOG/\>OPTFLG(20), OPTCON(5)\\
     \> \>LOGICAL        \>OPTFLG, OPTCON\\
     \> \>LOGICAL        \>DEBUG, DOUBLE, ECHO, INTER, TRACE, VERIFY,\\
     \>+\>               \>WARN, INFO, SYMPL\\
     \> \>LOGICAL        \>RESET, TELL\\
     \> \>EQUIVALENCE    \>(DEBUG,  OPTFLG(1)), (DOUBLE, OPTFLG(2))\\
     \> \>EQUIVALENCE    \>(ECHO,   OPTFLG(3)), (INTER,  OPTFLG(4))\\
     \> \>EQUIVALENCE    \>(TRACE,  OPTFLG(5)), (VERIFY, OPTFLG(6))\\
     \> \>EQUIVALENCE    \>(WARN,   OPTFLG(7)), (INFO,   OPTFLG(8))\\
     \> \>EQUIVALENCE    \>(SYMPL,  OPTFLG(9))\\
     \> \>EQUIVALENCE    \>(RESET,  OPTCON(1)), (TELL,   OPTCON(2))\\
}
\begin{mylist}
\ttitem{COFACT}
A real value used to limit the corrections at each iteration in closed
orbit search.

\ttitem{ICMDFL}
Dump all new commands.
\ttitem{IDEFFL}
Dump all new elements and parameters.
\ttitem{IEXPFL}
Dump all new expressions, and evaluated ones.
\ttitem{IKEYFL}
Dump all new keywords.
\ttitem{ILINFL}
Dump all new lines.

\ttitem{DEBUG}
True implies printing of messages for marking and dropping modified
banks.
\ttitem{DOUBLE}
If true, TFS tables are created in double precision.
\ttitem{ECHO}
True, to print input echo.
\ttitem{INTER}
True, if MAD runs in interactive mode.
\ttitem{TRACE}
True, to print messages for command begin and end.
The message includes information about timing.
\ttitem{VERIFY}
True implies \ttindex{VERIFY} option.
\ttitem{WARN}
If true, warning messages are printed.
\ttitem{INFO}
If true, information messages are printed.
\ttitem{SYMPL}
True forces symplectification of transfer matrices.

\ttitem{RESET}
True implies rest of all options to their defaults in the
(\ttindex{OPTION} command).
\ttitem{TELL}
True implies printing of all options in the \ttindex{OPTION} command.
\end{mylist}

The values of the 5 integer flags mean:
\begin{description}
\item[0:]
No dump.
\item[1:]
Dump in ``readable'' format.
\item[2:]
Dump in ZEBRA format.
\item[3:]
Dump in both formats.
\end{description}
 
\section{Physical Constants}
\label{Sphys}
\index{physical constants}
\index{constants}
Many useful physical constants are available in comdeck
\ttindex{PHYSICPM}:
\ttindex{CLIGHT}
\ttindex{AMU0}
\ttindex{EPS0}
\ttindex{HBAR}
\ttindex{QELECT}
\ttindex{FALFA}
\ttindex{EMASS}
\ttindex{ERAD}
\ttindex{ELAMDA}
\ttindex{ASUBE}
\ttindex{PMASS}
\ttindex{PRAD}
\ttindex{PLAMDA}
\ttindex{ASUBP}
\myxmp{
XXXXXX\=\kill
*---- \>Universal physical constants.\\
{*}     \>Velocity of light [m/s]:\\
      \>PARAMETER         (CLIGHT = 2.997 924 58 D+08)\\
{*}     \>Permeability of vacuum [V*s/A*m]:\\
      \>PARAMETER         (AMU0   = 1.256 637 061D-06)\\
{*}     \>Permittivity of vacuum [A*S/V*m]:\\
      \>PARAMETER         (EPS0   = 8.854 187 817D-12)\\
{*}     \>Reduced Planck's constant [GeV*s]:\\
      \>PARAMETER         (HBAR   = 6.582 122 0  D-25)\\
      \>\\
{*}---- \>Electromagnetic constants.\\
{*}     \>Elementary charge [A*s]:\\
      \>PARAMETER         (QELECT = 1.602 177 33 D-19)\\
{*}     \>Fine structure constant [1]:\\
      \>PARAMETER         (FALFA  = 7.297 353 08 D-03)\\
      \>\\
{*}---- \>Electron.\\
{*}     \>Rest mass [GeV]:\\
      \>PARAMETER         (EMASS  = 0.510 999 06 D-03)\\
{*}     \>Classical radius [m]:\\
      \>PARAMETER         (ERAD   = 2.817 940 92 D-15)\\
{*}     \>Reduced Compton wavelength [m]:\\
      \>PARAMETER         (ELAMDA = 3.861 593 23 D-13)\\
{*}     \>Magnetic moment anomaly [1]:\\
      \>PARAMETER         (ASUBE  = 1.159 652 193D-03)\\
      \>\\
{*}---- \>Proton.\\
{*}     \>Rest mass [GeV]:\\
      \>PARAMETER         (PMASS  = 0.938 272 31 D+00)\\
{*}     \>Classical radius [m]:\\
      \>PARAMETER         (PRAD   = 1.534 698 57 D-18)\\
{*}     \>Reduced Compton wavelength [m]:\\
      \>PARAMETER         (PLAMDA = 2.103 089 37 D-16)\\
{*}     \>Magnetic moment anomaly [1]:\\
      \>PARAMETER         (ASUBP  = 1.792 847 386D+00)
}
The value of~$\pi$ is available in comdeck \ttindex{PI}:
\index{mathematical constant}
\myxmp{
      PARAMETER         (PI = 3.1415926535898D0)
}
 
\section{Data for Main Working Beam Line}
\label{Swline}
\index{main beam line}
Most program modules require a working beam line to be set.
For simple access they may copy the most important data for this
line into a set of common blocks by calling \ttindex{UTBEAM}
(Section~\ref{UTBEAM}).
The comdeck \ttindex{RANGE} defines these common blocks as:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>COMMON /RNGCHR/   LINNAM, RNGNAM\\
     \> \>CHARACTER         LINNAM*(MCNAM), RNGNAM*(MCRNG)\\
     \> \>COMMON /RNGINT/   IRG1, IRG2, NSUP\\
     \> \>COMMON /RNGLOG/   SYMM\\
     \> \>LOGICAL           SYMM\\
     \> \>SAVE              /RNGCHR/, /RNGINT/, /RNGLOG/
}
with the variables:
\begin{mylist}
\ttitem{LINNAM}
The name of the main working beam line.
\ttitem{RNGNAM}
\index{range}
A character string encoding the current range set by a \ttindex{USE}
command.
\ttitem{IRG1}
The index into the working beam line for the beginning of the range.
\ttitem{IRG2}
The index into the working beam line for the end of the range.
\ttitem{NSUP}
\index{superperiods}
Number of superperiods.
\ttitem{SYMM}
\index{symmetry}
The symmetry flag.
\end{mylist}
 
\section{Status Flags}
\label{Sstat}
\index{status!flags}
The status flags are set by the program in response to certain
situations to help in deciding how to deal with computations.
They are held in common block \ttindex{STATUS}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>COMMON /STATUS/ \>ERROR,  SCAN,   NWARN,  NFAIL, IMODUL, IPLFLG,\\
\>+\>                \>INVAL,  MAYCPL, STABX,  STABY,  STABT,\\
\>+\>                \>NEWCOR, NEWMAP, PROMPT\\
\> \>SAVE            \>/STATUS/\\
\> \>LOGICAL         \>ERROR,  SCAN,\\
\>+\>                \>INVAL,  MAYCPL, STABX,  STABY,  STABT,\\
\>+\>                \>NEWCOR, NEWMAP, PROMPT
}
\begin{mylist}
\ttitem{ERROR}
\index{fatal error}
\index{error}
Fatal error in current command.
\ttitem{SCAN}
\index{scanning mode}
Scanning mode.
\ttitem{NWARN}
\index{warning}
Warning message count.
\ttitem{NFAIL}
\index{error}
Fatal error message count.
\ttitem{IMODUL}
\index{active process}
\index{process}
Process code for the current module (for \ttindex{HARMON},
\ttindex{MATCH}, \ttindex{TRACK}, \ttindex{SEQEDIT}, etc.).
\ttitem{IPLFLG}
\index{plot}
Zero, if no plot has been generated, set to one by first plot.
\ttitem{INVAL}
\index{initial values}
Optics computed with initial values.
\ttitem{MAYCPL}
\index{coupling}
Coupling effects found.
\ttitem{STABX}
\index{stability}
First mode is stable (usually horizontal).
\ttitem{STABY}
Second mode is stable (usually vertical).
\ttitem{STABT}
Third mode is stable (usually longitudinal).
\ttitem{NEWCOR}
\index{corrector!table}
\index{monitor!table}
Optical functions in table of correctors and monitors should be
recomputed.
\ttitem{NEWMAP}
\index{transfer!maps}
Precomputed maps should be dropped.
\ttitem{PROMPT}
\index{prompt}
Print prompt {\tt \ ``M: ==>''} before reading an input line.
\end{mylist}

A second common block contains flags which control program actions.
\index{control flags}
Several commands in MAD are not able to deal with all situations.
The control flags are set according to the data before each command;
those command routines may change the settings within certain limits.
\ttnindex{STFLAG}\ttnindex{CPFLAG}\ttnindex{DOFLAG}
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>PARAMETER       \>(MAXCPF = 10, MAXDOF = 10)\\
\> \>COMMON /STFLAG/ \>CPFLAG(MAXCPF), DOFLAG(MAXDOF)\\
\> \>LOGICAL         \>CPFLAG, CPLXY, CPLXT\\
\> \>LOGICAL         \>DOFLAG, DOCAV, DORAD, DOALI, DOFLD, DOKICK\\
\> \>SAVE            \>/STFLAG/\\
\> \>EQUIVALENCE     \>(CPLXY, CPFLAG(1)), (CPLXT, CPFLAG(2))\\
\> \>EQUIVALENCE     \>(DOCAV, DOFLAG(1)), (DORAD, DOFLAG(2))\\
\> \>EQUIVALENCE     \>(DOALI, DOFLAG(3)), (DOFLD, DOFLAG(4))\\
\> \>EQUIVALENCE     \>(DOKICK, DOFLAG(5))\\
}
The meaning of the flags is:
\begin{mylist}
\ttitem{CPLXY}
\index{coupling}
If {\tt true}, transverse coupling has been detected.
\ttitem{CPLXT}
\index{coupling}
If {\tt true}, synchro-betatron coupling has been detected.
\ttitem{DOCAV}
\index{coupling}
If {\tt true}, cavities are considered.
\ttitem{DORAD}
\index{coupling}
If {\tt true}, synchrotron radiation is considered.
\ttitem{DOALI}
\index{coupling}
If {\tt true}, alignment errors are considered.
\ttitem{DOFLD}
\index{coupling}
If {\tt true}, field errors are considered.
\ttitem{DOKICK}
\index{coupling}
If {\tt true}, the orbit corrector table is considered.
\end{mylist}
The flags whose names begin with {\tt CP} are set by various optics
routines. They should be reset to {\tt false} before running through
the machine.

The flags whose names begin with {\tt DO} are set to {\tt true} before
each command (except \ttindex{DORAD} which is set from the {\tt BEAM}
command.
If any of the effects is not desired,
a program module should reset the flag to {\tt false},
do its computations, and then reset it to the value it had upon entry.
 
\section{Summary Data for Optics}
\label{Ssumm}
\index{summary}
The global results of an optics calculation are kept in common block
\ttindex{SUMMRY}:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>COMMON /SUMMRY/ \>QX, XIX, COSMUX, SINMUX, BXMAX, DXMAX, XCOMAX,\\
\>+\>                \>SIGXCO, SIGDX,\\
\>+\>                \>QY, XIY, COSMUY, SINMUY, BYMAX, DYMAX, YCOMAX,\\
\>+\>                \>SIGYCO, SIGDY,\\
\>+\>                \>QS, ALFA, GAMTR, RBAR, DELTA\\
\> \>SAVE            \>/SUMMRY/
}
It contains the variables:
\begin{mylist}
\ttitem{QX}
\index{horizontal!tune}
\index{tune}
Horizontal tune $Q_x$.
\ttitem{XIX}
\index{horizontal!chromaticity}
\index{chromaticity}
Horizontal chromaticity $\xi_x = d Q_x / d \delta$.
\ttitem{COSMUX}
$\cos (2 \pi \mu_x)$
\ttitem{SINMUX}
$\sin (2 \pi \mu_x)$
\ttitem{BXMAX}
Maximum value of $\beta_x$.
\ttitem{DXMAX}
\index{horizontal!dispersion}
\index{dispersion}
Maximum value of horizontal dispersion $D_x$.
\ttitem{XCOMAX}
\index{horizontal!orbit}
\index{orbit}
Maximum horizontal orbit deviation.
\ttitem{SIGXCO}
\index{horizontal!beam size}
\index{beam!size}
Horizontal standard deviation for orbit.
\ttitem{SIGDX}
Horizontal standard deviation for dispersion.
\ttitem{QY}
\index{vertical!tune}
\index{tune}
Vertical tune $Q_y$.
\ttitem{XIY}
\index{vertical!chromaticity}
\index{chromaticity}
Vertical chromaticity $\xi_y = d Q_y / d \delta$.
\ttitem{COSMUY}
$\cos (2 \pi \mu_y)$
\ttitem{SINMUY}
$\sin (2 \pi \mu_y)$
\ttitem{BYMAX}
Maximum value of $\beta_y$.
\ttitem{DYMAX}
\index{vertical!dispersion}
\index{dispersion}
Maximum value of vertical dispersion $D_y$.
\ttitem{YCOMAX}
\index{vertical!orbit}
\index{orbit}
Maximum vertical orbit deviation.
\index{vertical!beam size}
\index{beam!size}
\ttitem{SIGYCO}
Vertical standard deviation for orbit.
\ttitem{SIGDY}
Vertical standard deviation for dispersion.
\ttitem{QS}
\index{synchrotron!tune}
\index{tune}
Synchrotron tune $Q_s$.
\ttitem{ALFA}
\index{momentum!compaction}
Momentum compaction.
\ttitem{GAMTR}
\index{transition energy}
Transition energy factor $\gamma_{tr} = E_{tr} / m_0$.
\ttitem{RBAR}
\index{machine radius}
\index{average radius}
Average machine radius.
\ttitem{DELTA}
\index{energy!error}
Relative energy error (global average in the presence of cavities).
\end{mylist}
 
\section{Logical Unit Numbers for Input and Output}
\label{Sunit}
\index{file}
\index{I/O stream}
\index{stream}
The logical unit numbers for the standard input/output files are
kept in common block \ttindex{ZUNIT}.
Most of them are set by the ZEBRA system:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>COMMON /ZUNIT/  \>IQREAD, IQPRNT, IQPR2,  IQLOG,  IQPNCH,\\
\>+\>                \>IQTTIN, IQTYPE\\
\> \>SAVE            \>/ZUNIT/
}
The unit numbers have the following meaning:
\begin{mylist}
\ttitem{IQREAD}
\index{input}
Logical unit number for current input file.
\ttitem{IQPRNT}
\index{output}
Logical unit number for ZEBRA print file.
Since ZEBRA uses this unit for some messages, it is made the same
as for the ECHO file.
\ttitem{IQPR2}
Logical unit number for PRINT print file (receives all listings).
\ttitem{IQLOG}
\index{log file}
Logical unit number for ECHO file (receives all messages).
\ttitem{IQPNCH}
\index{punch}
Logical unit for PUNCH file (not used).
\ttitem{IQTTIN}
\index{terminal}
Logical unit for terminal input.
\ttitem{IQTYPE}
Logical unit for terminal output.
\end{mylist}

%==============================================================================

\part{MAD Subroutines and Functions}

%==============================================================================

\chapter{Main Module ``AA''}
\label{AA}
The \ttindex{AA}~module is the main executive of MAD.
It also contains a few general-purpose utilities.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{AA}~Module}
\label{T-AA}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{AAATTR}&Decode attributes for a statement&\ref{AAATTR}\\
\ttindex{AABOOK}&Book new statement bank&\ref{AABOOK}\\
\ttindex{AACMND}&Decode executable command&-\\
\ttindex{AACOPY}&Copy attributes between banks&\ref{AACOPY}\\
\ttindex{AADROP}&Drop statement bank&\ref{AADROP}\\
\ttindex{AADUMP}&Dump command or element definition&\ref{AADUMP}\\
\ttindex{AAELEM}&Decode element definition&-\\
\ttindex{AAEXEC}&Execute command&\ref{AAEXEC}\\
\ttindex{AAFAIL}&Print fatal error message&\ref{AAFAIL}\\
\ttindex{AAINFO}&Print fatal error message&\ref{AAFAIL}\\
\ttindex{AAINIT}&Initialize MAD data structure&-\\
\ttindex{AAMAIN}&
  Main loop routine for commands and definitions&\ref{AAMAIN}\\
\ttindex{AAMARK}&Mark bank as modified&\ref{AAMARK}\\
\ttindex{AAOPTS}&Command routine for \ttindex{OPTION}&-\\
\ttindex{AAPARA}&Command routine for \ttindex{PARAMETER}&-\\
\ttindex{AAPDRP}&
  Delete precomputed maps after change in \ttindex{BEAM} common&
  \ref{AAPDRP}\\
\ttindex{AAPMOD}&
  Delete precomputed maps after parameter change&\ref{AAPMOD}\\
\ttindex{AAPROC}&
  Build procedure list for \ttindex{SUBROUTINE} or \ttindex{DO}&-\\
\ttindex{AAREAD}&Read complete command&-\\
\ttindex{AARUNS}&Execute \ttindex{SUBROUTINE} or \ttindex{DO}&-\\
\ttindex{AASERV}&
  Switch routine for process code \ttindex{MPSRV} (services)&-\\
\ttindex{AASET} &Command routine for \ttindex{SET} command&-\\
\ttindex{AASMOD}&Check validity for redefinitions&\ref{AASMOD}\\
\ttindex{AASUBR}&
  Switch routine for process code \ttindex{MPSUB} (subroutines)&-\\
\ttindex{AAVALU}&Command routine for \ttindex{VALUE} command&-\\
\ttindex{AAWARN}&Print warning message&\ref{AAFAIL}\\
\hline
\end{tabular}
\end{table}

\section{Statement Execution}
\label{AAMAIN}
The call
\mybox{CALL AAMAIN}
is the main program loop of MAD.
It reads statements from the current input file until it sees a
\ttindex{STOP} statement.
MAD calls it twice,
the first time to read the command dictionary,
and the second time to read the user's commands.

For each command \ttindex{AAMAIN} calls \ttindex{AAREAD} to read and
decode it.
Then it calls the proper switch routine for any definition or
subroutine command.
For executable commands it calls \ttindex{AAEXEC} to force the correct
housekeeping to be done.

\section{Switch Routine for Executable Commands}
\label{AAEXEC}
\mybox{CALL AAEXEC(LABEL,KEY)}
The parameters of \ttindex{AAEXEC} are the command label and keyword
respectively.
The routine performs the necessary book-keeping and uses the process
code of the command to select another switch routine which in turn
calls the proper command routine.
It is called for all executable commands,
i.~e. for commands having process codes greater than~10.
If a new process code is introduced,
a new path must be added to the multi-way IF-statement within this
routine.

\section{Book a New Statement Bank}
\label{AABOOK}
\mybox{CALL AABOOK(LBANK,LABEL,IPR,ISP,ILN,ILINK)}
books a new statement bank and links it to the current keyword,
pointed at by \ttindex{LCKEY}.
The routine assumes that the current keyword pointer \ttindex{LCKEY}
has been set,
and that the \ttindex{KEYWORD} common has been filled by a call to
\ttindex{KWGET}.
The arguments of \ttindex{AABOOK} are:
\begin{mylist}
\item[\tt LBANK]
Pointer to the bank booked (output).
\item[\tt LABEL]
Name for the new bank (4 characters used, input).
\item[\tt IPR]
Process code to be stored (input).
\item[\tt ISP]
Subprocess code to be stored (input).
\item[\tt ILN]
Input line number, indicating the beginning of the definition
command (input).
\item[\tt ILINK]
Number of the link in the current keyword bank which supports
the new bank (input).
\end{mylist}

\section{Attribute Decoding}
\label{AAATTR}
\mybox{CALL AAATTR(LDEF,LBANK,NKAT,EFLAG)}
decodes the attributes of a statement and fills a command bank.
It assumes that the current keyword pointer \ttindex{LCKEY} is set,
and that the \ttindex{KEYWORD} common has been filled by a call to
\ttindex{KWGET}.
It normally also checks that all attributes given are used,
but optionally it returns when it sees the first unknown attribute.
This permits to continue decoding using a different template,
a feature used by the sequence editor of MAD.
\ttindex{AAATTR} has the following arguments:
\begin{mylist}
\item[\tt LDEF]
Pointer to the bank containing the \emindex{second default}
\index{default!second} (input).
\item[\tt LBANK]
Pointer to the command bank to be filled (input).
\item[\tt NKAT]
Number of attributes of the corresponding keyword (input).
If this value is positive,
\ttindex{AAATTR} prints an error message if it sees an unknown
attribute.
If it is negative,
its absolute value is the number of attributes,
and the routine returns when it sees the first unknown attribute.
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Copy Attribute from a Bank to Another}
\label{AACOPY}
\mybox{CALL AACOPY(LSRC,ILINK,LTAR)}
copies one attribute from the source bank to the corresponding attribute
in the target bank and builds all the required links.
It has the arguments
\begin{mylist}
\item[\tt LSRC]
Pointer to the source bank (input).
\item[\tt ILINK]
Number of the attribute to be copied (same in both banks, input).
\item[\tt LTAR]
Pointer to the target bank (input).
\end{mylist}

\section{Dropping a Command or Definition}
\label{AADROP}
\mybox{CALL AADROP(L)}
\ttnindex{AADROP}
deletes a command or definition pointed at by {\tt L}.
This call first marks any dependent expression and variable reference
banks by setting the \emindex{drop bit}~\ttindex{MXDRP} 
and then unlinks them from the corresponding tables.
Finally it deletes the command or definition bank and all its
dependent banks.

\section{Dump a Command or Element Definition}
\label{AADUMP}
\ttnindex{AADUMP}
\mybox{CALL AADUMP(L)}
writes the contents of a command or definition pointed at by {\tt L}
on the ECHO file.
\clearpage

\section{Program Messages}
\label{AAFAIL}
\label{AAINFO}
\label{AAWARN}
The calls
\mybox{
CALL AAFAIL(SUBR,NLINES,MSG)\\
CALL AAINFO(SUBR,NLINES,MSG)\\
CALL AAWARN(SUBR,NLINES,MSG)
}
are used for all messages produced by MAD.
The arguments are the same for all three routines:
\begin{mylist}
\item[\tt SUBR]
Character constant containing the name of the calling routine.
This will be printed as part of the message.
\item[\tt NLINES]
Number of lines to be printed.
\item[\tt MSG]
A character array dimensioned in these routines as
\myxmp{CHARACTER*(*) MSG(*)}
containing the message.
A common block has been defined as
\mybox{
XXXXXX\=XXXXXXXXXXXXXXXXXX\=\kill
      \>COMMON /MESSAGE/  \>MSG(8)\\
      \>CHARACTER*120     \>MSG
}
which may be filled before calling one of these routines.
\end{mylist}
The routines have the following purposes:
\begin{mylist}
\ttitem{AAINFO}
Print informational message.
These messages can be suppressed by the command
\myxmp{OPTION,-INFO}
or reactivated by the command
\myxmp{OPTION,INFO}
\ttitem{AAWARN}
Print warning message.
These messages can be suppressed by the command
\myxmp{OPTION,-WARN}
or activated by the command
\myxmp{OPTION,WARN}
\ttitem{AAFAIL}
Print fatal error message.
These messages cannot be suppressed.
If MAD reads input from a file,
a fatal error causes it to enter scanning mode.
\end{mylist}
Example:
\myxmp{
XXXXXX\=\kill
      \>CHARACTER*(MCNAM) LABEL\\
      \>...\\
      \>LABEL = 'LABEL'\\
      \>CALL UTLENG(LABEL, ILENG)\\
      \>MSG(1) = 'Recursive call to "' // LABEL(1:ILENG) // '",'\\
      \>MSG(2) = 'Call skipped.'\\
      \>CALL AAWARN('AARUNS', 2, MSG)
}
prints the message
\myxmp{
XXXXXXXXXX\=\kill
AARUNS.   \>\#\# Warning \#\# Recursive call to "LABEL",\\
          \>Call skipped.
}
The same format could be obtained by
\myxmp{
XXXXXX\=\kill
      \>CHARACTER*(MCNAM) LABEL\\
      \>...\\
      \>LABEL = 'LABEL'\\
      \>CALL UTLENG(LABEL, ILENG)\\
      \>WRITE (MSG, 910) LABEL(1:ILENG)\\
910   \>FORMAT('Recursive call to "',A,'".'/'Call skipped.')\\
      \>CALL AAWARN('AARUNS', 2, MSG)
}

\section{Precomputed Maps}
\label{AAMARK}
\label{AAPDRP}
\label{AAPMOD}
\mybox{CALL AAPDRP}
For efficiency reasons MAD stores various transfer maps for later use
as long as there is no data change which makes them obsolete.
An update of the \ttindex{BEAM} bank makes transfer maps obsolete.
Therefore it must always be done via \ttindex{ENPUT},
which will call \ttindex{AAPDRP} when it has finished.
This ensures that all precomputed maps are dropped.
\mybox{CALL AAPMOD}
Before executing a command, \ttindex{AAEXEC} calls \ttindex{AAPMOD} to
check definitions and their dependences.
\ttindex{AAPMOD} sets the status bit~\ttindex{MXMOD} for all obsolete
maps,
and then drops any marked maps.
Marking is done by the call
\ttnindex{AAMARK}
\mybox{CALL AAMARK(SUBR,LBANK)}
where
\begin{mylist}
\item[\tt SUBR]
Character constant containing the name of the calling routine
(used for debug messages).
\item[\tt LBANK]
Pointer to the bank to be marked as modified.
\end{mylist}

Two more status bits are used for \ttindex{LUMP}s.
\ttindex{MXKNW} marks lumps when their modify status is known,
and \ttindex{MXLMP} helps to detect recursive \ttindex{LUMP} definitions.

\section{Check Validity for Redefinitions}                 
\label{AASMOD}
\mybox{CALL AASMOD)(IDIR,LOLD,LNEW)}
When a definition is replaced,
its name must never be transferred to a different class of objects.
One exception is allowed: Beam elements and beam lines may be
interchanged. 
At each redefinition of a name MAD calls \ttindex{AASMOD} in order to
detect the acceptability of the redefinition,
and to delete precomputed maps which may become obsolete due to the
redefinition.
The parameters are:
\begin{mylist}
\item[IDIR]
Directory index of the item being redefined.
\item[LOLD]
Pointer to the old definition.
\item[LNEW]
Pointer to the new definition.
\end{mylist}

%==============================================================================

\chapter{Beamparam Module ``BM''}
\label{BM}
The \ttindex{BM}~module implements the \ttindex{BMPM} command.
For a description refer to the MAD Physicist's Manual~\cite{PHYS}.

%==============================================================================

\chapter{Closed Orbit Correction Routines ``CO''}
\label{CO}
The \ttindex{CO}~module implements the commands related to closed orbit.
The routines are listed in table~\ref{T-CO}.
The algorithms are described in the MAD Physicist's Manual.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{CO}~module}
\label{T-CO}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{COCORR}&Command routine for \ttindex{CORRECT} command&-\\
\ttindex{COGDIS}&Fetch dispersion readings for a plane from table&-\\
\ttindex{COGKIK}&Fetch kicker strengths for a plane from table&-\\
\ttindex{COGMON}&Fetch monitor readings for a plane from table&-\\
\ttindex{COLDIS}&Orbit and dispersion correction by micado algorithm&-\\
\ttindex{COLORB}&Orbit correction only by micado algorithm&-\\
\ttindex{COMAIN}&Switch routine for \ttindex{CO}~module&-\\
\ttindex{COMICA}&Command routine for \ttindex{MICADO} command&-\\
\ttindex{COMDIS}&Set up influence matrix for orbit and dispersion for a plane&-\\
\ttindex{COMORB}&Set up influence matrix for orbit for a plane&-\\
\ttindex{COPDIS}&Print dispersion readings&-\\
\ttindex{COPKIK}&Print kicker strengths&-\\
\ttindex{COPMON}&Print orbit readings&-\\
\ttindex{CORDIS}&Command routine for \ttindex{GETDISP} command&-\\
\ttindex{CORKIK}&Command routine for \ttindex{GETKICK} command&-\\
\ttindex{CORMON}&Command routine for \ttindex{GETORBIT} command&-\\
\ttindex{COSKIK}&Increment kicker strengths for a plane in table&-\\
\ttindex{COTBLE}&Set up corrector and monitor table&-\\
\ttindex{COWDIS}&Command routine for \ttindex{PUTDISP} command&-\\
\ttindex{COWKIK}&Command routine for \ttindex{PUTKICK} command&-\\
\ttindex{COWMON}&Command routine for \ttindex{PUTORBIT} command&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Decoder Routines ``DC''}
\label{DC}
The \ttindex{DC}~module contains the high-level routine for data decoding.
Its main entry point is DCATTR, the routine to decode a single command
attribute.
It is called from various places in the \ttindex{AA}~module, 
and details on the other routines are of no concern to the programmer.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{DC}~module}
\label{T-DC}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{DCATTR}&Main entry point to \ttindex{DC}~module&\ref{DCATTR}\\
\ttindex{DCBEAM}&Decode beam line reference&-\\
\ttindex{DCCONS}&Decode constraint&-\\
\ttindex{DCFORM}&Decode formal parameter list for beam line&-\\
\ttindex{DCINDX}&Decode subscript list&-\\
\ttindex{DCINIT}&Called from \ttindex{AAINIT} to initialize \ttindex{DC}~module&-\\
\ttindex{DCLIST}&Called from \ttindex{DCBEAM} to decode beam line list&-\\
\ttindex{DCNAME}&Decode name attribute&-\\
\ttindex{DCRANG}&Decode range reference&-\\
\ttindex{DCREPT}&Decode repetition count&-\\
\ttindex{DCSTRG}&Decode character string&-\\
\ttindex{DCVREF}&Decode variable reference&-\\
\hline
\end{tabular}
\end{table}

\section{Decode a Single Command Attribute}
\label{DCATTR}
\mybox{CALL DCATTR(ITYPE,LBANK,IFRST,ILAST,EFLAG)}
decodes a single statement attribute preceded by an optional repeat
count.
The routine assumes that the current keyword pointer \ttindex{LCKEY}
is set,
and that the \ttindex{KEYWORD} common has been filled by a call to
\ttindex{KWGET}.
\ttindex{DCATTR} has the arguments
\begin{mylist}
\item[\tt ITYPE]
MAD data type of the attribute (input),
\item[\tt LBANK]
Pointer to the command bank to be filled (input),
\item[\tt IFRST]
Attribute number within the command bank where to store the value
(input),
\item[\tt ILAST]
For dimensioned attributes,
the last attribute number which may be filled with repetitions.
This is incremented for each value read (input/output),
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}
Direct use of this subroutine is not recommended,
but it may be useful under special circumstances.

%==============================================================================

\chapter{Directory Routines ``DI''}
\label{DI}
The routines of the \ttindex{DI}~module provide methods to create and
access directories (Section~\ref{Sdir}).

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{DI}~module}
\label{T-DI}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{DIADD} &Add a name to a directory (internal routine)&-\\
\ttindex{DIDEFI}&Define a name in a directory&\ref{DIDEFI}\\
\ttindex{DIDROP}&Drop a name from a directory&\ref{DIDROP}\\
\ttindex{DIFIND}&Find a name in a directory&\ref{DIFIND}\\
\ttindex{DILOOK}&Look up a name (internal routine)&-\\
\ttindex{DIMAKE}&Build new directory&\ref{DIMAKE}\\
\ttindex{DINAME}&Retrieve name from directory&\ref{DINAME}\\
\ttindex{DIREFE}&
  Find reference to a possibly indefined name&\ref{DIREFE}\\
\hline
\end{tabular}
\end{table}
 
\section{Defining a Name}
\label{DIDEFI}
\mybox{CALL DIDEFI(LDIR,LABEL,LBANK)}
defines a new name in a given directory.
If the name does not exist in the directory,
a new entry is created for the name.
If the name was already defined, \ttindex{DIDEFI} gives appropriate
messages.
It may also drop and/or modify some precomputed data,
when a redefinition makes this necessary.
In all cases \ttindex{DIDEFI} stores the bank pointer {\tt LBANK} in the
proper position of the pointer bank.
\begin{mylist}
\item[\tt LDIR(4)]
Directory handle (input).
\item[\tt LABEL]
Name to be defined (input).
\item[\tt LBANK(1)]
Bank pointer to be associated with {\tt LABEL} (input).
\end{mylist}
 
\section{Removing a Definition}
\label{DIDROP}
\ttnindex{DIDROP}
\mybox{CALL DIDROP(LDIR, LABEL)}
removes a bank pointer from a directory.
If {\tt LABEL} is found in {\tt LDIR},
the corresponding bank pointer is cleared in the directory.
The name itself remains in the directory,
and the bank pointed at by the original bank pointer is not dropped.
\begin{mylist}
\item[\tt LDIR(4)]
Directory handle (input).
\item[\tt LABEL]
Name whose definition is to be removed (input).
\end{mylist}
\clearpage
 
\section{Finding a Name}
\label{DIFIND}
When it is known that a name exists in a directory,
both directory index and bank pointer can be retrieved by the call
\ttnindex{DIFIND}
\mybox{CALL DIFIND(LDIR, LABEL, IDIR, LBANK)}
\begin{mylist}
\item[\tt LDIR(4)]
Directory handle (input).
\item[\tt LABEL]
Name to be looked for (input).
\item[\tt IDIR]
Directory index for LABEL in LDIR (output).
\item[\tt LBANK(1)]
Bank pointer associated with LABEL in LDIR (output).
\end{mylist}
If the name is not found, both {\tt IDIR} and {\tt LBANK} are returned
as zero.
 
\section{Retrieving a Name}
\label{DINAME}
\ttnindex{DINAME}
\mybox{CALL DINAME(LDIR, IDIR, LABEL)}
Retrieves a name from a directory.
\begin{mylist}
\item[\tt LDIR(4)]
Directory handle (input).
\item[\tt IDIR]
Directory index for the name requested (input).
\item[\tt LABEL]
Label at index {\tt IDIR} in directory {\tt LDIR} (output).
\end{mylist}

\section{Creating a Directory}
\label{DIMAKE}
\ttnindex{DIMAKE}
\mybox{ALL DIMAKE(NENTRY, ISUP, LDIR)}
creates an empty directory and links the new directory to the root bank.
Thus the directory will automatically be dumped when the MAD data
structure is dumped.
\begin{mylist}
\item[\tt NENTRY]
The initial number of entries (input).
If required, the directory grows later by adding {\tt NENTRY} entries
at a time.
\item[\tt ISUP]
Bias of the first supporting link in the root bank (input).
There must be 4 contiguous links allocated to each directory.
\item[\tt LDIR(4)]
{\em directory handle}\index{directory!handle} to be transmitted
to other directory utilities (output).
It must be dimensioned as \ttindex{LDIR(4)},
and must reside in a reference link area.
\ttindex{DIMAKE} fills it with pointers to the four directory banks.
\end{mylist}
 
\section{Referring to a Name}
\label{DIREFE}
\ttnindex{DIREFE}
\mybox{CALL DIREFE(LDIR, LABEL, IDIR)}
Returns a reference to a name in a directory.
If the name does not exist in the directory,
a new entry is created for the name with a zero pointer.
In any case the directory index for the name is returned.
\begin{mylist}
\item[\tt LDIR(4)]
Directory handle (input).
\item[\tt LABEL]
Name to be looked for (input).
\item[\tt IDIR]
Directory index for {\tt LABEL} in {\tt LDIR} (output).
\end{mylist}

%==============================================================================

\chapter{Emittance-Related Routines ``EM''}
\label{EM}
The \ttindex{EM}~module implements the emittance-related commands.
The routines are listed in Table~\ref{T-EM}.
The algorithms are described in in~\cite{CHAO} and in the MAD
Physicist's Manual.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{EM}~module}
\label{T-EM}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{EMCE2I}&Convert eigenvectors to internal sigma matrix form&-\\
\ttindex{EMCI2T}&Convert beam matrix from internal to TRANSPORT form&-\\
\ttindex{EMCT2I}&Convert beam matrix from TRANSPORT to internal form&-\\
\ttindex{EMDAMP}&Calculate radiation damping in an element&-\\
\ttindex{EMEMDO}&Command routine for \ttindex{EMIT} command&-\\
\ttindex{EMEMGO}&Work routine for \ttindex{EMIT} command&-\\
\ttindex{EMENDO}&Command routine for \ttindex{ENVELOPE} command&-\\
\ttindex{EMENGO}&Work routine for \ttindex{ENVELOPE} command&-\\
\ttindex{EMENPR}&Print beam sizes for \ttindex{ENVELOPE} command&-\\
\ttindex{EMENSV}&Save beam sizes for \ttindex{ENVELOPE} command&-\\
\ttindex{EMEVDO}&Command routine for \ttindex{EIGEN} command&-\\
\ttindex{EMEVGO}&Work routine for \ttindex{EIGEN} command&-\\
\ttindex{EMEVPR}&
  Print orbit and eigenvectors for \ttindex{EIGEN} command&-\\
\ttindex{EMEVSV}&
  Save orbit and eigenvectors for \ttindex{EIGEN} command&-\\
\ttindex{EMINIT}&Initialize radiation damping calculations&-\\
\ttindex{EMNORM}&Command routine for \ttindex{NORMAL} command&-\\
\ttindex{EMSSIG}&Work routine for \ttindex{SAVESIGMA} command&-\\
\ttindex{EMSUMM}&Make summary calculations for radiation damping&-\\
\ttindex{EMTWDO}&Command routine for \ttindex{TWISS1} command&-\\
\ttindex{EMTWGO}&Work routine for \ttindex{TWISS1} command&-\\
\ttindex{EMTWPR}&Print Mais-Ripken betatron functions&-\\
\ttindex{EMTWSV}&
  Save Mais-Ripken functions for \ttindex{TWISS1} command&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Environment Setup ``EN''}
\label{EN}
The \ttindex{EN}~module implements the commands to set up the machine
environment.
It also contains some services for other modules.
The algorithms are described in the MAD Physicist's Manual
as far as they concern physics calculations.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{EN}~module}
\label{T-EN}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{ENBEAM}&Command routine for \ttindex{BEAM} command&-\\
\ttindex{ENDUMP}&Command routine for \ttindex{SELECT} command&-\\
\tt ENFIX &Must be called for some commands in other modules to
  finish the environment set up begun with a \ttindex{BEAM} command &
  \ref{ENFIX}\\ 
\ttindex{ENFLAG}&Set an output flag (internal routine)&-\\
\tt ENFREQ&
  Must be called for some commands to change the RF frequency &
  \ref{ENFREQ}\\
\tt ENGET &
  Called by \ttindex{AAEXEC} to update \ttindex{BEAM} common from
  the \ttindex{BEAM} bank&\ref{ENGET}\\
\ttindex{ENMAIN}&Switch routine for \ttindex{EN}~module&-\\
\ttindex{ENPRNT}&Command routine for \ttindex{PRINT} command&-\\
\tt ENPUT &
  Called by any routine which changes the \ttindex{BEAM} common,
  to update the \ttindex{BEAM} bank.&\ref{ENPUT}\\
\ttindex{ENRANG}&Encode a range reference&\ref{ENRANG}\\
\ttindex{ENSBET}&Command routine for \ttindex{SAVEBETA} command&-\\
\ttindex{ENSPCA}&
  Define a \ttindex{SPLIT} position  (internal routine)&-\\
\ttindex{ENSPLT}&Command routine for \ttindex{SPLIT} command&-\\
\tt ENSRNG&
  Service routine to perform an action over a range&\ref{ENSRNG}\\ 
\tt ENSTYP&
  Service routine to perform an action on all elements with
  a certain \ttindex{TYPE} attribute&\ref{ENSTYP}\\
\ttindex{ENUSE} &Command routine for \ttindex{USE} command&-\\
\hline
\end{tabular}
\end{table}

\section{Fix up BEAM Data}
\label{ENFIX}\ttnindex{ENFIX}
\mybox{CALL ENFIX}
must be called by physics modules before using RF data and/or
beam sizes which depend on a \ttindex{BEAM} command.
\ttindex{ENFIX} figures out which data have been entered in
\ttindex{BEAM} and computes the missing values accordingly.
It adjusts the frequencies of all RF~cavities according to the
\emindex{revolution frequency}.

\section{Alter RF Frequencies}
\label{ENFREQ}\ttnindex{ENFREQ}
\mybox{CALL ENFREQ(DELTAP,DELTAT)}
adjusts the RF frequencies of all cavities such as to get an
approximate average energy error of \ttindex{DELTAP}.
It returns the expected difference in revolution time \ttindex{DELTAT}.

\section{Update BEAM Common from BEAM Bank}
\label{ENGET}\ttnindex{ENGET}
\mybox{CALL ENGET}
This call is made by \ttindex{AAEXEC} before each executable command
to insure that the contents of the \ttindex{BEAM} common agree with
those of the \ttindex{BEAM} bank.

\section{Update Beam Bank from BEAM Common}
\label{ENPUT}\ttnindex{ENPUT}
\mybox{CALL ENPUT}
This call must be made by any routine which modifies the contents
of the \ttindex{BEAM} common, to ensure that the changes are
transmitted into the \ttindex{BEAM} bank.

\section{Encode a Range Reference}
\label{ENRANG}\ttnindex{ENRANG}
\mybox{CALL ENRANG(LRNG,RNGNAM)}
returns a character representation of a range reference.
It has two arguments:
\begin{mylist}
\item[\tt LRNG]
Pointer to a range reference bank (input).
\item[\tt RNGNAM]
Character string equivalent to the input form which gave the range
reference (output).
This string must accommodate at least 60~characters.
\end{mylist}

\section{Perform an Action on all Elements of a Range}
\label{ENSRNG}\ttnindex{ENSRNG}
\mybox{CALL ENSRNG(LRNG,ACTION,IDUM1,IDUM2,DONE)}
loops over the elements in the current range of the working beam line
and calls the {\tt EXTERNAL} routine \ttindex{ACTION} for each element
which belongs to a given range reference.
It has the arguments:
\begin{mylist}
\item[\tt LRNG]
Pointer to the range reference bank to be used for selection (input).
\item[\tt ACTION]
FORTRAN subroutine which will be called for each selected element.
It must appear in an EXTERNAL statement in the calling routine
and be declared as
\mybox{
SUBROUTINE ACTION(IPOS,IDUM1,IDUM2,EFLAG)
}
with the arguments
\begin{mylist}
\item[\tt IPOS]
Position number for the selected element (input).
\item[\tt IDUM1,IDUM2]
Transmitted from the routine calling \ttindex{ENSRNG} (input).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}
\item[\tt IDUM1,IDUM2]
Two arguments which will be transmitted to \ttindex{ACTION}
(input/output).
\item[\tt DONE]
Is returned as {\tt .TRUE.}, if any element was selected (output).
\end{mylist}

\section{Perform an Action on all Elements Having a Given TYPE}
\label{ENSTYP}\ttnindex{ENSTYP}
\mybox{CALL ENSTYP(TYPE,ACTION,IDUM1,IDUM2,DONE)}
loops over the elements in the current range of the working beam line
nd calls the {\tt EXTERNAL} routine \ttindex{ACTION} for each element
which has the specified value of the \ttindex{TYPE} attribute.
It has the arguments:
\begin{mylist}
\item[\tt TYPE]
Value of the \ttindex{TYPE} attribute for selection (input).
\item[\tt ACTION]
FORTRAN subroutine which will be called for each selected element.
It must appear in an EXTERNAL statement in the calling routine
and be declared as
\mybox{
SUBROUTINE ACTION(IPOS,IDUM1,IDUM2,EFLAG)
}
with the arguments
\begin{mylist}
\item[\tt IPOS]
Position number for the selected element (input).
\item[\tt IDUM1,IDUM2]
Transmitted from the routine calling \ttindex{ENSRNG} (input/output).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}
\item[\tt IDUM1,IDUM2]
Two arguments which will be transmitted to \ttindex{ACTION}
(input/output).
\item[\tt DONE]
Returned as {\tt .TRUE.}, if any element was selected (output).
\end{mylist}

%==============================================================================

\chapter{Error Definitions ``ER''}
\label{ER}
The \ttindex{ER}~module provides definitions for machine imperfections.
The routines are listed in table~\ref{T-ER}.
Details about the data structure are found in Section~\ref{Serr}.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{ER}~module}
\label{T-ER}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{ERALCA}&Internal routine for \ttindex{ERALIG}&-\\
\ttindex{ERALIG}&Command routine for \ttindex{EALIGN} command&-\\
\ttindex{ERFCCA}&Internal routine for \ttindex{ERFCOM}&-\\
\ttindex{ERFCOM}&Command routine for \ttindex{EFCOMP} command&-\\
\ttindex{ERFICA}&Internal routine for \ttindex{ERFIEL}&-\\
\ttindex{ERFIEL}&Command routine for \ttindex{EFIELD} command&-\\
\ttindex{ERLIST}&Internal routine for \ttindex{ERPRNT}&-\\
\ttindex{ERMAIN}&Switch routine for \ttindex{ER}~module&-\\
\ttindex{EROPT} &Command routine for \ttindex{EOPT} command&-\\
\ttindex{ERPRNT}&Command routine for \ttindex{EPRINT} command&-\\
\ttindex{ERSAVE}&Command routine for \ttindex{ESAVE} command&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Expression Handler ``EX''}
\label{EX}
The \ttindex{EX}~module provides methods to decode and evaluate
expressions. 
Details about the data structure are found in Section~\ref{Sexp}.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{EX}~module}
\label{T-EX}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{EXBIN} &Internal routine for expression building&-\\
\ttindex{EXCONS}&Internal routine for expression building&-\\
\ttindex{EXCOPY}&Internal routine for expression building&-\\
\ttindex{EXDUMP}&Dump an expression bank&\ref{EXDUMP}\\
\ttindex{EXEVAL}&Evaluate a normal expression&\ref{EXEVAL}\\
\ttindex{EXEVL1}&Evaluate a string expression&\ref{EXEVAL}\\
\tt EXFILL&Called from \ttindex{AAEXEC} to fill in references &
  \ref{EXFILL}\\
\ttindex{EXHALF}&Internal routine for expression building&-\\
\ttindex{EXINIT}&
  Called from \ttindex{AAINIT} to initialize \ttindex{EX}~module&\\
\ttindex{EXLKEX}&Link a new expression bank&\ref{EXLKEX}\\
\ttindex{EXLKVR}&Link a new variable reference bank&\ref{EXLKVR}\\ 
\ttindex{EXLOAD}&Internal routine for expression building&-\\
\ttindex{EXMAKE}&Build normal expression bank&\ref{EXMAKE}\\
\ttindex{EXMAK1}&Build string expression bank&\ref{EXMAK1}\\
\ttindex{EXOPER}&Internal routine for expression interpreter&-\\
\tt EXORDR&Called from \ttindex{AAEXEC} to order expressions &
  \ref{EXORDR}\\
\ttindex{EXREAD}&Decode normal expression&\ref{EXREAD}\\
\ttindex{EXREFE}&Internal routine for expression building&-\\
\ttindex{EXSTRG}&Decode string expression&\ref{EXSTRG}\\
\ttindex{EXUNST}&Internal routine for expression building&-\\
\ttindex{EXUPDT}&
  Called from \ttindex{AAEXEC} to update expressions&\ref{EXUPDT}\\
\hline
\end{tabular}
\end{table}

The \ttindex{EX}~module uses a set of common blocks,
defined in COMDECK \ttindex{EXPRESS}, for the expression table.
This table is filled in by the expression decoders before building
expression banks:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>PARAMETER        \>(MAXEXP = 100)\\
\> \>COMMON /EXPRSA/  \>NXOPR, IXOPR(MAXEMP),\\
\>+\>                 \>IXSUB1(MAXEXP), IXSUB2(MAXEXP), IXSUB3(MAXEXP)\\
\> \>COMMON /EXPRSC/  \>AXBANK(MAXEXP), AXATTR(MAXEXP)\\
\> \>COMMON /EXPRSR/  \>RXVAL(MAXEXP)\\
\> \>SAVE             \>/EXPRSA/, /EXPRSC/, /EXPRSR/\\
\> \>CHARACTER*(MCNAM)\>AXBANK, AXATTR
}
\begin{mylist}
\ttitem{MAXEXP}
Maximum number of postfix operations allowed.
\ttitem{NXOPR}
Actual number of operations.
\ttitem{IXOPR}
Operation codes (Section~\ref{Sexp}).
\ttitem{IXSUBi}
$i^{th}$ subscript for variable load operation.
\ttitem{AXBANK}
Bank name for a variable load operation (parameter or bank attribute).
\ttitem{AXATTR}
Attribute name for a variable load operation (bank attribute load).
\ttitem{RXVAL}
Value for a constant load.
\end{mylist}

\section{Dump an Expression Bank}
\label{EXDUMP}\ttnindex{EXDUMP}
\mybox{CALL EXDUMP(L)}
dumps the expression bank pointed at by {\tt L} on the ECHO file.

\section{Evaluate a Single Expression}
\label{EXEVAL}\ttnindex{EXEVAL}
\mybox{CALL EXEVAL(L)}
evaluates the expression pointed at by {\tt L} by calling
\ttindex{EXOPER} for each operation in turn.

\section{Fill in Variable References}
\label{EXFILL}\ttnindex{EXFILL}
\mybox{CALL EXFILL}
loops over the {\em variable reference table}
\index{variable!reference!table} and fills in any missing pointers.
It gives messages for improper use of variables and/or undefined
operands.

\section{Link a New Expression Bank}
\label{EXLKEX}\ttnindex{EXLKEX}
\mybox{CALL EXLKEX(L)}
adds the expression bank pointed at by {\tt L} to the
{\em expression table}\index{expression!table}.

\section{Link a New Variable Reference Bank}
\label{EXLKVR}\ttnindex{EXLKVR}
\mybox{CALL EXLKVR(L)}
adds the variable reference bank pointed at by {\tt L} to the
{\em variable reference table}\index{variable!reference!table}.

\section{Build an Expression Bank from Table}
\label{EXMAKE}\ttnindex{EXMAKE}
\mybox{CALL EXMAKE(LBANK,ILINK,IDATA,RVAL,IEXPR)}
builds a new expression bank,
fills it with the current expression from common \ttindex{EXPRESS},
and links the new bank to the {\em expression table}
\index{expression!table}.
It has the parameters
\begin{mylist}
\item[\tt LBANK]
Bank into which the result shall be stored,
and by which the expression bank is supported (input).
\item[\tt ILINK]
Link number in the bank at {\tt LBANK} which will support the
new expression bank (input).
\item[\tt IDATA]
Bias in the bank at {\tt LBANK} where the result shall be stored
(input).
\item[\tt RVAL]
Value of the expression (for a constant expression only, input).
\item[\tt IEXPR]
Type of expression (input):
\begin{description}
\item[1:] Constant expression,
\item[2:] Ordinary expression requiring evaluation,
\item[3:] Deferred expression.
\end{description}
\end{mylist}
A special routine builds expression banks for expressions coming from
internal strings:
\label{EXMAK1}\ttnindex{EXMAK1}
\mybox{CALL EXMAK1(LTAB,LBNK,ILINK)}
builds a new expression bank,
fills it with the current expression from common \ttindex{EXPRESS},
and links the new bank to the {\em expression table}
\index{expression!table}.
It has the parameters
\begin{mylist}
\item[\tt LTAB]
Pointer to an open dynamic table (Chapter~\ref{TB})
which may be used as a source for operands. 
\item[\tt LBNK]
Bank into which the result shall be stored,
and by which the expression bank is supported (input).
\item[\tt ILINK]
Link which will support the new expression bank (input).
\end{mylist}
In this case the operands of the expression can also come from a table
column,
allowing to combine the columns like in a spread-sheet program.

\section{Order Arithmetic Expressions for Proper Evaluation}
\label{EXORDR}\ttnindex{EXORDR}
\mybox{CALL EXORDR}
orders the {\em expression table}\index{expression!table} for correct
evaluation of dependent expressions.
It skips \emindex{deferred expression},
but checks that all their operands are defined.
The \emindex{order bit}~\ttindex{MXORD} marks expressions which are
already in order,
and the \emindex{defer bit}~\ttindex{MXDEF} identifies deferred
expressions.

\section{Decode a Single Expression}
\label{EXREAD}\ttnindex{EXREAD}
\mybox{CALL EXREAD(IEVAL,RVAL,ISEEN)}
decodes an arithmetic expression and stores the decoded expression in
postfix notation in common \ttindex{EXPRESS}.
It does not build an expression bank.
To this purpose \ttindex{EXMAKE} must be called.
The arguments are
\begin{mylist}
\item[\tt IEVAL]
Type of expression expected (input):
\begin{description}
\item[1:] Must be constant expression.
\item[2:] Expression may depend on  variables, but may not deferred.
\item[3:] All expression types allowed.
\end{description}
\item[\tt RVAL]
Value of the expression (constant expression only, output).
\item[\tt ISEEN]
Actual type of expression seen (output):
\begin{description}
\item[1:] Constant expression, no later evaluation required.
\item[2:] Ordinary expression, must be linked to the expression table.
\item[3:] Deferred expression, requires deferred evaluation.
\end{description}
\end{mylist}
Expressions stored in strings, as used for plotting and listing tables,
are decoded by the call
\label{EXSTRG}\ttnindex{EXSTRG}
\mybox{CALL EXSTRG(NAME,LTAB,LBNK,ILINK,RVAL,EFLAG)}
It stores the decoded expression in postfix notation in common
\ttindex{EXPRESS}, and then builds an expression bank by calling
\ttindex{EXMAK1}.
Its arguments are
\begin{mylist}
\item[\tt NAME]
Name of a table column, of a table descriptor, of a global string,
or of an expression related to a table (input).
The name is searched for in this order.    
\item[\tt LTAB]
Pointer to an open dynamic table (input).
\item[\tt LBNK]
Bank into which the result shall be stored,
and by which the expression bank is supported (input).
\item[\tt ILINK]
Link which will support the new expression bank (input).
\item[\tt RVAL]
Value of the expression (constant expression only, output).
\item[\tt EFLAG]
Error flag (logical, output).
\end{mylist}

\section{Evaluate All Non-Deferred Expressions}
\label{EXUPDT}\ttnindex{EXUPDT}
\mybox{CALL EXUPDT}
loops over the expressions ordered by \ttindex{EXORDR} and evaluates
each of them in turn by a call to \ttindex{EXEVAL}.

%==============================================================================

\chapter{File Handlers ``FL''}
\label{FL}
The \ttindex{FL}~module provides the switch and command routines for
file access.
It also contains a few file-handling utilities.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{FL}~module}
\label{T-FL}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{FLASSI}&Command routine for \ttindex{ASSIGN} command&-\\
\tt FLCALL&
 Command routine for \ttindex{CALL} and \ttindex{RETURN} commands&-\\
\ttindex{FLCLOS}&Close a file&\ref{FLCLOS}\\
\ttindex{FLCSYS}&Command routine for \ttindex{SYSTEM} command&-\\
\ttindex{FLDELE}&Delete a file&\ref{FLDELE}\\
\ttindex{FLDUMP}&Command routine for \ttindex{POOLDUMP} command&-\\
\ttindex{FLEND} &Shut down file system&\ref{FLEND}\\
\ttindex{FLINIT}&Initialize file system&\ref{FLINIT}\\
\ttindex{FLLOAD}&Command routine for \ttindex{POOLLOAD} command&-\\
\ttindex{FLMAIN}&Switch routine for \ttindex{FL}~module&-\\
\ttindex{FLNAME}&Retrieve file name form file table&\ref{FLNAME}\\
\tt FLNFIX&Convert file name depending on operating system &
  \ref{FLNFIX}\\
\ttindex{FLNSET}&Build file name for standard file&\ref{FLNFIX}\\
\ttindex{FLOPEN}&Open file, system-independent part&\ref{FLOPEN}\\
\ttindex{FLRTFS}&Command routine for \ttindex{RETRIEVE} command&-\\
\ttindex{FLSYST}&Open file, system-dependent part&\ref{FLOPEN}\\
\ttindex{FLTELL}&Command routine for \ttindex{STATUS} command&-\\
\ttindex{FLTEXT}&Open text file, system-dependent&\ref{FLOPEN}\\
\ttindex{FLWTFS}&Command routine for \ttindex{ARCHIVE} command&-\\
\tt FLXCIT&
  Command routine for \ttindex{EXCITE} and \ttindex{INCREMENT}
  commands&-\\
\hline
\end{tabular}
\end{table}

The \ttindex{FL}~module uses a set of common blocks, \ttindex{FLTABLE},
for the file table, used to hold all known file names:
\myxmp{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
\> \>PARAMETER        \>(MAXDEF = 20, MAXFIL = 50)\\
\> \>COMMON /FLTABC/  \>IDFN(O:MAXFIL), IDAC(O:MAXFIL), IDDR(O:MAXFIL),\\
\>+\>                 \>IDFR(O:MAXFIL), IDLC(O:MAXFIL)\\
\> \>COMMON /FLTABI/  \>IDST(O:MAXFIL), IDLR(O:MAXFIL), IDLF(O:MAXFIL)\\
\> \>SAVE             \>/FLTABC/, /FLTABI/\\
\> \>CHARACTER*(MCFIL)\>IDFN\\
\> \>CHARACTER*1      \>IDAC, IDDR, IDFR, IDLC
}
The table is indexed by logical unit number and contains:
\begin{mylist}
\item[\tt MAXDEF]
Highest reserved unit number (for standard files).
\item[\tt MAXFIL]
Highest allocatable unit number.
\item[\tt IDFN]
File names as character strings.
\item[\tt IDAC]
Access codes: \ttindex{S} for sequential, \ttindex{D} for direct.
\item[\tt IDDR]
Data flow direction: \ttindex{R} for read, \ttindex{W} for write.
\item[\tt IDFR]
Format code: \ttindex{F} for formatted, \ttindex{U} for unformatted.
\item[\tt IDLC]
File location: \ttindex{D} for disk, \ttindex{T} for terminal,
\ttindex{S} for scratch.
\item[\tt IDST]
Status code: 0 for free entry, 1 for used entry, -1 for deleted file.
\item[\tt IDLR]
Record length in characters for direct access files.
\item[\tt IDLF]
File length in records for direct access files (relevant on IBM only).
\end{mylist}

\section{Close a File}
\label{FLCLOS}\ttnindex{FLCLOS}
\mybox{CALL FLCLOS(IUNIT,EFLAG)}
Closes a logical file.
\begin{mylist}
\item[\tt IUNIT]
Logical unit number for the file (input).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Delete a File}
\label{FLDELE}\ttnindex{FLDELE}
\mybox{CALL FLDELE(IUNIT,EFLAG)}
Deletes a file from the file system.
\begin{mylist}
\item[\tt IUNIT]
Logical unit number for the file (input).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Shut down File System}
\label{FLEND}\ttnindex{FLEND}
\mybox{CALL FLEND}
closes all open files and deletes any scratch files.

\section{Initialize File System}
\label{FLINIT}\ttnindex{FLINIT}
\mybox{CALL FLINIT}
initializes the internal file table.

\section{Retrieve File Name from File Table}
\label{FLNAME}\ttnindex{FLNAME}
\mybox{CALL FLNAME(IUNIT,FILNAM)}
retrieves the file name for a logical unit from the file table.
The name returned is the name under which the file is known to the
operating system.
\begin{mylist}
\item[\tt IUNIT]
Logical unit number for the file (input).
\item[\tt FILNAM]
String to receive the file name
(output, at least \ttindex{MCFIL} characters).
\end{mylist}

\section{Convert File Name Depending on Operating System}
\label{FLNFIX}\ttnindex{FLNFIX}
\mybox{CALL FLNFIX(STRNAM,MODE,FILNAM,LENG,EFLAG)}
converts an internal logical stream name,
as defined by the MAD program user,
to an external file name which will be known to the operating system.
This includes any format change to the file name required to make it
acceptable to the operating system.
On VM/CMS systems, e.~g. the name is converted to upper case and split
into the three parts (filename, filetype, filemode).
\begin{mylist}
\item[\tt STRNAM]
Internal logical stream name (input character string specified by
the program user).
\item[\tt MODE]
String containing the following four characters (input):
\begin{description}
\item[$1^{st}$~character, Access mode:]
\ttindex{S} for sequential, \ttindex{D} for direct.
\item[$2^{nd}$~character, Direction:]
\ttindex{R} for read, \ttindex{W} for write.
\item[$3^{rd}$~character, Format flag:]
\ttindex{F} for formatted, \ttindex{U} for unformatted.
\item[$4^{th}$~character, Location of file:]
\ttindex{D} for disk, \ttindex{T} for terminal, \ttindex{S} for scratch.
\end{description}
\item[\tt FILNAM]
External file name built, acceptable to the operating system (output).
This must accommodate at least \ttindex{MCFIL}~characters.
\item[\tt LENG]
The actual length of the external file name (output).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\ttnindex{FLNSET}
\mybox{CALL FLNSET(STRNAM,FILNAM)}
is a simplified version of the above,
it is used for the MAD standard files.
\begin{mylist}
\item[\tt STRNAM]
Internal logical stream name.
\item[\tt FILNAM]
External file name built, acceptable to the operating system (output).
This must accommodate at least \ttindex{MCFIL}~characters.
\end{mylist}

\section{Open a File}
\label{FLOPEN}\ttnindex{FLOPEN}
\mybox{CALL FLOPEN(STRNAM,MODE,LREC,LFIL,IUNIT,EFLAG)}
opens a file, and stores its external file name in the file table.
\begin{mylist}
\item[\tt STRNAM]
Internal logical stream name.
\item[\tt MODE]
String containing the following four characters (input):
\begin{description}
\item[$1^{st}$~character, Access mode:]
\ttindex{S} for sequential, \ttindex{D} for direct.
\item[$2^{nd}$~character, Direction:]
\ttindex{R} for read, \ttindex{W} for write.
\item[$3^{rd}$~character, Format flag:]
\ttindex{F} for formatted, \ttindex{U} for unformatted.
\item[$4^{th}$~character, Location of file:]
\ttindex{D} for disk, \ttindex{T} for terminal, \ttindex{S} for scratch.
\end{description}
\item[\tt LREC]
Record length in characters
(input, not relevant for formatted sequential files).
\item[\tt LFIL]
File length in records
(input, only relevant for IBM direct access files).
\item[\tt IUNIT]
Logical unit number (output). 
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}
The operating system dependent part of file open is done by
\ttindex{FLSYST}
\mybox{CALL FLSYST(FILNAM,MODE,LREC,LFIL,IUNIT,EFLAG)}
\begin{mylist}
\item[\tt FILNAM]
External file name built by \ttindex{FLNFIX}
\item[\tt MODE]
String containing the following four characters (input):
\begin{description}
\item[$1^{st}$~character, Access mode:]
\ttindex{S} for sequential, \ttindex{D} for direct.
\item[$2^{nd}$~character, Direction:]
\ttindex{R} for read, \ttindex{W} for write.
\item[$3^{rd}$~character, Format flag:]
\ttindex{F} for formatted, \ttindex{U} for unformatted.
\item[$4^{th}$~character, Location of file:]
\ttindex{D} for disk, \ttindex{T} for terminal, \ttindex{S} for scratch.
\end{description}
\item[\tt LREC]
Record length in characters
(input, not relevant for formatted sequential files).
\item[\tt LFIL]
File length in records
(input, only relevant for IBM direct access files).
\item[\tt IUNIT]
Logical unit number (input). 
\item[\tt EFLAG]
Logical error flag (output). 
\end{mylist}

For standard MAD files, MAD uses the simpler call
\ttnindex{FLTEXT}
\mybox{CALL FLTEXT(FILNAM,DIR,LREC,IUNIT,EFLAG)}
\begin{mylist}
\item[\tt FILNAM]
External file name built by \ttindex{FLNSET}
\item[\tt DIR]
One-character variable (input): \ttindex{R} for read, \ttindex{W} for
write. 
\item[\tt LREC]
Record length in characters
(input, no longer relevant, should be zero).
\item[\tt IUNIT]
Logical unit number (input).
\item[\tt EFLAG]
Logical error flag (output). 
\end{mylist}

%==============================================================================

\chapter{HARMON Module ``HA''}
\label{HA}
The \ttindex{HA}~module implements the commands of the
\ttindex{HARMON} module.
The algorithms used are described in~\cite{DONALD} and in the MAD
Physicist's Reference Manual.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{HA}~module}
\label{T-HA}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{HAATUN}&Find derivatives $\partial Q / \partial\varepsilon$&-\\
\ttindex{HABEGN}&Command routine for \ttindex{HARMON} command&-\\
\ttindex{HACELL}&Command routine for \ttindex{HCELL} command&-\\
\ttindex{HACFIT}&Adjust chromaticities to desired values&-\\
\ttindex{HACHCL}&Calculate chromaticities&-\\
\ttindex{HACHRM}&Command routine for \ttindex{HCHROMATICITY} command&-\\
\ttindex{HADBET}&Find derivatives $\partial\beta / \partial\delta$&-\\
\tt HADDSP&Find derivatives $\partial D / \partial\delta$ and
  $\partial^2 D / \partial\delta^2$&-\\
\tt HADTUN&Find derivatives $\partial^2 Q / \partial\delta^2$ and
  $\partial^3 Q / \partial\delta^3$&-\\
\ttindex{HAFCN} &Matching routine for \ttindex{HA}~module&-\\
\ttindex{HAFUNC}&Command routine for \ttindex{HFUNCTION} command&-\\
\ttindex{HALONG}&Set up ``long'' table of lattice functions&-\\
\ttindex{HAMAIN}&Switch routine for \ttindex{HA}~module&-\\
\ttindex{HAPAVE}&Print lattice functions averaged over elements&-\\
\ttindex{HAPRNT}&Matching print-out&-\\
\ttindex{HARESC}&Command routine for \ttindex{HRESONANCE} command&-\\
\ttindex{HARESO}&Compute resonance coefficients&-\\
\ttindex{HARSIG}&Internal routine for \ttindex{HARESO}&-\\
\ttindex{HASHRT}&
  Set up ``short'' table of averaged lattice functions&-\\
\ttindex{HASTRG}&Retrieve multipole strengths&-\\
\ttindex{HATHIN}&Organize thin lens calculations&-\\
\ttindex{HATUNE}&Command routine for \ttindex{HTUNE} command&-\\
\ttindex{HAVARY}&Command routine for \ttindex{HVARY} command&-\\
\ttindex{HAWEIG}&Command routine for \ttindex{HWEIGHT} command&-\\
\ttindex{HA4ANA}&Find fourth-order resonance coefficients&-\\
\ttindex{HA4SUM}&Internal routine for \ttindex{HA4ANA}&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Keyword Module ``KW''}
\label{KW}
The \ttindex{KW}~module is the keyword decoder.
It provides utilities for accessing keyword banks.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{KW}~module}
\label{T-KW}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{KWDIM} &Decode type and dimension for one keyword attribute&-\\
\ttindex{KWDUMP}&Dump keyword bank on ECHO file&\ref{KWDUMP}\\
\ttindex{KWGET} &
  Unpack keyword bank to \ttindex{KEYWORD} common&\ref{KWGET}\\
\ttindex{KWGRP} &Decode one keyword attribute group&-\\
\ttindex{KWMAIN}&
  Command routine for \ttindex{KEYWORD} and \ttindex{KEYEDIT} commands&
  -\\
\ttindex{KWMAKE}&
  Book keyword bank and link it to master keyword&\ref{KWMAKE}\\
\ttindex{KWPUT} &
  Pack \ttindex{KEYWORD} common to keyword bank&\ref{KWPUT}\\
\hline
\end{tabular}
\end{table}

\section{Write Keyword Definition on ECHO File}
\label{KWDUMP}\ttnindex{KWDUMP}
\mybox{CALL KWDUMP(L)}
writes the keyword definition pointed at by {\tt L} on the ECHO file.

\section{Unpack Keyword Definition}
\label{KWGET}\ttnindex{KWGET}
\mybox{CALL KWGET(LKEY,ILN,IPR,ISP,NKAT)}
unpacks a keyboard definition and stores information in local variables
and in the \ttindex{KEYWORD} common.
\begin{mylist}
\item[\tt LKEY]
Pointer to the keyword to be unpacked (input).
\item[\tt ILN]
Line number of last definition of the keyword (output).
\item[\tt IPR]
Process code for this keyword (output).
\item[\tt ISP]
Subprocess code for this keyword (output).
\item[\tt NKAT]
Number of keyword attributes for this keyword (output).
\end{mylist}
This call fills the following common arrays:
\begin{mylist}
\item[\tt IATYPE]
MAD data types for the keyword attributes. 
\item[\tt IADIM1]
First dimensions for the keyword attributes.
\item[\tt IADIM2]
Second dimensions for the keyword attributes.
\item[\tt IADIM3]
Third dimensions for the keyword attributes.
\item[\tt KATNAM]
Names of keyword attributes.
\end{mylist}

\section{Book New Keyword Bank}
\label{KWMAKE}\ttnindex{KWMAKE}
\mybox{CALL KWMAKE(LABEL,IPR,ISP,NKAT)}
books a new keyword bank, links it to the master keyword and to the
\emindex{keyword!directory}.
\begin{mylist}
\item[\tt LABEL]
Name of the new keyword (input).
\item[\tt IPR]
The process code (input).
\item[\tt ISP]
The subprocess code (input).
\item[\tt NKAT]
Number of keyword attributes (input).
\end{mylist}

\section{Pack Keyword Definition}
\label{KWPUT}\ttnindex{KWPUT}
\mybox{CALL KWPUT(LKEY,NKAT)}
packs the following common arrays to a keyword bank:
\begin{mylist}
\item[\tt IATYPE]
MAD data types for the keyword attributes. 
\item[\tt IADIM1]
First dimensions for the keyword attributes.
\item[\tt IADIM2]
Second dimensions for the keyword attributes.
\item[\tt IADIM3]
Third dimensions for the keyword attributes.
\item[\tt KATNAM]
Names of keyword attributes.
\end{mylist}
The call has two arguments:
\begin{mylist}
\item[\tt LKEY]
Pointer to the keyword bank to be filled (input).
\item[\tt NKAT]
Number of keyword attributes (input).
\end{mylist}

%==============================================================================

\chapter{Lie-Algebra Module ``LA''}
\label{LA}
The \ttindex{LA}~module contains routines to operate on Lie-algebraic
maps~\cite{DRAGT}.
A Lie-algebraic map represents the transformation of phase space
from entrance to exit of an element as the Lie transformation
\[
z^{(2)}_i = \lietran{f_1} \lietran{f_2} \lietran{f_3} \lietran{f_4}
        \ldots z^{(1)}_i,\qquad {\rm for} \quad i = 1 \ldots 6.
\]
The $f_i$~are homogeneous polynomials in~$Z$.

Many routines have been lifted from MARYLIE,
but most of them have been extensively modified.
There are also some new routines.
Note that not all routines keep a $f_1$~term.
The descriptions below use the following conventions:
\begin{mylist}
\ttitem{FP} is an array containing the generators for a map~$\cal F$.
\ttitem{FM} is a $6\times6$~matrix representing the linear terms of
the map~$\cal F$.
\end{mylist}
The algorithms used are documented in~\cite{DRAGT} and in the MAD
Physicist's Reference Manual.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{LA}~module}
\label{T-LA}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{LABETA}&
  Extract betatron portion of a transfer map&\ref{LABETA}\\
\ttindex{LABRKS}&
  Compute Poisson brackets relevant for the Lie series&-\\
\ttindex{LACHRM}&
  Chromatic expansion of a static transfer map&\ref{LACHRM}\\
\ttindex{LADC2R}&
  Transform dynamic map from Cartesian basis to resonance basis&
  \ref{LADPUR}\\
\ttindex{LADEIG}&
  Find eigenvalues of a dynamic transfer matrix&\ref{LADEIG}\\
\tt LADPUR&Internal routine to purify dynamic maps&-\\
\ttindex{LADPU2}&
  Transform dynamic map to Floquet variables&\ref{LADPUR}\\
\tt LADPU3&
  Transform third order part of dynamic map to normal form&
  \ref{LADPUR}\\
\tt LADPU4&
  Transform fourth order part of dynamic map to normal form&
  \ref{LADPUR}\\
\tt LADR2C&
  Transform dynamic map from resonance basis to Cartesian basis&
  \ref{LADPUR}\\
\ttindex{LADYNA}&Command routine for the \ttindex{DYNAMIC} command&-\\
\tt LAEMIT&Command routine for the \ttindex{NORMAL} command
  Note that this routine no longer uses Lie algebra.&-\\
\tt LAFXFN&
  Transform polynomial on phase space with a transfer map&\ref{LAFXFM}\\
\ttindex{LALUMP}&
  Find Lie algebraic transfer map for a \ttindex{LUMP}&\ref{LATURN}\\
\ttindex{LAMAIN}&Switch routine for the \ttindex{LA}~module&-\\
\tt LAMOVE&
  Transform orbit with a transfer map and return map around orbit&
  \ref{LAMOVE}\\
\tt LASC2R&
  Transform static map from Cartesian basis to resonance basis&
  \ref{LASPUR}\\
\ttindex{LASEIG}&
  Find eigenvalues of a static transfer matrix&\ref{LASEIG}\\
\tt LASPUC&
  Transform third order chromatic part of static map to normal form&
  \ref{LASPUR}\\
\tt LASPUG&
  Transform third order geometric part of static map to normal form&
  \ref{LASPUR}\\
\ttindex{LASPUR}&Internal routine to purify static maps&-\\
\tt LASPU4&
  Transform fourth order part of static map to normal form&
  \ref{LASPUR}\\
\tt LASR2C&
  Transform static map from resonance basis to Cartesian basis&
  \ref{LASPUR}\\
\ttindex{LASTAT}&Command routine for the \ttindex{STATIC} command&-\\
\ttindex{LATRNS}&Track orbits with the truncated Lie series&-\\
\ttindex{LATURN}&
  Find one turn map for the working beam line&\ref{LATURN}\\
\hline
\end{tabular}
\end{table}
 
\section{Operations on General Maps} 
\subsection{One-Turn Maps}
\label{LATURN}\ttnindex{LATURN}
\mybox{CALL LATURN(N,FP,FM)}
returns the map~$\cal F$ for the main beam line expansion.
There are three arguments:
\begin{mylist}
\item[\tt N]
Desired order $N$ of the map (input, $2 \le \hbox{\tt N} \le 6$),
i.~e. the order of the highest polynomial kept.
\item[\tt FP,FM]
Generators and matrix of $\cal F$ (output).
\end{mylist}
To improve speed,
transfer maps are kept in ZEBRA banks linked to the sequence bank
(Section~\ref{Sbeam}), as soon as they are calculated.
When \ttindex{LATURN} is called, MAD looks for such a map with the given
order.
If finds one, it immediately returns the map.
Otherwise it creates this map by using the call
\label{LALUMP}\ttnindex{LALUMP}
\mybox{CALL LALUMP(N,LSEQ,FP,FM)}
which concatenates the maps for all elements in a specified beam line
expansion.
There are four arguments:
\begin{mylist}
\item[\tt N]
Desired $N$ order of the map (input, $2 \le \hbox{\tt N} \le 6$),
order of the highest polynomial kept.
\item[\tt LSEQ]
Pointer to the beam line expansion,
normally \ttindex{LCSEQ} (input, Section~\ref{Sbeam}),
\item[\tt FP,FM]
Generators and matrix of~$\cal F$ (output).
\end{mylist}

\subsection{Transform Polynomial with a Transfer Map}
\label{LAFXFM}\ttnindex{LAXFRM}
\mybox{CALL LAFXFM(N,GP,GM,FP,HP)}
Transforms a polynomial~$F$ with a map~$\cal G$.
There are five arguments:
\begin{mylist}
\item[\tt N]
Order $N$ of the map~$\cal G$ ($2 \le \hbox{\tt N} \le 6$, input),
\item[\tt GP,GM]
Generators and matrix of~$\cal G$ (input),
\item[\tt FP]
Polynomial~$F$ to be transformed (input),
\item[\tt HP]
Resulting polynomial~$H$ (output).
\end{mylist}
$F$~and~$H$ are stored in the same format as the generators of a map.
 
\subsection{Transform Map to Map about an Orbit}
\label{LAMOVE}\ttnindex{LAMOVE}
\mybox{CALL LAMOVE(N,FP,FM,ORBIT,HP,HM)}
Moves a given orbit through a map~$\cal F$ and returns the map~$\cal H$
for the motion around the orbit.
There are six arguments:
\begin{mylist}
\item[\tt N]
Order $N$ of the map~$\cal F$ ($2 \le \hbox{\tt N} \le 6$, input),
\item[\tt FP,FM]
Generators and matrix for~$\cal F$ (input),
\item[\tt ORBIT]
The orbit to be moved through~$\cal F$,
\item[\tt HP,HM]
Map~$\cal H$ of order {\tt N} around the orbit
(output).
\end{mylist}

\section{Operations on Static Maps}
A static map does not change particle energy.

\subsection{Betatron factor of a Static Map}
\label{LABETA}\ttnindex{LABETA}
\mybox{CALL LABETA(N,FP,FM,BP,BM)}
extracts the betatron factor~$\cal B$ from a static map.
There are five arguments:
\begin{mylist}
\item[\tt N]
Order $N$ of the given map (input, $2 \le \hbox{\tt N} \le 4$),
\item[\tt FP,FM]
Static map~$\cal F$,
\item[\tt BP,BM]
Betatron factor~$\cal B$ of~$\cal F$ (output).
\end{mylist}
 
\subsection{Chromatic expansion of a Static Matrix}
\label{LACHRM}\ttnindex{LACHRM}
\mybox{CALL LACHRM(N,FP,FM,AM1,AM2)}
extracts the first and second derivatives of the transfer matrix with
respect to the energy error from a static map.
There are five arguments:
\begin{mylist}
\item[\tt N]
Order $N$ of the given map~$\cal F$ (input, $2 \le \hbox{\tt N} \le 4$),
\item[\tt FP,FM]
Generators and matrix of~$\cal F$ (input),
\item[\tt AM1,AM2]
Two $6 \times 6$~matrices which will receive the first and second
derivative.
\end{mylist}
 
\subsection{Eigenvalues and Eigenvectors of a Static Matrix}
\label{LASEIG}\ttnindex{LASEIG}
\mybox{CALL LASEIG(A,REEIG,AIEIG,E)}
Computes the eigenvalues and eigenvectors
of the $4 \times 4$~submatrix of a static $6 \times 6$~matrix~$A$.
The routine has four arguments:
\begin{mylist}
\item[\tt A]
Static matrix~$A$,
\item[\tt REEIG,AIEIG]
Two $6$~vectors which receive the real and imaginary parts of the
eigenvalues.
The fifth and sixth eigenvalues are set to one.
\item[\tt E]
$6 \times 6$~matrix which receives the eigenvectors.
A real vector is stored in a single column.
A complex pair is stored in two consecutive columns,
using one column for the real part, and one for the imaginary part.
\end{mylist}
 
\subsection{Purify Static Map}
Transformation to normal form involves several steps of
``purification''. 
This operation consists in repeated conjugation with several maps
to remove undesired terms successively.
The four routines
\label{LASPUR}
\mybox{CALL LASPU2(N,FP,FM,GP,GM,TP,TM)\\
       CALL LASPUC(N,FP,FM,GP,GM,TP,TM)\\
       CALL LASPUG(N,FP,FM,GP,GM,TP,TM)\\
       CALL LASPU4(N,FP,FM,GP,GM,TP,TM)}
have the following action:
\begin{mylist}
\ttitem{LASPU2}
Removes coupling terms of second order
by conjugation with the matrix of eigenvectors,
\ttitem{LASPUC}
Removes the chromatic terms of third order,
\ttitem{LASPUG}
Removes the geometric terms of third order,
\ttitem{LASPU4}
Removes terms of fourth order,
\end{mylist}
The four routines must be called in the order listed.
They all have the arguments
\begin{mylist}
\item[\tt N]
Order of all maps involved ($2 \le \hbox{\tt N} \le 4$, input),
\item[\tt FP,FM]
Map~$\cal F$ to be purified (input),
\item[\tt GP,GM]
Result~$\cal G$ of conjugation (output),
\item[\tt TP,TM]
Map~$\cal T$ used for conjugation (output):
${\cal G} \leftarrow {\cal T} {\cal F} {\cal T}^{-1}.$
\end{mylist}
 
A purified static map still contains some non-removable non-linearities.
The call
\ttnindex{LASC2R}
\mybox{CALL LASC2R(N,F,G)}
transforms such a map to static resonance form.
It has three arguments:
\begin{mylist}
\item[\tt N]
Order of polynomials involved ($2 \le \hbox{\tt N} \le 4$, input),
\item[\tt F]
Generators~$F$ of the purified static map~$\cal F$,
\item[\tt G]
Resonance coefficients~$G$ in a static resonance base.
\end{mylist}
\mybox{CALL LASR2C(N,G,F)}
is the opposite operation.

\section{Operations on Dynamic Maps}
A dynamic map is a map which may change the particle energy.
 
\subsection{Eigenvalues and Eigenvectors of a $6 \times 6$ Matrix}
\label{LADEIG}
\mybox{CALL LADEIG(FM,REEIG,AIEIG,AM)}
Computes the eigenvalues and eigenvectors
of the $6 \times 6$~matrix $A$.
The routine has four arguments:
\begin{mylist}
\item[\tt A]
Dynamic matrix~$A$,
\item[\tt REEIG,AIEIG]
Two $6$~vectors which receive the real and imaginary parts of the
eigenvalues.
\item[\tt E]
$6 \times 6$~matrix which receives the eigenvectors.
A real vector is stored in a single column.
A complex pair is stored in two consecutive columns,
using one column for the real part, and one for the imaginary part.
\end{mylist}
 
\subsection{Purifying Dynamic Map}
\label{LADPUR}
Transformation to normal form involves several steps of
``purification''. 
This operation consists in repeated conjugation with several maps
to remove undesired terms successively.
The three routines
\mybox{CALL LADPU2(N,FP,FM,GP,GM,TP,TM)\\
       CALL LADPU3(N,FP,FM,GP,GM,TP,TM)\\
       CALL LADPU4(N,FP,FM,GP,GM,TP,TM)}
have the following action:
\begin{mylist}
\ttitem{LADPU2}
Removes coupling terms of second order
by conjugation with the matrix of eigenvectors,
\ttitem{LADPU3}
Removes the terms of third order,
\ttitem{LADPU4}
Removes terms of fourth order,
\end{mylist}
The three routines must be called in the order listed.
They all have the arguments
\begin{mylist}
\item[\tt N]
Order $N$ of all maps involved ($2 \le \hbox{\tt N} \le 4$, input),
\item[\tt FP,FM]
Map~$\cal F$ to be purified (input),
\item[\tt GP,GM]
Result~$\cal G$ of conjugation (output),
\item[\tt TP,TM]
Map~$\cal T$ used for conjugation (output):
${\cal G} \leftarrow {\cal T} {\cal F} {\cal T}^{-1}.$
\end{mylist}

A purified dynamic map still contains some non-removable
non-linearities. 
The call
\mybox{CALL LADC2R(N,F,G)}
transforms such a map to dynamic resonance form.
It has three arguments:
\begin{mylist}
\item[\tt N]
Order $N$ of polynomials involved ($2 \le \hbox{\tt N} \le 4$, input),
\item[\tt F]
Generators~$F$ of the purified dynamic map~$\cal F$,
\item[\tt G]
Resonance coefficients~$G$ in a dynamic resonance base.
\end{mylist}
\mybox{CALL LADR2C(N,G,F)}
is the opposite operation.

%==============================================================================

\chapter{Lie-Algebraic Maps ``LM''}
\label{LM}
The ``LM''~module computes Lie-algebraic maps
for single elements and performs elementary operations thereon.
Note that not all routines keep a $f_1$~term.
The algorithms used are documented in the MAD Physicist's Reference
Manual. 

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{LM}~module}
\label{T-LM}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{LMARB}&
  Transfer map for an arbitrary element (not yet implemented)&-\\
\ttindex{LMBEND}&Transfer map for a bend includeing fringe fields&-\\
\ttindex{LMCANX}&Prepare transfer map for symplectic tracking&-\\
\ttindex{LMCAT}&Concatenate two transfer maps&\ref{LMCAT}\\
\ttindex{LMCLOR}&
  Find fixed point (closed orbit) of a transfer map&\ref{LMCLOR}\\
\ttindex{LMCOPY}&Copy a transfer map&\ref{LMCOPY}\\
\ttindex{LMCORR}&Transfer map for an closed orbit corrector&-\\
\ttindex{LMDPRT}&
  Print transfer map in dynamic resonance form&\ref{LMPRNT}\\
\ttindex{LMDRF}&Transfer map for a drift space&-\\
\ttindex{LMDSP1}&Transfer map for a misalignment at element entrance&-\\
\ttindex{LMDSP2}&Transfer map for a misalignment at element exit&-\\
\ttindex{LMELEM}&
  Switch routine to track through any element&\ref{LMELEM}\\
\ttindex{LMEXPO}&
  Calculate Lie transformation of a polynomial&\ref{LMEXPO}\\
\ttindex{LMFIXP}&Find fixed point of a static map&\ref{LMFIXP}\\
\ttindex{LMFRG1}&Transfer map for a fringe field at dipole entrance&-\\
\ttindex{LMFRG2}&Transfer map for a fringe field at dipole exit&-\\
\ttindex{LMG1MV}&Move $g_1$~part over a Lie operator&-\\
\ttindex{LMINV}&Invert a transfer map&\ref{LMINV}\\
\ttindex{LMMAP}&
  Switch routine to compute transfer map for any element&\ref{LMMAP}\\
\ttindex{LMMASK}&Mask out terms for given orders&\ref{LMMASK}\\
\ttindex{LMMULT}&Transfer map for a thin multipole&-\\
\ttindex{LMNEWT}&Non-linear part of symplectic tracking&-\\
\ttindex{LMOCT}&Transfer map for a long octupole&-\\
\ttindex{LMONE}&Return identity map&\ref{LMONE}\\
\ttindex{LMPRNT}&Print transfer map matrix and generators&\ref{LMPRNT}\\
\ttindex{LMQUAD}&Transfer map for a long quadrupole&-\\
\ttindex{LMREFL}&Reflect transfer map&\ref{LMREFL}\\
\ttindex{LMREVF}&Reverse factorization of a map&\ref{LMREVF}\\
\ttindex{LMRF}  &Transfer map for an RF cavity of zero length&-\\
\ttindex{LMSAND}&
  Conjugate transfer map with another transfer map&\ref{LMSAND}\\
\ttindex{LMSECT}&
  Transfer map for a sector dipole without fringe fields&-\\
\ttindex{LMSEP}&Transfer map for an electrostatic separator&-\\
\ttindex{LMSEXT}&Transfer map for a long sextupole&-\\
\ttindex{LMSOL}&
  Transfer map for a long solenoid without fringe fields&-\\
\ttindex{LMSPRT}&
  Print transfer map in static resonance form&\ref{LMPRNT}\\
\ttindex{LMSROT}&Transfer map for a rotation about the $s$-axis&-\\
\ttindex{LMTILT}&
  Conjugate transfer map with rotation around $s$-axis&\ref{LMTILT}\\
\ttindex{LMTRAK}&Track orbits by the symplectic method&-\\
\ttindex{LMUSER}&Transfer map for a user-define element&\ref{LMUSER}\\
\ttindex{LMYROT}&Transfer map for a rotation about the $y$-axis&-\\
\hline
\end{tabular}
\end{table}
\clearpage

\section{Concatenate two Maps}
\label{LMCAT}\ttnindex{LMCAT}
\mybox{CALL LMCAT(N,FP,FM,GP,GM,HP,HM)}
concatenates two Lie-algebraic maps~$\cal F$ and~$\cal G$ and returns
the resulting map~$\cal H$.
It takes five input arguments:
\begin{mylist}
\item[\tt N]
Order $N$ of all maps involved ($2 \le \hbox{\tt N} \le 6$).
\item[\tt FP,FM]
Generators and matrix of the {\em first} map~$\cal F$ in beam
order.
\item[\tt GP,GM]
Generators and matrix of the {\em second} map~$\cal G$ in beam
order.
\end{mylist}
It returns two arguments:
\begin{mylist}
\item[\tt HP,HM] 
Generators and matrix of the resulting map~$\cal H$.
\end{mylist}
LMCAT keeps displacement terms, if present.
 
\section{Find Closed Orbit and Map about the Closed Orbit}
\label{LMCLOR}\ttnindex{LMCLOR}
\mybox{CALL LMCLOR(LINE,N,FP,FM,DELTAT,DELTAP,HP,HM,ORBIT)}
computes the first-order fixed point, i.~e. the closed orbit of a
map~$\cal F$.
It returns the orbit for the fixed point and the map~$\cal H$ relative
to the fixed point.
It has five input arguments:
\begin{mylist}
\item[\tt LINE]
Name of the beam line having the map~$\cal F$ as
{\tt CHARACTER*(MCNAM)}.
\item[\tt N]
Order of the map~{\cal F}.
\item[\tt FP,FM]
Generators \ttindex{FP} and matrix \ttindex{FM} of the map~$\cal F$.
\item[\tt DELTAP]
(Average) relative energy error desired for the fixed point.
\end{mylist}
and returns four arguments:
\begin{mylist}
\item[\tt DELTAT]
Path length difference for the fixed point,
compared to reference particle.
\item[\tt HP,HM]
Generators \ttindex{HP} and matrix \ttindex{HM} of the map~$\cal H$.
\item[\tt ORBIT]
Orbit for the fixed point.
\end{mylist}
 
\section{Copy a Map}
\label{LMCOPY}\ttnindex{LMCOPY}
\mybox{CALL LMCOPY(N,FP,FM,GP,GM)}
Copies a map~$\cal F$, into a map~$\cal G$.
It has three input arguments:
\begin{mylist}
\item[\tt N]
Order of the map.
\item[\tt FP,FM]
Map~$\cal F$ to be copied.
\end{mylist}
and two output arguments:
\begin{mylist}
\item[\tt GP,GM]
Copied map~$\cal G$.
\end{mylist}
 
\section{Track with the Generating Function Method}
\label{LMELEM}\ttnindex{LMELEM}
\mybox{CALL LMELEM(ITURN,NORD,NSUP,IPOS,SUML,TRACK,NUMBER,NTRACK)}
tracks a set of orbits through any element using the symplectic
tracking method.
It assumes that \ttindex{UTBEAM} and \ttindex{UTELEM} have been called
beforehand to set the relevant pointers in common \ttindex{REFER}.
\begin{mylist}
\item[\tt ITURN]
Turn number, used for messages about lost particles (input).
\item[\tt NORD]
Order to be used for the transfer map(input).
\item[\tt ISUP]
Superperiod number, used for messages about lost particles (input).
\item[\tt IPOS]
Position number in the machine, used for messages(input).
\item[\tt SUML]
Accumulated length, updated by the routine (input/output)
\item[\tt TRACK]
Orbit positions to be updated (input/output).
\item[\tt NUMBER]
List of orbit numbers (input/output).
\item[\tt NTRACK]
Number of surviving orbits (input/output).
\end{mylist}
The orbits are compacted when an orbit is lost.
Thus the $n^{th}$~orbit is stored in \ttindex{TRACK(*,$i$)},
and its number is found in \ttindex{NUMBER($i$)}.
 
\section{Apply Exponential of a Lie operator to a Polynomial}
\label{LMEXPO}\ttnindex{LMEXPO}
\mybox{CALL LMEXPO(FP,IFPORD,GP,IARORD,HP,IMXORD)}
applies the Lie transformation for a homogeneous polynomial~$F_n$
to a set of generators~$\{G_i\}$ and returns the resulting
set~$\{H_k\}$:
\[
H_k = \sum \lietran{F_n} G_i, \qquad \hbox{terms of order }k.
\]
It has five input arguments:
\begin{mylist}
\item[\tt FP]
Coefficients of the homogeneous polynomial~$F_n$ of order~$n$.
\item[\tt IFPORD]
Order~$n$ of~$F_n$.
\item[\tt GP]
The coefficients of the set of homogeneous polynomials~$\{G_i\}$.
\item[\tt IARORD]
If positive, $\{G_i\}$~contains only order {\tt IARORD}.
If negative, $\{G_i\}$~contains all polynomials up to order 
{\tt -IARORD}.
\item[\tt IMXORD]
Order at which to truncate the result.
\end{mylist}
The result is returned in one argument:
\begin{mylist}
\item[\tt HP]
Set of homogeneous polynomials~$\{H_k\}$ generated.
\end{mylist}
 
\section{Find Fixed Point of a Static Map as a Function of~$\delta$}
\label{LMFIXP}\ttnindex{LMFIXP}
\mybox{CALL LMFIXP(FP,FM,AP,AM,TP,TM)}
transforms an order-4 map~$\cal F$ by conjugation with a map~$\cal T$:
${\cal A} \leftarrow {\cal T \cal F \cal T}^{-1}$
such that~$\cal T$ contains the first through third order dispersion
of~$\cal F$,
and~$\cal A$ is the map about the fixed point.
There are two input arguments:
\begin{mylist}
\item[\tt FP,FM]
Fourth-order map~$\cal F$.
\end{mylist}
and four output arguments:
\begin{mylist}
\item[\tt AP,AM]
Map~$\cal A$ about the fixed point.
\item[\tt TP,TM]
Transformation~$\cal T$ to the fixed point.
\end{mylist}
 
\section{Invert Lie-algebraic Map}
\label{LMINV}\ttnindex{LMINV}
\mybox{CALL LMINV(N,FP,FM,GP,GM)}
inverts the map~$\cal F$ of order {\tt N} and returns the result
in~$\cal G$.
                              
\subsection{Return Transfer Map for Any Element}
\label{LMMAP}\ttnindex{LMMAP}
\mybox{CALL LMMAP(N,EL,FP,FM)}
expects that the relevant pointers have been set by the calling routine:
\begin{mylist}
\ttitem{LCELM} The data bank for the current element (must be non-zero).
\ttitem{LCALI} Pointer to misalignment bank (may be zero).
\ttitem{LCFLD} Pointer to field error bank (may be zero).
\ttitem{LCCOM} Pointer to corrector or monitor bank
(must be non-zero for a corrector or monitor,
when an orbit correction has been made).
\end{mylist}
It extracts the relevant data and returns:
\begin{mylist}
\item[\tt EL]   The length of the current element,
\item[\tt FP,FM]Map~$\cal F$ for the current element.
\end{mylist}
 
\section{Wipe out Monomial Coefficients as Specified}
\label{LMMASK}\ttnindex{LMMASK}
\mybox{CALL LMMASK(N,WIPE,FP,FM,GP,GM)}
wipes out selected orders in the map~$\cal F$.
It has four input arguments:
\begin{mylist}
\item[\tt N]
Order of~$\cal F$.
\item[\tt WIPE]
Logical array of dimension at least {\tt N}.
If {\tt WIPE(I)} is {\tt .FALSE.},
the terms of order {\tt I} will be copied from~$\cal F$ to~$\cal G$,
otherwise these terms will be cleared in~$\cal G$.
\item[\tt FP,FM]
Input map~$\cal F$.
\end{mylist}
and two output arguments:
\begin{mylist}
\item[\tt GP,GM]
Map~$\cal G$ resulting from wiping out the selected orders.
\end{mylist}
 
\subsection{Identity Map}
\label{LMONE}\ttnindex{LMONE}
\mybox{CALL LMONE(N,FP,FM)}
Sets the map~$\cal F$ to the identity map.
 
\section{Print Representations of Lie-algebraic Maps}
\label{LMPRNT}\ttnindex{LMPRNT}
\mybox{CALL LMPRNT(IUNIT,N,FP,FM)}
prints the map~$\cal F$ of order {\tt N} on logical unit {\tt IUNIT}.

\ttnindex{LMDPRT} 
\mybox{CALL LMDPRT(IUNIT,N,FP)}
prints the dynamic resonance generators of a map computed by
\ttindex{LADC2R}. 
It has three input parameters:
\begin{mylist}
\item[\tt IUNIT]
Logical unit number to receive the output.
\item[\tt N]
Maximum order of the terms to be printed.
\item[\tt FP]
Array containing the dynamic resonance generators.
\end{mylist}

\ttnindex{LMSPRT}
\mybox{CALL LMSPRT(IUNIT,N,FP)}
prints the static resonance generators of a map computed by
\ttindex{LASC2R}. 
It has three input parameters:
\begin{mylist}
\item[\tt IUNIT]
Logical unit number to receive the output.
\item[\tt N]
Maximum order of the terms to be printed.
\item[\tt FP]
Array containing the static resonance generators.
\end{mylist}
 
\section{Reflect a Map}
\label{LMREFL}\ttnindex{LMREFL}
\mybox{CALL LMREFL(FP,FM,N,GP,GM)}
Reflects the map~$\cal F$ of order {\tt N} and returns the result
in~$\cal G$.
Reflection is equivalent to running through the elements
producing~$\cal F$ in inverse (reflected) order.
 
\section{Reverse the Order of Factorization}
\label{LMREVF}\ttnindex{LMREVF}
\mybox{CALL LMREVF(FP,FM,N,GP,GM)}
Reverses the order of factorization of the map~$\cal F$ (order {\tt N}),
and returns the result in~$\cal G$.
 
\section{Conjugate a Map}
\label{LMSAND}\ttnindex{LMSAND}
\mybox{CALL LMSAND(N,GP,GM,TP,TM,AP,AM)}
Conjugates the map~$\cal G$ with the map~$\cal T$:
${\cal A} \leftarrow {\cal T G T}^-1.$
 
\section{Modify Map for Rotated Elements}
\label{LMTILT}\ttnindex{LMTILT}
\mybox{CALL LMTILT(N,TILT,FP,FM)}
Conjugates the map~$\cal F$ with the map~$\cal R$ representing a
rotation about the~$s$-axis by the angle \ttindex{TILT} (in rads):
${\cal F} \leftarrow {\cal R F R}^{-1}$.
 
\subsection{Map for User-Defined Element}
\label{LMUSER}\ttnindex{LMUSER}
\mybox{CALL LMUSER(N,ISP,EL,FP,FM)}
may be replaced by the user to implement tracking through user-defined
elements.
It should take the element parameters from the element bank,
pointed at by \ttindex{LCELM} (Section~\ref{Srefer}).
\begin{mylist}
\item[\tt N] 
Order of the map desired (input).
\item[\tt ISP]
Subprocess code for the element (input).
\item[\tt EL]
Element length (output).
\item[\tt FP,FM]
Computed transfer map (output).
\end{mylist}

%==============================================================================

\chapter{Beam Lines ``LN''}
The \ttindex{LN}~module provides methods for decoding and accessing
beam lines, beam lists, and sequences.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{LN}~module}
\label{T-LN}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{LNBEAM}&Command routine for \ttindex{LINE} command&-\\
\tt LNCHCK&Check that a valid \ttindex{USE} command was seen&
  \ref{LNCHCK}\\
\tt LNDROP&Delete a beam line expansion and anonymous drifts which
  it may contain due to a \ttindex{SEQUENCE}&-\\
\tt LNDUMP&Write a \ttindex{LINE} or \ttindex{LIST} definition on the
  ECHO file&\ref{LNDUMP}\\
\ttindex{LNEBGN}&Command routine for \ttindex{SEQEDIT} command&-\\
\ttindex{LNECYC}&Command routine for \ttindex{CYCLE} command&-\\
\ttindex{LNEINS}&Command routine for \ttindex{INSTALL} command&-\\
\ttindex{LNEMOV}&Command routine for \ttindex{MOVE} command&-\\
\ttindex{LNEREF}&Command routine for \ttindex{REFLECT} command&-\\
\ttindex{LNEREM}&Command routine for \ttindex{REMOVE} command&-\\
\ttindex{LNFORM}&
  Fill in formal arguments for a \ttindex{LINE} to be expanded&-\\
\ttindex{LNINIT}&
  Called by \ttindex{AAINIT} to initialize \ttindex{LN}~module&-\\
\ttindex{LNLIST}&Command routine for \ttindex{LIST} command&-\\
\ttindex{LNMAIN}&Switch routine for LN~module&-\\
\ttindex{LNMAKE}&Book a \ttindex{LINE} bank&-\\
\ttindex{LNMARK}&Mark maps for working beam line as obsolete&-\\
\ttindex{LNPMOD}&
  Propagater modification flags for \ttindex{LINE} and \ttindex{LUMP}&
  -\\
\ttindex{LNREFE}&
  Build line expansiong from a beam line reference&\ref{LNREFE}\\
\ttindex{LNSEQ}&Command routine for \ttindex{SEQUENCE} command&-\\
\ttindex{LNXLST}&
  Expand beam line sequence, called by \ttindex{LNXPND}&-\\
\ttindex{LNXPND}&
  Get next item of replacement list, called by \ttindex{LNREFE}&-\\
\ttindex{LNXPUT}&Add element to line expansion&-\\
\ttindex{LNXRES}&Reset replacement lists, called by \ttindex{LNXPND}&-\\
\ttindex{LNXSEQ}&
  Expand beam line sequence, called by \ttindex{LNXPND}&-\\
\hline
\end{tabular}
\end{table}

\label{clsmark}
When a \ttindex{SEQUENCE} is decoded, MAD allocates new storage only
for elements which have new attributes with respect to the class
object.
Otherwise it duplicates the pointer to the class object.
Both the class and the copy are then marked as an alias by setting the
\emindex{alias bit} \ttindex{MXALS}.
The class object is also marked as a class by setting the
{\em class bit}\index{class!bit}~\ttindex{MXCLS}.

\section{Check for Valid USE Command}
\label{LNCHCK}\ttnindex{LNCHCK}
\mybox{CALL LNCHCK(COMAND,EFLAG)}
checks that a working beam line has been set,
and that it has not been deleted due to subsequent data changes.
It has two arguments:
\begin{mylist}
\item[\tt COMAND]
A character string containing the current command name (input).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Dump Beam Line Definition}
\label{LNDUMP}\ttnindex{LNDUMP}
\mybox{CALL LNDUMP(LLINE,LABEL)}
writes a beam line definition on the ECHO file,
using the arguments
\begin{mylist}
\item[\tt LLINE]
Pointer to the definition to be dumped.
\item[\tt LABEL]
Name of the definition to be dumped.
\end{mylist}

\section{Expand a Beam Line Reference}
\label{LNREFE}\ttnindex{LNREFE}
\mybox{CALL LNREFE(LBANK,IBIAS,LSEQ,LSUP,ISUP)}
Builds an expansion for a given beam line reference.
The banks produced are:
\begin{mylist}
\item[\tt LSDIR]
Directory indices for elements and lines belonging to the expansion.
\item[\tt LSFLG]
Flag words (Table~\ref{Tflag}).
\item[\tt LSNUM]
Element numbers (Table~\ref{Tbexp}).
\end{mylist}
The other banks are built by other routines as required.
The arguments of \ttindex{LNREFE} are
\begin{mylist}
\item[\tt LBANK]
Pointer to the command bank supporting the beam line reference bank
(input).
\item[\tt IBIAS]
Attribute number of the beam line reference (input).
\item[\tt LSEQ]
Pointer to the new beam line expansion tree (output).
For the working beam line this is \ttindex{LCSEQ}.
\item[\tt LSUP]
Pointer to the bank which will support the expansion tree (input).
For the working beam line this is \ttindex{LROOT}.
\item[\tt ISUP]
Bias in the supporting bank for the pointer to the expansion tree
(input).
For the working beam line this is {\tt -MCSEQ},
thus the link {\tt LQ(LROOT-MCSEQ)} points to the working beam line.
\end{mylist}


%==============================================================================

\chapter{Matching Module ``MT''}
\label{MT}
The \ttindex{MT}~module is the matching module.
The methods are based on the MINUIT program,
written by F.~James~\cite{JAMES}.
There is also a method \ttindex{LMDIF} lifted from the DIMAD program,
originally written at SLAC by B.~S.~Garbov et~al.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{MT}~module}
\label{T-MT}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{MTACON}&Add constraint to a position&\ref{MTACON}\\
\ttindex{MTBTIN}&Find periodic solution of linear lattice functions&-\\
\ttindex{MTBTTK}&Track linear lattice functions trough an element&-\\
\ttindex{MTCELL}&Command routine for \ttindex{CELL} command&-\\
\tt MTCOND&Evaluate matching conditions,
   internal routine for \ttindex{MTEND} and \ttindex{MTFCN}&-\\
\ttindex{MTCONS}&Command routine for \ttindex{CONSTRAINT} command&-\\
\ttindex{MTCPLE}&Command routine for \ttindex{COUPLE} command&-\\
\ttindex{MTDERI}&
  Find first and second derivatives of penalty function&-\\
\ttindex{MTEND}&Command routine for \ttindex{END} command&\ref{MTACON}\\
\ttindex{MTFCN}&Compute matching functions&\ref{MTACON}\\ 
\ttindex{MTFIX}&Command routine for \ttindex{FIX} command&-\\
\ttindex{MTGETI}&Get internal parameter values&-\\
\ttindex{MTHESS}&Compute covariance matrix&-\\
\ttindex{MTINIT}&Initialize \ttindex{MT}~module&-\\
\ttindex{MTLINE}&Find minimum along a line in parameter space&-\\
\ttindex{MTLMDF}&Command routine for \ttindex{LMDIF} command&-\\
\ttindex{MTMAIN}&Switch routine for \ttindex{MT}~module&\ref{MTMAIN}\\
\ttindex{MTMIGR}&Command routine for \ttindex{MIGRAD} command&-\\
\ttindex{MTMIG1}&Minimize by \ttindex{MIGRAD} method&-\\
\ttindex{MTMTCH}&Command routine for \ttindex{MATCH} command&-\\
\ttindex{MTPINI}&
 Initialize calculation of target functions&\ref{MTACON}\\
\ttindex{MTPMOD}&
 Delete precomputed transfer maps after parameter change&-\\
\ttindex{MTPRNT}&Print-out for matching&-\\
\ttindex{MTPSDF}&Ensure that covariance matrix is positive definite&-\\
\ttindex{MTPUTI}&Put internal parameter values&-\\
\ttindex{MTRAZZ}&Internal routine for \ttindex{MTSIM1}&-\\
\ttindex{MTRMAT}&Command routine for \ttindex{RMATRIX} command&-\\
\ttindex{MTSIMP}&Command routine for \ttindex{SIMPLEX} command&-\\
\ttindex{MTSIM1}&Minimize by \ttindex{SIMPLEX} method&-\\
\ttindex{MTTMAT}&Command routine for \ttindex{TMATRIX} command&-\\
\ttindex{MTVARY}&Command routine for \ttindex{VARY} command&-\\
\ttindex{MTVFND}&Look up a variable in the variable table&-\\
\ttindex{MTWEIG}&Command routine for \ttindex{WEIGHT} command&-\\
\hline
\ttindex{FDJAC}&Internal routine for \ttindex{LMDIF}&-\\
\ttindex{LMDIF}&Minimize by \ttindex{LMDIF} method&-\\
\ttindex{LMPAR}&Internal routine for \ttindex{LMDIF}&-\\
\hline
\end{tabular}
\end{table}

\clearpage
\section{Changes Required to Add New Constraint Types}
\label{MTACON}\ttnindex{MTACON}
A new constraint type can easily be added to the present matching
module.
First, one has to link a command routine to decode the
constraint to the switch routine \ttindex{MTMAIN}.
The command routine must link the constraint conditions to the working
beam line by calling \ttindex{MTACON} (possibly selecting the places via
\ttindex{ENSRNG} and/or \ttindex{ENSTYP}.
The actual evaluation of the constraint must be added to
\ttindex{MTCOND}. 
If the condition requires initialization, like the {\tt LINE=line}
condition for the \ttindex{CONSTRAINT} command,
this initialization must be added to \ttindex{MTPINI}.

\section{Changes Required to Add New Matching Methods}
\label{MTMAIN}\ttnindex{MTMAIN}
The command routine to execute a new matching method must be linked
to the switch routine \ttindex{MTMAIN}.
It can get access to the target functions via
\mybox{CALL MTFCN(NF,NX,X,FVEC,IFLAG)}
with the arguments
\begin{mylist}
\item[\tt NF]
Number of target functions (input).
\item[\tt NX]
Number of variable parameters (input).
\item[\tt X]
Values of variable parameters (input).
This must be dimensioned at {\tt NX}.
\item[\tt FVEC]
Values of the target functions (output).
This must be dimensioned at {\tt NF}.
\item[\tt IFLAG]
Integer error flag (output).
If this value is non-zero upon return,
the matching method should discard this point in parameter space as illegal.
\end{mylist}

%==============================================================================

\chapter{Matrix Utilities ``M66''}
\label{M66}
The \ttindex{M66}~module contains utilities for operations on
$6 \times 6$~matrices. 

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{M66}~module}
\label{T-M66}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{M66ADD}&Add two matrices&\ref{M66ADD}\\
\ttindex{M66BYV}&Multiply matrix by vector&\ref{M66BYV}\\
\ttindex{M66CPY}&Copy a matrix&\ref{M66CPY}\\
\ttindex{M66DIV}&Multiply a matrix by inverse of another&\ref{M66DIV}\\
\ttindex{M66EXP}&Exponentiate a matrix&\ref{M66EXP}\\
\ttindex{M66INV}&Invert a symplectic matrix&\ref{M66INV}\\
\ttindex{M66MAK}&Build matrix for $F_2$ polynomial&\ref{M66MAK}\\
\ttindex{M66MPY}&Multiply two matrices&\ref{M66MPY}\\
\ttindex{M66MTR}&
 Multiply matrix by transpose of another matrix&\ref{M66MTR}\\
\ttindex{M66NRM}&Return norm of a matrix&\ref{M66NRM}\\
\ttindex{M66ONE}&Build identity matrix&\ref{M66ONE}\\
\ttindex{M66PRT}&Print a matrix&\ref{M66PRT}\\
\ttindex{M66REF}&Reflect a symplectic matrix&\ref{M66REF}\\
\ttindex{M66SCL}&Scale a matrix&\ref{M66SCL}\\
\ttindex{M66STA}&Determine if matrix is static&\ref{M66STA}\\
\ttindex{M66SUB}&Subtract two matrices&\ref{M66SUB}\\
\ttindex{M66TP}&Transpose a matrix&\ref{M66TP}\\
\ttindex{M66TRM}&Multiply matrix by transpose of another&\ref{M66TRM}\\
\ttindex{M66ZRO}&Set a matrix to zero&\ref{M66ZRO}\\
\hline
\end{tabular}
\end{table}

\section{Add two Matrices}
\label{M66ADD}\ttnindex{M66ADD}
\mybox{CALL M66ADD(A,B,C)}
adds two $6 \times 6$~matrices: $C \leftarrow A + B$.
\begin{mylist}
\item[\tt A]
First summand~$A$ (input).
\item[\tt B]
Second summand~$B$ (input).
\item[\tt C]
Sum~$C$ (output).
\end{mylist}

\section{Multiply Matrix by Vector}
\label{M66BYV}\ttnindex{M66BYV}
\mybox{CALL M66BYV(A,B,C)}
multiplies a $6 \times 6$~matrix~$A$ by a vector~$B$:
$C \leftarrow A B$.
\begin{mylist}
\item[\tt A]
Matrix~$A$ (input).
\item[\tt B]
Vector~$B$ (input).
\item[\tt C]
Result vector~$C$ (output).
\end{mylist}

\section{Copy a Matrix}
\label{M66CPY}\ttnindex{M66CPY}
\mybox{CALL M66CPY(A,B)}
copies a $6 \times 6$~matrix: $B \leftarrow A$.
\begin{mylist}
\item[\tt A]
Matrix~$A$ to be copied (input).
\item[\tt B]
Copied matrix~$B$ (output).
\end{mylist}

\section{``Divide'' two Matrices}
\label{M66DIV}\ttnindex{M66DIV}
\mybox{CALL M66DIV(A,B,C,EFLAG)}
multiplies a general $6 \times 6$~matrix by the inverse of another one:
$C \leftarrow B^{-1} A$.
If $B$~cannot be inverted, {\tt EFLAG} is returned as {\tt .TRUE.}.
\begin{mylist}
\item[\tt A]
Matrix~$A$ (input).
\item[\tt B]
Matrix~$B$ (input).
\item[\tt C]
Result~$C$ (output).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Exponentiate a Matrix}
\label{M66EXP}\ttnindex{M66EXP}
\mybox{CALL M66EXP(A,B,EFLAG)}
exponentiates a matrix: $M \leftarrow e^{JS}$.
The matrix~$A$ must be built by \ttindex{M66MAK},
that is the equation $[F,Z] = AZ$ must be true for some quadratic
homogeneous polynomial~$F$.
\begin{mylist}
\item[\tt A]
Input matrix~$A$.
\item[\tt M]
Output matrix~$B$.
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Invert a Symplectic Matrix}
\label{M66INV}\ttnindex{M66INV}
\mybox{CALL M66INV(A,B)}
inverts a symplectic $6 \times 6$~matrix: $B \leftarrow A^{-1}$.
\begin{mylist}
\item[\tt A]
Symplectic matrix~$A$ to be inverted (input).
\item[\tt B]
Inverted matrix~$B$ (output).
\end{mylist}

\section{Matrix for Poisson Bracket with Second-Order Polynomial}
\label{M66MAK}\ttnindex{M66MAK}
\mybox{CALL M66MAK(F,A)}
returns the matrix~$A$ such that $AZ = [F,Z]$,
where $F$~is a quadratic homogeneous polynomial in phase space
coordinates. 
\begin{mylist}
\item[\tt F]
Second-order polynomial~$F$ (input),
stored in the order shown in Appendix~\ref{giorgelli}.
\item[\tt A]
Result matrix~$A$.
\end{mylist}

\section{Multiply Two Matrices}
\label{M66MTR}\ttnindex{M66MTR}
\mybox{CALL M66MTR(A,B,C)}
multiplies two $6 \times 6$~matrices: $C \leftarrow A B$.
\begin{mylist}
\item[\tt A]
First factor~$A$ (input).
\item[\tt B]
Second factor~$B$ (input).
\item[\tt C]
Product~$C$ (output).
\end{mylist}

\section{Multiply Matrix by Transpose of Another Matrix}
\label{M66MPY}\ttnindex{M66MPY}
\mybox{CALL M66MPY(A,B,C)}
multiplies a matrix~$A$ by the transpose of another matrix~$B$:
$C \leftarrow A B^T$.
\begin{mylist}
\item[\tt A]
First factor~$A$ (input).
\item[\tt B]
Second factor~$B$ to be transposed (input).
\item[\tt C]
Product~$C$ (output).
\end{mylist}

\section{Return Norm of a Matrix}
\label{M66NRM}\ttnindex{M66NRM}
\mybox{X = M66NRM(A)}
Returns the norm of the $6 \times 6$~matrix~$A$ in~$X$.
\begin{mylist}
\item[\tt A]
Input matrix~$A$.
\end{mylist}

\section{Build Identity Matrix}
\label{M66ONE}\ttnindex{M66ONE}
\mybox{CALL M66ONE(A)}
sets the matrix~$A$ to the $6 \times 6$~identity matrix.
\begin{mylist}
\item[\tt A]
Matrix~$A$ to be set to identity.
\end{mylist}

\section{Print a Matrix}
\label{M66PRT}\ttnindex{M66PRT}
\mybox{CALL M66PRT(A,IUNIT)}
prints the $6 \times 6$~matrix~$A$ on logical unit {\tt IUNIT}.
\begin{mylist}
\item[\tt A]
Matrix~$A$ to be printed (input).
\item[\tt IUNIT]
Logical unit number to receive output (input).
\end{mylist}

\section{Reflect a Symplectic Matrix}
\label{M66REF}\ttnindex{M66REF}
\mybox{CALL M66REF(A,B)}
reflects the symplectic $6 \times 6$~matrix~$A$ and returns the result
in~$B$.
The result is equivalent to reflecting the beam line which produced the
transfer matrix~$A$.
\begin{mylist}
\item[\tt A]
Symplectic input matrix~$A$.
\item[\tt B]
Reflected matrix~$B$ (output).
\end{mylist}

\section{Scale a Matrix}
\label{M66SCL}\ttnindex{M66SCL}
\mybox{CALL M66SCL(S,A,B)}
multiplies a $6 \times 6$~matrix~$A$ by a scalar~$S$:
$B \leftarrow S A$.
\begin{mylist}
\item[\tt S]
Scalar factor~$S$ (input).
\item[\tt A]
Matrix factor~$A$ (input).
\item[\tt B]
Product~$B$ (output).
\end{mylist}
                   
\section{Determine if a Matrix is Static}
\label{M66STA}\ttnindex{M66STA}
\mybox{SFLAG = M66STA(A)}
sets {\tt SFLAG} to {\tt .TRUE.} if the matrix~$A$ does not change
the particle energy.
\begin{mylist}
\item[\tt A]
Input matrix~$A$.
\end{mylist}

\section{Subtract two Matrices}
\label{M66SUB}\ttnindex{M66SUB}
\mybox{CALL M66SUB(A,B,C)}
subtracts two $6 \times 6$~matrices: $C \leftarrow A - B$.
\begin{mylist}
\item[\tt A]
First term~$A$ (input).                        
\item[\tt B]
Second term~$B$ (input).
\item[\tt C]
Difference~$C$ (output).
\end{mylist}

\section{Transpose a Matrix}
\label{M66TP}\ttnindex{M66TP}
\mybox{CALL M66TP(A,B)}
transposes a $6 \times 6$~matrix: $B \leftarrow A^T$.
\begin{mylist}
\item[\tt A]
Input matrix~$A$.
\item[\tt B]
Transposed matrix~$B$ (output).
\end{mylist}

\section{Multiply a Matrix by the Transpose of Another One}
\label{M66TRM}\ttnindex{M66TRM}
\mybox{CALL M66TRM(A,B,C)}
transposes a $6 \times 6$~matrix and multiplies it with another one:
$C \leftarrow A^T B$.
\begin{mylist}
\item[\tt A]
First factor~$A$ to be transposed (input).
\item[\tt B]
Second factor~$B$ (input).
\item[\tt C]
Product~$C$ (output).
\end{mylist}

\section{Set a Matrix to Zero}
\label{M66ZRO}\ttnindex{M66ZRO}
\mybox{CALL M66ZRO(A)}
sets a $6 \times 6$~matrix to zero: $A \leftarrow 0$.
\begin{mylist}
\item[\tt A]
Matrix~$A$ to be set to zero.
\end{mylist}

%==============================================================================

\chapter{Polynomial Algebra ``PA''}
\label{PA}
The \ttindex{PA}~module contains utilities for algebra on polynomials of
three and six variables.
Polynomials are stored in arrays,
with the coefficients ordered as in Appendix~\ref{giorgelli}.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{PA}~module}
\label{T-PA}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
         &General Routines&\\
\hline
\ttindex{PAINIT}&Initialize complete package&\ref{PAINIT}\\
\ttindex{PAXIND}&Internal routine to compute indexing&-\\
\hline
         &Polynomials in three variables&\\
\hline
\ttindex{PA3DIF}&Differentiate polynomial&\ref{PA3DIF}\\
\ttindex{PA3INI}&Initialize&-\\
\hline
         &Polynomials in six variables&\\
\hline
\ttindex{PA6ADD}&Add two polynomials&\ref{PA6ADD}\\
\ttindex{PA6BRK}&Poisson bracket of two polynomials&\ref{PA6BRK}\\
\ttindex{PA6CLR}&Clear a polynomial to zero&\ref{PA6CLR}\\
\ttindex{PA6CPY}&Copy a polynomial&\ref{PA6CPY}\\
\ttindex{PA6DIF}&Differentiate polynomial&\ref{PA6DIF}\\
\ttindex{PA6INI}&Initialize&-\\
\ttindex{PA6NRM}&Find norm of a polynomial&\ref{PA6NRM}\\
\ttindex{PA6PRD}&Product of two polynomials&\ref{PA6PRD}\\
\ttindex{PA6PRT}&Print a polynomial&\ref{PA6PRT}\\
\ttindex{PA6SCL}&Scale a polynomial&\ref{PA6SCL}\\
\ttindex{PA6SUB}&Subtract two polynomials&\ref{PA6SUB}\\
\ttindex{PA6SUM}&Scaled sum of two polynomials&\ref{PA6SUM}\\
\ttindex{PA6VAL}&Value of a polynomial&\ref{PA6VAL}\\
\ttindex{PA6XFM}&
 Transform arguments of a polynomial linearly&\ref{PA6XFM}\\
\hline
\end{tabular}
\end{table}

\section{Initialize Polynomial Package}
\label{PAINIT}\ttnindex{PAINIT}
\mybox{CALL PAINIT(N)}
initializes the polynomial package for a given order~{\tt N}.
It sets up ZEBRA banks with various tables.

\section{Derive Polynomial in Three Variables}
\label{PA3DIF}\ttnindex{PA3DIF}
\mybox{CALL PA3DIF(F,I,N,G)}
derives a polynomial in three variables with respect to one variable:
$G \leftarrow \partial F / \partial z_i$.
\begin{mylist}
\item[\tt F]
Coefficients of the polynomial~$F$ (input).
\item[\tt I]
Variable~$i$ with respect to which to differentiate (input).
\item[\tt N]
Order~$N$ of the polynomial (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomial of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt G]
Coefficients for the derivative~$G$, of order~$N - 1$ (output).
\end{mylist}

\section{Add Two Polynomials in Six Variables}
\label{PA6ADD}\ttnindex{PA6ADD}
\mybox{CALL PA6ADD(F,G,N,H)}
adds two polynomials in six variables: $H \leftarrow F + G$.
\begin{mylist}
\item[\tt F]
Coefficients for the first term (input).
\item[\tt G]
Coefficients for the second term (input).
\item[\tt N]
Order~$N$ of the polynomials (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomials of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt H]
Coefficients for the sum (output).
\end{mylist}

\section{Poisson Bracket of Two Polynomials in Six Variables}
\label{PA6BRK}\ttnindex{PA6BRK}
\mybox{CALL PA6BRK(F,NF,G,NG,H)}
Computes the Poisson bracket of two homogeneous polynomials in six
variables: $H \leftarrow [F,G]$.
\begin{mylist}
\item[\tt F]
Coefficients for the first operand~$F$ (input).
\item[\tt NF]
Order~$N_f$ of the polynomial~$F$ (input).
\item[\tt G]
Coefficients for the second operand~$G$ (input).
\item[\tt NORD]
Order~$N_g$ of the polynomial~$G$ (input).
\item[\tt H]
Coefficients for the product~$H$ of order $N_f + N_g - 2$ (output).
\end{mylist}

\section{Clear a Polynomial in Six Variables}
\label{PA6CLR}\ttnindex{PA6CLR}
\mybox{CALL PA6CLR(F,N)}
clears a polynomials in six variables: $F \leftarrow 0$.
\begin{mylist}
\item[\tt F]
Coefficients for the result (output).
\item[\tt N]
Order~$N$ of the polynomial (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomial of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\end{mylist}

\section{Copy a Polynomial in Six Variables}
\label{PA6CPY}\ttnindex{PA6CPY}
\mybox{CALL PA6CPY(F,N,G)}
copies a polynomials in six variables: $G \leftarrow F$.
\begin{mylist}
\item[\tt F]
Coefficients for the source (input).
\item[\tt N]
Order~$N$ of the polynomial (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomial of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt G]
Coefficients for the target (output).
\end{mylist}

\section{Differentiate Polynomial in Six Variables}
\label{PA6DIF}\ttnindex{PA6DIF}
\mybox{CALL PA6DIF(F,I,N,G)}
derives a polynomial in six variables with respect to one variable:
$G \leftarrow \partial F / \partial z_i$.
\begin{mylist}
\item[\tt F]
Coefficients of the polynomial~$F$ (input).
\item[\tt I]
Variable~$I$ with respect to which to differentiate (input).
\item[\tt N]
Order~$N$ of the polynomial (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomial of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt G]
Coefficients for the derivative~$G$, of order~$N - 1$ (output).
\end{mylist}

\section{Find Norm of a Polynomial in Six Variables}
\label{PA6NRM}\ttnindex{PA6NRM}
\mybox{X = PA6NRM(F,N)}
returns the norm of a polynomials in six variables: $X \leftarrow ||F||$.
\begin{mylist}
\item[\tt F]
Coefficients for the polynomial (input).
\item[\tt NF]
Order~$N_f$~of the polynomial~$F$ (input).
\end{mylist}
The norm of the polynomial is defined as the sum of the absolute values
of its coefficients.

\section{Multiply Two Polynomials in Six Variables}
\label{PA6PRD}\ttnindex{PA6PRD}
\mybox{CALL PA6PRD(F,NF,G,NG,H)}
subtracts two homogeneous polynomials in six variables: 
$H \leftarrow F G$. 
\begin{mylist}
\item[\tt F]
Coefficients for the first factor (input).
\item[\tt NF]
Order~$N_f$ of the polynomial~$F$ (input).
\item[\tt G]
Coefficients for the second factor (input).
\item[\tt NG]
Order~$N_g$ of the polynomial~$G$ (input).
\item[\tt H]
Coefficients for the product of order $N_f + N_g$ (output).
\end{mylist}


\section{Print a Polynomial in Six Variables}
\label{PA6PRT}\ttnindex{PA6PRT}
\mybox{CALL PA6PRT(F,N,IUNIT)}
prints a polynomial in six variables from order one to~$N$.
\begin{mylist}
\item[\tt F]
Coefficients for the polynomial (input).   
\item[\tt N]
Order~$N$ of the polynomial (input).
\item[\tt IUNIT]
Logical unit to receive output (input).
\end{mylist}

\section{Scale a Polynomial in Six Variables}
\label{PA6SCL}\ttnindex{PA6SCL}
\mybox{CALL PA6SCL(S,F,N,G)}
scales a polynomial in six variables: $G \leftarrow S F$.
\begin{mylist}
\item[\tt S]
Scalar factor (input).
\item[\tt F]
Coefficients for polynomial to be scaled (input).   
\item[\tt N]
Order~$N$ of the polynomial (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomial of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt G]
Coefficients for scaled result~$G$ (output).
\end{mylist}

\section{Subtract Two Polynomials in Six Variables}
\label{PA6SUB}\ttnindex{PA6SUB}
\mybox{CALL PA6SUB(F,G,N,H)}
subtracts two polynomials in six variables: $H \leftarrow F - G$.
\begin{mylist}
\item[\tt F]
Coefficients for the first term (input).   
\item[\tt G]
Coefficients for the second term (input).
\item[\tt N]
Order~$N$ of the polynomials (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomials of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt H]
Coefficients for the difference~$H$ (output).
\end{mylist}

\section{Scaled Sum of Two Polynomials in Six Variables}
\label{PA6SUM}\ttnindex{PA6SUM}
\mybox{CALL PA6SUM(S,F,N,G)}
scales a polynomial in six variables and adds it to another one:
$G \leftarrow G + S F$.
\begin{mylist}
\item[\tt S]
Scalar factor (input).
\item[\tt F]
Coefficients for polynomial to be scaled (input).   
\item[\tt N]
Order~$N$ of the polynomials (input):
\begin{description}
\item[$N > 0$:] Homogeneous polynomials of order~$N$.
\item[$N < 0$:] All orders up to~$N$.
\end{description}
\item[\tt G]
Coefficients for the accumulated sum~$G$ (output).
\end{mylist}

\section{Value of a Polynomial in Six Variables}
\label{PA6VAL}\ttnindex{PA6VAL}
\mybox{V = PA6VAL(F,N,Z)}
returns the value of a polynomial in six variables: $V \leftarrow F(Z)$.
\begin{mylist}
\item[\tt F]
Coefficients for the polynomial (input).   
\item[\tt N]
Order~$N$ of the polynomial (input).
\item[\tt Z]
A phase-space vector (input).
\end{mylist}

\section{Transform Arguments of a Polynomial in Six Variables}
\label{PA6XFM}\ttnindex{PA6XFM}
\mybox{CALL PA6XFM(F,N,A,G)}
transforms the arguments of a polynomial in six variables by a matrix:
$G(Z) \leftarrow F(AZ)$.
\begin{mylist}
\item[\tt F]
Coefficients for the polynomial (input).   
\item[\tt N]
Order~$N$ of the polynomial (input).
\item[\tt A]
Matrix for transformation (input).
\item[\tt G]
Coefficients for the transformed polynomial~$G$ (output).
\end{mylist}

%==============================================================================

\chapter{Plot Module ``PL''}
\label{PL}
The \ttindex{PL}~module implements plot commands.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{PL}~module}
\label{T-PL}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{PLARWE}&Tune plot (tune resonance lines)&\ref{PLARWE}\\
\ttindex{PLCOLI}&Enter variable formats, biasses in banks&-\\
\ttindex{PLCURV}&Plot one curve&-\\
\ttindex{PLDUMP}&Dump the plot bank (debugging)&\ref{PLDUMP}\\
\ttindex{PLELMA}&Return $4 \times 6$ element matrix&-\\
\ttindex{PLGACN}&Position curve annotation&-\\
\ttindex{PLGARW}&
  Code tune plot constraints in Polish notation&\ref{PLGARW}\\
\ttindex{PLGAXN}&Return compound vertical axis annotation&-\\
\ttindex{PLGCMD}&Return unpacked \ttindex{PLOT} command parameters&-\\
\ttindex{PLGETN}&Get variable names for labels etc.&-\\
\ttindex{PLGTBS}&Return table information such as biasses&-\\
\ttindex{PLINTP}&
  Interpolate variables plotted against $s$&\ref{PLINTP}\\
\ttindex{PLMAIN}&
  Plot module entry (\ttindex{PLOT}, \ttindex{RESPLOT}, 
  \ttindex{SETPLOT})&-\\
\ttindex{PLPLOT}&Plot one complete picture&\ref{PLPLOT}\\
\ttindex{PLPREP}&
  Prepare plot banks for routine \ttindex{PLPLOT}&\ref{PLPREP}\\
\ttindex{PLPTIT}&Prepare picture title&-\\
\ttindex{PLQCON}&Check user constraints on tune plot&\ref{PLQCON}\\
\ttindex{PLSCHM}&Plot machine schema (magnet symbols)&-\\
\ttindex{PLPVAL}&Calculate composite plot variables&-\\
\hline
\end{tabular}
\end{table}

\section{Make Tune Plot}
\label{PLARWE}\ttnindex{PLARWE}
\mybox{CALL PLARWE (IBK, ACTWIN)}
Makes a plot of tune resonance lines
\begin{mylist}
\item[\tt IBK]
Array containing:
the number of superperiods,
the number of constraints N,
the N constraints:
minimum, maximum, step, length {\tt L},
expression in Polish notation of length L,
\index{Polish notation}
coded as 100001=``$+$'', 100002=``$-$'', 100003=``$*$'',
100004=``$/$'', 100005={\tt KX}, 100006={\tt KY}, 100007={\tt KS},
all other simple integers. 
\item[\tt ACTWIN]
Active user window.
\end{mylist}

\section{Dump Plot Bank}
\label{PLDUMP}\ttnindex{PLDUMP}
\mybox{CALL PLDUMP}
Dumps the contents of the plot bank.

\section{Tune Plot Constraints}
\label{PLGARW}\ttnindex{PLGARW}
\mybox{CALL PLGARW (MXB, MXC, QC, IR, NTOT, IBK, IERR)}
Returns tune plot constraints in inverse Polish notation:
\begin{mylist}
\item[\tt MXB]
Maximum length of output array.
\item[\tt MXC]
Maximum number of constraints.
\item[\tt QC]
Constraints as read.
\item[\tt IR]
Lower limit, upper limit, step of loop.
\item[\tt NTOT]
Length occupied in output array.
\item[\tt IBK]
Output array  (format: see~\ref{PLARWE}).
\item[\tt IERR]
Error flag: 0=OK, else wrong expression.
\end{mylist}

\section{Interpolate Twiss Variables}
\label{PLINTP}\ttnindex{PLINTP}
\mybox{CALL PLINTP(IEP, NPNT, NMAX, STEP, VMIN, VMAX, IERR)}
Interpolates variables plotted against~$s$.   
\begin{mylist}
\item[\tt IEP]
Row number of first element.
\item[\tt NPNT]
Number of points 
\item[\tt NMAX]
Maximum number of points that should possibly appear.
\item[\tt STEP]
Maximum distance between two successive horizontal values.
\item[\tt VMIN]
Minima for 4 axes.
\item[\tt VMAX]
Maxima for 4 axes.
\item[\tt IERR]
Integer error flag: 0=OK, else wrong.
\end{mylist}

\section{Plot one Complete Picture}
\label{PLPLOT}\ttnindex{PLPLOT}
\mybox{CALL PLPLOT}
Plots one complete picture entirely from the information contained
in the plot bank structure \ttindex{PLMAIN}.
The format of this structure is given in the routine header of
\ttindex{PLPLOT}.

\section{Prepare one Complete Picture}
\label{PLPREP}\ttnindex{PLPREP}
\mybox{CALL PLPREP}
Fills one complete picture 
into the plot bank structure \ttindex{PLMAIN}.
The format of this structure is given in the routine header of
\ttindex{PLPLOT}.

\section{Check Tune Plot Constraints}
\label{PLQCON}\ttnindex{PLQCON}
\mybox{CALL PLQCON (KX, KY, KXYS, IBK, ISELCT, IERR)}
Checks the constraints on the tune resonances to be plotted
\begin{mylist}
\item[\tt KX]
Index of~$K_x$ in {\tt KXYS}.
\item[\tt KY]
Index of~$K_y$ in {\tt KXYS}.
\item[\tt HXYS]
Array containing $K_x=\hbox{\tt KXYS(KX)}$, $K_y=\hbox{\tt KXYS(KY)}$,
$K_s = \hbox{\tt KXYS(3)}$.
\item[\tt IBK]
Array containing constraints in inverse Polish notation 
(format: see~\ref{PLARWE}).
\item[\tt ISELCT]
Output flag: 1~if constraint is passed, else~0.
\item[\tt IERR]
Integer error flag: 0=OK, else wrong.
\end{mylist}

%==============================================================================

\chapter{Print Utilities ``PR''}
\label{PR}
The \ttindex{PR}~module contains the utilities for printing which may
be useful for consistent page layout.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{PR}~module}
\label{T-PR}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{PRLINE}&Print line of dashes&\ref{PRLINE}\\
\ttindex{PRPAGE}&Print page header&\ref{PRPAGE}\\
\hline
\end{tabular}
\end{table}
              
\section{Print a Line of Dashes over the Page}
\label{PRLINE}\ttnindex{PRLINE}
\mybox{CALL PRLINE(IUNIT)}
prints a line of 130~dashes across the page on logical unit {\tt IUNIT}.

\section{Print page Header}
\label{PRPAGE}\ttnindex{PRPAGE}
\mybox{CALL PRPAGE(IUNIT)}
prints the page header line, with title and version number,
on logical unit {\tt IUNIT}.

%==============================================================================

\chapter{Low-Level Reading Routines ``RD''}
\label{RD}
The \ttindex{RD}~module contains the low-level decoding routines.
These are not designed to be called directly,
but to act as subroutines of the \ttindex{DC}~module.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{RD}~module}
\label{T-RD}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{RDFAIL}&Count fatal error and mark place on input line&-\\ 
\ttindex{RDFIND}&Skip to next character occurring in a string&-\\
\ttindex{RDFORM}&Mark delimiters of formal argument list&-\\
\ttindex{RDINIT}&Initialize \ttindex{RD}~ module&-\\
\ttindex{RDINT}&Read an integer value&-\\
\ttindex{RDLINE}&Read a card image&-\\
\ttindex{RDLOGC}&Read a logical value&-\\
\ttindex{RDMARK}&Mark place on input line&-\\
\ttindex{RDNUMB}&Read a floating point value&-\\
\ttindex{RDSKIP}&Skip characters in a string&-\\
\ttindex{RDSTAT}&Read a complete statement into statement buffer&-\\
\ttindex{RDSTRG}&Read a string value&-\\
\ttindex{RDTEST}&Test and skip a character&-\\
\ttindex{RDWARN}&Count warning message and mark place on input line&-\\
\ttindex{RDWORD}&Read an alphanumeric string&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Survey Module ``SU''}
\label{SU}
The \ttindex{SU}~module performs all actions related to
\ttindex{SURVEY}. 
Some routines are provided for use in misalignment operations.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{SU}~module}
\label{T-SU}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{SUANGL}&Convert rotation matrix to three angles&-\\
\ttindex{SUCOPY}&Copy displacement and rotation matrix&-\\
\tt SUELEM&Return displacement and rotation matrix for an element&
  \ref{SUELEM}\\
\ttindex{SUHEAD}&Print survey header&-\\
\ttindex{SUIDEN}&
  Set displacement and rotation matrix to identity transform&-\\
\ttindex{SULINE}&
  Return displacement and rotation matrix for a line&\ref{SULINE}\\
\ttindex{SUMAIN}&Switch routine for \ttindex{SU}~module&-\\
\ttindex{SUMTRX}&Build rotation matrix from three angles&-\\
\ttindex{SURVEY}&Command routine for \ttindex{SURVEY} command&-\\
\tt SUTRAN&Transform displacement and rotation matrix for rotation&
  \ref{SUTRAN}\\
\ttindex{SUTRAK}&
  Advance displacement and rotation matrix through element&-\\
\tt SUUSER&
  Return displacement and rotation matrix for user-defined element&
  \ref{SUUSER}\\
\hline
\end{tabular}
\end{table}

\section{Displacement and Rotation for an Element}
\label{SUELEM}\ttnindex{SUELEM}
\mybox{CALL SUELEM(ELEN,ALEN,V,W)}
returns survey information about the current element,
pointed at by \ttindex{LCELM}.
\begin{mylist}
\item[\tt ELEN]
Element length, measured as the sagitta (output).
\item[\tt ALEN]
Element length, measured as the arc length (output).
\item[\tt V]
Three-dimensional displacement (output).
\item[\tt W]
Rotation, represented as a 3-dimensional orthogonal matrix (output).
\end{mylist}

\section{Displacement and Rotation for a Beam Line}
\label{SULINE}\ttnindex{SULINE}
\mybox{CALL SULINE(IPOS,ELEN,ALEN,V,W)}
returns survey information about the line ending at a given position
in the working beam line.
\begin{mylist}
\item[\tt IPOS]
Position counter in the working beam line, where the line in
question ends (input).
\item[\tt ELEN]
Line length, measured as the sagitta (output).
\item[\tt ALEN]
Line length, measured as the arc length (output).
\item[\tt V]
Three-dimensional displacement (output).
\item[\tt W]
Rotation, represented as a 3-dimensional orthogonal matrix
(output).
\end{mylist}

\section{Transform Displacement and Rotation with a Rotation}
\label{SUTRAN}\ttnindex{SUTRAN}
\mybox{CALL SUTRAN(W,V,WE)}
transforms the rotation and the displacement of the element exit with
respect to the element entrance from one reference to another.
\begin{mylist}
\item[\tt W,V]
Rotation matrix~$W$ and the displacement vector~$V$ for the
misalignment of an element.
\item[\tt WE]
Rotation~$W_e$ of the exit system with respect to entrance system.
\end{mylist}
Upon entry to the routine,~$W$ and~$V$ must be related to the element
entrance.
Upen exit the routine returns the same quantities related to the
element exit:
\[
W_2 = W_e^T W_1 W_e, \qquad V_2 = W_e^T V_1.
\]

\section{Displacement and Rotation for User-Defined Elements}
\label{SUUSER}\ttnindex{SUUSER}
\mybox{CALL SUUSER(ELEN,ALEN,V,W)}
returns survey information about user-defined elements.
It should take the element parameters from the element bank,
pointed at by \ttindex{LCELM} (Section~\ref{Srefer}).
\begin{mylist}
\item[\tt ELEN]
Element length, measured as the sagitta (output).
\item[\tt ALEN]
Element length, measured as the arc length (output).
\item[\tt V]
Three-dimensional displacement (output).
\item[\tt W]
Rotation, represented as a 3-dimensional orthogonal matrix (output).
\end{mylist}

%==============================================================================

\chapter{Formatted write routines ``SV''}
\label{SV}
The \ttindex{SV}~module contains the command routine for
the~\ttindex{HELP}, \ttindex{SHOW}, and \ttindex{SAVE}~commands.
Some of the routines may also be of use for building ad hoc
saving commands.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{SV}~module}
\label{T-SV}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{SVATTR}&Write one attribute of a command&-\\
\ttindex{SVBANK}&Write complete command&-\\
\ttindex{SVBEGN}&Begin new line on SAVE file&-\\
\ttindex{SVCONT}&Begin continuation line on SAVE file&-\\
\ttindex{SVDICT}&Write complete keyword definition&-\\
\ttindex{SVDUMP}&Write out last line of a command&-\\
\ttindex{SVEXPR}&Write arithmetic expression in encoded form&-\\
\ttindex{SVHELP}&Command routine for \ttindex{HELP} command&-\\
\ttindex{SVINT}&Write integer value&-\\
\ttindex{SVLINE}&Write \ttindex{LINE} command&-\\
\ttindex{SVLIST}&Write beam line list&-\\
\ttindex{SVLITT}&Write litteral string&-\\
\ttindex{SVMAIN}&Command routine for \ttindex{SAVE} command&-\\
\ttindex{SVNAME}&Write alphanumeric string&-\\
\ttindex{SVPARM}&Write \ttindex{PARAMETER} command&-\\
\ttindex{SVREAL}&Write real value&-\\
\ttindex{SVSEQ}&Write \ttindex{SEQUENCE} command&-\\
\ttindex{SVSHOW}&Command routine for \ttindex{SHOW} command&-\\
\ttindex{SVSUBR}&Write \ttindex{SUBROUTINE} definition&-\\
\ttindex{SVSTRG}&Write quoted string&-\\
\ttindex{SVVREF}&Write variable reference&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Dynamic Table Handler ``TB''}
\label{TB}
The ``TB''~module contains routines to read and write dynamic tables of
virtually unlimited size.
On Cray computers the tables reside in the SSD (Solid State Device),
on other computers on direct-access disk files.
The tables may be read and written as a whole as TFS files~\cite{TFS}.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{TB}~module}
\label{T-TB}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{TBBUFF}&Book table buffers&-\\
\ttindex{TBCHCK}&Check table pointer for validity&-\\
\ttindex{TBCLOS}&Close a dynamic table&\ref{TBCLOS}\\
\ttindex{TBCOL}&Find named column in table&\ref{TBCOL}\\
\ttindex{TBCREA}&Create new dynamic table&\ref{TBCREA}\\
\ttindex{TBDATA}&Decode table field&-\\
\ttindex{TBDROP}&Delete a dynamic table&\ref{TBDROP}\\
\ttindex{TBDUMP}&Dump tables to backing store&-\\
\ttindex{TBFILE}&Open direct-access file for table manager&-\\
\ttindex{TBFORM}&Decode table descriptor format&-\\
\ttindex{TBGDSC}&Retrieve table descriptor&\ref{TBGDSC}\\
\ttindex{TBGET}&Low-level table read&-\\
\ttindex{TBINIT}&Initialize table handler&-\\
\ttindex{TBINPT}&Simulate direct-access read&-\\
\ttindex{TBLIST}&Command routine for \ttindex{TABLE} command&-\\
\ttindex{TBNAME}&Decode TFS string&-\\
\ttindex{TBOPEN}&Open existing dynamic table&\ref{TBOPEN}\\
\ttindex{TBOUTP}&Simulate direct-access write&-\\
\ttindex{TBPDSC}&Add descriptor to table&\ref{TBPDSC}\\
\ttindex{TBPUT}&Low-level table write&-\\
\ttindex{TBREAD}&Read table buffer&-\\
\ttindex{TBRTFS}&Read dynamic table in ASCII TFS format&\ref{TBRTFS}\\
\ttindex{TBSEG}&Set table segment&\ref{TBSEG}\\
\ttindex{TBSET}&Set table row&\ref{TBSET}\\
\ttindex{TBWTFS}&Write dynamic table in ASCII TFS format&\ref{TBWTFS}\\
\ttindex{TBWRIT}&Write table buffer&-\\
\hline
\end{tabular}
\end{table}

\noindent Dynamic tables are organized in three dimensions:
\begin{description}
\item[column:]  Identified by name.
\item[row:]     Identified by number.
\item[segment:] Identified by number.
\end{description}
As an example consider the table of lattice functions.
Each column contains one given lattice function,
Each row refers to one position in the machine,
and each segment corresponds to one value of the energy error.

All items in a given column have the same data format,
identified by its ZEBRA data type code (Table~\ref{Tzebt}).
Each table row resides in a ZEBRA buffer bank.
At least one buffer bank must be allocated;
for better efficiency a larger number may be allocated if possible.
However, one can never allocate more buffers than available from the
ZEBRA store.
If more than one buffer bank is available,
these are used in a circular way.
Two buffers allow for example to access a table sequentially and to
have two consecutive rows in store at any time.

\clearpage
Use of a table requires the following steps:
\begin{enumerate}
\item Create the table (\ttindex{TBCREA}, Section~\ref{TBCREA}).
\item For each segment of the table, set the segment number
(\ttindex{TBSEG}, Section~\ref{TBSEG}).
\item For each row within the segment, set the row number
(\ttindex{TBSET}, Section~\ref{TBSET}).
The user must provide a flag value to \ttindex{TBSET}:
\begin{description}
\item[1 (read);] The buffer is filled by \ttindex{TBSET},
  but it will not be written when reused.
\item[2 (update):] The buffer is filled by \ttindex{TBSET},
  and written to backing store when reused.
\item[3 (write):] The buffer is cleared by \ttindex{TBSET},
  and written to backing store when reused.
\end{description}
For correct function of the table manager the value of this flag is
important.
The safest mode of operation is ``update'',
but it is also the slowest.
\item Close the table to release table buffers
(\ttindex{TBCLOS}, Section~\ref{TBCLOS}).
\end{enumerate}

\section{Close a Dynamic Table}
\label{TBCLOS}\ttnindex{TBCLOS}
\mybox{CALL TBCLOS(LTAB)}
closes the table identified by the pointer {\tt LTAB}.
This allows the table buffers to be released.

\section{Find a Table Column and its Format by Name}
\label{TBCOL}\ttnindex{TBCOL}
\mybox{CALL TBCOL(LTAB,COL,IFORM,IBIAS)}
searches an open table for a given column name.
\begin{mylist}
\item[\tt LTAB]
Pointer identifying the table (input).
\item[\tt COL]
Column name ({\tt MCNAM} characters, input).
\item[\tt IFORM]
ZEBRA data type associated with the column format (output).
\item[\tt IBIAS]
Bias of the column in the buffer banks.
\end{mylist}

\section{Create a Dynamic Table}
\label{TBCREA}\ttnindex{TBCREA}
\mybox{CALL TBCREA(TNAM,NSEG,NROW,NCOL,CNAM,ICFRM,NBUF,LTAB)}
creates a new dynamic table.
\begin{mylist}
\item[\tt TNAM]
Name to be given to the table ({\tt MCNAM} characters, input).
\item[\tt NSEG]
Number of segments to be allocated (input).
\item[\tt NROW]
Number of rows to be allocated (input).
\item[\tt NCOL]
Number of rows to be allocated (input).
\item[\tt CNAM]
Array of column names ({\tt NCOL} words of {\tt MCNAM} characters
each, input).
\item[\tt ICFRM]
Array of ZEBRA format codes ({\tt NCOL} integers, input).
\item[\tt NBUF]
Minimum number of buffers to be allocated (input).
A large number of buffers improves the access speed,
but it also occupies more space in the dynamic ZEBRA store.
\item[\tt LTAB]
Pointer to the created table (output), or zero in case of failure.
\end{mylist}

\section{Delete a Dynamic Table}
\label{TBDROP}\ttnindex{TBDROP}
\mybox{CALL TBDROP(LTAB)}
deletes the dynamic table identified by the pointer {\tt LTAB}.

\section{Retrive a Table Descriptor}
\label{TBGDSC}\ttnindex{TBGDSC}
\mybox{CALL TBGDSC(LTAB,DNAME,IFORM,IVAL,RVAL,SVAL)}
retrieves a table descriptor value from a table.
\begin{mylist}
\item[\tt LTAB]
Pointer identifying the table (input).
\item[\tt DNAME]
Descriptor name ({\tt MCNAM} characters, input).
\item[\tt IFORM]
ZEBRA data type for descriptor (output).
\item[\tt IVAL]
Value of descriptor, if integer (output).
\item[\tt RVAL]
Value of descriptor, if real (output).
\item[\tt SVAL]
Value of descriptor, if string (output).
\end{mylist}

\section{Open an Existing Dynamic Table}
\label{TBOPEN}\ttnindex{TBOPEN}
\mybox{CALL TBOPEN(TNAM,NBUF,LTAB)}
opens a dynamic table for reading or updating.
\begin{mylist}
\item[\tt TNAM]
Name given to the table at its creation ({\tt MCNAM} characters, input).
\item[\tt NBUF]
Minimum number of buffers to be allocated (input).
A large number of buffers improves the access speed,
but it also occupies more space in the dynamic ZEBRA store.
\item[\tt LTAB]
Pointer to the opened table (output), or zero in case of failure.
\end{mylist}

\section{Add a Table Descriptor}
\label{TBPDSC}\ttnindex{TBPDSC}
\mybox{CALL TBPDSC(LTAB,DNAME,IFORM,IVAL,RVAL,SVAL)}
adds a table descriptor value to a table.
\begin{mylist}
\item[\tt LTAB]
Pointer identifying the table (input).
\item[\tt DNAME]
Descriptor name ({\tt MCNAM} characters, input).
\item[\tt IFORM]
ZEBRA data type for descriptor (input).
\item[\tt IVAL]
Value of descriptor, if integer (input).
\item[\tt RVAL]
Value of descriptor, if real (input).
\item[\tt SVAL]
Value of descriptor, if string (input).
\end{mylist}

\section{Read a Table in ASCII TFS Format}
\label{TBRTFS}\ttnindex{TBRTFS}
\mybox{CALL TBRTFS(TNAM,IUNIT)}
reads a table in ASCII TFS format and leaves it open for reading.
\begin{mylist}
\item[\tt TNAM]
A name to be given to the table ({\tt MCNAM} characters, input).
\item[\tt IUNIT]
Logical unit number to read from (input).
\end{mylist}

\section{Set Table Segment}
\label{TBSEG}\ttnindex{TBSEG}
\mybox{CALL TBSEG(LTAB,ISEG,EFLAG)}
changes the active segment number for a table.
In the same time all buffers become empty;
they must be reloaded before using.
\begin{mylist}
\item[\tt LTAB]
Pointer identifying the table (input).
\item[\tt ISEG]
Desired segment number (input).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Set Table Row}
\label{TBSET}\ttnindex{TBSET}
\mybox{CALL TBSET(LTAB,IROW,IFLAG,LBUF)}
gives access to the table buffer for a given row.
\begin{mylist}
\item[\tt LTAB]
Pointer identifying the table (input).
\item[\tt IROW]
Desired Row number (input).
\item[\tt IFLAG]
Mode flag (input):
1: read, 2: update, 3: write.
For correct function of the table manager this flag is important,
since it controls when to fill or to dump buffers.
\item[\tt LBUF]
Pointer to the table buffer for the desired row (output).
\end{mylist}

\section{Write a Table in ASCII TFS Format}
\label{TBWTFS}\ttnindex{TBWTFS}
\mybox{CALL TBWTFS(TNAM,IUNIT)}
opens an existing table and writes it in ASCII TFS format.
\begin{mylist}
\item[\tt TNAM]
Name given to the table at its creation ({\tt MCNAM} characters, input).
\item[\tt IUNIT]
Logical unit number to read from (input).
\end{mylist}

%==============================================================================
                                         
\chapter{Transport Maps ``TM''}
\label{TM}
The \ttindex{TM}~module contains routines to compute and to operate on
Transport maps \cite{TPT}.
A general transfer map represents the transformation of phase space
from entrance to exit of an element.
A Transport map is given by the Taylor series for the general transfer map,
truncated at order~2:
\[
z^{(2)}_i = \Delta z_i + \sum_{k=1}^6 R_{ik} z^{(1)}_k
          + \sum_{k=1}^6 \sum_{l=1}^6 T_{ikl} z^{(1)}_k z^{(1)}_l,
          \qquad i = 1 \ldots 6.
\]
Due to truncation a Transport map is symplectic only in exceptional cases.
For algorithms refer to~\cite{SLAC75} and to the MAD Physicist's
Reference Manual.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{TM}~module}
\label{T-TM}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{TMALI1}&TRANSPORT map for misalignment at entrance&-\\
\ttindex{TMALI2}&TRANSPORT map for misalignment at exit&-\\
\ttindex{TMARB} &TRANSPORT map for \ttindex{MATRIX}&-\\
\ttindex{TMBB}  &TRANSPORT map for \ttindex{BEAMBEAM}&-\\
\ttindex{TMBEND}&
  TRANSPORT map for \ttindex{RBEND} or \ttindex{SBEND}&-\\
\ttindex{TMCAT} &Concatenate to TRANSPORT maps&\ref{TMCAT}\\
\ttindex{TMCLOR}&Find closed orbit&\ref{TMTURN}\\
\ttindex{TMCORR}&
  TRANSPORT map for \ttindex{HKICK}, \ttindex{VKICK},
  or \ttindex{KICK}&-\\
\tt TMDERI&
  Compute total derivative of $R$ matrix w.r.t. energy error&
  \ref{TMDERI}\\
\ttindex{TMDRF}&TRANSPORT map for \ttindex{DRIFT}&-\\
\ttindex{TMFOC}&Internal routine for focussing matrix&-\\
\ttindex{TMFRNG}&TRANSPORT map for fringing fields&-\\
\ttindex{TMFRST}&
  Transfer matrix for one turn w.r.t. given orbit&\ref{TMFRST}\\
\ttindex{TMINV}&Invert a TRANSPORT map&\ref{TMINV}\\
\ttindex{TMMAP}&TRANSPORT map for an element&\ref{TMMAP}\\
\ttindex{TMMKSM}&Multiply TRANSPORT map by its reflection&\ref{TMMKSM}\\
\ttindex{TMMULT}&TRANSPORT map for \ttindex{MULTIPOLE}&-\\
\ttindex{TMOCT}&TRANSPORT map for \ttindex{OCTUPOLE}&-\\
\ttindex{TMQUAD}&TRANSPORT map for \ttindex{QUADRUPOLE}&-\\
\ttindex{TMREFE}&
  Transfer matrix for one turn w.r.t. ideal orbit&\ref{TMFRST}\\
\ttindex{TMREFL}&Reflect a TRANSPORT map&\ref{TMREFL}\\
\ttindex{TMRF}  &TRANSPORT map for \ttindex{RFCAVITY}&-\\
\ttindex{TMSCND}&
  TRANSPORT map for one turn w.r.t. given orbit&\ref{TMSCND}\\
\ttindex{TMSECT}&TRANSPORT map for sector bend without fringe fields&-\\
\ttindex{TMSEP}&TRANSPORT map for \ttindex{ELSEPARATOR}&-\\
\ttindex{TMSEXT}&TRANSPORT map for \ttindex{SEXTUPOLE}&-\\
\ttindex{TMSOL}&TRANSPORT map for \ttindex{SOLENOID}&-\\
\ttindex{TMSROT}&TRANSPORT map for \ttindex{SROT}&-\\
\ttindex{TMSYMM}&Fill in symmetric terms in $T$ array&\ref{TMSYMM}\\
\ttindex{TMSYMP}&Symplectify an $R$ matrix&\ref{TMSYMP}\\
\tt TMTILT&
  Conjugate a TRANSPORT map with a rotation around $s$-axis&
  \ref{TMTILT}\\
\ttindex{TMTRAK}&Refer TRANSPORT map to a given orbit&\ref{TMTRAK}\\
\ttindex{TMTURN}&
  TRANSPORT map for one turn w.r.t. closed orbit&\ref{TMTURN}\\
\ttindex{TMUSER}&TRANSPORT map for user-defined elements&\ref{TMUSER}\\
\ttindex{TMYROT}&TRANSPORT map for \ttindex{YROT}&-\\
\hline
\end{tabular}
\end{table}

\section{Concatenate two TRANSPORT Maps}
\label{TMCAT}\ttnindex{TMCAT}
\mybox{CALL TMCAT(FSEC,RB,TB,RA,TA,RD,TD)}
concatenates two TRANSPORT maps.
\begin{mylist}
\item[\tt FSEC]
If {\tt .TRUE.} the second-order terms are also done (input).
\item[\tt RB,TB]
{\em Second} map in beam line order (input).
\item[\tt RA,TA]
{\em First} map in beam line order (input).
\item[\tt RD,TD]
Result of composition (output).
\end{mylist}

A similar routine also considers zero-order terms:
\ttnindex{TMCAT}
\mybox{CALL TMCAT1(FSEC,EB,RB,TB,EA,RA,TA,ED,RD,TD)}
concatenates two TRANSPORT maps.
\begin{mylist}
\item[\tt FSEC]
If {\tt .TRUE.} the second-order terms are also done (input).
\item[\tt EB,RB,TB]
{\em Second} map in beam line order (input).
\item[\tt EA,RA,TA]
{\em First} map in beam line order (input).
\item[\tt ED,RD,TD]
Result of composition (output).
\end{mylist}
The {\tt Ex} variables conbtain the kicks.

\section{Derivative of Transfer Matrix with Respect to $\delta p / p$}
\label{TMDERI}\ttnindex{TMDERI}
\mybox{CALL TMDERI(TT,DISP,RTP)}
computes the total derivative $dR_{ik}/d\delta = 2 \sum_{l=1}^6 T_{ikl} D_l$
of the first-order transfer matrix with respect to the relative energy
error.
\begin{mylist}
\item[\tt TT]
Second-order $T$~array for the map to be derived (input).
\item[\tt DISP]
Dispersion vector~$D$ for the initial position (input).
\item[\tt RT]
Total derivative $dR/d\delta$ (output).
\end{mylist}

\section{Transfer Matrix with Respect to Given Orbit}
\label{TMFRST}\ttnindex{TMFRST}
\mybox{CALL TMFRST(LSEQ,EFLAG)}
stores the the transfer matrix for a beam line expansion
in \ttindex{MAPTRN} (Section~\ref{Smapt}).
It takes the initial orbit coordinates from {\tt /OPTIC0/ ORBIT0(6)}
(Section~\ref{Sopt0}).
\begin{mylist}
\item[\tt LSEQ]
Pointer to a beam line expansion (input),
\item[\tt EFLAG]
Returned as true, if an overflow occurs (output).
\end{mylist}
This routine uses the control flags in {\tt /STFLAG/}
(Section~\ref{Sstat}).

\section{Invert a TRANSPORT Map}
\label{TMINV}\ttnindex{TMINV}
\mybox{CALL TMINV(RS,TS,RD,TD)}
inverts a TRANSPORT map.
\begin{mylist}
\item[\tt RS,TS]
TRANSPORT map to be inverted (input)
\item[\tt RD,TD]
Inverted map (output).
\end{mylist}

\section{TRANSPORT Map for Single Elements}
\label{TMMAP}\ttnindex{TMMAP}
\mybox{CALL TMMAP(FSEC,FTRK,EL,FMAP)}
stores the map and the kick for the current element in 
\ttindex{MAPELM} (Section~\ref{Smape}).
It assumes that the routines {\tt UTBEAM} and {\tt UTELEM} have been
called to set all relevant pointers.
\begin{mylist}
\item[\tt FSEC]
If {\tt .TRUE.} the second-order terms are also done (input).
\item[\tt FTRK]
If {\tt .TRUE.} the orbit in {\tt /OPTIC1/ ORBIT(6)}
(Section~\ref{Sopt1}) is advanced through the element (input).
\item[\tt EL]
Length of the element in~$m$ (output).
\item[\tt FMAP]
Logical flag telling whether the element affects the beam (output).
\end{mylist}
This routine uses the control flags in {\tt /STFLAG/}
(Section~\ref{Sstat}). 

\section{Add Symmetric Part to TRANSPORT Map}
\label{TMMKSM}\ttnindex{TMMKSM}
\mybox{CALL TMMKSM(FSEC)}
completes the accumulated map in \ttindex{MAPTRN} 
(Section~\ref{Smapt}) for a symmetric line.
It does this by premultiplying the map by the reflection, 
obtained by TMREFL.
\begin{mylist}
\item[\tt FSEC]
If {\tt .TRUE.} the second-order terms are also done (input).
\end{mylist}
Reflecting an element which is not longitudinally symmetric 
will not produce the desired effect. 
An accelerating cavity, for example, will become decelerating.

\section{Transfer Matrix with Respect to Ideal Orbit}
\label{TMREFE}\ttnindex{TMREFE}
\mybox{CALL TMREFE(LSEQ)}
stores the transfer matrix for a beam line expansion 
in \ttindex{MAPTRN} (Section~\ref{Smapt}).
It ignores any effects which may displace the orbit
and replaces RF~cavities by drifts.
\begin{mylist}
\item[\tt LSEQ]
Pointer to the a line expansion input).
\end{mylist}

\section{Reflect a TRANSPORT Map}
\label{TMREFL}\ttnindex{TMREFL}
\mybox{CALL TMREFL(RS,TS,RD,TD)}
reflects a TRANSPORT map, 
i.~e. it calculates the map for its elements taken in reverse order.
\begin{mylist}
\item[\tt RS,TS]
Map to be reflected (input).
\item[\tt RD,TD]
Reflected map (output).
\end{mylist}
Reflecting an element which is not longitudinally symmetric 
will not produce the desired effect. 
An accelerating cavity, for example, will become decelerating.

\section{TRANSPORT Map with respect to  Closed Orbit}
\label{TMSCND}\ttnindex{TMSCND}
\mybox{CALL TMSCND(LSEQ)}
stores the the TRANSPORT map for a beam line expansion
in \ttindex{MAPTRN} (Section~\ref{Smapt}).
It takes the initial orbit coordinates from {\tt /OPTIC0/ ORBIT0(6)}
(Section~\ref{Sopt0}).
\begin{mylist}
\item[\tt LSEQ]
Pointer to a beam line expansion (input).
\end{mylist}
This routine uses the control flags in {\tt /STFLAG/}
(Section~\ref{Sstat}). 

\section{Make $T$~Array Symmetric}
\label{TMSYMM}\ttnindex{TMSYMM}
The $T$~arrays in a TRANSPORT map is symmetric with respect
to its second and third indices.
To make definition of such an array easier, on may fill in
the values $T_{ikl}$ for $1 \le i \le 6, 1 \le k \le l \le 6$ 
only and call
\mybox{CALL CALL TMSYMM(T)} to make the array symmetric.

\section{Symplectify $R$~Matrix}
\label{TMSYMP}\ttnindex{TMSYMP}
\mybox{CALL TMSYMP(R)}
Modifies its argument, a $6 \times 6$~matrix {\tt R}, 
by a (hopefully) small amount to make it symplectic.

\section{Conjugate a TRANSPORT Map with a Rotation around the $s$-Axis}
\label{TMTILT}\ttnindex{TMTILT}
\mybox{CALL TMTILT(FSEC,TILT,EK,R,T)}
Is the transformation required for tilted elements.
It premultiplies the untilted map and kick with a rotation
and postmultiplies it by the inverse rotation.
\begin{mylist}
\item[\tt FSEC]
If {\tt .TRUE.} the second-order terms are also done (input).
\item[\tt TILT]
Rotation angle in~$rad$.
\item[\tt EK]
Six-dimensional kick $\Delta z$ associated with the map (input/output).
\item[\tt R,T]
Map to be transformed (input/output).
\end{mylist}

\section{Track Orbit Through a TRANSPORT Map}
\label{TMTRAK}\ttnindex{TMTRAK}
\mybox{CALL TMTRAK(EK,RE,TE,ORB1,ORB2)}
advances the orbit through a TRANSPORT map.
It also modifies the transfer matrix in \ttindex{MAPELM} to
become the matrix with respect to the given orbit.
\begin{mylist}
\item[\tt EK]
Kick in six dimensions (input).
\item[\tt RE,TE]
TRANSPORT map to be applied (input).
\item[\tt ORB1]
Orbit before transformation (input).
\item[\tt ORB2]
Orbit after transformation (output).
\end{mylist}

\section{Closed Orbit and TRANSPORT Map}
\label{TMTURN}\ttnindex{TMTURN}
\mybox{CALL TMTURN(LSEQ,DELTAT,DELTAP,MFLAG,EFLAG)}
stores the closed orbit for a beam line expansion in {\tt /OPTIC0/
ORBIT0(6)} (Section~\ref{Sopt0})
and the TRANSPORT map in \ttindex{MAPTRN} (Section~\ref{Smapt}).
\begin{mylist}
\item[\tt LSEQ]
Pointer to a beam line expansion (input).
\item[\tt DELTAP]
(Average) relative energy error $\delta E / p_0 c$ (input).
\item[\tt MFLAG]
If {\tt .TRUE.} the monitor readings are updated (input).
\item[\tt DELTAT]
Path length difference~$ct$ in~$m$ (output).
\item[\tt EFLAG]
Logical flag telling whether the orbit could be found (output).
\end{mylist}                   
To improve speed the closed orbit and transport map for each energy
error are kept in banks linked to the sequence bank.
The first time TMTURN is called for a given energy error,
it creates a corresponding bank by calling
\ttnindex{TMCLOR}
\mybox{CALL TMCLOR(LSEQ,DELTAT,DELTAP,SHOW,EFLAG)}
\begin{mylist}
\item[\tt LSEQ]
Pointer to the beam line expansion (input),
normally \ttindex{LCSEQ} (Section~\ref{Sbeam}).
\item[\tt DELTAP]
(Average) relative energy error $\delta E / p_0 c$ (input).
\item[\tt SHOW]
If {\tt .TRUE.},
a log is printed on the ECHO file during closed orbit search (input).
\item[\tt DELTAT]
Path length difference~$ct$ in~$m$ (output).
\item[\tt EFLAG]
If the closed orbit could not be found, this flag becomes true (output).
\end{mylist}
The banks containing the orbits and maps are dropped if anything
changes in the beam line.
These routines use the control flags in {\tt /STFLAG/}
(Section~\ref{Sstat}).

\section{TRANSPORT Map for User-Defined Element}
\label{TMUSER}\ttnindex{TMUSER}
\mybox{CALL TMUSER(FSEC,EK,RE,TE)}
returns the TRANSPORT map for an user-defined element.
It should take the element parameters from the element bank,
pointed at by {\tt LCELM} (Section~\ref{Srefer}).
\begin{mylist}
\item[\tt FSEC]
If {\tt .TRUE.}, the second-order terms must also be returned (input).
\item[\tt EK]
Kick in six dimensions (output).
\item[\tt RE,TE]
The TRANSPORT map for the element (output).
\end{mylist}

%==============================================================================

\chapter{``TAPE3'' Routines ``TP''}
\label{TP}
The \ttindex{TP}~module provides utilities for output for the
\ttindex{TAPE} option of \ttindex{SURVEY} and \ttindex{TWISS} commands.
As these routines are considered as obsolete, they are not documented.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{TP}~module}
\label{T-TP}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{TPELEM}&Write data for current element&-\\
\ttindex{TPHEAD}&Write header for \ttindex{TAPE} option file&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Tracking Module ``TR''}
\label{TR}
The \ttindex{TR}~module contains the switch and command routines for
tracking. 
These routines are not documented here,
as any change may seriously affect tracking speed.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{TR}~module}
\label{T-TR}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{TRBEGN}&Command routine for \ttindex{TRACK} command&-\\
\ttindex{TRCLOS}&Close machine-independent binary track file&-\\
\ttindex{TRDSP1}&Displace rays due to misalignments at entrance&-\\
\ttindex{TRDSP2}&Displace rays due to misalignments at exit&-\\
\ttindex{TREND}&Command routine for \ttindex{ENDTRACK} command&-\\
\ttindex{TREXEC}&Bookkeeping for tracking over many turns&-\\
\ttindex{TRFILE}&
  Write tracks on machine-independent binary track file&-\\
\ttindex{TFFLOW}&Test for overflow rays&-\\
\ttindex{TRHEAD}&Write header on machine-independent binary track file&-\\
\ttindex{TRMAIN}&Switch routine for \ttindex{TR}~module&-\\
\ttindex{TRKILL}&Remove rays lost by packing surviving rays&-\\
\ttindex{TRNOIS}&Command routine for \ttindex{NOISE} command&-\\
\ttindex{TRNRES}&Reset parameters which were changed due to noise&-\\
\ttindex{TRNSET}&Add noise to parameter values&-\\
\ttindex{TRPELM}&Print rays after an element&-\\
\ttindex{TRPTRN}&Print rays after a turn&-\\
\ttindex{TRRUN}&Command routine for \ttindex{RUN} command&-\\
\ttindex{TRSAVE}&Command routine for \ttindex{TSAVE} command&-\\
\ttindex{TRSTRT}&Command routine for \ttindex{START} command&-\\
\ttindex{TRTBLE}&Save current turn in track table&-\\
\ttindex{TRTURN}&Bookkeeping for tracking over one turn&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{TRANSPORT Tracking Routines ``TT''}
\label{TT}
The \ttindex{TT}~module contains routines for tracking by the
TRANSPORT method. 
The algorithms are straight-forward.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{TT}~module}
\label{T-TT}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{TTBB}  &Track through a \ttindex{BEAMBEAM} interaction&-\\
\ttindex{TTCORR}&
  Track through a \ttindex{HKICK}, \ttindex{VKICK}, or \ttindex{KICK}&
  -\\
\ttindex{TTDRF}&Track through a \ttindex{DRIFT} or similar element&-\\
\ttindex{TTELEM}&Track through an element&\ref{TTELEM}\\
\ttindex{TTMULT}&Track through a \ttindex{MULTIPOLE}&-\\
\ttindex{TTOCT}&Track through a \ttindex{OCTUPOLE}&-\\
\ttindex{TTQUAD}&Track through a \ttindex{QUADRUPOLE}&-\\
\ttindex{TTRF} &Track through a \ttindex{RFCAVITY}&-\\
\ttindex{TTSEXT}&Track through a \ttindex{SEXTUPOLE}&-\\
\ttindex{TTSOL}&Track through a \ttindex{SOLENOID}&-\\
\ttindex{TTSROT}&Track through a \ttindex{SROT}&-\\
\ttindex{TTTRAK}&Apply TRANSPORT map on a set of rays&\ref{TTTRAK}\\
\ttindex{TTUSER}&Track through a user-defined element&\ref{TTUSER}\\
\ttindex{TTYROT}&Track through a \ttindex{YROT}&-\\
\hline
\end{tabular}
\end{table}

\section{Track through an Element by TRANSPORT Method}
\label{TTELEM}\ttnindex{TTELEM}
\mybox{CALL TTELEM(ITURN,IORD,ISUP,IPOS,SUML,TRACK,NUMBER,NTRACK)}
advances a set of rays through the current element.
It assumes that \ttindex{UTBEAM} and \ttindex{UTELEM} have been called
to set the relevant pointers,
or that equivalent operations have been performed before the call.
Most elements are tracked by the TRANSPORT method;
however some elements (e.~g. thin multipoles) have their ad~hoc method.
\begin{mylist}
\item[\tt ITURN]
Number of current turn, for messages (input).
\item[\tt IORD]
Not used, present for compatibility with \ttindex{LMELEM}.
\item[\tt ISUP]
Number of current superperiod, for messages (input).
\item[\tt SUML]
Accumulated length (input/output).
\item[\tt TRACK]
Rays to be tracked (input/output).
\item[\tt NUMBER]
Ray numbers for the rays in \ttindex{TRACK} (input/output).
\item[\tt NTRACK]
Number of rays in {\tt TRACK}.
\end{mylist}
The orbits are compacted when an orbit is lost.
Thus the $n^{th}$~orbit is stored in {\tt TRACK(*,$i$)},
and its number is found in {\tt NUMBER($i$)}.

\section{Apply TRANSPORT Map to a Set of Rays}
\label{TTTRAK}\ttnindex{TTTRAK}
\mybox{CALL TTTRAK(D,R,T,TRACK,NTRACK)}
advances a set of rays through a given TRANSPORT map:
\[
z^{(2)}_i = \Delta z_i + \sum_{k=1}^6 R_{ik} z^{(1)}_k
          + \sum_{k=1}^6 \sum_{l=1}^6 T_{ikl} z^{(1)}_k z^{(1)}_l,
          \qquad {\rm for} \quad i = 1 \ldots 6.
\]
It has the arguments:
\begin{mylist}
\item[\tt D]
Kicks $\Delta Z$ (input).
\item[\tt R]
First-order terms~$R$ (input).
\item[\tt T]
Second-order terms~$T$ (input).
\item[\tt TRACK]
Set of rays (input/output).
\item[\tt NTRACK]
Number of rays (input).
\end{mylist}
The rays are stored as explained in Section~\ref{TTELEM}.

\section{Track through User-Defined Elements}
\label{TTUSER}\ttnindex{TTUSER}
\mybox{CALL TTUSER(EL,TRACK,NTRACK)}
may be replaced by the user to implement tracking through user-defined
elements.
It should take the element parameters from the element bank,
pointed at by {\tt LCELM} (Section~\ref{Srefer}).
\begin{mylist}
\item[\tt EL]
Element length (output).
\item[\tt TRACK]
Set of rays (input/output).
\item[\tt NTRACK]
Number of rays (input).
\end{mylist}
The rays are stored as explained in Section~\ref{TTELEM}.

%==============================================================================

\chapter{Twiss Routines ``TW''}
\label{TW}
The \ttindex{TW}~module contains the switch and command routines for
the commands of the Twiss group.
These include also derived commands, like \ttindex{IBS}.
For algorithms refer to the MAD Physicist's Manual.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{TW}~module}
\label{T-TW}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{TWBTGO}&Bookkeeping routine for {\tt TWISS,-COUPLE}&-\\
\ttindex{TWBTIN}&Initial lattice functions for {\tt TWISS,-COUPLE}&-\\
\ttindex{TWBTPR}&Print lattice function for {\tt TWISS,-COUPLE}&-\\
\ttindex{TWBTSV}&
  Save lattice functions in table for {\tt TWISS,-COUPLE}&-\\
\ttindex{TWBTTK}&Track lattice functions for {\tt TWISS,-COUPLE}&-\\
\ttindex{TWBTTP}&
  Write lattice functions on file for {\tt TWISS,-COUPLE}&-\\
\ttindex{TWCHGO}&Bookkeeping routine for {\tt TWISS,CHROM}&-\\
\ttindex{TWCHPR}&Print lattice functions for {\tt TWISS,CHROM}&-\\
\ttindex{TWCHTP}&
  Write lattice functions on file for {\tt TWISS,CHROM}&-\\
\ttindex{TWCLOG}&Compute Coulomb logarithm for  {\tt IBS}&-\\
\ttindex{TWCPGO}&Bookkeeping routine for {\tt TWISS,COUPLE}&-\\
\ttindex{TWCPIN}&Initial lattice functions for {\tt TWISS,COUPLE}&-\\
\ttindex{TWCPPR}&Print lattice functions for {\tt TWISS,COUPLE}&-\\
\ttindex{TWCPTK}&Track lattice functions for {\tt TWISS,COUPLE}&-\\
\ttindex{TWDISP}&Track dispersion&-\\
\ttindex{TWFILL}&Fill in given initial values&-\\
\ttindex{TWIBS}&Command routine for \ttindex{IBS}&-\\
\ttindex{TWISS}&Command routine for \ttindex{TWISS}&-\\
\ttindex{TWMAIN}&Switch routine for \ttindex{TW}~module&-\\
\ttindex{TWOPGO}&Bookkeeping routine for \ttindex{OPTICS}&-\\
\ttindex{TWOPSV}&
  Save lattice functions in table for \ttindex{OPTICS}&-\\
\ttindex{TWOPTC}&Command routine for \ttindex{OPTICS}&-\\
\ttindex{TBSBET}&Command routine for \ttindex{SAVEBETA}&-\\
\ttindex{TWSINT}&Bjorken/Mtingwa integrals&-\\
\ttindex{TWSMSV}&Save \ttindex{TWISS} summary data&-\\
\ttindex{TWSUMM}&Compute \ttindex{TWISS} summary data&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\chapter{Utility Routines ``UT''}
\label{UT}
The utilities in the \ttindex{UT}~module include routine to store data into
and to retrieve data from banks, and pattern matching routines.

\begin{table}[h]
\centering
\caption{Routines in the \ttindex{UT}~module}
\label{T-UT}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{UTBEAM}&
  Retrieve current working beam line and range&\ref{UTBEAM}\\
\ttindex{UTCLRC}&
  Clear occurrence counts in data bank directory&\ref{UTCLRC}\\
\ttindex{UTDASH}&Internal routine for \ttindex{UTPATT}&-\\
\ttindex{UTELEM}&
  Retrieve data and pointers for current element&\ref{UTELEM}\\
\ttindex{UTGFLT}&Retrieve floating-point data&\ref{UTGFLT}\\
\ttindex{UTGINT}&Retrieve integer data&\ref{UTGINT}\\
\ttindex{UTGLOG}&Retrieve logical data&\ref{UTGLOG}\\
\ttindex{UTGNAM}&Retrieve alphanumeric data&\ref{UTGNAM}\\
\ttindex{UTGPOS}&Retrieve position reference&\ref{UTGRNG}\\
\ttindex{UTGRNG}&Retrieve range reference&\ref{UTGRNG}\\
\ttindex{UTGSTR}&Retrieve string data&\ref{UTGSTR}\\
\ttindex{UTGTYP}&Retrieve MAD data types&\ref{UTGTYP}\\
\ttindex{UTLENG}&
  Find last non-blank character in a string&\ref{UTLENG}\\
\tt UTLOOK&
  Search for a name in a table, accepting abbreviations&\ref{UTLOOK}\\
\ttindex{UTMTCH}&Internal routine for \ttindex{UTMTPT}&-\\
\ttindex{UTMTPT}&Match name to pattern&\ref{UTPATT}\\
\ttindex{UTOCNM}&
  Generate unique name from occurrence counter&\ref{UTOCNM}\\
\ttindex{UTPATT}&Built pattern for pattern matcher&\ref{UTPATT}\\
\ttindex{UTPFLT}&Store floating-point data&\ref{UTPFLT}\\
\ttindex{UTPINT}&Store integer data&\ref{UTPINT}\\
\ttindex{UTPLOG}&Store logical data&\ref{UTPLOG}\\
\ttindex{UTPNAM}&Store alphanumeric data&\ref{UTPNAM}\\
\hline
\end{tabular}
\end{table}

\section{Retrieve Current Working Beam Line and Range}
\label{UTBEAM}\ttnindex{UTBEAM}
\mybox{CALL UTBEAM(LSEQ,IRG1,IRG2,SYMM,NSUP,LINNAM,RNGNAM)}
retrieves the data for the current working range.
The structure of the main beam line expansion is explained in
Section~\ref{Sbeam}.
\begin{mylist}
\item[\tt LSEQ]
Pointer to a beam line expansion (input).
\item[\tt IRG1]
Start position of the range set by the latest \ttindex{USE} command
(output). 
\item[\tt IRG2]
End position of the range set by the latest \ttindex{USE} command
(output). 
\item[\tt SYMM]
Symmetry flag from the latest \ttindex{USE} command (output).
\item[\tt NSUP]
Number of superperiods from the latest \ttindex{USE} command (output).
\item[\tt LINNAM]
Name of the expanded beam line (output).
\item[\tt RNGNAM]
Range specification in printable form (output).
\end{mylist}

\section{Clear Occurrence Counters In Data Bank Directory}
\label{UTCLRC}\ttnindex{UTCLRC}
\mybox{CALL UTCLRC}
is used internally by MAD to clears all occurrence counters in the
data bank directory.

\section{Retrieve Data and Pointers for Current Element}
\label{UTELEM}\ttnindex{UTELEM}
\mybox{CALL UTELEM(LSEQ,IPOS,IFLAG,ELMNAM,IOCC,IENUM)}
\begin{mylist}
\item[\tt LSEQ]
Pointer to a beam line expansion (input).
\item[\tt IPOS]
Position number
($\hbox{\tt IRG1} \le \hbox{\tt IPOS} \le \hbox{\tt IRG2}$, output).
\item[\tt IFLAG]
Flag word from the {\em position flags bank}\index{position!flags}
(output, Table~\ref{Tflag}).
\item[\tt ELMNAM]
Element name (output).
\item[\tt IOCC]
Occurrence number for the element or line \ttindex{ELMNAM} (output).
\item[\tt IENUM]
The physical element counter for this position (output).
Starts at one for the first element of the line (not of the range),
incremented for each element encountered.
\end{mylist}
The subroutine \ttindex{UTELEM} also sets the following reference
pointers in common block \ttindex{REFER}:
\begin{mylist}
\ttitem{LCELM}
Current element.
\ttitem{LCALI}
Misalignments for the current element (see Section~\ref{Serr}).
This pointer is zero, if there is no misalignment.
\ttitem{LCFLD}
Field errors for the current element (see Section~\ref{Serr}).
This pointer is zero, if there is no field error.
\ttitem{LCCOM}
Information specific to the current orbit corrector or monitor
(see Section~\ref{Scorr}).
This pointer is zero, if the current element is not a corrector or
monitor,
or if no orbit correction has been made yet.
\end{mylist}

As an example take a routine which lists all physical elements:
\begin{verbatim}
      SUBROUTINE LIST
+CALL IMPLICIT
+CALL SEQFLAG           required for MCODE
+CALL REFER             required for LCSEQ, LCALI, and LCFLD
      CHARACTER*(MCNAM) ELMNAM, LINNAM
      CHARACTER*40      RNGNAM
      LOGICAL           SYMM
 
      CALL UTBEAM(LCSEQ, IPOS1, IPOS2, SYMM, NSUP, LINNAM, RNGNAM)
      WRITE (IFILE, 910) LINNAM, RNGNAM
 
      DO 90 IPOS = IPOS1, IPOS2
        CALL UTELEM(LCSEQ, IPOS, IFLAG, ELMNAM, IOCC, IENUM)
        ICODE = JBYT(IFLAG,1,MCODE)
        IF (ICODE .EQ. 1) THEN
          WRITE (IFILE, 920) IENUM, IOCC, ELMNAM
          IF (LCALI .NE. 0) WRITE (IFILE, 930)
          IF (LCFLD .NE. 0) WRITE (IFILE, 940)
        ENDIF
   90 CONTINUE
 
  910 FORMAT(' Listing line: ',A,' Range: ',A)
  920 FORMAT(' Physical element number ',I5,' is occurrence ',I5,
     +       ' of name ',A)
  930 FORMAT(' This element is misaligned.')
  940 FORMAT(' This element has field errors.')
      END
\end{verbatim} 

\section{Fetch Attributes from Command or Definition Banks}
The routines in this section all retrieve data without requiring
detailed knowledge of the precise bank structure.
They all have three input arguments:
\begin{mylist}
\item[\tt LBANK]
Pointer to a command or definition bank (input).
\item[\tt I1,I2]
Range of attributes to be retrieved (input).
\item[\tt V]
Vector with dimension~{\tt (I2-I1+1)} (output).
\end{mylist}
of the proper type.
For ${\tt I1} \le i \le {\tt I2}$, the routines copies attribute~$i$
into {\tt V($i$-I1+1)}, if it has the expected type and has been set.
Otherwise {\tt V($i$-I1+1)} remains unchanged.
One may thus fill {\tt V} with default values prior to calling a
routine. 
Refer to the code for command routines for examples.

\subsection{Real or Deferred Values}
\label{UTGFLT}\ttnindex{URGFLT}
\mybox{CALL UTGFLT(LBANK,I1,I2,V)}
The output vector {\tt V} is of type {\tt REAL} (single precision
version) or {\tt DOUBLE PRECISION} (double precision version).
If an attribute is a deferred expression,
\ttindex{UTGFLT} generates a new value by calling \ttindex{EXEVAL}.

\subsection{Integer Values}
\label{UTGINT}\ttnindex{UTGINT}
\mybox{CALL UTGINT(LBANK,I1,I2,V)}
The output vector {\tt V} is of type \ttindex{INTEGER}.

\subsection{Logical Values}
\label{UTGLOG}\ttnindex{UTGLOG}
\mybox{CALL UTGLOG(LBANK,I1,I2,V)}
The output vector {\tt V} is of type \ttindex{LOGICAL}.

\subsection{Name Values}
\label{UTGNAM}\ttnindex{UTGNAM}
\mybox{CALL UTGNMT(LBANK,I1,I2,V)}
The output vector {\tt V} is of type \ttindex{CHARACTER}{\tt *(MCNAM)}.

\subsection{String Values}
\label{UTGSTR}\ttnindex{UTGSTR}
\mybox{CALL UTGSTR(LBANK,I1,I2,V)}
The output vector {\tt V} is of type \ttindex{CHARACTER}{\tt *(MCSTR)}.

\section{Data Type Flags}
\label{UTGTYP}\ttnindex{UTGTYP}
\mybox{CALL UTGTYP(LBANK,ITYPE)}
returns an array of MAD data types for the attributes of a command.
\begin{mylist}
\item[\tt LBANK]
Pointer to the command bank (input).
\item[\tt ITYPE]
\ttindex{INTEGER} array which will contain the MAD data type of each
attribute (if the attribute was entered) or zero (if not entered).     
{\tt ITYPE} must be dimensioned at least by the number of command
attributes.
\end{mylist}

\section{Ranges and Positions}
\label{UTGRNG}\ttnindex{UTGRNG}
\mybox{CALL UTGRNG(LRNG,LSEQ,IRG1,IRG2,EFLAG)}
returns the positions for the end points of a range.
\begin{mylist}
\item[\tt LRNG]
Pointer to a range reference bank (Table~\ref{Trang}, input).
\item[\tt LSEQ]
Pointer to a beam line expansion (Section~\ref{Sbeam}, input).
\item[\tt IRG1,IRG2]
Start and end positions of the range (output).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

The two positions are searched for by two calls to
\ttnindex{UTGPOS}
\mybox{CALL UTGPOS(LRNG,LSEQ,IEND,IPOS,EFLAG)}
\begin{mylist}
\item[\tt LRNG]
Pointer to the range reference bank (input).
\item[\tt LSEQ]
Pointer to a beam line expansion (input).
\item[\tt IEND]
Offset in the range reference bank: 0~for start, 3~for end (input).
\item[\tt IPOS]
Position found (output).
\item[\tt EFLAG]
Logical error flag (output).
\end{mylist}

\section{Find Last Non-Blank Character in a Name}
\label{UTLENG}\ttnindex{UTLENG}
\mybox{CALL UTLENG(WORD,LENG)}
takes a character variable {\tt WORD} of any length and returns
in {\tt LENG} the position of its last non-blank character.

\section{Look up Name in a Table}
\label{UTLOOK}\ttnindex{UTLOOK}
\mybox{PARAMETER         (NDICT = ...)\\
       CHARACTER*(MCNAM) DICT(NDICT)\\
       CALL UTLOOK(WORD,DICT,NDICT,IDICT)}
looks up a character variable {\tt WORD} of any length in the
dictionary vector {\tt DICT}.
If found, {\tt IDICT} is set to the position,
otherwise it is set to zero.
The routine accepts abbreviations, provided they have at least
characters and are unique:
\myxmp{PARAMETER         (NDICT = ...)\\
       CHARACTER*(MCNAM) DICT(NDICT)\\
       CHARACTER*(MCNAM) WORD\\
       CALL UTLENG(WORD,LENG)\\
       CALL UTLOOK(WORD(1:LENG),DICT,NDICT,IDICT)}
finds {\tt WORD='TI'} in the dictionary,
if there is exactly one dictionary entry beginning with {\tt 'TI'}.

\section{Generate Unique Name}
\label{UTOCNM}\ttnindex{UTOCNM}
\mybox{CALL UTOCNM(OLD,IOCC,NEW)}
constructs a unique name of the form ``{\tt xxxxxxxx[iiiiii]}'',
where ``{\tt xxxxxxxx}'' are the first eight characters
of the character variable {\tt OLD},
and ``{\tt iiiiii}'' is the encoded value of the integer {\tt IOCC}.
The result is returned in {\tt NEW},
which must be of type \ttindex{CHARACTER}{\tt *(16)}.

\section{Pattern Matching}
\label{UTPATT}\ttnindex{UTPATT}
Commands which use pattern matching (\ttindex{SAVE} and
\ttindex{REMOVE}) should first convert the pattern to an internal data
structure: 
\mybox{CALL UTPATT(PATT,LPATT)}
\begin{mylist}
\item[\tt PATT]
Pattern string (input).
\item[\tt LPATT]
Pointer to the generated data structure (output).
This pointer should reside in a structural link area.
\end{mylist}
The test whether a name matches the pattern is then made by
\mybox{CALL UTMTPT(LPATT,NAME,FOUND)}
\begin{mylist}
\item[\tt LPATT]
Pointer returned by \ttindex{UTPATT} (input).
\item[\tt NAME]
Name to be matched (input).
\item[\tt FOUND]
Logical flag (output is {\tt .TRUE.} on success).
\end{mylist}

\section{Store Attributes in Command or Definition Banks}
The routines in this section all store data without
requiring detailed knowledge of the precise bank structure.
\begin{mylist}
\item[\tt LBANK]
Pointer to a command or definition bank (input).
\item[\tt I1,I2]
Range of attributes to be stored (input).
\item[\tt V]
Vector with dimension~{\tt (I2-I1+1)} of the proper type (output).
\end{mylist}
For ${\tt I1} \le i \le {\tt I2}$ the value {\tt V($i$-I1+1)} is
copied into the $i^{th}$~attribute of the bank, provided this
attribute has the expected type, 
and the attribute is marked as set.
Refer to the code for command routines for examples.

\subsection{Real Values}
\label{UTPFLT}\ttnindex{UTPFLT}
\mybox{CALL UTPFLT(LBANK,I1,I2,V)}
The input vector {\tt V} is of type \ttindex{REAL} (single precision
version) or \ttindex{DOUBLE PRECISION} (double precision version).
If an attribute stored was defined previously by an expression,
the expression is erased.

\subsection{Integer Values}
\label{UTPINT}\ttnindex{UTPINT}
\mybox{CALL UTPINT(LBANK,I1,I2,V)}
The input vector {\tt V} is of type \ttindex{INTEGER}.

\subsection{Logical Values}
\label{UTPLOG}\ttnindex{UTPLOG}
\mybox{CALL UTPLOG(LBANK,I1,I2,V)}
The input vector {\tt V} is of type \ttindex{LOGICAL}.

\subsection{Name Values}
\label{UTPNAM}\ttnindex{UTPNAM}
\mybox{CALL UTPNAM(LBANK,I1,I2,V)}
The input vector {\tt V} is of type \ttindex{CHARACTER}{\tt *(MCNAM)}.

%==============================================================================

\chapter{Miscellaneous Routines in MAD}
\label{C-misc}

\begin{table}[h]
\centering
\caption{Miscellaneous Utilities in MAD}
\vspace{1ex}
\begin{tabular}{|l|p{0.7\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
         &\em Random Generators:&\\
\hline
\ttindex{FRNDM}&Uniform distribution in (0,1)&-\\
\ttindex{GRNDM}&Gaussian distribution with $\sigma = 1$&-\\
\ttindex{INIT55}&Initialize random generators&-\\
\ttindex{IRNDM}&Integer in range (1,999999999)&-\\
\ttindex{IRNGEN}&Get next number in sequence&-\\
\hline
         &\em Linear Algebra and Minimization:&\\
\hline
\ttindex{FDJAC2}&Internal routine for \ttindex{LMDIF}&-\\
\ttindex{HQR2}&Eigenvalues of a real general matrix&-\\
\ttindex{HTLSQ}&Least squares fit by Householder transforms&-\\
\ttindex{LMDIF}&Minimization by \ttindex{LMDIF} method&-\\
\ttindex{LMPAR}&Internal routine for \ttindex{LMDIF}&-\\
\tt ORTHES&Transform matrix to Hessenberg form by Householder
  transforms&-\\
\ttindex{ORTRAN}&Accumulate several Householder transforms&-\\
\ttindex{QRFAC}&Factorize by QR method&-\\
\ttindex{QRSOLV}&Solve linear equations after QR factorization&-\\
\ttindex{SOLVER}&Solve linear equations&-\\
\ttindex{SYMEIG}&Eigenvalues of real symmetric matrix&-\\
\ttindex{SYMSOL}&Solve linear equations with symmetric matrix&-\\
\ttindex{VDOT}&Dot product of two vectors&-\\
\ttindex{VMOD}&Modulus of a vector&-\\
\hline
         &\em Other Routines:&\\
\hline
\ttindex{CHINIT}&
  Initialize character code table, called by \ttindex{AAINIT}&-\\
\ttindex{ERRF}&
  Complex error function, used for \ttindex{BEAMBEAM} element&-\\
\ttindex{FACTOR}&Factorial function&-\\
\hline
         &\em User-Replaceable Routines:&\\
\hline
\ttindex{USERCM}&User-defined commands&-\\
\ttindex{USERDF}&User-defined definitions&-\\
\ttindex{USER0}&User-defined random generator, 0 arguments&-\\
\ttindex{USER1}&User-defined random generator, 1 argument&-\\
\ttindex{USER2}&User-defined random generator, 2 arguments&-\\
\hline
         &\em ZEBRA Services, see ZEBRA manual:&\\
\hline
\ttindex{ZABEND}&Abnormal end of program&-\\
\ttindex{ZEND}&Normal end of program&-\\
\ttindex{ZTELUS}&User-defined program error exit&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\part{CERN Library Routines Called by MAD}
\label{CERN}

%==============================================================================

\chapter{ZEBRA Routines}

\begin{table}[h]
\centering
\caption{ZEBRA Routines Called by MAD}
\label{T-ZEBRA}
\vspace{1ex}
\begin{tabular}{|l|p{0.65\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{DZSHOW}&Dump ZEBRA bank &\ref{DZSHOW}\\
\ttindex{FZENDI}&End ZEBRA input &\ref{FZENDI}\\
\ttindex{FZENDO}&End ZEBRA output &\ref{FZENDO}\\
\ttindex{FZFILE}&Declare file to ZEBRA &\ref{FZFILE}\\
\ttindex{FZIN}  &ZEBRA input &\ref{FZIN}\\
\ttindex{FZOUT} &ZEBRA output &\ref{FZOUT}\\
\ttindex{LZFIND}&Search linear list for word &\ref{LZFIND}\\
\ttindex{LZLAST}&Find last bank in linear list &\ref{LZLAST}\\
\ttindex{LZLONG}&Search linear list for word string &\ref{LZLONG}\\
\ttindex{MZBOOK}&Book new bank &\ref{MZBOOK}\\
\ttindex{MZCOPY}&Copy bank or structure &\ref{MZCOPY}\\
\ttindex{MZDROP}&Drop bank or structure &\ref{MZDROP}\\
\ttindex{MZEBRA}&Initialize ZEBRA system &\ref{MZEBRA}\\
\ttindex{MZEND} &End of ZEBRA processing &\ref{MZEND}\\
\ttindex{MZFLAG}&Flag bank or structure &\ref{MZFLAG}\\
\ttindex{MZGARB}&Garbage collection &\ref{MZGARB}\\
\ttindex{MZLINK}&Declare link area &\ref{MZLINK}\\
\ttindex{MZNEED}&Test for available space &\ref{MZNEED}\\
\ttindex{MZPUSH}&Change bank size &\ref{MZPUSH}\\
\ttindex{MZSTOR}&Initialize ZEBRA store &\ref{MZSTOR}\\
\ttindex{MZVERS}&Print ZEBRA version &\ref{MZVERS}\\
\ttindex{MZWIPE}&Wipe out division &\ref{MZWIPE}\\
\ttindex{MZWORK}&Allocate working space &\ref{MZWORK}\\
\ttindex{NZBANK}&Find number of banks in sinear list &\ref{NZBANK}\\
\ttindex{ZFATAL}&Fatal termination &\ref{ZFATAL}\\
\ttindex{ZFATAM}&Fatal termination with message &\ref{ZFATAM}\\
\ttindex{ZPHASE}&Switch processing phase &\ref{ZPHASE}\\
\ttindex{ZSHUNT}&Change bank linkage &\ref{ZSHUNT}\\
\ttindex{ZTOPSY}&Reverse order of linear list &\ref{ZTOPSY}\\
\hline
\end{tabular}
\end{table}

\section{Dump ZEBRA Bank}
\label{DZSHOW}\ttnindex{DZSHOW}
\mybox{
CALL DZSHOW(CHTEXT,ISTOR,LBANK,CHOPT,ILINK1,ILINK2,IDATA1,IDATA2)
}
Displays the contents of a bank or a data structure.
The output format is controlled by the I/O characteristics
of the structure.
\begin{mylist}
\item[\tt CHTEXT]
    Character variable printed to identify the output.
\item[\tt ISTOR]
    Index of the store containing the bank or data structure.
\item[\tt LBANK]
    Pointer to the bank or structure to be displayed.
\item[\tt CHOPT]
    Option string. A selection of the following:
    \begin{mylist}
    \item[\tt 'B']
        Print the single bank at {\tt LBANK} (default).
    \item[\tt 'D']
        Print the bank contents down (in five columns).
    \item[\tt 'S']
        Print the bank contents sideways (in lines of 10~elements).
    \item[\tt 'L']
        Print the whole linear structure supported by {\tt LBANK}.
    \item[\tt 'V']
        Print the vertical structure supported by {\tt LBANK}.
    \item[\tt 'Z']
        Print the structure in hexadecimal format.
    \end{mylist}
\item[\tt ILINK1,ILINK2]
    First and last link number to be printed for each bank.
    When both are zero, all links are displayed.
\item[\tt IDATA1,IDATA2]
    First and last data word to be printed for each bank.
    When both are zero, all data words are displayed.
\end{mylist}

\section{End ZEBRA Input}
\label{FZENDI}\ttnindex{FZENDI}
\mybox{CALL FZENDI(IUNIT,CHOPT)}
Ends one or several input files.
\begin{mylist}
\item[\tt IUNIT]
    Logical unit number. If zero, all FZ input files.
\item[\tt CHOPT]
    Option string. A selection of the following:
    \begin{mylist}
    \item[\tt 'O']
        Switch file to output; needed after positioning by reading.
    \item[\tt 'Q']
        Quiet, suppress printing of file statistics.
    \item[\tt 'R']
        Final rewind.
    \item[\tt 'T']
        Terminate, drop control bank for this file and print statistics.
    \item[\tt 'U']
        Unload file.
    \end{mylist}
\end{mylist}

\section{End ZEBRA Output}
\label{FZENDO}\ttnindex{FZENDO}
\mybox{CALL FZENDO(IUNIT,CHOPT)}
Terminates one or several output files.
\begin{mylist}
  \item[\tt IUNIT]
    Logical unit number. If zero, all FZ output files.
  \item[\tt CHOPT]
    Option string. A selection of the following:
    \begin{mylist}
    \item[\tt 'E']
        Write end of file (unless done).
    \item[\tt 'E2']
        Write end of data (unless done).
    \item[\tt 'F']
        Flush the buffer only.
    \item[\tt 'I']
        Switch to input, write end of data and rewind, if not yet done.
        Cancel the output permission.   
    \item[\tt 'Q']
        Quiet, suppress printing of file statistics.
    \item[\tt 'R']
        Rewind, unless done.
    \item[\tt 'T']
        Terminate; write end of run,
        drop control bank for this file and print statistics.
    \item[\tt 'U']
        Unload file.
    \end{mylist}
\end{mylist}

\section{Declare File to ZEBRA}
\label{FZFILE}\ttnindex{FZFILE}
\mybox{CALL FZFILE(IUNIT,LREC,CHOPT)}
Declares a file to ZEBRA.
\begin{mylist}
\item[\tt IUNIT]
    Logical unit number.
\item[\tt LREC]
    Record length. Zero gives system defaults.
\item[\tt CHOPT]
    Option string. A selection of the following:
    \begin{mylist}
    \item[file medium:]
        \begin{mylist}
        \item[default:]
            Disk.
        \item[\tt 'M']
            Memory.
        \item[\tt 'T']
            Magnetic tape.
        \end{mylist}
    \item[file format:]
        \begin{mylist}
        \item[default:]
            Native format.
        \item[\tt 'A']
            Exchange format, ASCII mapping.
        \item[\tt 'X']
            Exchange format, binary.
        \end{mylist}
    \item[data format:]
        \begin{mylist}
        \item[default for disk or tape files:]
            Same as file format.
        \item[default for memory:]
            Native format.
        \item[\tt 'N']
            Native format.
        \item[\tt 'X']
            Exchange data format.
        \end{mylist}
    \item[processing direction:]
        \begin{mylist}
        \item[default:]
            Input only.
        \item[\tt 'I']
            Input enabled.
        \item[\tt 'O']
            Output enabled.
        \item[\tt 'IO']
            Input and output enabled.
        \end{mylist}
    \item[end of file:]
        \begin{mylist}
        \item[\tt '0']
            No hardware file marks.
        \item[\tt '1']
            Hardware file mark only for level 2 end of file.
        \item[\tt '2']
            Hardware file marks for both level 1 and 2 end of files.
        \end{mylist}
    \item[various options:]
        \begin{mylist}
        \item[\tt 'R']
            Initial rewind.
        \item[\tt 'Q']
            Quiet, print error messages only.
        \item[\tt 'P']
            Permissive, enable error returns.
        \end{mylist}
    \end{mylist}
\end{mylist}

\section{ZEBRA Input}
\label{FZIN}\ttnindex{FZIN}
\mybox{CALL FZIN(IUNIT,IDIV,LSUP,IBIAS,CHOPT,NUH,IUHEAD)}
Reads a complete data structure from a file.
\begin{mylist}
\item[\tt IUNIT]
    Logical unit number.
\item[\tt IDIV]
    Index of the division to receive the data structure.
\item[\tt LSUP,IBIAS]
    See the description of \ttindex{MZBOOK} in Section~\ref{MZBOOK}.
\item[\tt CHOPT]
    Option string. Only default options are used in MAD.
\item[\tt NUH]
    Size of the user header (not used in MAD).
\item[\tt IUHEAD]
    The user header (not used in MAD).
\end{mylist}

\section{ZEBRA Output}
\label{FZOUT}\ttnindex{FZOUT}
\mybox{CALL FZOUT(IUNIT,IDIV,LENTRY,IEVENT,CHOPT,IOD,NUH,IUHEAD)}
Writes a data structure to a file.
\begin{mylist}
\item[\tt IUNIT]
    Logical unit number.
\item[\tt IDIV]
    Index of the store or division containing the data structure.
\item[\tt LENTRY]
    Pointer to the data structure to be written.
\item[\tt IEVENT]
    Start-of-event flag; always 1.
\item[\tt CHOPT]
    Option string.
\item[\tt IOD]
    Format descriptor for the user header (not used in MAD).
\item[\tt NUH]
    The size of the user header (not used in MAD).
\item[\tt IUHEAD]
    The user header (not used in MAD).
\end{mylist}

\section{Search Linear List for Word}
\label{LZFIND}\ttnindex{LZFIND}
\mybox{L=FUNCTION LZFIND(ISTOR,LSUP,IWORD,M)}
searches the linear list pointed at by {\tt LSUP} for the first bank
containing {\tt IWORD} in position {\tt M}.

\section{Find Last Bank in Linear List}
\label{LZLAST}\ttnindex{LZLAST}
\mybox{INTEGER FUNCTION LZLAST(ISTOR,LSUP)}
searches the linear list pointed at by {\tt LSUP} for its last bank.

\section{Search Linear List for Word String}
\label{LZLONG}\ttnindex{LZLONG}
\mybox{INTEGER FUNCTION LZLONG(ISTOR,LSUP,N,ITEXT,M)}
searches the linear list pointed at by {\tt LSUP} for the first bank
containing {\tt ITEXT} in positions {\tt N} to {\tt N+M-1}.

\section{Book New Bank}
\label{MZBOOK}\ttnindex{MZBOOK}
\mybox{CALL MZBOOK(IDIV,L,LSUP,IBIAS,IDH,NL,NS,ND,NIO,NZERO)}
books a new bank.
\begin{mylist}
\item[\tt IDIV]
    The division number, 2~for long-lived banks, 1~for temporary banks.
\item[\tt L]
    Pointer to the new bank (output).
\item[\tt LSUP,IBIAS]
    The new bank will be linked to link {\tt IBIAS} of the bank at
    {\tt LSUP}. 
    If {\tt IBIAS} is~1, {\tt LSUP} must be a structural link in a
    link area which will be made to point at the new bank.
\item[\tt IDH]
    Hollerith name of the bank.
\item[\tt NL]
    Total number of links to be allocated.
\item[\tt NS]
    Number of structural links (out of the total number) to be
    allocated. 
\item[\tt ND]
    Number of data words to be allocated.
\item[\tt NIO]
    ZEBRA data code (Section~\ref{Sconv}) for the bank.
\item[\tt NZERO]
    If zero, the bank is preset to zeros; if positive,
    the first \ttindex{NZERO} words are cleared;
    if negative, no presetting is done.
\end{mylist}

\section{Copy Bank or Structure}
\label{MZCOPY}\ttnindex{MZCOPY}
\mybox{CALL MZCOPY(IDIV1,LENTRY,IDIV2,LSUP,IBIAS,CHOPT)}
copies a data structure
\begin{mylist}
\item[\tt IDIV1,LENTRY]
    Structure to be copied resides in division {\tt IDIV1} and is
    pointed at by {\tt LENTRY}.
\item[\tt IDIV1,LSUP,IBIAS]
    Structure is copied to division {\tt IDIV2}, and will be linked
    to link {\tt IBIAS} of the bank at {\tt LSUP}.
\item[\tt CHOPT]
    Option string. In MAD this is always 'S' (single bank).
\end{mylist}

\section{Drop Bank or Structure}
\label{MZDROP}\ttnindex{MZDROP}
\mybox{CALL MZDROP(ISTOR,L,CHOPT)}
    drops a data structure.
\begin{mylist}
\item[\tt ISTOR]
    Store number. In MAD this is always zero.
\item[\tt L]
    Pointer to the bank to be dropped.
\item[\tt CHOPT]
    Option string. A selection of:
    \begin{mylist}
    \item[\tt 'L']
        Drop linear structure.
    \item[\tt 'V']
        Drop only vertical dependents.
    \item[default:]
        Drop bank and its vertical dependents.
    \end{mylist}
\end{mylist}

\section{Initialize ZEBRA System}
\label{MZEBRA}\ttnindex{MZEBRA}
\mybox{CALL MZEBRA(I)}
Initializes the ZEBRA system.
\begin{mylist}
\item[\tt I]
    The value {\tt -2} suppresses logging.
\end{mylist}

\section{End of ZEBRA Processing}
\label{MZEND}\ttnindex{MZEND}
\mybox{CALL MZEND}
Prints ZEBRA statistics about the usage of all divisions.

\section{Flag Bank or Structure}
\label{MZFLAG}\ttnindex{MZFLAG}
\mybox{CALL MZFLAG(ISTOR,L,IBIT,CHOPT)}
Sets a status bit in work {\tt IQ(L)} for all banks in a structure.
\begin{mylist}
\item[\tt ISTOR]
    Store number. This is always zero in MAD.
\item[\tt L]
    Pointer to the structure to be flagged.
\item[\tt IBIT]
    Number of the bit to be set.
    This may be interrogated for a bank by the function call
    {\tt JBIT(IQ(L),IBIT)}.
\item[\tt CHOPT]
    Option string.
    The same letters are accepted as for \ttindex{MZDROP}.
    Additionally the character {\tt 'Z'} causes the selected bit to be
    cleared to zero.
\end{mylist}

\section{Garbage Collection}
\label{MZGARB}\ttnindex{MZGARB}
\mybox{CALL MZGARB(IGARB,IWIPE)}
causes garbage collection in division {\tt IGARB} and division
{\tt IWIPE} is wiped out.

\section{Declare Link Area}
\label{MZLINK}\ttnindex{MZLINK}
\mybox{CALL MZLINK(ISTOR,NAME,LAREA,LREF,LREFL)}
declares a link area (in a COMMON block) to ZEBRA.
If this call is omitted, ZEBRA will not update the links in this area
in case of garbage collection.
\begin{mylist}
\item[\tt ISTOR]
    Store number. This is always zero in MAD.
\item[\tt NAME]
    Name of the link area.
\item[\tt LAREA]
    First word in the area, also the first link of this area.
\item[\tt LREF]
    First reference link, if any; otherwise the last structural link.
\item[\tt LREFL]
    Last reference link, if any; otherwise this parameter is
    {\tt LAREA}.
\end{mylist}
Examples:
\myxmp{
XXXXX\=\kill
{*}  \>Mixed link area:\\
     \>COMMON /LAMIX/ LS1, ..., LSN, LR1, ..., LRN\\
     \>CALL MZLINK(0, '/LAMIX/', LS1, LR1, LRN)\\
\\\
{*}  \>All structural links:\\
     \>COMMON /LASTR/ LS1, ..., LSN\\
     \>CALL MZLINK(0, '/LASTR/', LS1, LSN, LS1)\\
\\\
{*}  \>All reference links:\\
     \>COMMON /LAREF/ LR1, ..., LRN\\
     \>CALL MZLINK(0, '/LAREF/', LR1, LR1, LRN)
}

\section{Test for Available Space}
\label{MZNEED}\ttnindex{MZNEED}
\mybox{CALL MZNEED(IDIV,NNEED,CHOPT)}
Tests if the required number of words is available in a division.
\begin{mylist}
\item[\tt IDIV]
    Number of the division; 2~for long-lived data, 1~for temporary.
\item[\tt NNEED]
    Number of words needed.
\item[\tt CHOPT]
    Option string.
    If there are not enough words, and the option contains {\tt 'G'},
    garbage collection is performed.
\end{mylist}
The variable {\tt IQUEST(11)} will contain the number of words which
would remain {\em after allocating} {\tt NNEED} words.

\section{Change Bank Size}
\label{MZPUSH}\ttnindex{MZPUSH}
The size of a bank can be increased or decreased by using
\mybox{CALL MZPUSH(ISTOR,L,INCNL,INCND,CHOPT)}
\begin{mylist}
\item[\tt ISTOR]
    Store number. This is always zero in MAD.
\item[\tt L]
    The pointer to the bank whose size is to be changed.
    If the bank must be moved, {\tt L} is updated automatically.
\item[\tt INCNL]
    The number of links to be added (positive) or removed (negative).
    If the bank has only structural links, the new links will be
    structural as well, otherwise they will be reference links.
\item[\tt INCND]
    The number of data words to be added (positive) or removed
    (negative).
\item[\tt CHOPT]
    Option string. A selection of:
    \begin{mylist}
    \item[\tt 'R']
        No reference links point into the abandoned bank region.
    \item[\tt 'I']
        Only the supporting structural link,
        the link passed in {\tt L}, and the reverse links in the first
        level dependents point to this bank.
    \item[default]
        Any link may point to this bank.
    \end{mylist}
\end{mylist}

\section{Initialize ZEBRA Store}
\label{MZSTOR}\ttnindex{MZSTOR}
\mybox{
XXXXX\=X\=XXXXXXXXXXXXXXXXXX\=\kill
     \> \>PARAMETER         \>(MEMMIN = 100 000)\\
     \> \>PARAMETER         \>(MEMLEN = 500 000)\\
     \> \>COMMON /MEMORY/   \>FENCE, LQ(MWFLT*MEMLEN)\\
     \> \>SAVE              \>/MEMORY/\\
     \> \>INTEGER           \>IQ(MWFLT*MEMLEN)\\
     \> \>REAL              \>FENCE(2), Q(MWFLT*MEMLEN)\\
     \> \>DIMENSION         \>DQ(MEMLEN)\\
     \> \>EQUIVALENCE       \>(IQ(1), Q(1), DQ(1), LQ(9))\\
     \> \>EQUIVALENCE       \>(LROOT, LQ(1)), (LLUMP, LQ(2))\\
     \> \>...\\
     \> \>CALL MZSTOR(\=ISTOR,CHNAME,CHOPT,FENCE,LQ(1),IQ(LR),LQ(LW),\\
     \>+\>          \>LQ(LIM2),LQ(LAST))
}
is called oncy in the initialization phase.
It defines the working store as follows:
\begin{mylist}
\item[\tt ISTOR]
    Store number. This is returned as zero in the first call.
\item[\tt CHNAME]
    Name of the store for debugging.
\item[\tt CHOPT]
    Option string. If this is {\tt 'Q'}, the log level for the store
    is set to minimum logging.
\item[\tt FENCE]
    Safety area preceding the store to protect against reference to
    {\tt LQ(0), LQ(-1)} etc.
\item[\tt LQ(1)]
    First word of the dynamic store, first permanent structural link.
\item[\tt LQ(LR)]
    MAD uses {\tt IQ} in this position,
    thus reserving eight structural links, {\tt LQ(1)} through
    {\tt LQ(8)}. 
    First permanent reference link (no links reserved in MAD).
\item[\tt LQ(LW)]
    First word of the working area.
    MAD uses {\tt IQ} in this position,
    thus reserving no reference links.
    The working space is used as explained in Section~\ref{work}).
\item[\tt LQ(LIM2)]
    Lowest position of the upper limit of division~2,
    to protect divisions~1 and~2 from being squeezed out of existence
    by divisions created later.
    This parameter has no effect in MAD, as no other divisions 
    are ever created.
\item[\tt LQ(LAST)]
    Last word of the dynamic store.
\end{mylist}

\section{Print ZEBRA Version}
\label{MZVERS}\ttnindex{MZVERS}
\mybox{CALL MZVERS}
Prints the version of ZEBRA used.

\section{Wipe Out Division}
\label{MZWIPE}\ttnindex{MZWIPE}
\mybox{CALL MZWIPE(IDIV)}
Wipes out all banks contained in division~{\tt IDIV}.
MAD uses this to wipe out working space allocated in division~1.
Note that division~1 is also wiped out by changing the working space
limit with a call to \ttindex{MZWORK}.

\section{Allocate Working Space}
\label{MZWORK}\ttnindex{MZWORK}
\mybox{CALL MZWORK(ISTOR,DQ(IF),DQ(IL),IFLAG)}
is used to reserve or release working space.
MAD uses this to move the top-of-stack pointer of the working stack.
Note that a call to \ttindex{MZWORK} also wipes out division~1.
The parameters of \ttindex{MZWORK} are:
\begin{mylist}
\item[\tt ISTOR]
    Store number. Always zero in MAD.
\item[\tt DQ(IF)]
    First word of working space.
    MAD uses {\tt DQ(1)} in this position,
    thus the links reserved by {\tt CALL MZSTOR} are not changed.
\item[\tt DQ(IL)]
    Last word of working space.
\item[\tt IFLAG]
    Flag word with one of the values:
    \begin{mylist}
    \item[0]
        Define a new working space,
    \item[1]
        Vary length of the working space, keep links common to the
        old and new setup intact.
    \item[2]
        Vary last word of working space, don't change first word.
    \item[-1]
        Reset working space to null, i.~e. no links and no data words.
    \end{mylist}
\end{mylist}

\section{Find Number of Banks in Linear List}
\label{NZBANK}\ttnindex{NZBANK}
\mybox{N=NZBANK(ISTOR,LINK)}
Returns the number of banks in a linear structure:
\begin{mylist}
\item[\tt ISTOR]
    Store number. Always zero in MAD.
\item[\tt LINK]
    Pointer to first bank of the structure.
\end{mylist}
The variable {\tt N} will contain the number of banks in the list.

\section{Fatal Termination}
\label{ZFATAL}\ttnindex{ZFATAL}
\mybox{CALL ZFATAL}
is called by ZEBRA when an unrecoverable error occurs.
It kills the current job.

\section{Fatal Termination with Message}
\label{ZFATAM}\ttnindex{ZFATAM}
\mybox{CALL ZFATAM(MSG)}
is called by MAD when an unrecoverable error occurs.
It kills the current job after printing the message in the character
string \ttindex{MSG}.

\section{Switch Processing Phase}
\label{ZPHASE}\ttnindex{ZPHASE}
\mybox{CALL ZPHASE(IPHASE)}
Tells ZEBRA in which phase the program is.
The meaningful values for {\tt IPHASE} are:
\begin{mylist}
\item{zero}
    Initializing,
\item{positive}
    Running,
\item{negative}
    Cleaning up.
\end{mylist}
MAD does not use further conventions.

\section{Change Bank Linkage}
\label{ZSHUNT}\ttnindex{ZSHUNT}
\mybox{CALL ZSHUNT(ISTOR,LSH,LSUP,JBIAS,IFLAG)}
Changes the linking of a bank:
\begin{mylist}
\item[\tt ISTOR]
    Store number. Always zero in MAD.
\item[\tt LSH]
    Pointer to the bank to be relinked.
\item[\tt LSUP]
    Pointer to the new supporting bank.
\item[\tt JBIAS]
    Number of the new supporting structural link.
\item[\tt IFLAG]
    If zero, only a single bank is relinked, otherwise the whole
    linear structure pointed at by {\tt LSH} is relinked.
\end{mylist}

\section{Reverse Order of Linear List}
\label{ZTOPSY}\ttnindex{ZTOPSY}
\mybox{CALL ZTOPSY(ISTOR,LLS)}
reverses the order of banks in a linear structure, sitting in store
{\tt ISTOR} and pointed at by {\tt LLS}.

%==============================================================================

\chapter{Other Routines External to MAD}

\section{GX Package, High-Level Plot Routines}

The high-level plotting routines used by MAD are listed in
table~\ref{T-GX}.
They provide an easy interface to the GKS system,
and may be replaced for driving a different plotting system.
For documentation refer to the GXPLOT~Manual~\cite{GXPLOT}.

\begin{table}[h]
\centering
\caption{GXPLOT Routines called by MAD}
\label{T-GX}
\vspace{1ex}
\begin{tabular}{|l|p{0.65\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{GXASKU}&Ask user for plot options&-\\
\ttindex{GXCLOS}&Close terminal work station&-\\
\ttindex{GXCLRW}&Clear open workstations, set picture name&-\\
\ttindex{GXCUBI}&Calculate third-order natural spline&-\\
\ttindex{GXCUBV}&Calculate value of third-order spline&-\\
\ttindex{GXEOPN}&Set logical unit number for a file&-\\
\ttindex{GXFRM1}&Plot a frame with several axes, return windows&-\\
\ttindex{GXINIT}&Initialize plot package&-\\
\ttindex{GXOPEN}&Open terminal workstation&-\\
\ttindex{GXPL}  &Plot polyline with clipping&-\\
\ttindex{GXPLT1}&Plot smoothed polyline (spline) with clipping&-\\
\ttindex{GXPMSW}&Plot software marker symbol&-\\
\ttindex{GXPNBL}&Find first and last non-blank in a string&-\\
\ttindex{GXQAXS}&Inquire axis parameters&-\\
\ttindex{GXQCRV}&Inquire curve set parameters&-\\
\ttindex{GXQRVP}&Inquire viewport ratio&-\\
\ttindex{GXQVAR}&Inquire selected variable value &-\\
\ttindex{GXREST}&Restore GKS settings&-\\
\ttindex{GXSAVE}&Save GKS settings&-\\
\ttindex{GXSAXS}&Set axis parameters&-\\
\ttindex{GXSCRV}&Set curve set parameters&-\\
\ttindex{GXSDEF}&Set undefined variables/restore defaults&-\\
\ttindex{GXSVAR}&Set selected variable value&-\\
\ttindex{GXSVPT}&Set workstation viewport&-\\
\ttindex{GXSWND}&Set window&-\\
\ttindex{GXTERM}&Terminate plot package&-\\
\ttindex{GXTX}  &Plot text, including greek characters etc.&-\\
\ttindex{GXWAIT}&Wait for user input while diplaying a frame&-\\
\hline
\end{tabular}
\end{table}

\clearpage

\section{GKS Plotting Routines}
\label{C-GKS}

The low-level plotting routines used in the standard distribution of
MAD are listed in table~\ref{T-GKS}.
For documentation refer to the GKS~Manual~\cite{GKS}.

\begin{table}[h]
\centering
\caption{GKS Routines Called by MAD}
\label{T-GKS}
\vspace{1ex}
\begin{tabular}{|l|p{0.65\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{GPL}   &Plot points&-\\
\ttindex{GSCHH} &Set character height&-\\
\ttindex{GSCHXP}&Set character expansion factor&-\\
\ttindex{GSLN}  &Set ...&-\\
\ttindex{GSLWSC}&Set ...&-\\
\ttindex{GSMK}  &Set mark character&-\\
\ttindex{GSTXAL}&Set text alignment&-\\
\hline
\end{tabular}
\end{table}

\section{EPIO Routines, Machine-Independent Binary I/O}

The routines for machine-independen binary I/O used by MAD are listed
in table~\ref{T-EPIO}.
For documentation refer to the EPIO~Manual~\cite{EPIO}.

\begin{table}[h]
\centering
\caption{EPIO Routines Called by MAD}
\label{T-EPIO}
\vspace{1ex}
\begin{tabular}{|l|p{0.65\textwidth}|c|}
\hline
Name&Purpose&Section\\
\hline
\ttindex{BLO32W}&Convert 32 bit to native word&-\\
\ttindex{CTOIBM}&Convert floating point to IBM format&-\\
\ttindex{EPEND} &Terminate of machine-independent I/O&-\\
\ttindex{EPINIT}&Initialize machine-independent I/O&-\\
\ttindex{EPOUTL}&Write a record&-\\
\ttindex{EPSETW}&Set selected control word&-\\ 
\ttindex{STOASC}&Convert string to  ASCII&-\\
\hline
\end{tabular}
\end{table}

\clearpage

\section{Miscellaneous Routines}
\label{kernlib}
MAD uses a few minor routines from the CERN KERNLIB library.
These are listed in table~\ref{T-MCERN}.
For documentation refer to the relevant CERN program library
document~\cite{CERNLIB}.

\begin{table}[h]
\centering
\caption{Miscellaneous CERN Library Routines Called by MAD}
\label{T-MCERN}
\vspace{1ex}
\begin{tabular}{|l|l|p{0.65\textwidth}|c|}
\hline
Package&Name&Purpose&Section\\
\hline
\tt F122&\ttindex{VZERO} &Fill an array with zeroes&-\\
        &\ttindex{VBLANK}&Fill an array with Hollerith blanks&-\\
        &\ttindex{VFILL} &Fill an array with given word&-\\
\hline
\tt M101&\ttindex{SORTZV}&Sort array&-\\
\hline
\tt M409&\ttindex{UCTOH} &Copy character to Hollerith&-\\
        &\ttindex{UHTOC} &Copy Hollerith to character&-\\
\hline
\tt M421&\ttindex{JBIT}  &Fetch bit from a word&-\\
        &\ttindex{JBYT}  &Fetch byte from a word&-\\
        &\ttindex{SBIT0} &Clear a bit in a word&-\\
        &\ttindex{SBIT1} &Set a bit in a word&-\\
        &\ttindex{SBYT}  &Store a byte in a word&-\\
\hline
\tt V300&\ttindex{UZERO} &Clear an array to fill&-\\
\hline                
\tt V301&\ttindex{UCOPY} &Copy $n$ words&-\\
\hline
\tt V304&\ttindex{IUCOMP}&Look up a word in a table&-\\
\hline
\tt Z007&\ttindex{DATIMH}&Date and time in Hollerith&-\\
        &\ttindex{TIMEL} &Time left for execution&-\\
        &\ttindex{TIMEX} &Time used for execution&-\\
\hline
\tt Z044&\ttindex{INTRAC}&Identify interactive job&-\\
\hline
\tt Z100&\ttindex{JOBNAM}&Retrieve job name&-\\
\hline
\end{tabular}
\end{table}

%==============================================================================

\appendix

\chapter{An Example of a New Element: Wiggler}

\chapter{An Example of a New Module: Part List}

%==============================================================================

\chapter{Indexing Scheme for Symbolic Polynomials}
\label{giorgelli}
The polynomial manipulation routines of MAD use a storage scheme for
polynomials invented by Giorgelli~\cite{GIORG}.
The monomials are ordered by their order;
and within the order in lexicographical sequence.
The tables below list the monomials in this order.

\section{First-Order Terms}
\indent
\begin{tabbing}
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\\
  1\>$x                 $\>  2\>$p_x               $\>
  3\>$y                 $\>  4\>$p_y               $\>
  5\>$t                 $\\
  6\>$p_t               $
\end{tabbing}

\section{Second-Order Terms}
\indent
\begin{tabbing}
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\\
  7\>$x  ^2             $\>  8\>$x  p_x            $\>
  9\>$x  y              $\> 10\>$x  p_y            $\>
 11\>$x  t              $\\
 12\>$x  p_t            $\> 13\>$p_x^2             $\>
 14\>$p_xy              $\> 15\>$p_xp_y            $\>
 16\>$p_xt              $\\
 17\>$p_xp_t            $\> 18\>$y  ^2             $\>
 19\>$y  p_y            $\> 20\>$y  t              $\>
 21\>$y  p_t            $\\
 22\>$p_y^2             $\> 23\>$p_yt              $\>
 24\>$p_yp_t            $\> 25\>$t  ^2             $\>
 26\>$t  p_t            $\\
 27\>$p_t^2             $
\end{tabbing}

\section{Third-Order Terms}
\indent
\begin{tabbing}
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\\
 28\>$x  ^3             $\> 29\>$x  ^2 p_x         $\>
 30\>$x  ^2 y           $\> 31\>$x  ^2 p_y         $\>
 32\>$x  ^2 t           $\\
 33\>$x  ^2 p_t         $\> 34\>$x  p_x^2          $\>
 35\>$x  p_xy           $\> 36\>$x  p_xp_y         $\>
 37\>$x  p_xt           $\\
 38\>$x  p_xp_t         $\> 39\>$x  y  ^2          $\>
 40\>$x  y  p_y         $\> 41\>$x  y  t           $\>
 42\>$x  y  p_t         $\\
 43\>$x  p_y^2          $\> 44\>$x  p_yt           $\>
 45\>$x  p_yp_t         $\> 46\>$x  t  ^2          $\>
 47\>$x  t  p_t         $\\
 48\>$x  p_t^2          $\> 49\>$p_x^3             $\>
 50\>$p_x^2 y           $\> 51\>$p_x^2 p_y         $\>
 52\>$p_x^2 t           $\\
 53\>$p_x^2 p_t         $\> 54\>$p_xy  ^2          $\>
 55\>$p_xy  p_y         $\> 56\>$p_xy  t           $\>
 57\>$p_xy  p_t         $\\
 58\>$p_xp_y^2          $\> 59\>$p_xp_yt           $\>
 60\>$p_xp_yp_t         $\> 61\>$p_xt  ^2          $\>
 62\>$p_xt  p_t         $\\
 63\>$p_xp_t^2          $\> 64\>$y  ^3             $\>
 65\>$y  ^2 p_y         $\> 66\>$y  ^2 t           $\>
 67\>$y  ^2 p_t         $\\
 68\>$y  p_y^2          $\> 69\>$y  p_yt           $\>
 70\>$y  p_yp_t         $\> 71\>$y  t  ^2          $\>
 72\>$y  t  p_t         $\\
 73\>$y  p_t^2          $\> 74\>$p_y^3             $\>
 75\>$p_y^2 t           $\> 76\>$p_y^2 p_t         $\>
 77\>$p_yt  ^2          $\\
 78\>$p_yt  p_t         $\> 79\>$p_yp_t^2          $\>
 80\>$t  ^3             $\> 81\>$t  ^2 p_t         $\>
 82\>$t  p_t^2          $\\
 83\>$p_t^3             $
\end{tabbing}

\section{Fourth-Order Terms}
\indent
\begin{tabbing}
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\\
 84\>$x  ^4             $\> 85\>$x  ^3 p_x         $\>
 86\>$x  ^3 y           $\> 87\>$x  ^3 p_y         $\>
 88\>$x  ^3 t           $\\
 89\>$x  ^3 p_t         $\> 90\>$x  ^2 p_x^2       $\>
 91\>$x  ^2 p_xy        $\> 92\>$x  ^2 p_xp_y      $\>
 93\>$x  ^2 p_xt        $\\
 94\>$x  ^2 p_xp_t      $\> 95\>$x  ^2 y  ^2       $\>
 96\>$x  ^2 y  p_y      $\> 97\>$x  ^2 y  t        $\>
 98\>$x  ^2 y  p_t      $\\
 99\>$x  ^2 p_y^2       $\>100\>$x  ^2 p_yt        $\>
101\>$x  ^2 p_yp_t      $\>102\>$x  ^2 t  ^2       $\>
103\>$x  ^2 t  p_t      $\\
104\>$x  ^2 p_t^2       $\>105\>$x  p_x^3          $\>
106\>$x  p_x^2 y        $\>107\>$x  p_x^2 p_y      $\>
108\>$x  p_x^2 t        $\\
109\>$x  p_x^2 p_t      $\>110\>$x  p_xy  ^2       $\>
111\>$x  p_xy  p_y      $\>112\>$x  p_xy  t        $\>
113\>$x  p_xy  p_t      $\\
114\>$x  p_xp_y^2       $\>115\>$x  p_xp_yt        $\>
116\>$x  p_xp_yp_t      $\>117\>$x  p_xt  ^2       $\>
118\>$x  p_xt  p_t      $\\
119\>$x  p_xp_t^2       $\>120\>$x  y  ^3          $\>
121\>$x  y  ^2 p_y      $\>122\>$x  y  ^2 t        $\>
123\>$x  y  ^2 p_t      $\\
124\>$x  y  p_y^2       $\>125\>$x  y  p_yt        $\>
126\>$x  y  p_yp_t      $\>127\>$x  y  t  ^2       $\>
128\>$x  y  t  p_t      $\\
129\>$x  y  p_t^2       $\>130\>$x  p_y^3          $\>
131\>$x  p_y^2 t        $\>132\>$x  p_y^2 p_t      $\>
133\>$x  p_yt  ^2       $\\
134\>$x  p_yt  p_t      $\>135\>$x  p_yp_t^2       $\>
136\>$x  t  ^3          $\>137\>$x  t  ^2 p_t      $\>
138\>$x  t  p_t^2       $\\
139\>$x  p_t^3          $\>140\>$p_x^4             $\>
141\>$p_x^3 y           $\>142\>$p_x^3 p_y         $\>
143\>$p_x^3 t           $\\
144\>$p_x^3 p_t         $\>145\>$p_x^2 y  ^2       $\>
146\>$p_x^2 y  p_y      $\>147\>$p_x^2 y  t        $\>
148\>$p_x^2 y  p_t      $\\
149\>$p_x^2 p_y^2       $\>150\>$p_x^2 p_yt        $\>
151\>$p_x^2 p_yp_t      $\>152\>$p_x^2 t  ^2       $\>
153\>$p_x^2 t  p_t      $\\
154\>$p_x^2 p_t^2       $\>155\>$p_xy  ^3          $\>
156\>$p_xy  ^2 p_y      $\>157\>$p_xy  ^2 t        $\>
158\>$p_xy  ^2 p_t      $\\
159\>$p_xy  p_y^2       $\>160\>$p_xy  p_yt        $\>
161\>$p_xy  p_yp_t      $\>162\>$p_xy  t  ^2       $\>
163\>$p_xy  t  p_t      $\\
164\>$p_xy  p_t^2       $\>165\>$p_xp_y^3          $\>
166\>$p_xp_y^2 t        $\>167\>$p_xp_y^2 p_t      $\>
168\>$p_xp_yt  ^2       $\\
169\>$p_xp_yt  p_t      $\>170\>$p_xp_yp_t^2       $\>
171\>$p_xt  ^3          $\>172\>$p_xt  ^2 p_t      $\>
173\>$p_xt  p_t^2       $\\
174\>$p_xp_t^3          $\>175\>$y  ^4             $\>
176\>$y  ^3 p_y         $\>177\>$y  ^3 t           $\>
178\>$y  ^3 p_t         $\\
179\>$y  ^2 p_y^2       $\>180\>$y  ^2 p_yt        $\>
181\>$y  ^2 p_yp_t      $\>182\>$y  ^2 t  ^2       $\>
183\>$y  ^2 t  p_t      $\\
184\>$y  ^2 p_t^2       $\>185\>$y  p_y^3          $\>
186\>$y  p_y^2 t        $\>187\>$y  p_y^2 p_t      $\>
188\>$y  p_yt  ^2       $\\
189\>$y  p_yt  p_t      $\>190\>$y  p_yp_t^2       $\>
191\>$y  t  ^3          $\>192\>$y  t  ^2 p_t      $\>
193\>$y  t  p_t^2       $\\
194\>$y  p_t^3          $\>195\>$p_y^4             $\>
196\>$p_y^3 t           $\>197\>$p_y^3 p_t         $\>
198\>$p_y^2 t  ^2       $\\
199\>$p_y^2 t  p_t      $\>200\>$p_y^2 p_t^2       $\>
201\>$p_yt  ^3          $\>202\>$p_yt  ^2 p_t      $\>
203\>$p_yt  p_t^2       $\\
204\>$p_yp_t^3          $\>205\>$t  ^4             $\>
206\>$t  ^3 p_t         $\>207\>$t  ^2 p_t^2       $\>
208\>$t  p_t^3          $\\
209\>$p_t^4             $
\end{tabbing}

\section{Fifth-Order Terms}
\indent
\begin{tabbing}
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\\
210\>$x  ^5             $\>211\>$x  ^4 p_x         $\>
212\>$x  ^4 y           $\>213\>$x  ^4 p_y         $\>
214\>$x  ^4 t           $\\
215\>$x  ^4 p_t         $\>216\>$x  ^3 p_x^2       $\>
217\>$x  ^3 p_xy        $\>218\>$x  ^3 p_xp_y      $\>
219\>$x  ^3 p_xt        $\\
220\>$x  ^3 p_xp_t      $\>221\>$x  ^3 y  ^2       $\>
222\>$x  ^3 y  p_y      $\>223\>$x  ^3 y  t        $\>
224\>$x  ^3 y  p_t      $\\
225\>$x  ^3 p_y^2       $\>226\>$x  ^3 p_yt        $\>
227\>$x  ^3 p_yp_t      $\>228\>$x  ^3 t  ^2       $\>
229\>$x  ^3 t  p_t      $\\
230\>$x  ^3 p_t^2       $\>231\>$x  ^2 p_x^3       $\>
232\>$x  ^2 p_x^2 y     $\>233\>$x  ^2 p_x^2 p_y   $\>
234\>$x  ^2 p_x^2 t     $\\
235\>$x  ^2 p_x^2 p_t   $\>236\>$x  ^2 p_xy  ^2    $\>
237\>$x  ^2 p_xy  p_y   $\>238\>$x  ^2 p_xy  t     $\>
239\>$x  ^2 p_xy  p_t   $\\
240\>$x  ^2 p_xp_y^2    $\>241\>$x  ^2 p_xp_yt     $\>
242\>$x  ^2 p_xp_yp_t   $\>243\>$x  ^2 p_xt  ^2    $\>
244\>$x  ^2 p_xt  p_t   $\\
245\>$x  ^2 p_xp_t^2    $\>246\>$x  ^2 y  ^3       $\>
247\>$x  ^2 y  ^2 p_y   $\>248\>$x  ^2 y  ^2 t     $\>
249\>$x  ^2 y  ^2 p_t   $\\
250\>$x  ^2 y  p_y^2    $\>251\>$x  ^2 y  p_yt     $\>
252\>$x  ^2 y  p_yp_t   $\>253\>$x  ^2 y  t  ^2    $\>
254\>$x  ^2 y  t  p_t   $\\
255\>$x  ^2 y  p_t^2    $\>256\>$x  ^2 p_y^3       $\>
257\>$x  ^2 p_y^2 t     $\>258\>$x  ^2 p_y^2 p_t   $\>
259\>$x  ^2 p_yt  ^2    $\\
260\>$x  ^2 p_yt  p_t   $\>261\>$x  ^2 p_yp_t^2    $\>
262\>$x  ^2 t  ^3       $\>263\>$x  ^2 t  ^2 p_t   $\>
264\>$x  ^2 t  p_t^2    $\\
265\>$x  ^2 p_t^3       $\>266\>$x  p_x^4          $\>
267\>$x  p_x^3 y        $\>268\>$x  p_x^3 p_y      $\>
269\>$x  p_x^3 t        $\\
270\>$x  p_x^3 p_t      $\>271\>$x  p_x^2 y  ^2    $\>
272\>$x  p_x^2 y  p_y   $\>273\>$x  p_x^2 y  t     $\>
274\>$x  p_x^2 y  p_t   $\\
275\>$x  p_x^2 p_y^2    $\>276\>$x  p_x^2 p_yt     $\>
277\>$x  p_x^2 p_yp_t   $\>278\>$x  p_x^2 t  ^2    $\>
279\>$x  p_x^2 t  p_t   $\\
280\>$x  p_x^2 p_t^2    $\>281\>$x  p_xy  ^3       $\>
282\>$x  p_xy  ^2 p_y   $\>283\>$x  p_xy  ^2 t     $\>
284\>$x  p_xy  ^2 p_t   $\\
285\>$x  p_xy  p_y^2    $\>286\>$x  p_xy  p_yt     $\>
287\>$x  p_xy  p_yp_t   $\>288\>$x  p_xy  t  ^2    $\>
289\>$x  p_xy  t  p_t   $\\
290\>$x  p_xy  p_t^2    $\>291\>$x  p_xp_y^3       $\>
292\>$x  p_xp_y^2 t     $\>293\>$x  p_xp_y^2 p_t   $\>
294\>$x  p_xp_yt  ^2    $\\
295\>$x  p_xp_yt  p_t   $\>296\>$x  p_xp_yp_t^2    $\>
297\>$x  p_xt  ^3       $\>298\>$x  p_xt  ^2 p_t   $\>
299\>$x  p_xt  p_t^2    $\\
300\>$x  p_xp_t^3       $\>301\>$x  y  ^4          $\>
302\>$x  y  ^3 p_y      $\>303\>$x  y  ^3 t        $\>
304\>$x  y  ^3 p_t      $\\
305\>$x  y  ^2 p_y^2    $\>306\>$x  y  ^2 p_yt     $\>
307\>$x  y  ^2 p_yp_t   $\>308\>$x  y  ^2 t  ^2    $\>
309\>$x  y  ^2 t  p_t   $\\
310\>$x  y  ^2 p_t^2    $\>311\>$x  y  p_y^3       $\>
312\>$x  y  p_y^2 t     $\>313\>$x  y  p_y^2 p_t   $\>
314\>$x  y  p_yt  ^2    $\\
315\>$x  y  p_yt  p_t   $\>316\>$x  y  p_yp_t^2    $\>
317\>$x  y  t  ^3       $\>318\>$x  y  t  ^2 p_t   $\>
319\>$x  y  t  p_t^2    $\\
320\>$x  y  p_t^3       $\>321\>$x  p_y^4          $\>
322\>$x  p_y^3 t        $\>323\>$x  p_y^3 p_t      $\>
324\>$x  p_y^2 t  ^2    $\\
325\>$x  p_y^2 t  p_t   $\>326\>$x  p_y^2 p_t^2    $\>
327\>$x  p_yt  ^3       $\>328\>$x  p_yt  ^2 p_t   $\>
329\>$x  p_yt  p_t^2    $\\
330\>$x  p_yp_t^3       $\>331\>$x  t  ^4          $\>
332\>$x  t  ^3 p_t      $\>333\>$x  t  ^2 p_t^2    $\>
334\>$x  t  p_t^3       $\\
335\>$x  p_t^4          $\>336\>$p_x^5             $\>
337\>$p_x^4 y           $\>338\>$p_x^4 p_y         $\>
339\>$p_x^4 t           $\\
340\>$p_x^4 p_t         $\>341\>$p_x^3 y  ^2       $\>
342\>$p_x^3 y  p_y      $\>343\>$p_x^3 y  t        $\>
344\>$p_x^3 y  p_t      $\\
345\>$p_x^3 p_y^2       $\>346\>$p_x^3 p_yt        $\>
347\>$p_x^3 p_yp_t      $\>348\>$p_x^3 t  ^2       $\>
349\>$p_x^3 t  p_t      $\\
350\>$p_x^3 p_t^2       $\>351\>$p_x^2 y  ^3       $\>
352\>$p_x^2 y  ^2 p_y   $\>353\>$p_x^2 y  ^2 t     $\>
354\>$p_x^2 y  ^2 p_t   $\\
355\>$p_x^2 y  p_y^2    $\>356\>$p_x^2 y  p_yt     $\>
357\>$p_x^2 y  p_yp_t   $\>358\>$p_x^2 y  t  ^2    $\>
359\>$p_x^2 y  t  p_t   $\\
360\>$p_x^2 y  p_t^2    $\>361\>$p_x^2 p_y^3       $\>
362\>$p_x^2 p_y^2 t     $\>363\>$p_x^2 p_y^2 p_t   $\>
364\>$p_x^2 p_yt  ^2    $\\
365\>$p_x^2 p_yt  p_t   $\>366\>$p_x^2 p_yp_t^2    $\>
367\>$p_x^2 t  ^3       $\>368\>$p_x^2 t  ^2 p_t   $\>
369\>$p_x^2 t  p_t^2    $\\
370\>$p_x^2 p_t^3       $\>371\>$p_xy  ^4          $\>
372\>$p_xy  ^3 p_y      $\>373\>$p_xy  ^3 t        $\>
374\>$p_xy  ^3 p_t      $\\
375\>$p_xy  ^2 p_y^2    $\>376\>$p_xy  ^2 p_yt     $\>
377\>$p_xy  ^2 p_yp_t   $\>378\>$p_xy  ^2 t  ^2    $\>
379\>$p_xy  ^2 t  p_t   $\\
380\>$p_xy  ^2 p_t^2    $\>381\>$p_xy  p_y^3       $\>
382\>$p_xy  p_y^2 t     $\>383\>$p_xy  p_y^2 p_t   $\>
384\>$p_xy  p_yt  ^2    $\\
385\>$p_xy  p_yt  p_t   $\>386\>$p_xy  p_yp_t^2    $\>
387\>$p_xy  t  ^3       $\>388\>$p_xy  t  ^2 p_t   $\>
389\>$p_xy  t  p_t^2    $\\
390\>$p_xy  p_t^3       $\>391\>$p_xp_y^4          $\>
392\>$p_xp_y^3 t        $\>393\>$p_xp_y^3 p_t      $\>
394\>$p_xp_y^2 t  ^2    $\\
395\>$p_xp_y^2 t  p_t   $\>396\>$p_xp_y^2 p_t^2    $\>
397\>$p_xp_yt  ^3       $\>398\>$p_xp_yt  ^2 p_t   $\>
399\>$p_xp_yt  p_t^2    $\\
400\>$p_xp_yp_t^3       $\>401\>$p_xt  ^4          $\>
402\>$p_xt  ^3 p_t      $\>403\>$p_xt  ^2 p_t^2    $\>
404\>$p_xt  p_t^3       $\\
405\>$p_xp_t^4          $\>406\>$y  ^5             $\>
407\>$y  ^4 p_y         $\>408\>$y  ^4 t           $\>
409\>$y  ^4 p_t         $\\
410\>$y  ^3 p_y^2       $\>411\>$y  ^3 p_yt        $\>
412\>$y  ^3 p_yp_t      $\>413\>$y  ^3 t  ^2       $\>
414\>$y  ^3 t  p_t      $\\
415\>$y  ^3 p_t^2       $\>416\>$y  ^2 p_y^3       $\>
417\>$y  ^2 p_y^2 t     $\>418\>$y  ^2 p_y^2 p_t   $\>
419\>$y  ^2 p_yt  ^2    $\\
420\>$y  ^2 p_yt  p_t   $\>421\>$y  ^2 p_yp_t^2    $\>
422\>$y  ^2 t  ^3       $\>423\>$y  ^2 t  ^2 p_t   $\>
424\>$y  ^2 t  p_t^2    $\\
425\>$y  ^2 p_t^3       $\>426\>$y  p_y^4          $\>
427\>$y  p_y^3 t        $\>428\>$y  p_y^3 p_t      $\>
429\>$y  p_y^2 t  ^2    $\\
430\>$y  p_y^2 t  p_t   $\>431\>$y  p_y^2 p_t^2    $\>
432\>$y  p_yt  ^3       $\>433\>$y  p_yt  ^2 p_t   $\>
434\>$y  p_yt  p_t^2    $\\
435\>$y  p_yp_t^3       $\>436\>$y  t  ^4          $\>
437\>$y  t  ^3 p_t      $\>438\>$y  t  ^2 p_t^2    $\>
439\>$y  t  p_t^3       $\\
440\>$y  p_t^4          $\>441\>$p_y^5             $\>
442\>$p_y^4 t           $\>443\>$p_y^4 p_t         $\>
444\>$p_y^3 t  ^2       $\\
445\>$p_y^3 t  p_t      $\>446\>$p_y^3 p_t^2       $\>
447\>$p_y^2 t  ^3       $\>448\>$p_y^2 t  ^2 p_t   $\>
449\>$p_y^2 t  p_t^2    $\\
450\>$p_y^2 p_t^3       $\>451\>$p_yt  ^4          $\>
452\>$p_yt  ^3 p_t      $\>453\>$p_yt  ^2 p_t^2    $\>
454\>$p_yt  p_t^3       $\\
455\>$p_yp_t^4          $\>456\>$t  ^5             $\>
457\>$t  ^4 p_t         $\>458\>$t  ^3 p_t^2       $\>
459\>$t  ^2 p_t^3       $\\
460\>$t  p_t^4          $\>461\>$p_t^5             $
\end{tabbing}

\section{Sixth-Order Terms}
\indent
\begin{tabbing}
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\kern1cm\=index\ \=variables\kern1cm\=
index\ \=variables\\
462\>$x  ^6             $\>463\>$x  ^5 p_x         $\>
464\>$x  ^5 y           $\>465\>$x  ^5 p_y         $\>
466\>$x  ^5 t           $\\
467\>$x  ^5 p_t         $\>468\>$x  ^4 p_x^2       $\>
469\>$x  ^4 p_xy        $\>470\>$x  ^4 p_xp_y      $\>
471\>$x  ^4 p_xt        $\\
472\>$x  ^4 p_xp_t      $\>473\>$x  ^4 y  ^2       $\>
474\>$x  ^4 y  p_y      $\>475\>$x  ^4 y  t        $\>
476\>$x  ^4 y  p_t      $\\
477\>$x  ^4 p_y^2       $\>478\>$x  ^4 p_yt        $\>
479\>$x  ^4 p_yp_t      $\>480\>$x  ^4 t  ^2       $\>
481\>$x  ^4 t  p_t      $\\
482\>$x  ^4 p_t^2       $\>483\>$x  ^3 p_x^3       $\>
484\>$x  ^3 p_x^2 y     $\>485\>$x  ^3 p_x^2 p_y   $\>
486\>$x  ^3 p_x^2 t     $\\
487\>$x  ^3 p_x^2 p_t   $\>488\>$x  ^3 p_xy  ^2    $\>
489\>$x  ^3 p_xy  p_y   $\>490\>$x  ^3 p_xy  t     $\>
491\>$x  ^3 p_xy  p_t   $\\
492\>$x  ^3 p_xp_y^2    $\>493\>$x  ^3 p_xp_yt     $\>
494\>$x  ^3 p_xp_yp_t   $\>495\>$x  ^3 p_xt  ^2    $\>
496\>$x  ^3 p_xt  p_t   $\\
497\>$x  ^3 p_xp_t^2    $\>498\>$x  ^3 y  ^3       $\>
499\>$x  ^3 y  ^2 p_y   $\>500\>$x  ^3 y  ^2 t     $\>
501\>$x  ^3 y  ^2 p_t   $\\
502\>$x  ^3 y  p_y^2    $\>503\>$x  ^3 y  p_yt     $\>
504\>$x  ^3 y  p_yp_t   $\>505\>$x  ^3 y  t  ^2    $\>
506\>$x  ^3 y  t  p_t   $\\
507\>$x  ^3 y  p_t^2    $\>508\>$x  ^3 p_y^3       $\>
509\>$x  ^3 p_y^2 t     $\>510\>$x  ^3 p_y^2 p_t   $\>
511\>$x  ^3 p_yt  ^2    $\\
512\>$x  ^3 p_yt  p_t   $\>513\>$x  ^3 p_yp_t^2    $\>
514\>$x  ^3 t  ^3       $\>515\>$x  ^3 t  ^2 p_t   $\>
516\>$x  ^3 t  p_t^2    $\\
517\>$x  ^3 p_t^3       $\>518\>$x  ^2 p_x^4       $\>
519\>$x  ^2 p_x^3 y     $\>520\>$x  ^2 p_x^3 p_y   $\>
521\>$x  ^2 p_x^3 t     $\\
522\>$x  ^2 p_x^3 p_t   $\>523\>$x  ^2 p_x^2 y  ^2 $\>
524\>$x  ^2 p_x^2 y  p_y$\>525\>$x  ^2 p_x^2 y  t  $\>
526\>$x  ^2 p_x^2 y  p_t$\\
527\>$x  ^2 p_x^2 p_y^2 $\>528\>$x  ^2 p_x^2 p_yt  $\>
529\>$x  ^2 p_x^2 p_yp_t$\>530\>$x  ^2 p_x^2 t  ^2 $\>
531\>$x  ^2 p_x^2 t  p_t$\\
532\>$x  ^2 p_x^2 p_t^2 $\>533\>$x  ^2 p_xy  ^3    $\>
534\>$x  ^2 p_xy  ^2 p_y$\>535\>$x  ^2 p_xy  ^2 t  $\>
536\>$x  ^2 p_xy  ^2 p_t$\\
537\>$x  ^2 p_xy  p_y^2 $\>538\>$x  ^2 p_xy  p_yt  $\>
539\>$x  ^2 p_xy  p_yp_t$\>540\>$x  ^2 p_xy  t  ^2 $\>
541\>$x  ^2 p_xy  t  p_t$\\
542\>$x  ^2 p_xy  p_t^2 $\>543\>$x  ^2 p_xp_y^3    $\>
544\>$x  ^2 p_xp_y^2 t  $\>545\>$x  ^2 p_xp_y^2 p_t$\>
546\>$x  ^2 p_xp_yt  ^2 $\\
547\>$x  ^2 p_xp_yt  p_t$\>548\>$x  ^2 p_xp_yp_t^2 $\>
549\>$x  ^2 p_xt  ^3    $\>550\>$x  ^2 p_xt  ^2 p_t$\>
551\>$x  ^2 p_xt  p_t^2 $\\
552\>$x  ^2 p_xp_t^3    $\>553\>$x  ^2 y  ^4       $\>
554\>$x  ^2 y  ^3 p_y   $\>555\>$x  ^2 y  ^3 t     $\>
556\>$x  ^2 y  ^3 p_t   $\\
557\>$x  ^2 y  ^2 p_y^2 $\>558\>$x  ^2 y  ^2 p_yt  $\>
559\>$x  ^2 y  ^2 p_yp_t$\>560\>$x  ^2 y  ^2 t  ^2 $\>
561\>$x  ^2 y  ^2 t  p_t$\\
562\>$x  ^2 y  ^2 p_t^2 $\>563\>$x  ^2 y  p_y^3    $\>
564\>$x  ^2 y  p_y^2 t  $\>565\>$x  ^2 y  p_y^2 p_t$\>
566\>$x  ^2 y  p_yt  ^2 $\\
567\>$x  ^2 y  p_yt  p_t$\>568\>$x  ^2 y  p_yp_t^2 $\>
569\>$x  ^2 y  t  ^3    $\>570\>$x  ^2 y  t  ^2 p_t$\>
571\>$x  ^2 y  t  p_t^2 $\\
572\>$x  ^2 y  p_t^3    $\>573\>$x  ^2 p_y^4       $\>
574\>$x  ^2 p_y^3 t     $\>575\>$x  ^2 p_y^3 p_t   $\>
576\>$x  ^2 p_y^2 t  ^2 $\\
577\>$x  ^2 p_y^2 t  p_t$\>578\>$x  ^2 p_y^2 p_t^2 $\>
579\>$x  ^2 p_yt  ^3    $\>580\>$x  ^2 p_yt  ^2 p_t$\>
581\>$x  ^2 p_yt  p_t^2 $\\
582\>$x  ^2 p_yp_t^3    $\>583\>$x  ^2 t  ^4       $\>
584\>$x  ^2 t  ^3 p_t   $\>585\>$x  ^2 t  ^2 p_t^2 $\>
586\>$x  ^2 t  p_t^3    $\\
587\>$x  ^2 p_t^4       $\>588\>$x  p_x^5          $\>
589\>$x  p_x^4 y        $\>590\>$x  p_x^4 p_y      $\>
591\>$x  p_x^4 t        $\\
592\>$x  p_x^4 p_t      $\>593\>$x  p_x^3 y  ^2    $\>
594\>$x  p_x^3 y  p_y   $\>595\>$x  p_x^3 y  t     $\>
596\>$x  p_x^3 y  p_t   $\\
597\>$x  p_x^3 p_y^2    $\>598\>$x  p_x^3 p_yt     $\>
599\>$x  p_x^3 p_yp_t   $\>600\>$x  p_x^3 t  ^2    $\>
601\>$x  p_x^3 t  p_t   $\\
602\>$x  p_x^3 p_t^2    $\>603\>$x  p_x^2 y  ^3    $\>
604\>$x  p_x^2 y  ^2 p_y$\>605\>$x  p_x^2 y  ^2 t  $\>
606\>$x  p_x^2 y  ^2 p_t$\\
607\>$x  p_x^2 y  p_y^2 $\>608\>$x  p_x^2 y  p_yt  $\>
609\>$x  p_x^2 y  p_yp_t$\>610\>$x  p_x^2 y  t  ^2 $\>
611\>$x  p_x^2 y  t  p_t$\\
612\>$x  p_x^2 y  p_t^2 $\>613\>$x  p_x^2 p_y^3    $\>
614\>$x  p_x^2 p_y^2 t  $\>615\>$x  p_x^2 p_y^2 p_t$\>
616\>$x  p_x^2 p_yt  ^2 $\\
617\>$x  p_x^2 p_yt  p_t$\>618\>$x  p_x^2 p_yp_t^2 $\>
619\>$x  p_x^2 t  ^3    $\>620\>$x  p_x^2 t  ^2 p_t$\>
621\>$x  p_x^2 t  p_t^2 $\\
622\>$x  p_x^2 p_t^3    $\>623\>$x  p_xy  ^4       $\>
624\>$x  p_xy  ^3 p_y   $\>625\>$x  p_xy  ^3 t     $\>
626\>$x  p_xy  ^3 p_t   $\\
627\>$x  p_xy  ^2 p_y^2 $\>628\>$x  p_xy  ^2 p_yt  $\>
629\>$x  p_xy  ^2 p_yp_t$\>630\>$x  p_xy  ^2 t  ^2 $\>
631\>$x  p_xy  ^2 t  p_t$\\
632\>$x  p_xy  ^2 p_t^2 $\>633\>$x  p_xy  p_y^3    $\>
634\>$x  p_xy  p_y^2 t  $\>635\>$x  p_xy  p_y^2 p_t$\>
636\>$x  p_xy  p_yt  ^2 $\\
637\>$x  p_xy  p_yt  p_t$\>638\>$x  p_xy  p_yp_t^2 $\>
639\>$x  p_xy  t  ^3    $\>640\>$x  p_xy  t  ^2 p_t$\>
641\>$x  p_xy  t  p_t^2 $\\
642\>$x  p_xy  p_t^3    $\>643\>$x  p_xp_y^4       $\>
644\>$x  p_xp_y^3 t     $\>645\>$x  p_xp_y^3 p_t   $\>
646\>$x  p_xp_y^2 t  ^2 $\\
647\>$x  p_xp_y^2 t  p_t$\>648\>$x  p_xp_y^2 p_t^2 $\>
649\>$x  p_xp_yt  ^3    $\>650\>$x  p_xp_yt  ^2 p_t$\>
651\>$x  p_xp_yt  p_t^2 $\\
652\>$x  p_xp_yp_t^3    $\>653\>$x  p_xt  ^4       $\>
654\>$x  p_xt  ^3 p_t   $\>655\>$x  p_xt  ^2 p_t^2 $\>
656\>$x  p_xt  p_t^3    $\\
657\>$x  p_xp_t^4       $\>658\>$x  y  ^5          $\>
659\>$x  y  ^4 p_y      $\>660\>$x  y  ^4 t        $\>
661\>$x  y  ^4 p_t      $\\
662\>$x  y  ^3 p_y^2    $\>663\>$x  y  ^3 p_yt     $\>
664\>$x  y  ^3 p_yp_t   $\>665\>$x  y  ^3 t  ^2    $\>
666\>$x  y  ^3 t  p_t   $\\
667\>$x  y  ^3 p_t^2    $\>668\>$x  y  ^2 p_y^3    $\>
669\>$x  y  ^2 p_y^2 t  $\>670\>$x  y  ^2 p_y^2 p_t$\>
671\>$x  y  ^2 p_yt  ^2 $\\
672\>$x  y  ^2 p_yt  p_t$\>673\>$x  y  ^2 p_yp_t^2 $\>
674\>$x  y  ^2 t  ^3    $\>675\>$x  y  ^2 t  ^2 p_t$\>
676\>$x  y  ^2 t  p_t^2 $\\
677\>$x  y  ^2 p_t^3    $\>678\>$x  y  p_y^4       $\>
679\>$x  y  p_y^3 t     $\>680\>$x  y  p_y^3 p_t   $\>
681\>$x  y  p_y^2 t  ^2 $\\
682\>$x  y  p_y^2 t  p_t$\>683\>$x  y  p_y^2 p_t^2 $\>
684\>$x  y  p_yt  ^3    $\>685\>$x  y  p_yt  ^2 p_t$\>
686\>$x  y  p_yt  p_t^2 $\\
687\>$x  y  p_yp_t^3    $\>688\>$x  y  t  ^4       $\>
689\>$x  y  t  ^3 p_t   $\>690\>$x  y  t  ^2 p_t^2 $\>
691\>$x  y  t  p_t^3    $\\
692\>$x  y  p_t^4       $\>693\>$x  p_y^5          $\>
694\>$x  p_y^4 t        $\>695\>$x  p_y^4 p_t      $\>
696\>$x  p_y^3 t  ^2    $\\
697\>$x  p_y^3 t  p_t   $\>698\>$x  p_y^3 p_t^2    $\>
699\>$x  p_y^2 t  ^3    $\>700\>$x  p_y^2 t  ^2 p_t$\>
701\>$x  p_y^2 t  p_t^2 $\\
702\>$x  p_y^2 p_t^3    $\>703\>$x  p_yt  ^4       $\>
704\>$x  p_yt  ^3 p_t   $\>705\>$x  p_yt  ^2 p_t^2 $\>
706\>$x  p_yt  p_t^3    $\\
707\>$x  p_yp_t^4       $\>708\>$x  t  ^5          $\>
709\>$x  t  ^4 p_t      $\>710\>$x  t  ^3 p_t^2    $\>
711\>$x  t  ^2 p_t^3    $\\
712\>$x  t  p_t^4       $\>713\>$x  p_t^5          $\>
714\>$p_x^6             $\>715\>$p_x^5 y           $\>
716\>$p_x^5 p_y         $\\
717\>$p_x^5 t           $\>718\>$p_x^5 p_t         $\>
719\>$p_x^4 y  ^2       $\>720\>$p_x^4 y  p_y      $\>
721\>$p_x^4 y  t        $\\
722\>$p_x^4 y  p_t      $\>723\>$p_x^4 p_y^2       $\>
724\>$p_x^4 p_yt        $\>725\>$p_x^4 p_yp_t      $\>
726\>$p_x^4 t  ^2       $\\
727\>$p_x^4 t  p_t      $\>728\>$p_x^4 p_t^2       $\>
729\>$p_x^3 y  ^3       $\>730\>$p_x^3 y  ^2 p_y   $\>
731\>$p_x^3 y  ^2 t     $\\
732\>$p_x^3 y  ^2 p_t   $\>733\>$p_x^3 y  p_y^2    $\>
734\>$p_x^3 y  p_yt     $\>735\>$p_x^3 y  p_yp_t   $\>
736\>$p_x^3 y  t  ^2    $\\
737\>$p_x^3 y  t  p_t   $\>738\>$p_x^3 y  p_t^2    $\>
739\>$p_x^3 p_y^3       $\>740\>$p_x^3 p_y^2 t     $\>
741\>$p_x^3 p_y^2 p_t   $\\
742\>$p_x^3 p_yt  ^2    $\>743\>$p_x^3 p_yt  p_t   $\>
744\>$p_x^3 p_yp_t^2    $\>745\>$p_x^3 t  ^3       $\>
746\>$p_x^3 t  ^2 p_t   $\\
747\>$p_x^3 t  p_t^2    $\>748\>$p_x^3 p_t^3       $\>
749\>$p_x^2 y  ^4       $\>750\>$p_x^2 y  ^3 p_y   $\>
751\>$p_x^2 y  ^3 t     $\\
752\>$p_x^2 y  ^3 p_t   $\>753\>$p_x^2 y  ^2 p_y^2 $\>
754\>$p_x^2 y  ^2 p_yt  $\>755\>$p_x^2 y  ^2 p_yp_t$\>
756\>$p_x^2 y  ^2 t  ^2 $\\
757\>$p_x^2 y  ^2 t  p_t$\>758\>$p_x^2 y  ^2 p_t^2 $\>
759\>$p_x^2 y  p_y^3    $\>760\>$p_x^2 y  p_y^2 t  $\>
761\>$p_x^2 y  p_y^2 p_t$\\
762\>$p_x^2 y  p_yt  ^2 $\>763\>$p_x^2 y  p_yt  p_t$\>
764\>$p_x^2 y  p_yp_t^2 $\>765\>$p_x^2 y  t  ^3    $\>
766\>$p_x^2 y  t  ^2 p_t$\\
767\>$p_x^2 y  t  p_t^2 $\>768\>$p_x^2 y  p_t^3    $\>
769\>$p_x^2 p_y^4       $\>770\>$p_x^2 p_y^3 t     $\>
771\>$p_x^2 p_y^3 p_t   $\\
772\>$p_x^2 p_y^2 t  ^2 $\>773\>$p_x^2 p_y^2 t  p_t$\>
774\>$p_x^2 p_y^2 p_t^2 $\>775\>$p_x^2 p_yt  ^3    $\>
776\>$p_x^2 p_yt  ^2 p_t$\\
777\>$p_x^2 p_yt  p_t^2 $\>778\>$p_x^2 p_yp_t^3    $\>
779\>$p_x^2 t  ^4       $\>780\>$p_x^2 t  ^3 p_t   $\>
781\>$p_x^2 t  ^2 p_t^2 $\\
782\>$p_x^2 t  p_t^3    $\>783\>$p_x^2 p_t^4       $\>
784\>$p_xy  ^5          $\>785\>$p_xy  ^4 p_y      $\>
786\>$p_xy  ^4 t        $\\
787\>$p_xy  ^4 p_t      $\>788\>$p_xy  ^3 p_y^2    $\>
789\>$p_xy  ^3 p_yt     $\>790\>$p_xy  ^3 p_yp_t   $\>
791\>$p_xy  ^3 t  ^2    $\\
792\>$p_xy  ^3 t  p_t   $\>793\>$p_xy  ^3 p_t^2    $\>
794\>$p_xy  ^2 p_y^3    $\>795\>$p_xy  ^2 p_y^2 t  $\>
796\>$p_xy  ^2 p_y^2 p_t$\\
797\>$p_xy  ^2 p_yt  ^2 $\>798\>$p_xy  ^2 p_yt  p_t$\>
799\>$p_xy  ^2 p_yp_t^2 $\>800\>$p_xy  ^2 t  ^3    $\>
801\>$p_xy  ^2 t  ^2 p_t$\\
802\>$p_xy  ^2 t  p_t^2 $\>803\>$p_xy  ^2 p_t^3    $\>
804\>$p_xy  p_y^4       $\>805\>$p_xy  p_y^3 t     $\>
806\>$p_xy  p_y^3 p_t   $\\
807\>$p_xy  p_y^2 t  ^2 $\>808\>$p_xy  p_y^2 t  p_t$\>
809\>$p_xy  p_y^2 p_t^2 $\>810\>$p_xy  p_yt  ^3    $\>
811\>$p_xy  p_yt  ^2 p_t$\\
812\>$p_xy  p_yt  p_t^2 $\>813\>$p_xy  p_yp_t^3    $\>
814\>$p_xy  t  ^4       $\>815\>$p_xy  t  ^3 p_t   $\>
816\>$p_xy  t  ^2 p_t^2 $\\
817\>$p_xy  t  p_t^3    $\>818\>$p_xy  p_t^4       $\>
819\>$p_xp_y^5          $\>820\>$p_xp_y^4 t        $\>
821\>$p_xp_y^4 p_t      $\\
822\>$p_xp_y^3 t  ^2    $\>823\>$p_xp_y^3 t  p_t   $\>
824\>$p_xp_y^3 p_t^2    $\>825\>$p_xp_y^2 t  ^3    $\>
826\>$p_xp_y^2 t  ^2 p_t$\\
827\>$p_xp_y^2 t  p_t^2 $\>828\>$p_xp_y^2 p_t^3    $\>
829\>$p_xp_yt  ^4       $\>830\>$p_xp_yt  ^3 p_t   $\>
831\>$p_xp_yt  ^2 p_t^2 $\\
832\>$p_xp_yt  p_t^3    $\>833\>$p_xp_yp_t^4       $\>
834\>$p_xt  ^5          $\>835\>$p_xt  ^4 p_t      $\>
836\>$p_xt  ^3 p_t^2    $\\
837\>$p_xt  ^2 p_t^3    $\>838\>$p_xt  p_t^4       $\>
839\>$p_xp_t^5          $\>840\>$y  ^6             $\>
841\>$y  ^5 p_y         $\\
842\>$y  ^5 t           $\>843\>$y  ^5 p_t         $\>
844\>$y  ^4 p_y^2       $\>845\>$y  ^4 p_yt        $\>
846\>$y  ^4 p_yp_t      $\\
847\>$y  ^4 t  ^2       $\>848\>$y  ^4 t  p_t      $\>
849\>$y  ^4 p_t^2       $\>850\>$y  ^3 p_y^3       $\>
851\>$y  ^3 p_y^2 t     $\\
852\>$y  ^3 p_y^2 p_t   $\>853\>$y  ^3 p_yt  ^2    $\>
854\>$y  ^3 p_yt  p_t   $\>855\>$y  ^3 p_yp_t^2    $\>
856\>$y  ^3 t  ^3       $\\
857\>$y  ^3 t  ^2 p_t   $\>858\>$y  ^3 t  p_t^2    $\>
859\>$y  ^3 p_t^3       $\>860\>$y  ^2 p_y^4       $\>
861\>$y  ^2 p_y^3 t     $\\
862\>$y  ^2 p_y^3 p_t   $\>863\>$y  ^2 p_y^2 t  ^2 $\>
864\>$y  ^2 p_y^2 t  p_t$\>865\>$y  ^2 p_y^2 p_t^2 $\>
866\>$y  ^2 p_yt  ^3    $\\
867\>$y  ^2 p_yt  ^2 p_t$\>868\>$y  ^2 p_yt  p_t^2 $\>
869\>$y  ^2 p_yp_t^3    $\>870\>$y  ^2 t  ^4       $\>
871\>$y  ^2 t  ^3 p_t   $\\
872\>$y  ^2 t  ^2 p_t^2 $\>873\>$y  ^2 t  p_t^3    $\>
874\>$y  ^2 p_t^4       $\>875\>$y  p_y^5          $\>
876\>$y  p_y^4 t        $\\
877\>$y  p_y^4 p_t      $\>878\>$y  p_y^3 t  ^2    $\>
879\>$y  p_y^3 t  p_t   $\>880\>$y  p_y^3 p_t^2    $\>
881\>$y  p_y^2 t  ^3    $\\
882\>$y  p_y^2 t  ^2 p_t$\>883\>$y  p_y^2 t  p_t^2 $\>
884\>$y  p_y^2 p_t^3    $\>885\>$y  p_yt  ^4       $\>
886\>$y  p_yt  ^3 p_t   $\\
887\>$y  p_yt  ^2 p_t^2 $\>888\>$y  p_yt  p_t^3    $\>
889\>$y  p_yp_t^4       $\>890\>$y  t  ^5          $\>
891\>$y  t  ^4 p_t      $\\
892\>$y  t  ^3 p_t^2    $\>893\>$y  t  ^2 p_t^3    $\>
894\>$y  t  p_t^4       $\>895\>$y  p_t^5          $\>
896\>$p_y^6             $\\
897\>$p_y^5 t           $\>898\>$p_y^5 p_t         $\>
899\>$p_y^4 t  ^2       $\>900\>$p_y^4 t  p_t      $\>
901\>$p_y^4 p_t^2       $\\
902\>$p_y^3 t  ^3       $\>903\>$p_y^3 t  ^2 p_t   $\>
904\>$p_y^3 t  p_t^2    $\>905\>$p_y^3 p_t^3       $\>
906\>$p_y^2 t  ^4       $\\
907\>$p_y^2 t  ^3 p_t   $\>908\>$p_y^2 t  ^2 p_t^2 $\>
909\>$p_y^2 t  p_t^3    $\>910\>$p_y^2 p_t^4       $\>
911\>$p_yt  ^5          $\\
912\>$p_yt  ^4 p_t      $\>913\>$p_yt  ^3 p_t^2    $\>
914\>$p_yt  ^2 p_t^3    $\>915\>$p_yt  p_t^4       $\>
916\>$p_yp_t^5          $\\
917\>$t  ^6             $\>918\>$t  ^5 p_t         $\>
919\>$t  ^4 p_t^2       $\>920\>$t  ^3 p_t^3       $\>
921\>$t  ^2 p_t^4       $\\
922\>$t  p_t^5          $\>923\>$p_t^6             $
\end{tabbing}

%==============================================================================

\begin{thebibliography}{99}

\bibitem{SLAC75}
K.~L.~Brown,
{\it A First- and Second-Order Matrix Theory for the Design of Beam Transport
Systems and Charged Particle Spectrometers}.
SLAC-75, Revision 3, 1972.

\bibitem{TPT}
K.~L.~Brown, D.~C.~Carey, Ch.~Iselin,and  F.~Rothacker,
{\it TRANSPORT --- A Computer Program for Designing Charged
  Particle Beam Transport Systems}.
CERN 73-16, revised as CERN 80-4, CERN, 1980.
 
\bibitem{ZEBRA} 
R.~Brun, J.~Zoll,
{\it ZEBRA User Guide},
CERN Program Library Q100.

\bibitem{CERNLIB}
CERN Program Library, Collection of Short Writeups.
Available from the CERN Program Library.

\bibitem{CHAO}
A. Chao.
Evaluation of beam distribution parameters in an electron storage ring.
{\it Journal of Applied Physics}, 50:595--598, 1979.
 
\bibitem{TFS}
Ph. Defert, Ph. Hofmann, and R. Keyser.
{\it The Table File System, the C Interfaces}.
LAW Note 9, CERN, 1989.

\bibitem{DONALD}
M.~Donald and D.~Schofield.
{\it A User's Guide to the HARMON Program}.
LEP Note 420, CERN, 1982.

\bibitem{DRAGT}
A. Dragt.
{\it Lectures on Nonlinear Orbit Dynamics, 1981 Summer School on High
  Energy Particle Accelerators, Fermi National Accelerator Laboratory,
  July 1981}.
American Institute of Physics, 1982.

\bibitem{GIORG}
Giorgelli, {\it Comp. Phys. Comm.}, {\bf 16}, (1979), pg. 331.
 
\bibitem{GKS}
{\sl The Graphical Kernel System (GKS)}.
ISO, Geneva, July 1985.
International Standard ISO 7942.
 
\bibitem{GXPLOT}
H. Grote.
{\sl GXPLOT User's Guide and Reference Manual}.
LEP TH Note 57, CERN, 1988.

\bibitem{MAD}
H.~Grote, F.~C.~Iselin,
{\it The MAD Program (Methodical Accelerator Design) Version 8.10,
User's Reference Manual},
CERN/SL/90-13 (AP), Rev. 3.

\bibitem{EPIO}
H.~Grote, I.~McLaren,
{EP~Standard Format Input/Output Package},
CERN Program Library Long Write-Up I101.

\bibitem{PHYS}
H.~Grote, F.~C.~Iselin,
{\it The MAD Program (Methodical Accelerator Design) Version 8.10,
Physicist's Reference Manual},
to be published.

\bibitem{LIE}
F.~Ch.~Iselin,
{\it Lie Transformations and Transport Equations for Combined-Function
Dipoles},
Particle Accelerators, 1985, {\bf 17}, 143-155.

\bibitem{JAMES}
F.~James,
{\it MINUIT long write-up}. CERN Program Library D506.

\bibitem{TENG}
L.~C. Teng,
{\it Concerning n-Dimensional Coupled Motion}.
FN 229, FNAL, 1971.

\end{thebibliography}

\printindex

\end{document}
\end
