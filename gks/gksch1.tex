%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                 %
%   GKS User Guide -- LaTeX Source                                %
%                                                                 %
%   Chapter 1                                                     %
%                                                                 %
%   The following external EPS files are referenced:              %
%         hbbatch.eps, hbookc11.eps                               %
%                                                                 %
%   Editor: Michel Goossens / CN-AS                               %
%   Last Mod.: 14 July 1992 12:30 mg                              %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\chapter{\protect\label{sec:intro}Introduction}
 
As a matter of policy, a recommendation was made by HEPCCC to base
future HEP computer graphics applications on the ISO standard
Graphical Kernel System,
GKS \cite{bib-gks2d} and GKS-3D \cite{bib-gks3d}.
GKS had been in use already at CERN for 2D applications, but the decision
to use GKS also for 3D work led to a new tender operation
being carried out
in 1986. This resulted in the firm GTS-GRAL, of Darmstadt,
being selected to provide new implementations of both GKS and GKS-3D
(called {\it GKSGRAL} and {\it GKSGRAL-3D}).
These have been installed on all the major CERN
operating systems (VM/CMS, UNICOS, VMS, AEGIS and UNIX) and
the contract with GTS-GRAL includes
provision for institutes affiliated to CERN to obtain a licence for the
use of the software at very favourable rates.
 
GKSGRAL drivers are available for a large range of graphics terminals.
Users should be aware of the implications in testing and maintenance
work which has to be carried out on the very large number of
operating-system/driver combinations.
\section{What is GKS (the Graphical Kernel System)}
The Graphical Kernel System (GKS) \cite{bib-gks2d} is a document produced
by the International Standards Organization (ISO) which defines a common
interface to interactive computer graphics for application programs.
GKS has been designed by a group of experts representing the national
standards institutions of most major industrialized countries.
The full standard provides functional specifications for some
200 subroutines which perform graphics input and output
in a device independent way.
Application programs can thus move freely between different graphics
devices and different host computers.
For the first time graphics programs have become genuinely portable.
 
However, one should point out that GKS itself is not portable.
Individual GKS implementations will vary substantially as they have to
support different graphics devices on different computers.
Moreover, GKS is a {\it kernel} system, and thus does not include
an arbitrary collection of functions to produce histograms or
contour plots, etc. Such facilities are regarded as applications
which sit on top of the basic graphics package and, at CERN,
they are provided by the Graphical Extensions to the NAG Library
\cite{bib-nagref}, or the HPLOT package \cite{bib-HPLOT}.
 
In order to allow particular applications to choose a graphics package
with the appropriate capability, GKS has been defined to have
different {\it levels}. The level structure has two dimensions,
one for output (0, 1, or 2) and one for input (a, b, or c).
Higher levels include the capabilities of lower levels.
In the United States, ANSI has defined also a level 'm', for very simple
applications, which sits below output level '0'.
Most implementations provide all output (level '2') and intermediate
input (level 'b'). The reason input level 'c' is not usually supported
is that it requires asynchronous input facilities not found in all
operating systems.
 
\index{FORTRAN binding}
The GKS functions have been defined independently from a specific
programming language, and {\it bindings} to individual languages are
subject to separate standards efforts which have been undertaken
for all the major languages.
The FORTRAN binding is defined by \cite{bib-gksftn}.
 
The Graphical Kernel System for two dimensional graphics was
adopted as an ISO standard in 1985, and since that date work has been
in progress to define a three dimensional super-set \cite{bib-gks3d}
which was accepted as an International Standard during 1988.
The FORTRAN binding to GKS-3D has also been published as a
Draft International Standard \cite{bib-gksftn3}.
 
The GKS functions are separated into those which pass values to GKS for
control, setting or output, and those which inquire about
status information. There are 8 distinct classes:
 
\begin{center}
\begin{tabular}{ll}
1. Control functions&5. Transformations\\
2. Output Attributes&6. Input functions\\
3. Output Primitives&7. Metafile functions\\
4. Segment functions&8. Inquiry functions\\
\end{tabular}
\end{center}
 
\begin{note}
 
{\bf Throughout this document many values are specified using}
{\bf GKS Enumerated Types}. The symbolic names for these all
begin with 'G' and are enclosed in single quotes within the text.
(But do {\bf not} include the quotes in FORTRAN calls!)
They have been coded into an {\it Include File},
called ENUM.INC, which is listed in Appendix on Page~\pageref{sec:hdenum}.
\end{note}
\section{Major Differences to Earlier Graphics Interfaces}
 
In some respects GKS is a major departure from earlier software
interfaces to graphics display systems, and several new concepts have
been introduced. The following is a brief list of the new features,
which will be more fully described within the body of the document.
\begin{OL}
\index{current point}
\item GKS has no concept of a {\it current point}. This idea dates
from when most graphics devices were pen plotters, in which case the
current point corresponded clearly to the position of the pen.
However, it would be less obvious where one would define the current
point when drawing a filled polygon on a raster display.
Thus, all GKS primitives which require
a starting point specify that point in the function call.
\item In most cases earlier software interfaces could only control a single
device at a time, and if some means was provided to 'capture' the graphics
output for storage, then this was handled in a special way.
GKS simplifies this situation considerably by defining
{\it Workstations}, which correspond to 'virtual devices'.
GKS maps each workstation onto a real piece of hardware, but to the
application programmer they are all handled in the same way, and
several workstations can be active simultaneously.
There is a workstation which writes the output it receives onto a
{\it Metafile} for storage and/or transmission over a network
and this, also, is handled just like any other workstation.
\item GKS incorporates the concept of a {\it Logical Device} to
control input. There are six classes of Logical Input Devices, and these
are mapped onto the actual physical devices in use, without the application
programmer having to write special code if, for example, (s)he is using
a mouse instead of a tablet. This helps to make application code much
more portable. The following logical devices are of particular interest:
 \begin{OL}
\item The Logical {\it Locator} Device, which returns the locator position
{\it in the user's coordinate system}, not that of the physical device.
\item The Logical {\it Pick} Device, which tells the application
at which object the user is pointing, without having to provide the code to
work it out.
\item The Logical {\it Choice} Device, which allows the user to
choose one option out of a set.
 \end{OL}
\item GKS provides a mechanism to group the graphics output commands into
{\it Segments}, where they may be stored for later use.
Thus, an image stored in a segment could be made invisible and then visible
again without the application having to re-draw it.
Information sent to a workstation to produce an image which is not
stored is called {\it non-retained data}.
\item Finally, GKS provides a whole host of functions allowing the application
to {\it inquire} at run-time the state and/or capabilities of a
workstation or the implementation of GKS itself.
This is a very important feature for allowing code to be written in a
portable way, and still to make the best possible use of the environment in
which it is running.
\end{OL}
\section{\protect\label{sec:metint}Computer Graphics Metafiles (GKSM and CGM)}
 
A graphics metafile is a computer file containing a set of data records
describing a graphical image. It may be used for
\begin{OL}
\item Transporting graphical information between different types of computers.
\item Transporting graphical information from one site to another.
(by magnetic tape for example)
\item Transporting graphical information from one application to another.
\item Device spooling, e.g. for a plotter.
\end{OL}
\index{Appendix E metafile}
 
As yet there is no official ISO standard for writing a GKS Metafile (GKSM).
However, the ISO GKS Functional Description assumes the existence of one and,
in Appendix E of the document, a metafile format is described
and its use is recommended.
A GKS metafile created using this format is known as an Appendix E metafile.
Unfortunately, not all implementations follow the Appendix E format,
and so GKSM metafiles created by different GKS packages may be incompatible.
In fact, even different examples of Appendix E metafiles may be
incompatible due to variations in the file record structures, etc.
 
\index{Appendix E metafile!Computer Graphics Metafile}
\index{Appendix E metafile!CGM}
The Computer Graphics Metafile (CGM) has been produced by a separate
standards group within ISO and, when implementations become available,
it will be an alternative to the Appendix E metafile for the storage
and transmission of complete pictures.
One should note that because CGM is an independent standard
compatible with GKS, it is expected to become adopted as the
picture interchange format used between all graphics standards.
\section{The Computer Graphics Virtual Device Interface (CGI)}
\index{logical workstations}
 
One of the new features introduced by GKS was the concept of a
{\it Logical Workstation}.
This provides an interface layer within the graphics package below
which are situated a set of workstation drivers.
The workstations simulate in software any features which are not provided
by a particular display, and so simplify the problem of driving
new devices. To the applications programmer all workstations
have (more-or-less) similar capabilities, although their response
time will clearly be faster if these capabilities are built into the hardware,
rather than emulated. However, GKS defines only the interface as
seen by the application, and not the internal workstation interface.
This means that it is not possible to move workstation drivers
from one implementation of GKS to another.
 
There are difficulties in defining this interface because, if the
level is too high, then most workstation drivers must incorporate
a great deal of code. If on the other hand the level is too low,
then the software will not be able to make use of advanced features
in high-performance display systems.
There is thus is a trade-off to be made, which is currently
decided upon by the designers of each graphics package.
The goal of the CGI \cite{bib-cgiref} is to standardize this interface.
However, it is proving to be a lengthy business,
because there are difficulties to persuade all the
parties involved to compromise.
 
It should be mentioned that one of the goals of CGI is to allow
the functionality of the graphics system to be split between multiple
CPUs. For example, the features defined by the CGI could either be
built into a graphics terminal, or programmed into a Personal Workstation.
This type of functionality has become loosely termed
{\it Networked Graphics}.
\index{networked graphics}
\index{X-Window}
In this realm CGI may be overtaken by events, because a networked graphics
system called {\it X-Window} is fast becoming a 'de facto' standard.
X-Window comes from MIT, and is an outcome of the Athena Project
financed by DEC and IBM.
\section{Overview of Basic Facilities available at CERN}
 
\index{MGKS}
\index{PLOT10/GKS}
The following graphics services and facilities are supported at CERN
and will be described in more detail within this manual.
Note that PLOT10/GKS and MGKS are no longer supported.
\subsection{GKSGRAL}
\index{GKSGRAL}
\index{GKSGRAL-3D}
 
Both GKS (2D) and GKS-3D libraries from GTS-GRAL ({\it GKSGRAL} and
{\it GKSGRAL-3D}) are available for general use
on IBM VM/CMS, VAX VMS, CRAY UNICOS, APOLLO AEGIS, and UNIX.
However, in the case of UNIX, compiled libraries are only available from CERN
for those machines on which they may be produced.
 
As of March, 1990, the PROduction GKSGRAL version
is 7.4/3.2, and the GKSGRAL-3D version is 2.0.
\subsection{Include Files}
\index{include files!gtsdev}
\index{include files!enum}
 
To aid program writing two {\it INCLUDE FILES} are available:
\begin{DLtt}{123456}
\item[GTSDEV]This file contains a set of parameters
defining the GKS Workstation Types available on GKSGRAL.
\item[ENUM]This file contains a set of parameters
defining the GKS Enumeration Types. {\bf It is highly recommended}
that these are used in preference to directly coding in collections of
integers, the meaning of which is immediately forgotten.
\end{DLtt}
 
Although the use of include files is not standard FORTRAN-77,
this facility is supported by the compilers on all the major CERN systems.
To produce standard FORTRAN code the text of the include file must be inserted
into the application program.
\subsection{GKS Metafile Display and Editing}
\index{GRVIEW}
\index{GRVIEW}
\index{GKSTV}
\index{GKSED}
\index{metafiles}
\index{editor}
 
GKS Appendix E metafiles may be interpreted on display screens
using the interactive command {\bf GRVIEW}, which is available on
IBM, VAX and APOLLO systems. GRVIEW also allows metafiles to be edited,
and combines features from the old commands GKSTV and GKSED, which
it replaces.
\subsection{Hardcopy and Conversion Facilities}
 
\index{metafiles}
\index{hardcopy}
\index{conversion}
\index{postscript}
\index{GRPLOT}
\index{GRCONV}
\index{GKSVT}
\index{GKSCP}
\index{GKSX87}
\index{GKS3812}
\index{GKSSGML}
\index{VERSATEC}
\index{XEROX}
\index{IBM3812}
GKS Appendix E metafiles may be interpreted onto a range of hardcopy
devices using the command {\bf GRPLOT}, or converted to
another format using {\bf GRCONV}. These two commands have replaced
the old utilities GKSVT, GKSCP, GKSX87, GKS3812, and GKSSGML.
 
GRCONV runs locally to convert a GKS Appendix~E metafile into a PostScript
file or a file of Tektronix 4014 escape sequences. The command also may
be used to convert a metafile into IBM~3812 format for inclusion
in documents produced by SGML.
GRPLOT plots a metafile on a device specified by a parameter.
Supported devices include the computer centre monochrome and colour
Versatec plotters, the Xerox 4050s, and the IBM~3812s.
 
Apart from Appendix~E metafiles, it is possible to produce PostScript
or Tektronix 4014 output files, either directly from GKS, via GRVIEW,
or via GRCONV.
PostScript files may be printed on any local PostScript printer,
although they are less versatile than a metafile and may not be edited or
plotted on any other type of hardcopy device. Various laser printers
accept files of Tektronix 4014 escape codes as input.
\subsection{Mainframe Graphics using PCs}
\index{PCs}
\index{Emulators}
\index{TeemTalk}
 
After evaluation of several graphics emulators, the TeemTalk package
from Pericom has been selected as being suitable to allow IBM compatible
PCs to be used as graphics terminals. TeemTalk emulates Tektronix
4107/4207 colour terminals which are supported by GKS on all CERN
time-sharing systems, and it is possible for CERN to order licences at
very favorable rates.
\Lit{$==>$} ??? Those people who would like to obtain a licence should contact
R.~Cailliau or F.~Ovett of AS-MI.
\subsection{Documentation}
\index{documentation}
 
Apart from this {\bf GKS/GKS-3D at CERN}, there exists
\Lit{$==>$} To complete ...
the {\bf GRVIEW, GRCONV and GRPLOT; Metafile Utility User's Guide}
\cite{bib-grref}, + ...,
all of which are available from the UCO.
Copies of the {\bf GKSGRAL Reference Manual} \cite{bib-gtsref} and the
{\bf GKSGRAL-3D Reference Manual} \cite{bib-gtsref3} may be borrowed
from the Computer Science Library, purchased from GTS-GRAL,
or purchased from CERN under an agreement with GTS-GRAL
(see Appendix on Page~\pageref{sec:gtsdist} for details).
{\bf Note that the GKSGRAL manuals are covered by copyright.}
 
\index{HELP}
\index{FIND}
On-Line help files are available using the {\bf FIND~xxx} command on
IBM, the {\bf HELP~xxx} command on VMS,
and via the command {\bf HELP~CERN~xxx} on APOLLO.
Keywords (xxx) are:
GRAPHICS, GKS, GRPLOT, GRCONV, GRVIEW, and GKSPACK.
\subsection{The User Consultancy Office (UCO)}
\index{UCO}
\index{User Consultancy Office}
 
General graphics inquiries should be directed to the User Consultancy Office
on the ground floor of Building~513 (Tel:~4952,
Electronic Mail: \Lit{UCO@CERNVM.CERN.CH}.
\chapter{\protect\label{sec:gkspr}GKS Primer}
\section{Workstations}
\index{workstation}
\subsection{Definition}
 
GKS defines the concept of an abstract {\it graphical workstation}
which provide the logical interface through which the application
program controls the physical devices.
A workstation can have one {\it display surface} and/or a collection
of {\it logical input devices}.
Thus, a particular interactive workstation may
belong to one of three classes: Output-Only, Input-Only,
or Input-Output. (There are a further two classes of
workstation: Metafile-Input and Metafile-Output.)
GKS allows several workstations to be open simultaneously,
for example, one for an interactive graphics terminal
and one for a metafile or hardcopy device.
The actual maximum number of simultaneously open workstations is
installation dependent; in the GTS-GRAL implementation it is set to 15.
 
GKS allows the appearance of output primitives to vary between
workstations in order to take advantage of their differing
capabilities. However, it is possible to inquire at run-time what
the actual capabilities are, and to design one's code appropriately.
The inquiry functions are too numerous to list in this Primer,
and the reader is referred to one of the texts in the bibliography.
 
\subsection{Opening and Closing GKS}
 
Before any workstation is {\it opened} or {\it activated},
GKS itself must be {\it opened}.
This must be the first call in any GKS program
as it performs the initialization.
The last call should be to {\it close} (exit from) GKS.
\index{GKS routine!{\protect\tt GOPKS}}
\index{GKS routine!{\protect\tt GCLKS}}
\index{error file}
\begin{XMP}
CALL GOPKS(ERRFIL, BUF)
  .......
CALL GCLKS
\end{XMP}
ERRFIL defines the FORTRAN logical unit number to which all error
messages will be sent. BUF is the amount of memory space to be
used. (This parameter is ignored by the GKSGRAL and GKSGRAL-3D implementations.)
\subsection{Opening and Closing a Workstation}
 
\index{workstation!opening/closing}
\index{workstation!identifier}
Each workstation is identified in the application program by a
unique number, the {\it workstation identifier}. This number is used
in routines which communicate with the device, i.e. when output is to be
sent to it, or when it is to be cleared, etc. In order
to establish a connection between the application program and
a workstation, the workstation has to be {\it opened}.
When the workstation is {\it closed},
the connection is released, segments stored in Workstation Dependent
Segment Storage are lost, and no further interactions are possible.
\index{GKS routine!{\protect\tt GOPWK}}
\index{GKS routine!{\protect\tt GCLWK}}
\index{connection identifier}
\index{workstation!connection identifier}
\index{workstation!type}
The calls to open and close a workstation are:
\begin{XMP}
CALL GOPWK(WKID, CONID, WTYPE)
   and
CALL GCLWK(WKID)
\end{XMP}
 
The workstation identifier WKID is a positive integer which the
application chooses, and is typically a number like 1,2,3...
The integer CONID is the Connection Identifier which connects the
workstation to an I/O channel. It is usually a FORTRAN logical unit
number, but depends on the workstation and the host computer being used.
Thus, the value of conid must be obtained from the
workstation-dependent documentation.
 
The {\it Workstation Type} (WTYPE) is an integer which specifies
which type of workstation should be opened,
e.g. a Tektronix 4014 or a Versatec plotter.
Workstation Types are implementation dependent.
A list of workstation identifiers in use at CERN will be found in the
appendix.
\subsection{Activating and Deactivating a Workstation}
\index{workstation!activation}
 
When primitives and attributes are output they are sent to all
{\it open} and {\it active} workstations.
When a workstation is {\it deactivated} no further
output is sent to it. At the end of the application program all open
workstations must be deactivated and closed before GKS itself can be closed.
\index{GKS routine!{\protect\tt GACWK}}
\index{GKS routine!{\protect\tt GDAWK}}
To activate or deactivate the workstation the calls are:
\begin{XMP}
CALL GACWK(WKID)
 
CALL GDAWK(WKID)
\end{XMP}
Note that Input-Only and Metafile-Input workstations may not be activated.
\subsection{Clearing the Workstation}
 
\index{workstation!update}
The application has control over clearing the display
surface at any time by calling:
\index{GKS routine!{\protect\tt GCLRWK}}
\begin{XMP}
CALL GCLRWK(WKID, COFL)
\end{XMP}
The integer COFL controls the way in which the update happens.
If COFL is set to 'GALWAY' (see note at bottom of page 1),
then the workstation is cleared even if there was no previous output.
If COFL is set to 'GCONDI', then the drawing surface is cleared only
if there has been previous output.
Clearing the workstation deletes all WDSS segments stored on that
workstation (segments are described in Chapter on Page~\pageref{sec:seghdr}),
and on a hardcopy device the paper is advanced.
For metafile interpretation by the CERN utilities this
function is used to indicate 'end of picture'.
 
Note that the workstation is cleared automatically when
it is opened. Some implementations also clear the workstation when it is
closed, but this is not mandated in the standard.
\subsection{\protect\label{sec:defsta}Deferral States}
\index{deferral states}
 
GKS allows the programmer to {\it defer} sending output to a
workstation by calling the function Set Deferral State.
For example, it might be more efficient to send
primitives in batches, rather than one at a time.
Thus, 'As Soon As Possible' often may not be as {\it fast} as possible!
For most users of GKS the default values should be
acceptable (but note that these are device-dependent).
The call is:
\index{GKS routine!{\protect\tt GSDS}}
\begin{XMP}
CALL GSDS(WKID, DEFMOD, REGMOD)
\end{XMP}
 
The second argument, DEFMOD, controls when output should be sent to
the workstation specified by WKID, and can take the following values:
\begin{DLtt}{123456}
\item['GASAP']
send output As Soon As Possible
\item['GBNIG']
send output Before Next Interaction Globally. This makes sure
that the workstation is up-to-date before the next input action
on {\it any} open workstation
\item['GBNIL']
send output Before Next Interaction Locally. This makes sure
that the workstation is up-to-date before the next input action
on the workstation specified in the call
\item['GASTI']
At Some TIme allows GKS to choose some opportune moment to
bring the workstation up-to-date
\end{DLtt}
 
The third argument, REGMOD, controls what should happen on
those workstations which require the image on the display to be
regenerated in some circumstances.
For example, to delete a segment on a direct view storage tube display,
such as a TEKTRONIX 4014, would require the screen
to be cleared and then the remaining contents re-drawn.
\index{implicit regeneration}
This is called {\it implicit regeneration}.
REGMOD can take the following values:
\begin{DLtt}{123456}
\item['GSUPPD']
Re-drawing is suppressed until an update is forced by calling
the Update Workstation function, GUWK, or by re-drawing all the
segments with GRSGWK.
\item['GALLOW']
Immediate re-drawing is allowed.
\end{DLtt}
\subsection{Updating the Workstation}
 
Because of the deferral mode set, not all the output may yet have been sent
to the display. The routine
\index{workstation!update}
\index{GKS routine!{\protect\tt GUWK}}
\begin{XMP}
CALL GUWK(WKID, REGFL)
\end{XMP}
\index{non-retained data}
\index{implicit regeneration}
is provided to bring the contents of the workstation WKID up-to-date.
The argument REGFL can take the values 'GPOSTP' or 'GPERFO'.
If 'GPOSTP' is specified, then all deferred actions are performed
at some time.
If 'GPERFO' is specified, then all deferred actions are performed,
the workstation transformation is updated,
the display surface is cleared, and all segments are
re-drawn as necessary. If an implicit regeneration of the image
has to be performed then non-retained data (primitives not stored
in segments) will be lost.
 
Note that a call to GUWK will {\bf not} necessarily clear
the workstation and re-draw all segments from scratch.
However, this can be achieved by calling the function GRSGWK
(see section on Page~\pageref{sec:grsgwk}).
\subsection{Sending Messages/Prompts}
\index{messages}
\index{prompts}
 
In order to display messages and prompts on the display surface
the following routine is provided:
\index{GKS routine!{\protect\tt GMSG}}
\begin{XMP}
CALL GMSG(WKID, STR)
\end{XMP}
WKID specifies on which workstation the text string STR should appear.
Where and how the message is written out is both implementation
and workstation-dependent.
\section{\protect\label{sec:dprim}The Drawing Primitives}
\index{primitives!2D}
 
Drawing primitives are the basic elements of graphics output, such as
lines, text etc.
GKS supports the six output primitives which are described below:
{\it polyline, polymarker, fill area, text, cell array},
and the {\it generalised drawing primitive}.
Each primitive has a corresponding set of {\it attributes}
e.g. line type, colour index, character height, etc.
The appearance of an individual primitive is governed by the
attributes in force at the time when the primitive is passed to GKS,
and attribute setting will be described in the following chapter.
A number of example programs may be found in Appendix on Page~\pageref{sec:exmpref}
which illustrate the use of the following features.
\begin{figure}[h]
\caption{Examples of some GKS Primitives}
\label{fig:prims}
\end{figure}
\begin{note}
The Polyline, Polymarker, and Fill Area primitives are specified by an
array of points which may not be arbitrarily large, and the maximum
size of this array is implementation-dependent. The GKSGRAL
implementation at CERN restricts the number points in a Fill Area to
300. However, calls to Polyline or Polymarker can handle more points
than this by internally sub-dividing the array.
\end{note}
\subsection{Polyline}
\index{polyline}
 
This draws line segments between two or more points using the
currently set attributes for line style, polyline colour index and
line width scale factor. The call is:
\index{GKS routine!{\protect\tt GPL}}
\begin{XMP}
CALL GPL(N, PXA, PYA)
\end{XMP}
where N is the number of points, and PXA(N), PYA(N) are real
arrays containing the X and Y values of the points in the
application program's own coordinate system (called the
{\it World Coordinates System}).
\subsection{Polymarker}
\index{polymarker}
 
This marks a sequence of points with the marker symbol selected by the
currently set attributes for polymarker colour index, marker type and
marker size scale factor. The marker size to which the scale factor
is applied is workstation-dependent.
The call is:
\index{GKS routine!{\protect\tt GPM}}
\begin{XMP}
CALL GPM(N, PXA, PYA)
\end{XMP}
where N, PXA and PYA have the same meanings as for GPL.
 
\subsection{Text}
\index{text}
 
Text is displayed using the current attribute settings for text colour
index, text font and precision, character-up vector, text alignment,
character expansion factor, character spacing, text path and
character height. The call is:
\index{GKS routine!{\protect\tt GTX}}
\begin{XMP}
CALL GTX(PX, PY, STR)
\end{XMP}
where PX and PY are real numbers which define in World Coordinates the
starting position of the text string STR.
\subsection{Fill Area}
\index{fill area}
 
Fill Area draws an area which is specified by a polygon.
The interior of the polygon can be either not filled (hollow), filled
with a solid colour, or filled with various patterns.
The fill area style and colour is specified by the current setting of
the fill area colour index, fill area style and fill area style index
attributes. The call is:
\index{GKS routine!{\protect\tt GFA}}
\begin{XMP}
CALL GFA(N, PXA, PYA)
\end{XMP}
where N, PXA, PYA have the same meaning as for GPL and GPM.
If the first and last points are different, they are joined by a line.
\subsection{Cell Array}
\index{cell array}
 
The Cell Array is an array of rectangular cells with individual
colours. It serves for passing raster images to GKS.
Note that in general, colour values within the Cell Array do not
correspond to picture elements (pixels) on a hardware display,
and that all primitives, including Cell Arrays, are subject to
the usual GKS transformations.
The call is:
\index{GKS routine!{\protect\tt GCA}}
\begin{XMP}
CALL GCA(PX,PY,QX,QY,DIMX,DIMY,ISC,ISR,DX,DY,COLIA)
\end{XMP}
Neither the Cell Array primitive nor the function call arguments will be
described in detail in this Primer, and the reader is referred to the GKSGRAL
manual, or one of the texts in the bibliography, for more information.
\subsection{Generalised Drawing Primitive}
\index{generalised drawing primitive}
\index{GDP}
 
Although at present GKS defines only six types of graphics primitives,
the standard allows for these to be augmented within particular
implementations by using {\it Generalised Drawing Primitives} (GDPs).
Thus, the Generalised Drawing Primitive may be thought
of as a 'standard way to be non-standard', and in fact a mechanism
exists for implementors of GKS to register GDPs with the International
Standards Organization group responsible for GKS.
The intention is that these registered GDPs will be incorporated as new
primitives within future revisions of the standard.
However, note that the use of GDPs may make programs
{\bf non-portable to other GKS implementations}. On the other
hand, they do permit the GKS driver to make use of special hardware
features, circle drawing for example, if these features are available.
 
GKSGRAL supports 6 GDPs:
\index{circle GDP}
\index{arc GDP}
\index{ellipse GDP}
\index{Bezier curve GDP}
\index{cubic curve GDP}
\begin{OL}
\item Circle
\item Circular Arc
\item Ellipse
\item Elliptical Arc
\item Bezier Curve defined by Bezier Polygon
\item Cubic Curve defined by Interpolation Points
\end{OL}
The call is:
\index{GKS routine!{\protect\tt GGDP}}
\begin{XMP}
CALL GGDP(N, PXA, PYA, PRIMID, IDR, DATREC)
\end{XMP}
See the GKSGRAL Manual for more details.
\section{\protect\label{sec:attrbs}The Output Attributes}
\index{attributes}
 
Before actually outputting any primitives, the application will want to
specify the exact way in which the drawing appears on the display
surface. This {\it rendering} process is controlled
by {\it output attributes}.
Output primitives have geometric and non-geometric attributes.
Geometric attributes, such as the character height,
affect the size and shape of a primitive, whereas non-geometric
attributes are qualities such as colour, line style, etc.
 
Output attributes affect the appearance or rendering of primitives at the
moment when the primitives are sent to GKS, and attributes are said to be
{\it bound} to primitives at this time.
Thus, modification of an attribute has no effect on primitives which
have been output already.
GKS attributes are said to be {\it modal} in character because,
after setting an attribute, GKS is in a mode in which the value of that
attribute will be bound to all primitives of the appropriate type which
follow. Setting a different value for the attribute would then
change the mode.
\subsection{Attribute Bundles}
\index{bundled attributes}
\index{individual attributes}
\index{bundle index}
 
There are two ways of specifying attributes,
{\it Bundled} and {\it Individually}.
Attributes may be set individually by calling the appropriate routines
one at a time. As an example, for a polyline one could set the
line style, the line width, and the colour by calling the routines
GSLN, GSLWSC, and GPLCI, before calling GPL to output the polyline.
Setting attributes individually will ensure that
the primitives to which they are bound appear the same on all
workstations, assuming that the workstations have sufficient capability.
However, if attributes are set using bundles, then the results will
be workstation-dependent.
 
Bundled attributes are assigned by selecting a {\it bundle index}
for a particular type of primitive using the routines given in section
on Page~\pageref{sec:setbnd}. The bundle index points to an entry in the
appropriate workstation {\it bundle table}.
Hence, each workstation has a bundle table for every primitive type,
and each entry in a bundle table contains a pre-defined set of
attributes for that particular primitive.
For example, the first entry in the polyline bundle table may contain
the attributes {\it dotted} and {\it red}, the second may
contain {\it solid, double thickness} and {\it blue}, etc.
Note that attribute bundles do
{\bf not} contain geometric attributes.
Beginners are advised to ignore attribute bundles and to set each
attribute individually. However, read the next section on
Aspect Source Flags before trying out a program.
 
As an example of why one might make use of attribute bundles,
consider an application which sometimes uses a colour terminal and
sometimes a monochrome one.
By drawing polylines with, say, bundle table index 5, the actual
appearance of the polylines will depend on the contents of
polyline bundle 5 on the two workstations. Thus, the application
can arrange to distinguish the polylines by using a particular
colour on the colour terminal, and a particular dash pattern
on the monochrome terminal, without making changes to the body of the
code which draws the primitives.
 
By using attribute bundles to specify attributes, and assuming that
the primitives have been stored in segments
(segments are described in Chapter on Page~\pageref{sec:seghdr}),
the application can also change the appearance of primitives
{\it after} they have been output to a workstation by
re-defining the contents of the bundle table.
This effect can not be achieved if the
attributes are set individually without deleting and re-drawing
the primitives.
\subsubsection{Aspect Source Flags}
\index{ASFs}
\index{aspect source flags}
 
To control whether a primitive attribute should be set individually,
or using a bundle table index, each primitive has a set of attributes
called the {\it Aspect Source Flags} (ASFs);
one flag for each primitive attribute.
If the ASF for a particular attribute is set to 'GBUNDL',
then the primitive will be bound to the attributes in the bundle table
entry pointed to by the bundle index currently in force.
If the ASF for a particular attribute is set to 'GINDIV',
then the primitive will be bound to the current individual attribute values
for that type of primitive.
 
Unfortunately, the committee which designed GKS could not agree on
whether the default setting for the ASFs should be bundled or individual.
Thus, American implementations, such as PLOT10/GKS, tend to default
the ASFs to set attributes individually, whilst European implementations,
such as GKSGRAL, tend to default ASFs to bundled attributes.
In order to be safe, {\bf users of GKS are advised to set their own default
values for the ASFs} as soon as they open GKS.
This can be done by calling:
\index{GKS routine!{\protect\tt GSASF}}
\begin{XMP}
CALL GSASF(ASFLST)
\end{XMP}
where ASFLST is an array of 13 integers, one for each attribute,
which must be set to 'GBUNDL' or 'GINDIV'.
The bundle table index for each attribute is given in parentheses
in the attribute list below.
An example program which calls GSASF may be
found in Appendix on Page~\pageref{sec:expfa}.
\subsubsection{Defining Attribute Bundles}
 
It is possible to define the entries in the bundle tables by calling one
of the following routines:
\index{GKS routine!{\protect\tt GSPLR}}
\index{GKS routine!{\protect\tt GSPMR}}
\index{GKS routine!{\protect\tt GSTXR}}
\index{GKS routine!{\protect\tt GSFAR}}
\index{GKS routine!{\protect\tt GSPAR}}
 
Set {\bf polyline} representation:
\begin{XMP}
GSPLR(WKID, PLI, LN, LWSC, PLCI)
\end{XMP}
 
Set {\bf polymarker} representation
\begin{XMP}
GSPMR(WKID, PMI, MK, MKSC, PMCI)
\end{XMP}
 
Set {\bf text} representation
\begin{XMP}
GSTXR(WKID, TXI, TXF, TXP, CHXP, CHSP, TXCI)
\end{XMP}
 
Set {\bf fill area} representation
\begin{XMP}
GSFAR(WKID, FAI, FAIS, FASI, FACI)
\end{XMP}
 
Set {\bf pattern} representation
\begin{XMP}
GSPAR(WKID, PAI, DIMX, DIMY, NCS, NRS, DX, DY, PACI)
\end{XMP}
As arguments, each routine requires the workstation identifier (WKID)
and bundle index (PLI, etc.) to be set, plus a value for each of the
non-geometric attributes for that particular primitive,
and which are listed below.
Details of GSPAR will not be given in this Primer; see the GKSGRAL manual
or one of the references in the bibliography for more information.
\subsection{\protect\label{sec:attlst}The List of GKS Attributes}
\index{attributes!list of}
\subsubsection{Individual Attributes}
\begin{UL}
\item {\bf POLYLINE}
\index{polyline}
\begin{DLtt}{123456}
\item[LN]
\index{GKS routine!{\protect\tt GSLN}}
(integer) the polyline line style (ASF 1). Set by GSLN(LN).
\item[LWSC]
\index{GKS routine!{\protect\tt GSLWSC}}
(real) the line width scale factor (ASF 2). Set by GSLWSC(LWSC).
\item[PLCI]
\index{GKS routine!{\protect\tt GSPLCI}}
(integer) the polyline colour index (ASF 3). Set by GSPLCI(PLCI).
\end{DLtt}
\item {\bf POLYMARKER}
\index{polymarker}
\begin{DLtt}{123456}
\item[MK]
\index{GKS routine!{\protect\tt GSMK}}
(integer) the polymarker type (ASF 4). Set by GSMK(MK).
\item[MKSC]
\index{GKS routine!{\protect\tt GSMKSC}}
(real) the marker size scale factor (ASF 5). Set by GSMKSC(MKSC).
\item[PMCI]
\index{GKS routine!{\protect\tt GSPMCI}}
(integer) the polymarker colour index (ASF 6). Set by GSPMCI(PMCI).
\end{DLtt}
\item {\bf TEXT}
\index{text}
\begin{DLtt}{123456}
\item[TXF]
\index{GKS routine!{\protect\tt GSTXFP}}
(integer) the text font (ASF 7). Set by GSTXFP(TXF, TXP).
\item[TXP]
(enumerated) the text precision (ASF 7). Set by GSTXFP(TXF, TXP).
\item[CHXP]
\index{GKS routine!{\protect\tt GSCHXP}}
(real) the character expansion factor (ASF 8). Set by GSCHXP(CHXP).
\item[CHSP]
\index{GKS routine!{\protect\tt GSCHSP}}
(real) the character spacing (ASF 9). Set by GSCHSP(CHSP).
\item[TXCI]
\index{GKS routine!{\protect\tt GSTXCI}}
(integer) the text colour index (ASF 10). Set by GSTXCI(TXCI).
\item[CHUP]
\index{GKS routine!{\protect\tt GSCHUP}}
(real) the character up vector. Set by GSCHUP(CHUX, CHUY).
\item[TXAL]
\index{GKS routine!{\protect\tt GSTXAL}}
(enumerated) the text alignment. Set by GSTXAL(TXALH, TXALV).
\item[TXP]
\index{GKS routine!{\protect\tt GSTXP}}
(enumerated) the text path. Set by GSTXP(TXP).
\item[CHH]
\index{GKS routine!{\protect\tt GSCHH}}
(real) the character height. Set by GSCHH(CHH).
\end{DLtt}
\item {\bf FILL AREA}
\index{fill area}
\begin{DLtt}{123456}
\item[FAIS]
\index{GKS routine!{\protect\tt GSFAIS}}
(enumerated) the fill area interior style (ASF 11). Set by GSFAIS(FAIS).
\item[FASI]
\index{GKS routine!{\protect\tt GSFASI}}
(integer) the fill area style index (ASF 12). Set by GSFASI(FASI).
\item[FACI]
\index{GKS routine!{\protect\tt GSFACI}}
(integer) the fill area colour index (ASF 13). Set by GSFACI(FACI).
\end{DLtt}
\item {\bf PATTERN}
\begin{DLtt}{123456}
\index{pattern}
\item[PA]
\index{GKS routine!{\protect\tt GSPA}}
(real) the pattern size. Set by GSPA(PASZX, PASZY).
\item[PARF]
\index{GKS routine!{\protect\tt GSPARF}}
(real) the pattern reference point. Set by GSPARF(RFX, RFY).
\end{DLtt}
\end{UL}
\subsubsection{\protect\label{sec:setbnd}Bundled Attributes}
\begin{UL}
\item {\bf POLYLINE}
\index{polyline}
\begin{DLtt}{123456}
\item[PLI]
\index{GKS routine!{\protect\tt GSPLI}}
(integer) the polyline bundle index. Set by GSPLI(PLI).
\end{DLtt}
\item {\bf POLYMARKER}
\index{polymarker}
\begin{DLtt}{123456}
\item[PMI]
\index{GKS routine!{\protect\tt GSPMI}}
(integer) the polymarker bundle index. Set by GSPMI(PMI).
\end{DLtt}
\item {\bf TEXT}
\index{text}
\begin{DLtt}{123456}
\item[TXI]
\index{GKS routine!{\protect\tt GSTXI}}
(integer) the text bundle index. Set by GSTXI(TXI).
\end{DLtt}
\item {\bf FILL AREA}
\index{fill area}
\begin{DLtt}{123456}
\item[FAI]
\index{GKS routine!{\protect\tt GSFAI}}
(integer) the fill area bundle index. Set by GSFAI(FAI).
\end{DLtt}
\end{UL}
\subsection{Specifying Line Styles For Polylines}
\index{polyline styles}
 
It is possible to draw polylines {\it solid, dashed, dotted}
or {\it dashed-dotted} ('GLSOLI', 'GLDASH', 'GLDOT', 'GLDASD').
For example:
\index{GKS routine!{\protect\tt GSLN}}
\begin{XMP}
CALL GSLN(GLDASH) - sets the line style to dashed
\end{XMP}
The different line styles available are shown in \ref{fig:linstyl}.
\begin{figure}[h]
\caption{GKS line styles}
\label{fig:linstyl}
\end{figure}
.pa
 
It is also possible to specify a scale factor which modifies the nominal
width of lines on the workstation. For example:
\index{GKS routine!{\protect\tt GSLWSC}}
\begin{XMP}
CALL GSLWSC(2.0)
\end{XMP}
should double the nominal line width. Note, however, that this (Real) parameter
is implementation-dependent, and may be ignored by terminal drivers as it
is both difficult and expensive to emulate in software if the device
does not support the feature in hardware.
\subsection{Specifying Marker Types for Polymarkers}
\index{polymarker types}
 
The five GKS Marker types, {\it point, plus, asterisk, circle}
and {\it cross} ('GPOINT', 'GPLUS', 'GAST', 'GOMARK', 'GXMARK'),
are demonstrated in \ref{fig:mark}.
For example:
\index{GKS routine!{\protect\tt GSMK}}
\begin{XMP}
CALL GSMK(GPOINT) - sets the marker type to point
\end{XMP}
\begin{figure}[h]
\caption{GKS marker types}
\label{fig:mark}
\end{figure}
 
Markers may be scaled in size by calling GSMKSC. For example:
\index{GKS routine!{\protect\tt GSMKSC}}
\begin{XMP}
CALL GSMKSC(3.5)
\end{XMP}
will scale the following markers by 3.5 times. The implementation of this
function is workstation-dependent. In particular, markers drawn on terminals
by hardware may only exist in certain fixed sizes.
\subsection{Specifying Fill Areas}
\index{fill area}
\index{hatching}
 
Many applications need shaded or coloured areas as well as lines and points.
GKS allows one to draw such an area by specifying an array of points
representing a closed polygon. If the last point in the array is not the
same as the first, these two will be joined.
The interior style of the area can be set to one of the four values
{\it hollow, solid, pattern}, and {\it hatch},
which are demonstrated in \ref{fig:fill}
('GHOLLO', 'GSOLID', 'GPATTR', 'GHATCH').
Examples for setting fill area interior style are:
\index{GKS routine!{\protect\tt GSFAIS}}
\begin{XMP}
CALL GSFAIS(GHOLLO)
     or
CALL GSFAIS(GSOLID)
\end{XMP}
 
For interior style hollow the boundary polygon only is drawn as a solid line.
For style {\it solid} the interior is completely filled with a uniform
colour, as specified by the fill area colour index set by calling GSFACI.
\index{GKS routine!{\protect\tt GSFACI}}
Workstations for devices which support area filling of polygons by hardware
should normally make use of this feature.
However, this is not always possible, as some monochrome terminals do not
use the correct algorithm to perform the area fill.
 
For interior styles {\it hatch} and {\it pattern},
the particular hatch algorithm or pattern used may be chosen by specifying
a fill area style index.
This represents a second level of selection on the way the area is filled,
and the index points into either a hatch or pattern table stored at the
workstation. Thus, hatches and patterns are workstation-dependent.
The fill area style index is set by calling:
\index{GKS routine!{\protect\tt GSFASI}}
\begin{XMP}
CALL GSFASI(FASI)
\end{XMP}
where FASI is an integer value. To find out the effect of setting a particular
index, it is necessary to consult the workstation documentation.
 
\index{GKS routine!{\protect\tt GUSHTR}}
\index{GKS routine!{\protect\tt GSPARF}}
\index{GKS routine!{\protect\tt GSPAR}}
\index{GKS routine!{\protect\tt GSPA}}
The GKS standard provides calls to modify patterns by setting the pattern
reference point (GSPARF) and pattern size (GSPA).
The pattern representation attribute bundle is set using GSPAR.
The GKSGRAL package also allows the possibility to define one's
own hatch styles by calling the routine GUSHTR,
although this is not a standard GKS feature.
None of these routines will be described further in this Primer,
and the reader is referred to the texts in the bibliography
for more information.
\begin{figure}[h]
\caption{GKS fill area styles}
\label{fig:fill}
\end{figure}
\subsection{Specifying Text}
\index{text}
\index{converting numeric variables}
\index{numeric variables}
 
Text is the most complex of the GKS primitives because there are
so many different variations. The text attributes are described below.
Note that only the non-geometric attributes may be set in the text
bundle table.
({\bf HINT:} For FORTRAN programmers, it is possible to use the
{\it Internal Write} construct to convert numeric variables to character
strings for output as text primitives, see section on Page~\pageref{sec:refintw}).
\subsubsection{Font and Precision}
\index{text!fonts}
\index{text!precision}
\index{string precision text}
\index{character precision text}
\index{stroke precision text}
 
The {\it text font} is specified by an integer font number,
and fonts are workstation-dependent.
Any text font which is not supported on a given workstation is defaulted
to 1. This text font is a simple, roman type font produced by stroking
out each character using line segments.
To find out which fonts are provided by a particular implementation
one should consult the relevant reference manual.
 
The {\it text precision} attribute determines how closely the chosen
font has to obey the specifications of the other text attributes.
The choices for text precision are:
{\it string, char} and {\it stroke}
('GSTRP', 'GCHARP', 'GSTRKP').
In {\it string} precision the text string should be placed as close
as possible to the position specified by the primitive call.
None of the other text attributes need be taken into account
except the approximate size specified by character height.
Thus, if string precision is specified, the implementation is usually free
to make use of hardware characters which can be drawn much faster than
generating the fonts in software.
If {\it char} precision together with a workstation-provided font is
chosen, GKS will try a workstation dependent approximation.
In {\it stroke} precision GKS has to follow precisely the attribute
specifications, and always defaults to font 1
if the requested font does not exist.
Note that an implementation of GKS {\it may} provide stroke precision
text on a particular workstation even if the application specified only
a lower precision.
Both the text font and the text precision are set by the same routine:
\index{GKS routine!{\protect\tt GSTXFP}}
\begin{XMP}
CALL GSTXFP(FONT, PREC)
\end{XMP}
\begin{figure}[h]
\caption{Text fonts, precisions and up vectors}
\label{fig:fonts}
\end{figure}
\subsubsection{Expansion Factor}
\index{character!expansion factor}
 
The character expansion factor, a real number, causes each character to
appear 'fatter' or 'thinner' than normal. The default value is 1.0.
The height of the character is not affected, nor is the space
between the characters.
\index{GKS routine!{\protect\tt GSCHXP}}
\begin{XMP}
CALL GSCHXP(CHXP)
\end{XMP}
\subsubsection{Spacing}
\index{character!spacing}
 
The character spacing attribute defines the amount of extra
blank space to be inserted between adjacent characters of a text string.
This is a real number defined as a fraction of the character height.
The default value is 0.0. A positive character spacing spreads the
letters out, a negative one makes the letters overlap.
\index{GKS routine!{\protect\tt GSCHSP}}
\begin{XMP}
CALL GSCHSP(CHSP)
\end{XMP}
\subsubsection{Character-Up-Vector}
\index{character!up-vector}
 
The char-up vector defines the orientation of the text.
The text is written from left to right along a line perpendicular to the
char-up vector, which is specified by its X and Y components
(two real numbers):
\index{GKS routine!{\protect\tt GSCHUP}}
\begin{XMP}
CALL GSCHUP(CHUX, CHUY)
\end{XMP}
The effect of choosing different combinations of text font,
text precision and character-up-vector is shown in \ref{fig:fonts}.
\subsubsection{Alignment}
\index{text!alignment}
 
The text string as a whole is positioned relative to the point specified
in the GTX primitive call according to the current setting of the text
alignment attribute. The call to GSTXAL has two parameters for
horizontal and vertical alignment.
\index{GKS routine!{\protect\tt GSTXAL}}
\begin{XMP}
CALL GSTXAL(TXALH, TXALV).
\end{XMP}
The horizontal alignment is either {\it normal, left edge, centre},
or the {\it right edge} of the text string
('GAHNOR', 'GALEFT', 'GACENT', 'GARITE').
The vertical alignment is either {\it normal, top, cap line, half,
base line}, or {\it bottom}
(GAVNOR', 'GATOP', 'GACAP', 'GAHALF', 'GABASE', 'GABOTT').
The alignment attribute is illustrated in \ref{fig:align}.
The selection of {\it normal} for either horizontal or vertical
alignment results in GKS choosing the most appropriate value
depending on the current Text Path.
\begin{figure}[h]
\caption{Text alignment}
\label{fig:align}
\end{figure}
\subsubsection{Text Path}
\index{text!path}
 
The text path describes the direction in which the text string is written.
The possible values are {\it Right, Left, Up} and {\it Down}
('GRIGHT', 'GLEFT', 'GUP', ' GDOWN').
The default for the text path is perpendicular to the up vector (i.e. 'GRIGHT').
\index{GKS routine!{\protect\tt GSTXP}}
\begin{XMP}
CALL GSTXP(TXP)
\end{XMP}
\subsubsection{Height}
\index{character!height}
 
The character height is set in {\bf World Coordinates} by calling
GSCHH. Increasing the height automatically causes a corresponding
increase in the width of the character.
\index{GKS routine!{\protect\tt GSCHH}}
\begin{XMP}
CALL GSCHH(CHH)
\end{XMP}
 
Note that the use of World Coordinates to specify the character height may
cause problems if the normalization transformation chosen has a very large
or very small range in Y. In this case it is possible that when using a
metafile as an output workstation the number of digits required to
specify the character height may be more than the range used to define
real numbers within the metafile. If it would be inconvenient to modify
the range of World Coordinate Y values, then another possible solution to
the problem is to superimpose two viewports, one on top of the other.
All characters may then be drawn on one of the viewports which has been
defined using a more reasonable normalization transformation.
\subsection{Specifying Colour}
\index{colour!index}
 
Colour is specified separately for each primitive type by a colour index value.
\index{GKS routine!{\protect\tt GSPLCI}}
\begin{DLtt}{123456}
\item[Polyline]CALL GSPLCI(PLCI)
\item[Polymarker]CALL GSPMCI(PMCI)
\item[Text]CALL GSTXCI(TXCI)
\item[Fill Area]CALL GSFACI(FACI)
\end{DLtt}
The {\it colour index}, instead of defining a colour directly, points to
an entry in a {\it colour look-up table} which is workstation-dependent.
If the colour is an attribute of a primitive, then one can specify a colour
index either as an individual attribute or as part of a bundle table.
The size of the colour table is workstation-dependent, but
the table always contains the entries 0 and 1.
The background colour is 0, and the default foreground colour is 1.
Each entry greater than 1 defines an additional foreground colour.
If a colour index greater than the maximum is
specified, then the default value 1 is taken, which ensures that a program
written using colour will run on a monochrome device.
\index{colour!look-up table}
 
To set entries in the colour look-up table
one must call the function Set Colour Representation (GSCR).
It takes as parameters the workstation identifier, the colour index
to be set, and a value (from 0 to 1.0) for each of the red, blue, and green
intensities. The workstation then uses the closest available
colour to that which has been requested.
\index{GKS routine!{\protect\tt GSCR}}
\begin{XMP}
CALL GSCR(WKID, INDEX, RED, GREEN, BLUE)
\end{XMP}
 
The highest possible value for the colour index (NCOLI)
depends on the capabilities of the device and can be inquired using
GQCF and specifying the workstation type:
\index{GKS routine!{\protect\tt GQCF}}
\begin{XMP}
CALL GQCF(WTYPE, ERRIND, NCOLI, COLA, NPCI)
\end{XMP}
The parameter COLA ('GMONOC' or 'GCOLOR') indicates whether or not colour
is available, and NPCI specifies the number of pre-defined colour indices.
 
The colour index can also be used if part of a previously drawn picture
is to be erased. The part to be erased should be re-drawn in
the background colour (index=0).
All other attribute settings and transformations must be
exactly as they where when the picture was produced initially.
However, even in this case, the trick may not work if the primitive
being erased overlays another primitive, and not just the background.
 
Colour may be part of a fill area pattern, in which case different parts
of the pattern may be defined to be different colours.
For the cell array primitive an array of colours is specified
as part of the primitive itself.
\section{Coordinates and Transformations}
\index{transformations}
\index{coordinate systems}
\index{world coordinates}
\index{normalized device coordinates}
\index{device coordinates}
 
GKS defines three coordinate systems:
\begin{OL}
\item WORLD Coordinates  (WC)
\item NORMALIZED DEVICE Coordinates  (NDC)
\item DEVICE Coordinates  (DC)
\end{OL}
The application program specifies the coordinates of points in primitive
calls using a cartesian coordinate system with whichever scale
is the most convenient.
This system is called the {\it World Coordinate System}.
The WC range can go from negative to positive infinity along both axes,
which gives the application an unlimited choice of coordinates.
The definition of the WC space is independent of any graphics
output device and can be different for each application as the
requirements dictate.
 
All world coordinates are transformed by GKS to a 'virtual' device
space, the {\it Normalized Device Coordinate} (NDC) space.
The NDC space ranges from 0 to 1 in both x and y.
This space is device independent and appears identical for all
workstations in the system. A transformation from WC to NDC is called a
{\it Normalization Transformation}.
GKS allows more than one such transformation to be defined,
and so an application may draw each part of a picture in
its own WC system, and then map them into a single NDC space.
See \ref{fig:windows} and \ref{fig:trafos}.
 
The third coordinate system is that of the hardware device.
GKS uses specific information about the graphics output device
to transform normalized device coordinates into
coordinates that the device itself understands. Usually the units
in the device dependent space will be metres or raster units.
The translation from NDC to DC is called the
{\it Workstation Transformation}.
\index{window}
\index{viewport}
\index{normal!transformation}
\index{transformation!normalization}
\subsection{\protect\label{sec:nortrn}Normalization Transformation}
 
This transformation is specified by mapping a {\it Window}
in the application's WC space to a {\it Viewport} in NDC space.
Both the WC window and the NDC viewport are rectangles parallel to the
x,y axes.
They are specified by calls to Set WiNdow and Set ViewPort:
\index{GKS routine!{\protect\tt GSWN}}
\index{GKS routine!{\protect\tt GSVP}}
\begin{XMP}
CALL GSWN (TNR, WXMIN, WXMAX, WYMIN, WYMAX)
 
CALL GSVP (TNR, VXMIN, VXMAX, VYMIN, VYMAX)
\end{XMP}
\index{aspect ratio}
\index{TNR}
Because there may be several Normalization Transformations, the integer
value TNR indicates to which one the call applies.
The other values are real numbers defining the {\it bottom left} and
{\it top right} corners of the two rectangles. The window is
specified in the WC system, and the viewport in the NDC system. If the
x and y sides of the window and the viewport do not have the same
{\it Aspect Ratio} a distortion effect will take place.
This may or may not be intentional!
 
As has been mentioned, it is possible to generate a complex picture
with different world coordinates for different parts of the image,
or to place several pictures on different areas of the screen.
This is achieved by specifying multiple normalization transformations.
Each transformation is assigned a transformation number (TNR) for which
the range is 0 to some implementation-dependent maximum (usually about 20).
Thus, the transformation corresponding to each number
specifies a separate window-to-viewport mapping.
If the viewports overlap then their contents will be superimposed.
 
The default transformation number is 0, for which the WC and NDC
coordinate systems are the same.
Transformation 0 may not be modified, and so its use
is always equivalent to calling:
\begin{XMP}
CALL GSWN (TNR, 0.0, 1.0, 0.0, 1.0)
CALL GSVP (TNR, 0.0, 1.0, 0.0, 1.0)
\end{XMP}
 
The application specifies which normalization transformation is
active at a given time by a call to GSELNT (SELect Normalization
Transformation):
\index{GKS routine!{\protect\tt GSELNT}}
\begin{XMP}
CALL GSELNT(TNR)
\end{XMP}
All primitives created subsequently will be transformed according to this
transformation until a different one is selected.
\begin{figure}[h]
\index{window}
\index{viewport}
\caption{Windows and Viewports}
\label{fig:windows}
\end{figure}
\subsection{\protect\label{sec:wstntfm}Workstation Transformation}
\index{workstation!transformation}
\index{transformation!workstation}
 
The method of defining which portion of NDC space is to appear on
a specific workstation is similar to the way a viewport is positioned
in NDC space (the Normalization Transformation). The {\it Workstation
Transformation} defines that part of NDC space which will be visible,
and where it will appear on the display surface.
It is set by calling the functions Set WorKstation WiNdow and
Set WorKstation ViewPort:
\index{GKS routine!{\protect\tt GSWKWN}}
\index{GKS routine!{\protect\tt GSWKVP}}
\index{window}
\index{viewport}
\index{workstation!window}
\index{workstation!viewport}
\begin{XMP}
CALL GSWKWN(WKID, WXMIN, WXMAX, WYMIN, WYMAX)
 
CALL GSWKVP(WKID, VXMIN, VXMAX, VYMIN, VYMAX)
\end{XMP}
Set Workstation Window specifies in NDC coordinates the area of the NDC
space to be output to the device. Set Workstation Viewport specifies in
{\it Display Coordinates} (DC) where on the device the window will appear.
These functions may be called at any time. However, whether or not
the effect is immediately visible is workstation-dependent.
For example, if changing the workstation transformation requires an
implicit image regeneration, then the timing of when it will take place
is affected by the current deferral mode (see section on Page~\pageref{sec:defsta}).
\index{implicit regeneration}
\index{deferral states}
\index{aspect ratio}
 
The aspect ratio for the workstation window and the workstation viewport
{\bf must always be the same}.
If they are not, then {\bf the specified transformation is ignored},
and the complete workstation window is displayed on the device
in the correct aspect ratio.
A rectangle is used with the bottom left corner set to the bottom
left corner of the specified viewport, and which is as large as possible.
 
The {\bf default setting} for the workstation transformation is
to map the whole unit square of NDC onto the largest square possible for the
workstation. For rectangular displays, this means that not all of
the display surface is used. Conversely, if the workstation
transformation is set so that all of a rectangular display is
used, then either: (1) the normalization transformation can not
preserve the aspect ratio, or: (2) not all of NDC space can be used.
 
\index{GKS routine!{\protect\tt GQDSP}}
\index{GKS routine!{\protect\tt GQMDS (see GQDSP)}}
To inquire the range of device coordinates corresponding to a particular
workstation type, it is possible to call the function GQDSP
(inQuire Display SPace). (Note: The 3D version is called GQDVOL.)
\begin{XMP}
CALL GQDSP (WTYPE, ERRIND, DCUNIT, RX, RY, LX, LY)
\end{XMP}
The routine returns the units in which the display surface
is measured (DCUNIT), and also the maximum x and y values
in each direction.
Some devices, for example hardcopy plotters, are measured in metres
(DCUNIT='GMETRE'), so the routine will return the actual size of the
device. Other devices, for example graphics terminals,
will be defined in raster or some other units (DCUNIT='GOTHU').
RX, RY are real device coordinates,
and LX, LY are in integer raster units.
 
As an example of how to use this routine, below is a fragment of code
which allows an application to draw on the whole of a rectangular
display surface with a 'Landscape' aspect ratio
(width~>~height).
See also the example in Appendix on Page~\pageref{sec:ex3dv}.
\begin{XMP}
C  Inquire the Workstation Display Surface Size
      CALL gqdsp (wtype, errind, dcunit, rx, ry, lx, ly)
C
C  Set the Workstation Window and Viewport (assume x > y)
      CALL gswkwn(wkid, 0.0, 1.0, 0.0, ry/rx)
      CALL gswkvp(wkid, 0.0, rx,  0.0, ry)
C
C  Make sure Workstation Transformation is used
      CALL guwk  (wkid, gperfo)
C
C  Set Window and Viewport for Normalization Tfrm 'trn'
      CALL gswn  (trn,  xmn, xmx, ymn, ymx)
      CALL gsvp  (trn,  0.0, 1.0, 0.0, ry/rx)
C
C  Select this Normalization Tfrm for future primitives
      CALL gselnt(trn)
\end{XMP}
\begin{figure}[h]
\caption{Normalization and Workstation Transformations}
\label{fig:trafos}
\end{figure}
\subsection{\protect\label{sec:nrmclp}Clipping}
\index{clipping}
\index{GKS routine!{\protect\tt GSCLIP}}
 
Clipping is the exclusion of those primitives, or parts of primitives,
which lie outside a specified window or viewport. That is to say, if
clipping to a particular window is enabled, then only those parts of
primitives which lie within the boundaries of the window will be
displayed. Both the normalization transformation viewport (in NDC space)
and the workstation window can be used to clip a picture.
Clipping at the boundary of the normalization transformation viewport
(clipping rectangle) effects the image displayed on ALL workstations.
However, clipping at the boundary of the
workstation window only affects the image on the display surface
belonging to that particular workstation.
This is illustrated in Workstation Viewport 1 in \ref{fig:windows}.
 
The application can control whether clipping at the boundary of the
clipping rectangle is enabled or not by calling the routine GSCLIP(VAL).
This routine takes the value 'GNCLIP' (no clip) or 'GCLIP' (clip),
and the default is to clip.
Clipping at the workstation window may not be switched off.
\section{\protect\label{sec:seghdr}Segments}
\index{segments}
 
GKS provides a way to collect and store together the primitives that
make up all or part of a picture. Such a collection of primitives is
called a {\it segment}, has a unique name, and may be manipulated
as a unit in various ways.
Only one segment can be open at a time, and once a segment has
been closed further output primitives cannot be added to it,
nor can the primitives in it be modified.
 
\index{non-retained data}
Any {\it non-retained} data output whilst there is no open
segment will be lost if the screen is cleared for some reason.
There are several circumstances when this may be useful.
For example, a message written on the screen may have only limited
validity, or one may wish to output a very complicated image with
too much data to be stored, or which needs only to be displayed once.
However, much of the power of GKS comes from the ability to
interactively modify the image {\it without} always having
to regenerate the complete picture.
To make use of this feature, primitives must be stored in segments.
\subsection{Segment Storage}
\index{segment!storage}
\index{WDSS}
\index{WISS}
 
Every workstation in a GKS output level 1 or 2 implementation has
associated with it a {\it Workstation Dependent Segment Store}
(WDSS). At the time a segment is created, it is stored in the WDSS of all
open and activated workstations.
The WDSS may be physically located in the Graphics Terminal,
in which case there can be a substantial improvement in performance.
Of course, care must be taken not to exceed the available memory space.
 
In addition to WDSS, GKS output level 2 implementations
have also a {\it Workstation Independent Segment Store} (WISS).
WISS is a mechanism for storing segments in a
workstation-independent way, and allows segments to be re-used
and manipulated on different workstations at different times.
WISS is treated like any another workstation, just like a terminal
for example, and if it is open and activated when a segment is created,
then that segment will be stored there
as well as on the WDSSs of the other active workstations.
For example, one might store an object in WISS at the same time
as displaying it on a terminal. Then, at a later time, it would
be possible to make a hardcopy of the object by extracting the segment(s)
in which it was stored from the WISS and copying it (them) to a plotter.
A transformation or segment deletion affects the segment wherever it is stored.
 
Before primitives are stored in WDSS or WISS they first undergo
the normalization transformation currently in force.
Also, when a segment is created, the current clipping rectangle
together with the clipping flags, are stored in the segment,
but clipping is not performed
on the primitives when they are stored, but only when the
contents of the segment are output to a device.
\subsection{Segment Creation, Deletion, and Re-naming}
 
To use GKS segmentation, first a segment must be created by calling:
\index{GKS routine!{\protect\tt GCRSG}}
\begin{XMP}
CALL GCRSG(SGNA)
\end{XMP}
where SGNA is an integer segment name. A segment called SGNA will
be created on all active workstations, including WISS, and will remain
open and store all primitives and attributes which are output until one calls:
\index{GKS routine!{\protect\tt GCLSG}}
\begin{XMP}
CALL GCLSG
\end{XMP}
Only a single segment may be open at one time.
 
Segments may be renamed, or deleted on a particular workstation
or all workstations by the following calls:
\index{GKS routine!{\protect\tt GRENSG}}
\index{GKS routine!{\protect\tt GDSGWK}}
\index{GKS routine!{\protect\tt GDSG}}
\begin{XMP}
CALL GRENSG(SGNOLD, SGNNEW)
 
CALL GDSGWK(WKID, SGNA)
 
CALL GDSG(SGNA)
\end{XMP}
Once a segment has been deleted the same segment name may be re-used.
Note that the Clear Workstation function deletes all the segments
stored in WDSS on that workstation.
 
The following fragment of code shows the use of segments.
See also the example in Appendix on Page~\pageref{sec:ex3dv}.
\begin{XMP}
      ---------
      ---------
      CALL gcrsg(1)                   ! Create segment 1
      CALL objone                     ! Draw an object
      CALL gclsg                      ! close segment
      CALL gcrsg(2)                   ! Create segment 2
      CALL objtwo                     ! Draw an object
      CALL gclsg                      ! Close segment
      ---------
      ---------
      ---------
      CALL guwk(wkid, gperfo)         ! Update Workstation
      ---------
      ---------
\end{XMP}
\subsection{\protect\label{sec:segnam}Segment Names}
\index{segment!names}
 
As indicated above, the FORTRAN binding requires segment names to be
integers, and these may be restricted by an implementation to a particular
range of values (1-32763 for GKSGRAL). However, because segment names
are specified by integers does not imply that an implementation has to
make available as many segments as there are names, and the maximum
number of available segments is also an implementation-dependent feature
which may be much smaller than the maximum legal name.
(Thus, one can not assume that an implementation stores name {\it N}
as the {\it N}'th element of an array.)
GKS does not provide inquiry functions to obtain either of these maximum
values, so one must consult the relevant documentation.
 
The GKS standard provides a function, GQSGUS, to inQuire the set of SeGment
names in USe. However, as it is difficult to work with variable length
sets in FORTRAN, the FORTRAN binding has modified this function to allow
only the inquiry of the name of one element of the set at a time:
\begin{XMP}
CALL GQSGUS(N, ERRIND, NSG, SGNA)
\end{XMP}
where
\begin{DLtt}{123456}
\item[N]is the N'th segment in the set (an input parameter)
\item[ERRIND]is an error number
\item[NSG]is the total number of segments in use
\item[SGNA]is the name of the N'th segment
\end{DLtt}
Thus, in FORTRAN, it is necessary to call GQSGUS in a loop from 1 to NSG
in order to obtain a list of all the segment names in use.
 
Note that the function:
\begin{XMP}
CALL GQSGWK(WKID, N, ERRIND, NSG, SGNA)
\end{XMP}
works in a similar way to GQSGUS but provides the list of segment names
associated with workstation WKID.
\subsection{\protect\label{sec:segasi}Segment Association, Copying, and Insertion,}
\index{segment!association}
\index{segment!copying}
\index{segment!insertion}
 
To view the contents of segments stored in WISS
it is necessary to transfer them to a real device.
This can be accomplished in three ways:
\begin{DLtt}{123456}
\item[Association]
Associate SeGment to WorKstation retrieves a segment stored in WISS
and sends it to the designated workstation as if this workstation had been
activated when the segment was first created.
It is thus stored in the WDSS of the designated workstation.
Nothing may be added to the segment.
There must be no open segment when this function is called.
\index{GKS routine!{\protect\tt GASGWK}}
\begin{XMP}
CALL GASGWK(WKID, SGNA)
\end{XMP}
\item[Copying]
Copy SeGment to WorKstation transforms the {\it contents}
of the designated WISS segment using the segment transformation
(described below), and then sends the result to the workstation specified.
The clipping volume of the copied segment is also sent to the
workstation. Note that the copied segment itself is not transferred;
its contents are just drawn on the output device {\bf without being
stored in WDSS}.
Thus, there must be no open segment when this function is called.
\index{GKS routine!{\protect\tt GCSGWK}}
\begin{XMP}
CALL GCSGWK(WKID, SGNA)
\end{XMP}
\item[Insertion]
INsert SeGment transforms the {\it contents} of the designated WIS
 segment using both the transformation stored in the segment header
{\bf and} then the matrix provided in the call (MTX),
before inserting the results into the output stream as if
they had come directly from the application.
Thus, the output of Insert Segment goes to all activated workstations,
including the WISS, and will be stored in a segment if one is open.
All clipping rectangles and indicators, etc. are ignored.
The transformation matrix, MTX, may be produced using the routine
GEVTM as described below.
\index{GKS routine!{\protect\tt GINSG}}
\begin{XMP}
CALL GINSG(SGNA, MTX)
\end{XMP}
\end{DLtt}
The flow of graphics data between WISS, WDSS and the application
is shown in \ref{fig:dataflo}.
\begin{figure}[h]
\caption{Data Flow for GKS}
\label{fig:dataflo}
\end{figure}
\subsection{Segment Attributes}
\index{segment!attributes}
 
The appearance of segments depends on the following segment attributes:
\begin{UL}
\item segment transformation
\item visibility
\item highlighting
\item segment priority
\item detectability
\index{transformation!segment}
\end{UL}
Segment attributes may be modified after the segment has been closed,
and the changes will become visible on all active workstations
on which the segment has been stored. However, the timing of when these
changes take place is workstation-dependent, and may also be
affected by the deferral mode which is in force
(see sections on Page~\pageref{sec:defsta} and on Page~\pageref{grsgwk}).
This is because some workstations may require picture regeneration
to produce the new attribute state on the display.
\subsubsection{\protect\label{sec:segtfm}Segment Transformations}
\index{segment!transformation}
 
A {\it segment transformation} is a transformation of all the
coordinates within a segment and is performed by a 2~x~3
matrix stored in the segment header. It maps from NDC to NDC. As an
example of the use of segment transformations, consider a circuit
design application which has symbols for transistors, capacitors,
resistors, etc. Such an application would store each symbol in a
separate segment, and then call INsert SeGement specifying a
transformation matrix in order to duplicate a particular symbol at the
positions and orientations required.
 
When a segment is created GKS sets a default null transformation
which leaves the original coordinates unchanged.
Before setting a transformation it is necessary
to evaluate the transformation matrix by either using one's own
algorithm, or by using the routines:
\index{GKS routine!{\protect\tt GEVTM}}
\index{GKS routine!{\protect\tt GACTM}}
\begin{XMP}
CALL GEVTM(X0, Y0, DX, DY, PHI, FX, FY, SW, MXOUT)
 
     and/or
 
CALL GACTM(MXIN, X0, Y0, DX, DY, PHI, FX, FY, SW, MXOUT)
\end{XMP}
GEVTM evaluates a matrix (MXOUT), whilst GACTM accumulates changes to
an existing matrix (MXIN).
Both routines require the definition of:
\begin{DLtt}{123456}
\item[X0, Y0]
(real) a fixed reference point about which 2D rotations take place.
\item[DX, DY]
(real) a translation (or shift) vector.
\item[PHI]
(real) an angle of rotation about X0, Y0.
\item[FX, FY]
(real) X and Y scale factors.
\item[SW]
(enumerated) a switch specifying whether the reference point and
shift vector are given in World Coordinates
or Normalized Device Coordinates ('GWC' or 'GNDC').
\end{DLtt}
The transformation is composed in the order: scale, rotate, shift.
In the case of GACTM, the matrix MXIN is pre-concatenated with that
formed from the scale, rotate, and shift parameters, so
MXOUT~=~SHIFT~*~ROTATE~*~SCALE~*~MXIN.
 
Once the transformation matrix has been evaluated, it may then be
Set in the SeGmenT by calling the routine:
\index{GKS routine!{\protect\tt GSSGT}}
\begin{XMP}
CALL GSSGT(SGNA, MTX)
\end{XMP}
An example of using a segment transformation may be
found in Appendix on Page~\pageref{sec:ex3dv}.
\subsubsection{Visibility}
\index{segment!visibility}
 
Segment {\it VISibility} (GSVIS) determines whether or not the
segment is displayed; the default is for the segment to be visible.
The values are 'GINVIS' or 'GVISI'.
As an example of its use, messages or icons could be created in segments
which would normally be invisible, but which could be made visible
at the appropriate time by the application program. The call is:
\index{GKS routine!{\protect\tt GSVIS}}
\begin{XMP}
CALL GSVIS(SGNA, GVISI)
\end{XMP}
Note that if a segment is invisible it is not detectable
(cannot be picked), even if detectability is enabled.
Also, even if a segment has visibility enabled, it may not actually be
drawn if the deferral state is set to something other than 'GASAP'
(see section on Page~\pageref{sec:defsta}).
\subsubsection{Highlighting}
\index{segment!highlighting}
 
Many display systems have some means for {\it highlighting}
graphical output, eg by making it brighter, or by causing it to blink.
The implementation of this attribute is dependent on the device
being used. Note that in order for a Segment to be HighLIghTed (GSHLIT),
it must first be made visible. The default is not highlighted.
The possible values are 'GNORML' or 'GHILIT'. The call is:
\index{GKS routine!{\protect\tt GSHLIT}}
\begin{XMP}
CALL GSHLIT(SGNA, GHILIT)
\end{XMP}
\subsubsection{Priority}
\index{segment!priority}
 
SeGment {\it Priority}, a real number in the range 0.0 to 1.0,
enables the control of the order in which segments are re-drawn when
the picture has been changed.
It also controls the order in which segments are picked.
If parts of segments overlap, then the segment with the highest
priority will be picked first and displayed on top of all the others.
If two segments with the same priority occupy the same area of the display
surface, then the last one will be drawn on top.
The default priority is 0.0. The call is:
\index{GKS routine!{\protect\tt GSSGP}}
\begin{XMP}
CALL GSSGP(SGNA, PRIOR)
\end{XMP}
 
The number of segment priority levels available (NSGP) for a particular
workstation, WTYPE, may be inquired using:
\index{GKS routine!{\protect\tt GQSGP}}
\begin{XMP}
CALL GQSGP(WTYPE, ERRIND, NSGP)
\end{XMP}
\subsubsection{Detectability}
\index{segment!detectability}
 
Segment {\it DeTECtability} controls which segments can be
picked by the operator using a Logical Pick Device, and which ones cannot.
Values are 'GUNDET' or 'GDETEC'.
If a segment is detectable, it can be picked.
The default setting is un-detectable. The call is:
\index{GKS routine!{\protect\tt GSDTEC}}
\begin{XMP}
CALL GSDTEC(SGNA, GDETEC)
\end{XMP}
Note that if a segment is invisible it is not detectable
(cannot be picked), even if detectability is enabled.
\subsection{The Pick Identifier}
\index{pick input}
\index{pick identifier}
 
It is possible to attach an integer {\it Pick Identifier} to primitives
which are stored in segments using the routine:
\index{GKS routine!{\protect\tt GSPKID}}
\begin{XMP}
CALL GSPKID(PCID)
\end{XMP}
This inserts one or more Pick Identifiers (PCIDs) into a
segment, and these are associated with the subsequent primitives.
If one of these primitives is picked sometime later using a Logical Pick
input device (see on Page~\pageref{sec:inphdr}), then one of the
pieces of information returned to the application is its PCID.
 
As the application is free to choose the value of the Pick Identifier,
this provides a second level of naming,
and provides a mechanism to refer back to an application database.
For example, if the identifiers 1 to 4 were attached to the four wheels
of a car, then picking wheel number three would return the identifier
'3' to the application program.
\subsection{\protect\label{sec:grsgwk}Segment Re-drawing}
\index{segment!re-drawing}
 
It is possible to force all segments within the WDSS on a particular
workstation to be re-drawn by calling the routine
Re-draw SeGments on WorKstation:
\index{GKS routine!{\protect\tt GRSGWK}}
\begin{XMP}
CALL GRSGWK(WKID)
\end{XMP}
\index{non-retained data}
 
The routine clears the screen, performs all deferred actions,
and re-draws all segments. All non-retained data is lost.
Possible reasons to re-draw all segments are:
\begin{OL}
\item if a segment had been over-written or deleted and it is
desired to regenerate a clean image;
\item if one wishes to remove all non-retained data,
system messages, etc;
\item if, on this workstation, image regeneration is required in order to
display the effect of modifying a segment attribute, and implicit
regeneration is switched off.
\end{OL}
The action of this routine differs from that of
Update WorKstation (GUWK), which may or may not re-draw segments
which have not been changed.
\section{Graphical Input}
\subsection{\protect\label{sec:inphdr}Logical Input Devices}
\index{input}
\index{logical input devices}
\index{input!classes}
\index{input!device numbers}
 
GKS organizes data that can be input to an applications program
into six types, each related to a {\it Logical Input Device}.
The actual physical input devices are mapped onto these logical
devices, which makes it possible for GKS to organize the different
forms of data in a device-independent way, and thus helps to make the
code more portable.
A logical input device is identified by 3 items:
\begin{OL}
\item a workstation identifier
\item an input class
\item a device number
\end{OL}
The six input classes and the logical input values they provide are:
\begin{DLtt}{123456}
\item[LOCATOR]
\index{locator input}
\index{transformation!locator input}
\index{viewport}
Returns a position (an x,y value) in World Coordinates
and a Normalization Transformation number corresponding to that
used to map back from Normalized Device Coordinates to World Coordinates.
The NT used corresponds to that viewport with the highest
{\it Viewport Input Priority} (set by calling GSVPIP).
{\bf Warning:} {\it If there is no viewport input priority set then
NT 0 is used as default, in which case the coordinates are
returned in NDC.} This may not be what is expected!
\index{GKS routine!{\protect\tt GSVPIP}}
\begin{XMP}
CALL GSVPIP(TNR, RTNR, RELPRI)
\end{XMP}
\begin{DLtt}{123456}
\item[TNR]Transformation Number
\item[RTNR]Reference Transformation Number
\item[RELPRI]
One of the values 'GHIGHR' or 'GLOWER' defined in the Include File,
ENUM.INC, which is listed in the Appendix on Page~\pageref{sec:hdenum}.
\end{DLtt}
\item[STROKE]
\index{stroke input}
Returns a sequence of (x,y) points in World Coordinates
and a Normalization Transformation as for the Locator.
\item[VALUATOR]
\index{valuator input}
Returns a real value, for example, to control some sort
of analogue device.
\item[CHOICE]
\index{choice input}
Returns a non-negative integer which represents a choice from a
selection of several possibilities. This could be implemented as a
menu, for example.
\item[STRING]
\index{string input}
Returns a string of characters from the keyboard.
\item[PICK]
\index{pick input}
Returns a segment name and a pick identifier of an object pointed
at by the user. Thus, the application does not have
to use the locator to return a position, and then try to find out
to which object the position corresponds.
\end{DLtt}
\subsection{Prompt/Echo Types and Triggers}
\index{prompt/echo type}
\index{trigger}
\index{input!prompt/echo type}
\index{input!trigger}
 
A {\it Prompt} and an {\it Echo} type is defined for
each logical input device.
For example, enabling the pick device might
prompt with a cursor of a particular shape which would track
the tablet or mouse to constitute an echo.
Acceptance of a {\it trigger} by the application,
hitting a key, for example, causes feedback
via an {\it acknowledgment} process.
Thus, the picked object could be made to blink.
Different prompt/echo types can be set when initializing the device.
They are implementation and workstation-dependent,
so see the relevant reference manual for details.
\subsection{Input Modes}
\index{input!modes}
\index{input!request}
\index{input!sample}
\index{input!event}
\index{request input}
\index{sample input}
\index{event input}
 
Logical input devices can be operated in three modes:
{\it Request}, {\it Sample}, and {\it Event}
('GREQU', 'GSAMPL', 'GEVENT').
In Request mode the application enables a device and then waits
for the user to trigger input, perhaps by pushing a key.
This is similar to issuing a FORTRAN {\it READ}.
In Sample mode the application can {\it measure}
the current value of the device, for example the locator position,
without waiting for a trigger. Finally, in Event mode, the application
can enable a set of several logical devices simultaneously.
Output measures from devices which have been triggered will be
placed in an {\it Event Queue}, from whence they can be
extracted by the application.
 
Note that in GKS input level 'b' only Request mode input is available,
and that it is not possible to request GKS input
and issue a FORTRAN I/O operation at the same time.
(However, although not required by the standard, the GKSGRAL level 'b'
implementation provides Sample input for some devices.)
\subsection{Request Input Functions}
\index{GKS routine!{\protect\tt GRQCH}}
\index{GKS routine!{\protect\tt GRQLC}}
\index{GKS routine!{\protect\tt GRQST}}
\index{GKS routine!{\protect\tt GRQSK}}
\index{GKS routine!{\protect\tt GRQVL}}
\index{GKS routine!{\protect\tt GRQPK}}
 
To request input one of the following calls needs to be made.
\begin{DLtt}{123456}
\item[Locator]CALL GRQLC(WKID, LCDNR, STAT, TNR, PX, PY)
\begin{DLtt}{123456}
\item[WKID](I) Workstation identifier
\item[LCDNR](I) The number of the logical locator device (usually 1).
\item[STAT](O) Error status (integer)
\item[TNR](O) The Normalization Transformation number used to
convert the input position to World Coordinates.
\item[PX,PY](O) The returned coordinates in WC.
\end{DLtt}
\item[String]CALL GRQST(WKID, STDNR, STAT, LOSTR, STR)
\begin{DLtt}{123456}
\item[WKID](I) Workstation identifier
\item[STDNR](I) The number of the logical string device (usually 1).
\item[STAT](O) Error status (integer)
\item[LOSTR](O) string length
\item[STR](O) The returned character string
\end{DLtt}
\item[Stroke]CALL GRQSK(WKID, STDNR, N, STAT, TNR, NPX, PX, PY)
\begin{DLtt}{123456}
\item[WKID](I) Workstation identifier
\item[STDNR](I) The number of the logical stroke device (usually 1).
\item[N](I) Maximum number of points (size of point arrays).
\item[STAT](O) Error status (integer)
\item[TNR](O) The Normalization Transformation number used to
convert the input position to World Coordinates.
\item[NPX](O) Number of points returned.
\item[PX,PY](O) The returned coordinate arrays (WC).
\end{DLtt}
\item[Valuator]CALL GRQVL(WKID, VLDNR, STAT, VAL)
\begin{DLtt}{123456}
\item[WKID](I) Workstation identifier
\item[VLDNR](I) The number of the logical valuator device (usually 1).
\item[STAT](O) Error status (integer)
\item[VAL](O) The returned value (real number).
\end{DLtt}
\item[Choice]CALL GRQCH(WKID, CHDNR, STAT, CHNR)
\begin{DLtt}{123456}
\item[WKID](I) Workstation identifier
\item[CHDNR](I) The number of the logical choice device (usually 1).
\item[STAT](O) Error status (integer)
\item[CHNR](O) The returned choice number (integer).
\end{DLtt}
\item[Pick]CALL GRQPK(WKID, PCDNR, STAT, SGNA, PCID)
\begin{DLtt}{123456}
\item[WKID](I) Workstation identifier.
\item[PCDNR](I) The number of the logical pick device (usually 1).
\item[STAT](O) Error status (integer)
\item[SGNA](O) Picked segment name.
\item[PCID](O) Pick identifier (integer set by GSPKID).
\end{DLtt}
\end{DLtt}
\subsection{Initializing Logical Input Devices}
\index{initializing logical input devices}
 
For each of the input classes there is an initialization function which
can change the values set as default by GKS for use in Request Mode
(and which should be called after the mode has been set).
The function calls are:
\index{GKS routine!{\protect\tt GINCH}}
\index{GKS routine!{\protect\tt GINLC}}
\index{GKS routine!{\protect\tt GINST}}
\index{GKS routine!{\protect\tt GINSK}}
\index{GKS routine!{\protect\tt GINVL}}
\index{GKS routine!{\protect\tt GINPK}}
\begin{DLtt}{123456}
\item[Initialize locator]CALL GINLC(...)
\item[Initialize string]CALL GINST(...)
\item[Initialize stroke]CALL GINSK(...)
\item[Initialize valuator]CALL GINVL(...)
\item[Initialize choice]CALL GINCH(...)
\item[Initialize pick]CALL GINPK(...)
\end{DLtt}
\index{echo area}
\index{normal!transformation}
\index{transformation!input initialization}
For all the input classes the echo area can be changed
(i.e. the portion of the display surface where the prompt appears and
which can accept input from the operator).
For Locator and Stroke input the initialization function sets the
initial normalization transformation and the initial locator position.
The initialization functions also select the required prompt/echo type.
 
A detailed description of the initialization functions is outside the scope
of this Primer, so those readers who wish to dig somewhat deeper should
consult the reference manual for the GKS implementation being used.
An example using GKSGRAL may be found in
Appendix on Page~\pageref{sec:iinput}).
\subsection{Input Inquiry Functions}
\index{input!inquiry functions}
 
There are two types of inquiry functions for GKS input. The first
is {\it Inquire Device State}, and the information is obtained by
calling GQCHS, GQLCS, etc.
The second is {\it Inquire Default Device Data} and the
information is obtained by GQDVL, GQDST etc. There is also a function
GQLI which can inquire the number of available logical input devices.
A detailed description of these functions is outside the scope of this
Primer, and so for more information the reader is referred to the
GKSGRAL manual or one of the texts in the bibliography.
\chapter{GKS Metafiles}
\index{metafiles}
 
GKS provides metafiles for the storage of graphical information.
Their principal uses are:
\begin{OL}
\item transporting graphical information between computer systems
\item transporting graphical information from one site to another
(by magnetic tape for example)
\item device spooling, e.g. for a plotter
\end{OL}
\index{Appendix E metafile}
 
There is no official ISO standard for writing a GKS metafile.
However, in Appendix E of the ISO GKS Functional Description
document a metafile format is described, and its use is recommended.
A GKS metafile created using this format is
known as an Appendix E metafile.
Unfortunately, not all implementations follow the Appendix E format,
and so metafiles created by different GKS packages may be incompatible.
In fact, even different examples of Appendix E metafiles may be
incompatible due to variations in the file record lengths, etc.
\section{Writing Metafiles}
 
A GKS metafile is produced by a standard GKS output-only workstation.
The workstation must first be 'opened' (GOPWK), then 'activated' (GACWK),
and all graphical information following these calls is recorded on the
metafile as a series of items (listed in an appendix of the
{\it GKS/GKS-3D Primer})
until a 'deactivate workstation' is encountered (GDAWK).
Hence the application must control it in the same way as a terminal
or a plotter. Clearly, some of the workstation inquiry functions,
such as Inquire Text Extent, can not be used because this knowledge
depends on the device(s) ultimately chosen to interpret the metafile.
Thus, a GKS metafile does not record a complete 'picture' so much
as all the actions performed to make such a picture. If the application
deletes segments and then draws different ones, all this will be recorded
on the metafile if it is active.
 
This last point has a number of ramifications. Because the metafile
{\it captures} all the output generated whilst it is active,
it could be used to record a dynamic sequence, like a cartoon,
as long as it is re-interpreted onto a dynamic display system.
However, if the object of the exercise is to interpret the metafile onto
a hardcopy device, it is not clear what the interpreter would be expected
to do with, for example, a Delete Segment operation!
Thus, for this kind of use, the metafile workstation should only be
activated when a finished picture is ready to be output, perhaps by
copying the image from WISS. A classic mistake is to leave the metafile
workstation activated whilst one works interactively on a terminal,
and then crash when all the available disc space is used up.
\index{GKS routine!{\protect\tt GOPWK}}
\index{GKS routine!{\protect\tt GACWK}}
\index{GKS routine!{\protect\tt GDAWK}}
\index{GKS routine!{\protect\tt GCLWK}}
\index{conid}
\index{connection identifier}
 
To open an Appendix E metafile workstation the call is:
\begin{XMP}
CALL GOPWK(WKID, CONID, WTYPE)
\end{XMP}
where the parameter WTYPE specifies the metafile workstation which is
defined in the documentation for the GKS implementation in use
(see Appendix on Page~\pageref{sec:gtstyp} for the GKSGRAL values).
 
\index{VAX!metafile open}
\index{IBM!metafile open}
The metafile will be written to the logical unit number corresponding
to the connection identifier (conid) in the GOPWK call
(see section on Page~\pageref{sec:conref} for legal values).
On VM/CMS, a conid of XX with no OPEN or FILEDEF statements would result
in a metafile name 'FILE~FTXXF001'.
A convenient way to declare FILEDEFs from a FORTRAN program is to use
the CERN library routine VMCMS (code Z305).
However, Version 2.3 of the VM/CMS FORTRAN compiler provides the
possibility to specify the file name in the OPEN statement,
and this is now the recommended mechanism. A '/' is required
before the filename:
\begin{XMP}
OPEN(UNIT=CONID, FILE='/filename filetype filemode', STATUS='NEW')
\end{XMP}
 
On VAX/VMS the metafile can be written to a file which should be opened
prior to the call to GOPWK. If there is no OPEN statement, the metafile will
be written to FOR0XX.DAT, where XX is the specified conid, unless
FOR0XX is defined as a logical name.
Under VMS, the OPEN statement should read:
\begin{XMP}
OPEN(UNIT=CONID, FILE='filename.ext', STATUS='NEW')
\end{XMP}
 
On APOLLO the OPEN statement is mandatory with a format as above.
On the CRAY the OPEN statement is optional. If it is missing, then
the file will be given the name 'fort.N' where N is a number from 1 to
99 corresponding to the connection id. Note that unlike on VMS,
a value of N from 1 to 9 has no leading 0.
If a file name has not been defined via the open statement, then one can
be assigned using the command 'assign~-a~myname~fort.N'.
\section{Shipping Metafiles}
 
One of the fundamental uses of a metafile is that it can
be stored in a device independent manner and transferred to
other hosts and other sites where it can be subsequently interpreted.
Metafiles at CERN are normal text files written in 80 character records,
which makes transfers between host computers straightforward.
However, it should be mentioned that for transfers from VAX/VMS to VM/CMS
using NFT, the qualifier '/CR' is essential if the file has not been
opened using the parameter CARRIAGECONTROL='LIST'.
The REXX exec below gives an example of an appropriate metafile transfer
using interlink:
\begin{XMP}
/* Interlink metafile transfer */
'exec nft receive vxcern::disk$gg:[userid]gts.met gts metafile a/cr'
\end{XMP}
\section{GRVIEW and the Interpretation of Metafiles}
\index{metafile!interpreter}
\index{interpreting metafiles}
\index{GRVIEW}
\index{editor}
 
To use the graphical information stored in the metafile it must be
interpreted so that the original picture can be re-created on whatever
device the application requests.
GKS provides three functions in order to interpret metafiles,
and these may be called by applications which require to manipulate
the contents of a metafile explicitly:
\index{GKS routine!{\protect\tt GRDITM}}
\index{GKS routine!{\protect\tt GGTITM}}
\index{GKS routine!{\protect\tt GIITM}}
\begin{DLtt}{123456}
\item[GGTITM]get item from metafile
\item[GRDITM]read item from metafile
\item[GIITM]interpret item from metafile
\end{DLtt}
 
In order to view a GKS metafile on a terminal a program is available
called {\bf GRVIEW}.
This is an interactive program which allows the user to view and/or edit
the pictures (frames) in one or more metafiles.
The pictures may be viewed sequentially,
or it is possible to skip frames to get to a particular picture.
If the frames have been named using the {\bf GCNAME} function,
then it is possible to search for pictures by name, and also to make
a directory list of all pictures on the metafile.
 
\index{PostScript}
After viewing a picture the user has the possibility to write it out
onto a GKS metafile, or in various other formats, including PostScript
and Tektronix 4014 escape codes.
This allows sub-sets of the pictures on the original file to be produced.
There is also a feature provided which allows the position and scale of the
Workstation Viewport to be re-set. Thus, the size of the output picture can
be changed to suit better a particular device.
 
Without being quite so sophisticated, GRVIEW attempts to provide the sort
of capabilities available on commercial products such as {\it MACDRAW},
except that GRVIEW runs on VAX, APOLLO, and IBM computers with any GKS
supported terminal. Having said this, it should be clear that the
'user friendliness'  of an editor is much greater on a colour APOLLO
or VAX workstation, or on a Tektronix 4207, than on a machine with only
the capabilities of a Tektronix 4014.
 
GRVIEW operates in one of three modes, which are selected on the command line:
\begin{OL}
\item VIEWING mode is the default. In this case GRVIEW is used to allow the
pictures on the metafile to be displayed on a graphics terminal.
In this pure viewing mode GRVIEW does not make use of any internal picture
storage and so will run more efficiently.
\item COPY mode also allows the input metafile to be displayed, but in
addition frames may be selected for copying onto an output file.
This may be another metafile, a PostScript file, or a file containing
Tektronix 4014 escape sequences. In copy mode the contents of each picture
may not be changed, but each picture may be named (if it is not already),
scaled in size, and several pictures may be packed onto a single page.
\item EDIT mode allows the pictures on an input metafile to be edited,
or for a completely new picture to be generated from scratch.
\end{OL}
 
Depending on the system in use, GRVIEW allows parameters to be provided
on the command line, or via an interactive dialogue. The program also
prompts the user to provide any missing information.
The user now HAS to define which terminal type is
being used because the diversity of incompatible terminals available does
not permit a useful default to be chosen.
There are also features which warn the user if too many GKS errors have
been produced (to avoid filling up the user's file space with messages),
and which allow VM/CMS users to regain control after a pre-set number of
graphics operations as VM has no simple interrupt facility.
 
\index{HELP}
\index{FIND}
More details of how GRVIEW operates may be found in reference
\cite{bib-grref}, or by typing {\bf HELP~GRVIEW} or
{\bf FIND~GRVIEW}.
\section{GRCONV and the Conversion of Metafiles}
\index{converting metafiles}
\index{GRCONV}
 
As described in section on Page~\pageref{sec:mhcpref}, metafiles may be used for
the production of hardcopy output via the command {\bf GRPLOT}.
However, there are output devices for which there may not be support within
GRPLOT, or it may be desired to combine pictures into documents existing
in a particular output format or Page Description Language.
For these and other reasons it is often useful to be able to transform
a metafile into a different format, and to accomplish this the utility
{\bf GRCONV} has been written. Note, however, that keeping the
original picture in the form of a metafile is the most flexible, as
this does not place any restrictions on its final use.
 
GRCONV converts the input metafile to a new format which is stored on one
or more output files. For example, GRCONV can produce as output
normal or Encapsulated PostScript files, files of Tektronix 4014%
\footnote{Will be installed on VM/CMS if there is a demand.}
escape sequences, or bit maps in IBM~3812 format.
The PostScript files may be printed at CERN using the {\bf XPRINT}
command, as well as being used as a mechanism for the transmission of pictures
for printing at external institutes.
Pictures encoded in Encapsulated PostScript format
(see section on Page~\pageref{sec:epsref})
also may be incorporated into documents produced by SGML, BookMaster,
or TeX text processing systems.
The Tektronix 4014 escape sequences may be used to drive some laser printers,
including the DEC LN03, which do not support PostScript.
 
GRCONV operates in one of three modes: {\bf Interactively}, in which it
prompts for input and allows a selection of pictures chosen by commands from
an alpha-numeric terminal to be converted; {\bf Batch}, in which all the
relevant parameters must be given on the command line and in which the whole
metafile is converted; and {\bf Remote-Batch} which is similar to the
last case but in which the command is executed on a remote machine.
Thus, whilst Interactive and Batch modes run locally, the
Remote-Batch mode allows the input metafile to be converted into a form
which may only be available on the remote host. For example, this feature
allows GRCONV to subsume the old GKSSGML by producing a set of IBM-3812
bitmap files on CERNVM.
 
\index{HELP}
\index{FIND}
More details of how GRCONV operates may be found in reference
\cite{bib-grref}, or by typing {\bf HELP~GRCONV} or
{\bf FIND~GRCONV}.
\chapter{\protect\label{sec:hcopy}Making Hardcopies}
\index{hardcopy}
 
It is possible to make hardcopy plots either interactively with GKS or via
a metafile. Some devices accept acetate sheets, which allow transparencies
to be produced for overhead projectors.
The GKS plotter or metafile workstations operate just like any other,
with an important exception. Namely, functions such as 'Delete Segment'
will not undraw what has been output on the paper!
Thus, when making a hardcopy, it is suggested that the picture to be plotted
is produced first interactively on a terminal screen and stored in
WISS (Workstation Independent Segment Storage). During this time
the plotter or metafile workstation should be deactivated.
When the picture is complete, and does not require further modification,
then the plotter or metafile workstation may be activated and the
WISS segments containing the picture sent to it by calling
Associate SeGment to WorKstation (GASGWK).
\section{Hardcopies via an Interactive Program}
 
Plotter output may be produced by an interactive program running on a
machine directly connected to a hardcopy device.
For example, GKSGRAL at CERN supports Hewlett Packard pen plotters,
VERSATEC electrostatic and thermal plotters, and any laser printer
\index{VERSATEC}
\index{PostScript}
driven via the PostScript interface. (See the latest version of the
include file {\it GTSDEV} for a complete up-to-date
list of supported devices.)
 
In the case of VERSATEC or PostScript,
an intermediate plot file is generally produced
which must be queued to the device.
However, use of an HP plotter normally assumes that the device is connected
directly in parallel with the terminal line, and it is activated by special
escape sequences sent by the driver, but it is also possible to produce
an HP plotter file by specifying a connection identifier of
conid~=~(100~+~n), where n is a small integer greater
than 1. This causes the output to be written to FORTRAN Logical Unit number n,
and the file has the name PLxxxx.PLT, where 'xxxx' indicates the
workstation type. Some laser printers do not support
PostScript but do, in fact, support the Tektronix 4014 protocol.
In this case it is possible to capture the 4014 escape codes
on a file which is later sent to the printer. In any case,
to capture the graphics on a file, first open a file on unit n,
and then open the corresponding GKS
workstation with a conid of (100~+~n).
 
Note that use of a hardcopy device via an interactive program has the
advantage that the application can inquire the specific device
characteristics, and thus tailor the output accordingly.
\section{\protect\label{sec:mhcpref}Hardcopies via a Metafile}
\index{GRPLOT}
\index{GKSVT}
\index{GKSCP}
\index{GKSX87}
\index{GKS3812}
\index{APA 6670}
\index{VERSATEC}
\index{XEROX}
\index{PostScript}
\index{IBM!metafile hardcopy}
\index{IBM!3812}
 
Using a metafile it is possible to make hardcopy plots on devices connected
to the central computing facilities. The devices currently supported
include:
\Lit{$==>$} To be updated ...
\begin{UL}
\item VERSATEC Model CE 3236E (colour with 36 inch roll paper, 400 dpi)
\item VERSATEC Versacolor Model VE2700 (white and transparent A4 cut sheet)
\item XEROX Model 4050 Laser Printer (A4 cut sheet)
\item IBM 3812 Laser Printers  (A4 cut sheet)
\item PostScript printers, such as Apple Laser Writers, etc.
\end{UL}
 
It is not necessary to be logged on to one of the computer centre machines
to use these services. The command {\bf GRPLOT} may be used to output
metafiles on any of the central plotting devices from all centrally supported
machines at CERN connected via either the DECNET or TCP/IP protocols,
as the command first transfers the metafile over the network
to the correct destination.
The GRPLOT command has replaced the previous
collection of GKSVT, GKSCP, GKSX87, and GKS3812;
rather than having a separate command for each plotter, the output device is
provided as a parameter. The mechanism for naming output devices is the
same as that for the latest version of XPRINT.
 
\index{HELP}
\index{FIND}
More details of how GRPLOT operates may be found in reference
\cite{bib-grref}, or by typing {\bf HELP~GRPLOT} or
{\bf FIND~GRPLOT}.
\begin{note}
Postscript and VERSACOLOR colour plotter produces output on
A4 cut sheets. However, the paper and ink donor rolls are expensive.
Thus, users are asked to use the device only for the final
version of their plots, and not whilst debugging programs.
Plots can not be released automatically, and users have to release them by
hand using a terminal next to the device
which is installed in the user area on the ground floor of
building 513.
\end{note}
\section{\protect\label{sec:sgmlgra}Mixed Text and Graphics}
\Lit{$==>$} To be updated ...
\subsection{Via SGML/BookMaster}
\index{SGML}
\index{PostScript}
\index{BookMaster}
\index{GRCONV}
 
A version of the document markup language SGML layered on top of the
IBM BookMaster product \cite{CERNSGM1} is implemented on the central
VM/CMS service and supports the inclusion of pictures into compound
documents.
The syntax of SGML/BookMaster is not identical to that of the original
Waterloo/Script based SGML implementation available at CERN, but the procedure
is similar. Namely,
\begin{OL}
\item Use a graphics application program, including calls to GCNAME,
to produce a metafile.
\item Run GRCONV to produce the set of picture files.
\item Mark-up a document with SGML/BookMaster and associate the picture files
with particular figures within the document.
\item Run SGML/BookMaster on the document.
\item Edit the document as necessary and repeat previous step until
result is satisfactory.
\end{OL}
Note that it is not necessary to repeat the first two steps every time
SGML/BookMaster is used to re-process the document as long as the picture
files are stored on the user's mini-disk.
 
The GRCONV command can be used to generate the picture files,
but as it is possible to print the resulting document on either IBM-3812
compatible or PostScript printers the user must take care to select
the correct output format.
As it would be cumbersome to require every picture to be stored in
its own metafile and processed separately, GRCONV can handle metafiles
which contain several pictures (separated by 'CLEAR WORKSTATION' items),
and be instructed to produce a separate output file for each picture on the
metafile.
If the user is not working under VM/CMS%
\footnote{Care must be taken to ensure that there is no conflict
in having GRCONV write to a VM/CMS mini-disk which is accessed in
write mode by another process. The user should have a write password
on a mini-disk available for access by GRCONV in write-mode},
GRCONV first transfers the metafile to the user's VM account, and then
interprets it to produce the required set of output files.
Note that GRCONV replaces the command GKSSGML, and has a wider range of
features.
 
A complete job to print a PostScript picture is given below.
PostScript pictures can be scaled at will, but if a {\bf BoundingBox}
command is present in the Encapsulated PostScript file,
the WIDTH parameter of the {\bf ARTWORK} tag is redundant,
and the size specified by the BoundingBox or DEPTH inside the file will
be used. In order to avoid conflicts in the X and Y scaling,
users are advised not to specify both DEPTH {\it and} WIDTH.
\begin{XMP}
<!DOCTYPE USERDOC SYSTEM "USERDOC DTD *" [
<!-- Declare the Encapsulated PostScript file -->
<!ENTITY FIGURE1 SYSTEM "MYFIG1$S EPS" CDATA EPS>
]>
<USERDOC>
<PROLOG>
<DOCPROF>
</PROLOG>
<BODY>
<... some text
<ARTWORK NAME=FIGURE1 DEPTH=17CM ALIGN=CENTER>
\end{XMP}
 
The procedure for output onto an IBM-3812 compatible printer
(IBM-3812 or IBM-3816) is similar, but in this case
the graphics image is stored not in an Encapsulated PostScript
file but in a PSEG3820 image file which cannot be scaled.
\begin{XMP}
<!DOCTYPE USERDOC SYSTEM "USERDOC DTD *" [
<!-- Declare the PSEG      file -->
<!ENTITY FIGURE1 SYSTEM "MYFIG1$S PSEG3820 *" NDATA PSEG>
]>
<USERDOC>
<PROLOG>
<DOCPROF>
</PROLOG>
<BODY>
\chapter{Title text}
<ARTWORK NAME=FIGURE1>
\end{XMP}
 
Note that the figure name {\it FIGURE1} specified by the {\bf NAME}
attribute of the {\bf ARTWORK} tag is defined at the beginning of the
file via the {\bf ENTITY} declaration. Thus, the actual file name
on the user's disk and the name of the figure in the text are decoupled;
one can change the figure used by changing the ENTITY declaration
and without modifying the body of the text.
There should be one picture file and one ENTITY declaration for each figure.
 
SGML/BookMaster does not place restrictions on the file names used,
but the original CERN implementation of SGML did. Thus, for backwards
compatability, GRCONV still generates file names conforming
to the old convention: the file name must contain
eight (8) characters terminating in an 'S'.
As described in section on Page~\pageref{sec:gcnref},
if the name supplied by the application
which calls GCNAME provides less than 7 characters, then GCNAME pads the name
out with \Lit{'$'}s. Hence \Lit{'MYFIG1'} becomes \Lit{'MYFIG1$S'}.
If GCNAME was not used by the application to write names for
each figure onto the metafile then GRCONV will generate names
for each picture file automatically. The algorithm used is described
in \cite{bib-grref}.
\subsection{Via Waterloo/Script SGML}
\Lit{$==>$} KEEP it ???
\index{SGML}
\index{GGRCONV}
 
The original version of the document markup language SGML \cite{bib-sgmlref}
implemented on the central VM/CMS service supports the inclusion of pictures.
However, note that this SGML implementation is being replaced
by a new one layered on top of the IBM BookMaster product (see above).
 
For each picture to be included when using the IBM-3812 
output devices SGML requires two files;
one to define the amount of space to be reserved within the document,
and one containing the actual bit-map. These files must be accessible to
SGML on one of the users mini-disks.
As described in \cite{bib-sgmlref}, the files may originate from several
sources. This section will discuss how to use the {\bf GRCONV} command to
produce them from a GKS metafile and store them on the specified mini-disk.
 
The sequence of operations would be:
\begin{OL}
\item Use a graphics application program, including calls to GCNAME,
to produce a metafile.
\item Run GRCONV to produce the set of picture files and store them on
a user disk.
\item Mark-up a document with SGML and associate the picture files
with particular figures within the document.
\item Run SGML on the document.
\item Edit the document as necessary and repeat previous step until
result is satisfactory.
\end{OL}
Note that it is not necessary to repeat the first two steps every time
SGML is used to re-process the document so long as the picture files
are stored on the user's disk.
 
An example of the SGML syntax necessary to include a figure corresponding
to a pair of picture files would be:
\begin{XMP}
<FIG>
<PICTURE NAME=XXXXXXXS>
<FIGCAP>This is the Figure Caption
</FIG>
\end{XMP}
When SGML encounters the tag 'PICTURE' it reads a file
specified by the 'NAME' attribute.
The name {\bf must} consist of 8 characters ending with an 'S'.
The file type under VM/CMS is 'SGML'. (The name of the corresponding
bit-map file has the same first 7 characters, but the eighth is 'P'.)
The GRCONV command can be used to generate these two files.
In fact, as it would be cumbersome to require every picture to be stored in
its own metafile and processed separately,
GRCONV can handle metafiles which contain several pictures (separated by
'CLEAR WORKSTATION' items). It then produces one pair of output files
for each picture on the metafile.
If the user is not working under VM/CMS, GRCONV first transfers the metafile to
the user's VM account, and then interprets it to produce the required
set of output files. (Care must be taken to ensure that there is no conflict
in having GRCONV write to a VM/CMS mini-disk which is accessed in
write mode by another process. The user should have a write password
on a mini-disk available for access by GRCONV in write-mode.)
Note that GRCONV replaces the command GKSSGML,
and has a wider range of features.
\subsection{Via \LaTeX}
\index{latex@\LaTeX}
 
As the mechanism used to incorporate pictures into TeX documents depends
not on TeX itself, but on the printer driver used by TeX, no single
mechanism exists to achieve this. Thus, unfortunately, the procedure
varies and is not described here. For details, see \cite{bib-TAC}.
 
Assuming the hardcopy will be onto a device which supports PostScript
or an IBM-3812, then GRCONV should be used to produce an Encapsulated PostScript
or PSEG38PP/PSEG3820 file as for the SGML/BookMaster case above.
\subsection{\protect\label{sec:gcnref}Naming Pictures}
\Lit{$==>$} Keep ???
\index{GCNAME}
\index{GKS routine!{\protect\tt GCNAME}}
 
In order to include pictures within a document clearly it is necessary to
have some way in which to designate which picture goes where.
Thus, the pictures require naming in some way.
To accomplish this, a routine called GCNAME has been added to the
GKSGRAL and GKSGRAL-3d libraries.
(It is available also for DECGKS, and in source format in GKSPACK.)
 
GCNAME outputs a user item containing a name string onto the metafile
and, for example, this is used by GRCONV to generate the file names,
and by GRVIEW to allow the user to choose by name the picture to be edited.
GCNAME should be called to name a picture immediately after the previous
picture delimiter (Clear Workstation) and before any primitives or attributes
for the named frame have been written out. The call is:
\begin{XMP}
CALL GCNAME(WKID, NAME)
\end{XMP}
where WKID is the metafile workstation identifier,
and NAME is a FORTRAN variable or constant of type CHARACTER
and with a length of {\bf seven (7)} characters.
The seven characters must correspond to the 'XXXXXXX' preceeding the 'S'
used in the picture NAME tag used by SGML.
If less than 7 characters are used then GRCONV
will pad the name out with dollar signs (\Lit{'$'}).
Thus, if a picture was named 'FPROJ' by GCNAME, then the corresponding SGML
NAME tag would need to be be \Lit{'FPROJ$$S'}.
This convention is maintained for backwards compatability, although
it is not required by SGML/BookMaster.
 
Even though not required for other operating systems, in order
to remain compatible with the file naming scheme used by VM/CMS,
GCNAME restricts the character set allowed for GCNAME to upper-case alphabetic,
the digits 0-9, and the dollar sign (\Lit{'$'}).
Lower-case characters are automatically converted to upper-case.
This is also why the number of characters is limited.
 
In order to avoid getting spurious or empty picture files produced by
GRCONV, application code should issue the Clear Workstation call to
the metafile workstation only if a complete picture really has been written to
the file.
\subsection{\protect\label{sec:epsref}Encapsulated PostScript}
\index{Encapsulated PostScript}
\index{PostScript}
 
It is possible to use the GKS PostScript driver in order to produce output
files in the format {\bf Encapsulated Postscript}, which is used by
various text-processors (TeX, SGML, BookMaster, etc.) in order to combine
PostScript-encoded data originating from different sources.
Encapsulated Postscript format is similar to standard PostScript but
with some additional header information concerning the picture size.
The PostScript instruction "showpage" which is normally included
at the end of the file in order to tell the interpreter to print the
preceeding information is removed in the Encapsulated format.
This avoids any conflict with the contents of other PostScript files
into which the Encapsulated file may be embedded.
Thus, sending an Encapsulated PostScript file to a printer directly will
not produce any output.
 
It is possible to use GRCONV to convert a GKS metafile to Encapsulated
PostScript format by specifying the requisite qualifier ('EPSPM', ...).
If the input metafile contains several pictures it is also possible to
use the 'SPLIT' option in order to get one output file per picture.
 
If a PostScript file is to be produced directly by a GKS application
program then the following applies:
\begin{OL}
\item
Open a GKS PostScript Workstation. The Workstation Type is the same
for both normal and Encapsulated PostScript formats.
\item
As for all drivers, if the connection identifier is less than 100
(see on Page~\pageref{sec:conref}) then the PostScript instructions
are sent directly to the terminal.
(Useful if the terminal supports Display PostScript).
\item
If the connection identifier is greater than 100 but less than 200
(conid~=~100~+~n), then PostScript instructions will be
written to a file in normal PostScript format opened on unit number 'n'.
The file may include several pictures.
\item
If the connection identifier is greater than 200
(conid~=~200~+~n), then PostScript instructions will be
written to a file in Encapsulated PostScript format opened on unit number 'n'.
Only one picture should be included per file.
\end{OL}
\section{Use of Workstation Transformations to Change Picture Size}
\index{workstation transformation}
\index{picture size}
\index{size}
 
When using GKS from an application program it is not necessary to
specify a workstation transformation to set the size of the output picture.
In this case, the Normalization Viewport will automatically be made to map to
the largest possible square which fits onto the output device display surface.
This is often acceptable for an interactive graphics session.
However, when making a hardcopy image, especially if this
must fit within a document, then the actual size of the picture may
well be very important.
The GKS Workstation Transformation, which is described fully in
on Page~\pageref{sec:gkspr}, allows the actual area required
to be specified in metres.
A brief summary will be given here.
 
The {\it Workstation Transformation} defines which part of the
Normalized Device Coordinate (NDC) space will
be visible, and where it will appear on the display surface.
It is set by calling the functions Set WorKstation WiNdow and
Set WorKstation ViewPort:
\begin{XMP}
\index{GKS routine!{\protect\tt GSWKWN}}
\index{GKS routine!{\protect\tt GSWKVP}}
CALL GSWKWN(WKID, WXMIN, WXMAX, WYMIN, WYMAX)
 
CALL GSWKVP(WKID, VXMIN, VXMAX, VYMIN, VYMAX)
\end{XMP}
Set Workstation Window specifies in NDC coordinates the area of the NDC
space to be output to the device. Set Workstation Viewport specifies in
{\it Display Coordinates} (DC) where on the device the window will appear.
The aspect ratio for the workstation window and the workstation viewport
{\bf must always be the same}.
If they are not, then {\bf the specified transformation is ignored},
and the complete workstation window is displayed on the device
in the correct aspect ratio.
 
As an example, suppose that the picture occupies the area (wxmin,~wymin)
to (wxmax,~wymax) in World Coordinates. This may be mapped via the
Normalization Transformation to a Viewport (vxmin,~vymin) to
(vxmax,~vymax), and this does not have to preserve the aspect ratio.
This Viewport must now be output onto an A4 sheet so as to fill the width
of the page, assuming an aspect ratio with width~>~height.
\begin{note}
Although the width of an A4 page is 21cm, most output devices do not
permit the full width to be used. Consult the Workstation Description Table
for the device to find out what is the maximum size.
\end{note}
\begin{XMP}
C  Set the Window and Viewport for Normalization Tfrm 'trn'
C  and select this Normalization Tfrm for future primitives.
C
      CALL gswn  (trn,  wxmin, wxmax, wymin, wymax)
      CALL gsvp  (trn,  vxmin, vxmax, vymin, vymax)
      CALL gselnt(trn)
C
C  Set the Workstation Window and Workstation Viewport
C  Note that 18.9 cm is the maximum width for PostScript Portrait Mode
C  (The Workstation Window to map from the Normalization Viewport)
C
      CALL gswkwn(wkid, vxmin, vxmax, vymin, vymax)
      CALL gswkvp(wkid, 0.0,   0.189,
     *                  0.0,   0.189*(vymax-vymin)/(vxmax-vxmin))
\end{XMP}
\chapter{GKS-3D Primer}
\index{GKS-3D}
\begin{note}
Whilst in general the information in this Primer is independent of
a particular GKS implementation, this is not entirely the case for
GKS-3D. The reason is that the goal of the Primer is not simply
to describe the functionality of GKS, but to explain in detail
how it may be used via the FORTRAN language binding.
However, as the binding has not yet been completely finalised for
GKS-3D, this chapter explains its use in terms of a
particular implementation, namely GKSGRAL-3D Version 2.0.
 
The text of the Draft International Standard for the GKS-3D
FORTRAN binding was published at the end of 1988,
with voting to finish by May, 1989.
Discrepancies between the FORTRAN DIS and GKSGRAL-3D Version 2.0 are minor,
and are mentioned at the appropriate places within the chapter.
Only the setting of the viewing parameters and the aspect source
flags are affected, and the text will be revised after the final
voting on the standard is complete.
The changes between VSN 1.1 and VSN 2.0 of GKSGRAL-3D
are described in Appendix on Page~\pageref{sec:vsn2upd}.
\end{note}
\section{Introduction to GKS-3D}
 
GKS-3D is a pure super-set of GKS designed to handle 3D graphics in
a compatible way. That is to say, a 2D application written to
the GKS standard is guaranteed to run in a GKS-3D environment
without change. However, apart from the usual GKS functions,
GKS-3D provides additional ones to handle 3D primitives,
3D input, and 3D viewing.
As for GKS, the standard is in multiple parts with the language
bindings separate from functional specification.
The FORTRAN binding is defined in \cite{bib-gksftn3}.
 
All primitives within GKS-3D are deemed to be three dimensional.
Thus, although an application using GKS-3D may make only 2D function
calls, all the 2D primitives will be turned immediately into the
corresponding 3D versions inside the package by the addition of
a Z coordinate. This has several noticeable effects:
\begin{UL}
\item 2D function calls may be slightly slower than 3D ones (using the
same GKS-3D package), as a 2D call will add a Z coordinate
and then make the corresponding 3D function call.
\item 2D applications running on GKS-3D will take more storage space
in WDSS and WISS.
\item A 2D picture stored on a 3D metafile will require more space
than on a 2D metafile. Also, quite clearly, {\bf such a picture could
not be re-interpreted by reading the metafile into a GKS (2D)
implementation}.
\end{UL}
\section{The Drawing Primitives}
\index{GKS3D!drawing primitives}
\index{primitives!3D}
 
With one addition, GKS-3D supports the same GKS primitive types as
described in chapter on Page~\pageref{sec:dprim}.
Four of the functions are called in a similar way to that for GKS-2D,
but with the addition of a third coordinate:
\index{GKS routine!{\protect\tt GPL3}}
\index{GKS routine!{\protect\tt GPM3}}
\index{GKS routine!{\protect\tt GFA3}}
\index{GKS routine!{\protect\tt GGDP3}}
\begin{DLtt}{123456}
\item[Polyline 3D]CALL GPL3(N, PXA, PYA, PZA)
\item[Polymarker 3D]CALL GPM3(N, PXA, PYA, PZA)
\item[Fill Area 3D]CALL GFA3(N, PXA, PYA, PZA)
\item[GDP 3D]CALL GGDP3(N, PXA, PYA, PZA, PRIMID, IDR, DATREC)
\end{DLtt}
 
However, the 3D routines for Cell Array (GCA3) and Text (GTX3) have
calling sequences which are substantially changed.
GCA3 is not described here, and those brave enough to peruse
the standards document will see why. Concerning GTX3, it should be
emphasized that this function is only required if it is desired to place
text on a surface which is not parallel to the X-Y plane,
otherwise the 2D text function (GTX) is sufficient.
For example, one would need to use GTX3 to write 'MIGROS' on the
side of a truck drawn with some random orientation.
\index{text!3D}
\index{GKS routine!{\protect\tt GTX3}}
 
The function call for 3D Text is:
\begin{XMP}
CALL GTX3(PX, PY, PZ, TDX, TDY, TDZ, STR)
\end{XMP}
where the arguments are as follows:
\begin{DLtt}{123456}
\item[PX, PY, PZ]
Reference Point (start point of text string)
\item[TDX/Y/Z(2)]
Two Text Direction vectors (three real arrays of length 2).
\item[STR]
The character string to be output.
\end{DLtt}
For both GTX and GTX3 the character string, STR, is drawn in a plane.
The difference is that in the 3D case this {\it text plane} can be
oriented in space using two {\it text direction vectors}, U and V,
specified by TDX(1), TDY(1), TDZ(1), and TDX(2), TDY(2), TDZ(2).
The text is drawn in a plane perpendicular to the vector formed from
taking the vector product U~x~V,
and the origin of the local coordinate system in which the geometric
text attributes are measured is defined by the reference point, P.
The X axis of the local text coordinate system is parallel to the
first direction vector, U, and the Y axis is perpendicular
to this direction. Thus, the system reduces to the 2D case if
U and V are defined as (1,~0,~0) and (0,~1,~0).
An example program using 3D Text is given in Appendix on Page~\pageref{sec:ex3dv}.
 
The additional primitive, called {\it Fill Area Set}
(or {\it Fill Area Set 3}), generates a set of polygonal
areas which may be hollow or filled with a uniform colour,
pattern, or hatch style.
Thus, it allows the application to specify regions with holes,
or disjoint regions which must be treated as a single entity.
There are both 2D and 3D versions of Fill Area Set, and the
2D function will be added to the next revision of GKS.
Unlike the Fill Area primitive, Fill Area Set and Fill Area Set 3
have separate attributes, described below, to control the edge
style of the polygons.
The calls are:
\index{fill area set}
\index{GKS routine!{\protect\tt GFAS}}
\index{GKS routine!{\protect\tt GFAS3}}
\begin{XMP}
CALL GFAS(NPTR, PTR, PX, PY)
 
CALL GFAS3(NPTR, PTR, PX, PY, PZ)
\end{XMP}
where the arguments are as follows:
\begin{DLtt}{123456}
\item[NPTR]
(integer) Number of fill areas in set
\item[PTR(NPTR)]
(integer) Array of pointers to starting elements of lists in
PX(N), PY(N), PZ(N). Total number of coordinates is PTR(NPTR)-1.
\item[XA/YA/ZA(*)]
(real) List of points for all fill areas of the set.
\end{DLtt}
Thus, all the polygons are packed into the arrays, XA(N), YA(N), ZA(N),
and the start point of each polygon is indicated by the pointers in
the array PTR(NPTR).
 
\begin{note}
Although they are specified in a 3D space, the primitives Text,
Cell Array, Fill Area, and Fill Area Set are all {\bf coplanar}.
It is the responsibility of the application program to ensure that the
coordinates supplied fulfil this condition.
What happens if they are not coplanar is implementation-dependent!
\end{note}
\section{The Output Attributes}
\index{GKS3D!attributes}
\index{attributes!3D}
 
As for the primitives, GKS-3D uses almost the same output attributes as
GKS-2D (described in Chapter on Page~\pageref{sec:attrbs}), but with the
three following additions:
\begin{OL}
\item Extra attributes are required for the new Fill Area Set primitive.
\index{view index}
\index{GKS3D!view index}
\index{attributes!view index}
\item The {\it View Index} attribute.
This is analogous to the Normalization Transformation index attribute,
and specifies which viewing transformation is to be used to process
the primitive.
\item The {\it Hidden Line/Hidden Surface} (HLHSR) attribute specifies
which HLHSR algorithm should be used to process the primitive
(if HLHSR is supported by the workstation).
\end{OL}
 
The Fill Area Set primitive uses the same attributes as Fill Area to
control the interior of the polygons (see section on Page~\pageref{sec:attlst}),
plus the following which allow independent control of the edges:
\index{fill area set}
\index{GKS routine!{\protect\tt GSEDFG}}
\index{GKS routine!{\protect\tt GSEDT}}
\index{GKS routine!{\protect\tt GSEWSC}}
\index{GKS routine!{\protect\tt GSEDCI}}
\begin{DLtt}{123456}
\item[EDFLAG]
the Fill Area Set edge flag (ASF 1). Set by GSEDFG(EDFLAG).
EDFLAG may take the vales 'GON' or 'GOFF'.
\item[EDTYPE]
the Fill Area Set edge type (ASF 2). Set by GSEDT(EDTYPE).
EDTYPE is an integer value which is workstation-dependent.
\item[EDWSF]
the Fill Area Set edge width scale factor (ASF 3). Set by GSEWSC(EDWSF).
The value of EDWSF is a real number which modifies the width of the line
used to draw the edge of the Fill Area Set.
\item[EDCI]
the Fill Area Set edge colour index (ASF 4). Set by GSEDCI(EDCI).
\end{DLtt}
The numbers in brackets are, for the GTS-GRAL implementation,
the indices into the integer array ASFLST(4)
used to set the corresponding Attribute Source Flags by calling:
\index{GKS routine!{\protect\tt GASF3}}
\index{attribute source flags}
\begin{XMP}
CALL GASF3(ASFLST)
\end{XMP}
However, the DIS FORTRAN binding uses GASF3 to set all the
Attribute Source Flags in one go by defining the array ASFLST to be of
length 17, where elements 1 to 13 correspond to the 2D case and the last
four elements are those listed here.
 
Note that the Fill Area Set
primitive is rendered using two independent sets of attributes,
one for the interior, and one for the edge. This separate set of
edge attributes also has its own attribute bundle, selected by calling
GSEDI, plus a corresponding routine to Set the EDge Representation:
\index{GKS routine!{\protect\tt GSEDI}}
\index{GKS routine!{\protect\tt GSEDR}}
\begin{XMP}
GSEDI(EDI)
     and
GSEDR(WKID, EDI, EDFLAG, EDTYPE, EDWSF, EDCI)
\end{XMP}
\section{Viewing in 3D}
\index{GKS3D!viewing}
\index{transformation!3D viewing}
\index{viewing pipeline}
 
Setting up the {\it Viewing Parameters} is undoubtedly the most
complicated part of any 3D graphics system. When primitives are output
to a workstation they (conceptually) pass through a series of processes
called the {\it Viewing Pipeline} before they finally reach the
display surface. This pipeline is briefly described below in order that
the reader is aware of the complete process (see \ref{fig:pipe}).
The transformations will then be covered in more detail.
\begin{OL}
\item The primitives are transformed by the {\it Normalization
Transformation} from World Coordinates (WC3) to Normalized
Device Coordinates (NDC3), which are always in the range [0.0, 1.0].
This transformation is composed of a translation and change of scale,
but no rotation. GKS-3D allows for the existence of many World
Coordinates systems, and their corresponding Normalization
Transformations are numbered from 0 upwards. Normalization
Transformation 0 always corresponds to the identity matrix.
Normalization in 3D is exactly analogous to the 2D case described
in section on Page~\pageref{sec:nortrn}.
\item Primitives which are stored in segments are also processed by the
{\it Segment Transformation} before proceeding to the next stage.
In the 3D case this requires a 3~x~4 matrix which is
described below. The segment transformation maps NDC3 to NDC3,
and includes scaling, rotation, and translation.
\item Having assembled the components in a unique NDC3 space,
primitives may next be clipped to a box to remove extraneous
information. This is called the {\it Normalization Clip}, and may be
switched on or off using the {\it Normalization Clip Flag}.
\item The primitives are now 'viewed' from some arbitrary direction.
The {\it View Orientation Transformation} performs a rotation only
to take Normalized Device Coordinates to View Reference Coordinates
(VRC3). The application is free to calculate the corresponding matrix
itself, or to use a utility routine which is described below.
\item The {\it View Mapping (Projection) Transformation} next takes
View Reference Coordinates to Normalized Projection Coordinates
(NPC3)
in order to provide parallel or perspective projection of the image.
As for the View Orientation Transformation, the application is free
to calculate the required matrix using its own algorithm, or to call a
utility function.
\begin{figure}[h]
\caption{The GKS-3D Viewing Pipeline}
\label{fig:pipe}
\end{figure}
\item At this point the {\it View Clip} takes place.
It is positioned at this stage in the pipeline so that the clip box may be
defined as a rectangular parallelepiped with its sides parallel to
the axes of the NPC3 system, and thus the clipping algorithm is
more efficient. The View Clip is controlled by three {\it Clip Flags}
which allow clipping to be turned on or off separately for the
front plane, back plane, and window.
\item Finally, the {\it Workstation Transformation} takes
Normalized Projection Coordinates to Display Coordinates (DC3) in order
to position the projected image in the device coordinate space. It
preserves the aspect ratio, and includes a clipping operation which
cannot be disabled. As their clip faces are parallel, the View Clip and
Workstation Clip are usually combined internally for efficiency. DC3
coordinates may be in metres or raster units. The Workstation Window
limits are [0,1]x[0,1]x[0,1].
\end{OL}
 
A good implementation of the graphics pipeline will attempt to combine
as many as possible of the stages in the pipeline using matrix
concatenation in order to reduce the amount of computation necessary.
\subsection{The Normalization Transformation}
\index{normal!transformation}
\index{transformation!3D normalization}
 
As in the 2D case, this is specified by a Window volume in World
Coordinates, and a Viewport volume in Normalized Device Coordinates.
The Normalization Clip is controlled as for GKS-2D
(see section on Page~\pageref{sec:nrmclp}).
The calls are:
\index{GKS routine!{\protect\tt GSW3}}
\index{GKS routine!{\protect\tt GSV3}}
\begin{XMP}
CALL GSW3(TNR, WN)
 
CALL GSV3(TNR, VP)
\end{XMP}
where WN and VP are real arrays of dimension 6 containing (XMIN,
XMAX, YMIN, YMAX, ZMIN, ZMAX).
\subsection{The View Orientation Transformation}
\index{view orientation transformation}
\index{transformation!3D view orientation}
 
The {\it View Orientation Transformation} algorithm provided by a
utility function in the GKS-3D standard performs a rotation in three
dimensions in order to take Normalized Device Coordinates to View
Reference Coordinates (VRC3), where the axes are labeled U, V and N
(see \ref{fig:vrc}).
The definition of the UVN system requires the application to specify:
 \begin{OL}
\item The {\it View Reference Point} (VRP), which is a point on or
near the object to be viewed, and is the origin of the VRC3 system.
\item The {\it View Plane Normal} (VPN), which points from the
View Reference Point towards the eye point. The VPN is the third axis
of the VRC3 system, and the plane perpendicular to the View Plane Normal
through the View Reference Point is called the {\it View Reference Plane}.
\item The {\it View Up Vector} (VUV), which defines the direction
to be considered as 'UP' within the View Plane.
It is the second axis of the VRC3 system.
{\bf Clearly, the View Plane Normal and the View Up Vector must not
be defined to be collinear.}
 \end{OL}
\index{window}
\index{viewport}
Thus, in the View Reference system, the axis N is along the
View Plane Normal, the axis V is the projection of the View Up Vector
onto the View Reference Plane, and the axis U is constructed to form the
third axis of a right-handed coordinate system.
The default transformation sets the identity matrix.
The limits of the VRC3 system are [0,1]x[0,1]x[0,1].
\begin{figure}[h]
\caption[The GKS-3D View Reference System]%
        {The GKS-3D View Reference System.
The View Reference Point, defined in World Coordinates,
should be situated near the object to be viewed.
The View Plane Normal is directed at the eye point.
}
\label{fig:vrc}
\end{figure}
\subsection{The View Mapping (Projection) Transformation}
\index{view mapping transformation}
\index{projection transformation}
\index{transformation!3D view mapping}
 
The {\it View Mapping (Projection) Transformation} provided by a
utility function in the GKS-3D standard takes View Reference Coordinates
to Normalized Projection Coordinates (NPC3), and the projection may be
either parallel or perspective (see \ref{fig:proj}).
The default View Mapping Transformation sets the identity matrix.
 
The transformation maps the {\it View Volume} in VRC3 space to a
rectangular parallelepiped in Normalized Projection Coordinates.
The horizontal and vertical boundaries of the View Volume are specified
by the projectors drawn from the {\it Projection Reference Point}
(the centre of projection) to the corners of the {\it View Window},
which is a rectangle parallel to the View Reference Plane,
and with edges parallel to the U and V axes.
The View Window cuts the N axis of the VRC3 system at the
{\it View Plane Distance} (VPD) from the View Reference Point.
The hither (front) and yon (back) boundaries of the View volume are
specified by the {\it Front Plane} and the {\it Back
Plane}, which are planes parallel to the View Reference Plane at
distances from the View Reference Point called the {\it Front Plane
Distance} (FPD) and the {\it Back Plane Distance} (BPD).
 
The rectangular parallelepiped in NPC3 to which the View Volume is
mapped, called the {\it Projection Viewport Limits}, is
specified by the two points (XMIN, YMIN, ZMIN) and (XMAX, YMAX, ZMAX).
Although the View Mapping operation maps a volume to a volume,
which is slightly different from the usual idea of projection onto a plane,
a little thought should (hopefully) convince the reader that the effect is
equivalent. Consider looking at the result along the N axis; the effect is
that the contents of a truncated pyramid are distorted to map into a
rectangular volume, and thus objects closer to the viewer will be magnified.
 
For parallel projection, the projectors are parallel to a line drawn from
the Projection Reference Point to the centre of the View Window,
and thus the PRP should be set in the middle of the View Window
to produce an orthographic projection.
In this case the actual Z value of the PRP is unimportant, so long as it is
not identical to the View Plane Distance.
 
The {\it View Clip} takes place at the edges of the View
Clipping Limits according to the setting of the clipping indicators.
There are three of these: the x-y clipping indicator, the front clipping
indicator, and the back clipping indicator.
The default clipping limits are set to
[0,1]x[0,1]x[0,1] and all clipping indicators set to clip on ('GCLIP').
It would normally be the case that the View Clipping Limits and the
Projection Viewport Limits were set to the same values, but this is
not a requirement. If not set to be co-incident, there is clearly the
possibility for an application to clip away all of the image by mistake!
\begin{figure}[h]
\caption[The GKS-3D Projection System]%
        {The GKS-3D Projection System.
The figure shows the definition of the View Volume with
Perspective Projection.
}
\label{fig:proj}
\end{figure}
\subsection{Setting the 3D View Representation}
\index{view representation in 3D}
 
Having described the concepts, this section will attempt to explain
how all these parameters are actually set. This is an area of
the GKS-3D standard which was modified fairly late,
and release 2.0 of GKSGRAL-3D still took place before the publication
of the Draft International Standard for the FORTRAN binding
\cite{bib-gksftn3}.
 
As for the Normalization Transformation, there may be more than one
Viewing Transformation (actually, combined Viewing and Projection
Transformation plus Clip), and the different transformations
are specified by a {\it View Index}.
However, unlike the Normalization Transformation, which applies to all
primitives no matter on which workstation they are displayed,
the Viewing Transformation is workstation-dependent, and so the
same VieW Index (VWI) may produce a different effect on each active display.
The View Index is set using the routine:
\index{GKS routine!{\protect\tt GSVWI}}
\index{view index}
\index{GKS3D!view index}
\index{attributes!view index}
\begin{XMP}
CALL GSVWI(VWI)
\end{XMP}
Following this call all primitives will be transformed according to the
parameters specified by viewing attribute bundle VWI, assuming that
the deferral mode set has allowed the workstation to be brought
up-to-date. The default viewing attributes,
corresponding to VWI~=~0,
define identity matrices for the View Orientation and View Mapping
transformations, and place the clip limits at the boundary of NPC3 space.
 
As indicated, the attribute values contained in
the viewing attribute bundle specified by VWI must be defined separately
for each workstation using the call:
\index{GKS routine!{\protect\tt GSVWR}}
\begin{XMP}
CALL GSVWR(WKID, VWI, VWM, PRM, VCLP, CLW, CLB, CLF)
\end{XMP}
\begin{DLtt}{123456}
\item[WKID]Workstation Identifier
\item[VWI]The View Index
\item[VWM]The View Orientation Matrix (a~4~x~4 real array),
which may be calculated by the function GEVVWM
\item[PRM]The Projection (View Mapping) Matrix
(a~4~x~4 real array),
which may be calculated by the function GEVPJM
\item[VCLP]The View Clipping Limits (XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX)
\item[CLW]Clip Indicator for Window Clipping ('GNCLIP', 'GCLIP')
\item[CLB]Clip Indicator for Back Plane Clipping ('GNCLIP', 'GCLIP')
\item[CLF]Clip Indicator for Front Plane Clipping ('GNCLIP', 'GCLIP')
\end{DLtt}
 
The utility functions provided to evaluate the matrices are EValuate
VieW orientation Matrix and EValuate ProJection (View Mapping) Matrix:
\index{GKS routine!{\protect\tt GEVVWM}}
\begin{XMP}
CALL GEVVWM(VRPX, VRPY, VRPZ, VUPX, VUPY, VUPZ,
                    VPNX, VPNY, VPNZ, CSW, ERR, VWM)
\end{XMP}
\begin{DLtt}{123456}
\item[VRPX/Y/Z]The View Reference Point in NDC3 or WC3
\item[VUPX/Y/Z]The View Up Vector in NDC3 or WC3
\item[VPNX/Y/Z]The View Plane Normal in NDC3 or WC3
\item[CSW]Switch specifying whether the vectors are given in
World Coordinates or Normalized Device Coordinates ('GWC' or 'GNDC')
\item[ERR](out) Error indicator
\item[VWM](out) View Matrix (a~4~x~4 real array)
\end{DLtt}
\index{GKS routine!{\protect\tt GEVPJM}}
\begin{XMP}
CALL GEVPJM(UMIN, UMAX, VMIN, VMAX, PRVP, PROTYP,
                    PRPU, PRPV, PRPN, VPD, BPD, FPD, ERR, PRM)
\end{XMP}
\begin{DLtt}{123456}
\item[U, V](MIN,MAX) The limits of the View Window on the
View Reference Plane measured relative to the View Reference Point.
UMIN, VMIN is the bottom left corner, UMAX, VMAX is the top right corner.
\item[PRVP]The Projection Viewport Limits (a 6 element real array
containing XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX)
\item[PROTYP]The Projection Type flag integer ('GPARL' or 'GPERS')
\item[PRUP/V/N]The Projection Reference Point.
\item[VPD]The View Plane Distance from the View Reference Point
along the N axis.
(Note that the View Reference Point does {\it not} have to be
contained in the View Plane).
\item[BPD, FPD]The Back and Front Plane Distances from the
View Reference Point along the N axis. FPD must be greater than BPD.
\item[ERR](out) Error indicator
\item[PRM](out) Projection Matrix (a~4~x~4 real array)
\end{DLtt}
\subsection{Workstation Transformation}
\index{workstation!transformation 3D}
\index{transformation!3D workstation}
 
This is specified by a {\it Workstation Window} volume in
Normalized Projection Coordinates, and a {\it Workstation
Viewport} volume in Device Coordinates.
The Workstation Transformation always preserves the aspect ratio,
and the default transformation will be used if the window or viewport
volumes are not correctly set.
\index{GKS routine!{\protect\tt GSWKW3}}
\index{GKS routine!{\protect\tt GSWKV3}}
\begin{XMP}
CALL GSWKW3(WKID, WKWN)
 
CALL GSWKV3(WKID, WKVP)
\end{XMP}
where WKWN and WKVP are real arrays of dimension 6 containing
(XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX)
 
\index{GKS routine!{\protect\tt GQDVOL}}
To inquire the range of device coordinates corresponding to a particular
workstation type, it is possible to call the function GQDVOL
(inQuire Display VOLume).
\begin{XMP}
CALL GQDVOL (WTYPE, ERRIND, DCUNIT, RX, RY, RZ, LX, LY, LZ)
\end{XMP}
The routine returns the units in which the display surface
is measured (DCUNIT), and also the maximum x, y, and z values
in each direction.
Some devices, for example hardcopy plotters, are measured in metres
(DCUNIT='GMETRE'), so the routine will return the actual size of the
device. Other devices, for example graphics terminals,
will be defined in raster or some other units (DCUNIT='GOTHU').
RX, RY, RZ are real device coordinates,
and LX, LY, LZ are in integer raster units.
The use of GQDVOL is analogous to the use of GQDSP,
which is described in section on Page~\pageref{sec:wstntfm}.
\subsection{But I don't see anything!}
 
The first (and second and maybe third) time one tries out a 3D application,
even after having checked the code very carefully, there may be nothing
on the screen. The following is a list of possible pitfalls:
\begin{OL}
\item Is the View Reference Point really on or near the object to be viewed?
\item Is it defined in WC or NDC, and does this match the coordinate switch?
\item Is the View Plane Normal pointing the correct way?
A classical bug is to look 180 degrees in the wrong direction.
GKS-3D uses a Right-Handed system, so if the object to be viewed is
at the origin, and is viewed along the Z axis, then one
{\it looks} in the {\bf negative} Z direction, but the VPN
{\it points} in the {\bf positive} Z direction (0.0, 0.0, 1.0).
\begin{note}
As only the direction and not the length of View Plane Normal vector
matters, one can simply use the coordinates of the eye point to specify this
vector, so long as the View Reference Point is placed at the origin.
\end{note}
\item Assuming one wants an orthographic projection, is the Projection
Reference Point in the middle of the View Window?
\item Has the View Window (UMIN, VMIN), (UMAX, VMAX)
{\it really} been set around the object?
\item Have the Front Plane and Back Plane distances been set correctly
in front and behind the object?
\item Is the aspect ratio of the Normalization Viewport volume the same
as that of View volume?
\item Are the Clipping Limits which define the projection parallelepiped
correctly set within the NPC system limits? Do the Clipping Limits
and Projection Viewport Limits match?
{\bf It is always safer to start with clipping switched off!}
\item Have the Workstation Window and Workstation Viewport been set
to the same aspect ratio?
\end{OL}
\section{Segments}
\index{segment!3D}
\index{transformation!3D segment}
\index{GKS3D!segments}
 
Segmentation operates in GKS-3D in the same way as for GKS,
described in section on Page~\pageref{sec:segtfm}, except that the segment
transformation matrix is defined to be 3~x~4.
(3~x~3 for scaling and rotation plus 3~x~1 for
translation).
Thus, the 2D utility routines which calculate a segment
transformation matrix, GEVTM and GACTM, are modified as follows:
\index{GKS routine!{\protect\tt GEVTM3}}
\index{GKS routine!{\protect\tt GACTM3}}
\begin{XMP}
CALL GEVTM3(X0, Y0, Z0, DX, DY, DZ,
              ROTX, ROTY, ROTZ, FX, FY, FZ, SW, MXOUT)
 
CALL GACTM3(MXIN, X0, Y0, Z0, DX, DY, DZ,
              ROTX, ROTY, ROTZ, FX, FY, FZ, SW, MXOUT)
\end{XMP}
Similarly to the 2D case, GEVTM3 evaluates a matrix (MXOUT),
whilst GACTM3 accumulates changes to an existing matrix (MXIN).
Both routines require the definition of:
\begin{DLtt}{123456}
\item[X0, Y0, Z0]
(real) a fixed reference point about which 3D rotations take place.
\item[DX, DY, DZ]
(real) a translation (or shift) vector.
\item[ROTX, Y, Z]
(real) angles of rotation about the X, Y, and Z axes.
\item[FX, FY, FZ]
(real) X, Y, and Z scale factors.
\item[SW]
(enumerated) a switch specifying whether the reference point and
shift vector are given in World Coordinates
or Normalized Device Coordinates ('GWC' or 'GNDC').
\item[MXOUT]
(real) 3~x~4 output matrix composed in the
order: scale, rotate, shift.
In the case of GACTM, the matrix MXIN is pre-concatenated with that
formed from the scale, rotate, and shift parameters, so
MXOUT~=~SHIFT~*~ROTATE~*~SCALE~*~MXIN.
\end{DLtt}
 
Once the transformation matrix has been evaluated, it may then be
set in the segment by calling the routine:
\index{GKS routine!{\protect\tt GSSGT3}}
\begin{XMP}
CALL GSSGT3(SGNA, MTX)
\end{XMP}
To INsert a SeGment into the output stream GINSG becomes:
\index{GKS routine!{\protect\tt GINSG3}}
\begin{XMP}
CALL GINSG3(SGNA, MTX)
\end{XMP}
 
Because GKS-3D is upwards compatible to GKS, one can still use the
2D versions of these routines.
In this case, 2~x~3 matrices will be automatically filled-out
to 3~x~4 by the suitable additions of 0s and 1s.
\begin{note}
GKS segment transformations are provided in order to orient the
contents of segments with respect to the coordinate system in which
their primitives were originally specified. In most cases {\bf it is
extremely inefficient to modify the transformations in each segment
in order to view a scene from a different direction}. The viewing
transformation should be used for this purpose
\end{note}
\section{Graphical Input}
\index{GKS3D!input}
\index{input!for 3D}
 
As only the Locator and Stroke logical devices return coordinate
values, only these two have 3D versions of the routines used
for the three input modes. Thus, for request mode, the calls are:
\begin{XMP}
CALL GRQLC3(WKID, LCDNR, STAT, TNR, VWI, PX, PY, PZ)
 
      and
 
CALL GRQSK3(WKID, SKDNR, STAT, N, TNR, VWI, NP, PX, PY, PZ)
\end{XMP}
Where, apart from the extra dimension, PZ, the only difference to the
2D calls is the addition of the View Index, VWI.
(Note that as for TNR, VWI is an output parameter.)
This corresponds to the index of the viewing attribute bundle used to
convert the position(s) back from NPC3 coordinates to NDC3 coordinates.
Of course, when using a physical 2D device, it is awkward for the user
to provide the third coordinate for 3D input.
 
Although only Locator and Stroke have 3D functions to obtain input,
all six logical devices have 3D versions of the initialization
functions. For example, these allow the echo areas to be positioned
in space, rather than in a plane. They will not be discussed
further in this Primer.
\section{GKS-3D Metafile}
\index{metafile!for 3D}
\index{GKS3D!metafile}
\index{Appendix E metafile}
\index{CGM}
 
As for GKS, the GKS-3D standard has an Appendix E metafile.
The logical format of the 2D and 3D Appendix E metafiles are the
same. However, the contents are incompatible, as in one
case points are represented by two values, and in the other by
three values. The two types of metafile are clearly distinguishable
by inspecting the metafile header record. In all other respects,
the control and usage of the 2D and 3D metafiles are the same.
 
The Computer Graphics Metafile, CGM, will not initially have a 3D
version. Therefore, if a CGM metafile driver is added to GKS-3D,
the output could contain only a 2D projection. This would be sufficient
to make a hardcopy, but only with the viewing parameters chosen
when the metafile was created.
\begin{note}
The GKS-3D Appendix E metafile has never been implemented by
GTSGRAL. Nevertheless, an additional output workstation is
provided to produce a 2D
metafile by carrying out the viewing and projection operations before
outputting data to the file. This feature is useful for making hardcopies.
\end{note}
\chapter{\protect\label{sec:refhint}General Hints for GKS Use}
\index{hints}
\section{System and Implementation Dependencies}
 
As mentioned elsewhere in this document certain features of GKS and GKS-3D
are system or implementation dependent. System dependencies are described
in the manual appropriate for the implementation in use.
 
The principle implementation dependencies to watch for are text fonts and
fill area hatch styles
but it is also possible to have difficulties by inadvertently trying to
exceed some maximum value, such as a table length.
GKS has many inquiry function which may be used to discover the current
and/or maximum value of various parameters,
and it is not the intention of the Primer to describe all of them.
However, one should take note of the following routines:
\index{GKS routine!{\protect\tt GQWKM}}
\index{GKS routine!{\protect\tt GQMNTN}}
\index{GKS routine!{\protect\tt GQLWK}}
\index{GKS routine!{\protect\tt GQLWK3}}
\index{GKS routine!{\protect\tt GQSGS}}
\index{GKS routine!{\protect\tt GQSGP}}
\begin{XMP}
CALL GQWKM(ERRIND, MXOPWK, MXACWK, MXWKAS)
 
CALL GQMNTN(ERRIND, MAXTNR)
 
CALL GQLWK(WTYPE, ERRIND, MPLBTE, MPMBTE, MTXBTE, MFABTE, MPAI, MCOLI)
    or
CALL GQLWK3(WTYPE, ERRIND, MPLBTE, MPMBTE, MTXBTE, MFABTE, MPAI,
             MEDBTE, MCOLI, MVTE)
 
CALL GQSGP(WTYPE, ERRIND, NSGP)
\end{XMP}
where the parameters are as follows:
\begin{DLtt}{123456}
\item[WTYPE]workstation type (input parameter)
\item[ERRIND]error number
\item[MXOPWK]maximum number of simultaneously open workstations
\item[MXACWK]maximum number of simultaneously active workstations
\item[MXWKAS]maximum number of workstations associated with a segment
\item[MAXTNR]maximum normalization transformation number
\item[MPLBTE]maximum number of polyline bundle table entries
\item[MPMBTE]maximum number of polymarker bundle table entries
\item[MTXBTE]maximum number of text bundle table entries
\item[MFABTE]maximum number of fill area bundle table entries
\item[MPAI]maximum number of pattern indices
\item[MEDBTE]maximum number of edge bundle table entries
\item[MCOLI]maximum number of colour indices
\item[MVTE]maximum number of view table entries
\item[NSGP]maximum number of segment priorities
\end{DLtt}
There is unfortunately no function provided to inquire the maximum available
number of segments or the maximum available segment name so one must consult
the relevant documentation.
\section{Integrating separately written modules of code.}
 
As is the case when any independent software modules are combined into a
single program, care must be taken that on entry a module saves the
state of the current environment and sets up its own defaults.
The original environment must then be restored on exiting from
the module. This applies to saving and restoring registers when
making a subroutine call no more than saving and restoring (parts of) the
GKS State List and Workstation State Lists when entering a graphics module.
For example, two modules of graphics code may use the same Normalization
Transformation indices. If module B sets different windows and viewports
than module A, then on re-using routines in A after calling module B the
transformations will no longer produce the expected results.
 
GKS provides a mechanism to handle this situation in the form of a large set
of inquiry functions. These enable a module of code to inquire at run time the
values of those parameters it intends to modify in order that they may
be correctly restored afterwards. In particular, functions exist
to inquire attribute values and bundle table entries, values of the
aspect source flags, and the normalization and viewing (for GKS-3D)
transformations corresponding to a particular normalization or view index.
As an example:
\begin{XMP}
           ----
      REAL WINDOW(4)
      REAL VIEWPT(4)
           ----
C     Inquire current window and viewport for Transformation Number X
C
      CALL GQNT(TNX, ERRIND, WINDOW, VIEWPT)
      CALL GSWN(TNX, WXMINA, WXMAXA, WYMINA, WYMAXA)
           ----
C     Restore window which was modified for Transformation Number X
C
      CALL GSWN(TNX, WINDOW(1), WINDOW(2), WINDOW(3), WINDOW(4))
           ----
\end{XMP}
 
If several modules of code which are to be combined use GKS segments then
clearly they must not both attempt to use the same segment names.
Either one can agree before hand on the allocation of a range of names
to each module, or else code can be written which assigns segment names
at run time after checking that the values are not in use
(see section on Page~\pageref{sec:segnam}).
\subsection{Using GKS-3D libraries for GKS (2D) applications}
 
As GKS-3D is a super-set of GKS it is possible to run a GKS 2D application
linked to a GKS-3D library. However, if a 2D code module is incorporated
into a larger 3D program then the programmer must be aware that primitives
will be bound to the current View Index {\bf as well as} the current
Normalization Transformation Index, possibly entailing 3D transformations
plus view clipping.
Thus, to be sure that the code within the 2D module will behave as if linked
to a 2D library the View Index should be set to 0 (identity matrix) in the
3D code before calling the 2D module.
This can not be done in the 2D module itself, as otherwise the linker would give
an error when linking to GKS which does include the 3D function GSVWI.
\section{\protect\label{sec:refintw}Plotting numbers as text strings}
 
For FORTRAN programmers it is possible to use the {\it Internal Write}
construct to convert numeric variables to character strings for output as
text primitives or via GMSG:
\begin{XMP}
      REAL      rvar
      CHARACTER str*11
        ----
C     Set Variable
      rvar = v1 * v2 / v3
C     Convert to a character string
      WRITE(str, '(''RVAR= '',F5.1)') rvar
      CALL GMSG(wkid, str)
        ----
\end{XMP}
\section{\protect\label{sec:gkspref}GKSPACK}
\index{GKSPACK}
 
GKSPACK contains routines which may be placed into several categories.
\begin{UL}
\item
One category of routines is intended to ease the use of GKS for
those people with simple applications who do not need further GKS features,
NAG graphics users for example. These routines are built on top
of GKS and are not implementation dependant. They include
routines to initialize and stop GKS (GCINIT, GCSTOP),
to ask the user for input (GPRMPT), etc.
\item
The next category of routines provide facilities to allow applications
which must run on several GKS implementations to obtain information
about workstation types and connection identifiers from a data file.
This avoids having to ask the user interactively to supply implementation
dependant values. These routines include GCGIMP, GCGWTC, etc.
\item
Some routines provide access to GKS features which might be awkward to use,
or which may be implementation dependant. For example, use of GDPs,
or the construction of menus. GKSGRAL includes a large number of utility
routines of this type starting with the sentinel characters {\bf GU},
and GKSPACK contains CERN-written emulations of many of them for
use with other GKS implementations.
\item
Another category of routines is for non-standard GKS utilities which allow the
user to perform specific actions not foreseen by the GKS standard, and which may
require internal knowledge of the GKS implementation.
Thus, it may not be possible to implement these routines for GKS
implementations other than the one from GTS-GRAL if access to the source
code is not available.
The principal examples of routines in this category, heavily used
at CERN by PAW for instance, are GCATOG and GCGTOA. These are used to switch
the graphics terminal between graphics and alphanumeric mode in order for
applications to intermix graphics and Fortran I/O on the same device.
\end{UL}
 
For various technical reasons it has been decided to include entry points
for all routines in GKSPACK in the GTS-GRAL libraries%
\footnote{At the time of preparing this document there
is a possibility that there may be
a delay in introducing a few of the GKSPACK routines into
the Apollo library due to the change over to SR~10.}
maintained by CERN.
This means that users of GKSGRAL do {\bf not} need to link to a separate
library in order to have access to GKSPACK routines, which is a change to the
previous situation when it was necessary to link applications
also with the CERN library 'NGRAFLIB'.
 
For users of other GKS implementations a PAM file, named GKSPACK,
is available.
Initially, apart from GKSGRAL, this has support only for DECGKS.
The PAM file distributed by the CERN Program Library will be
included also on the GTS-GRAL distribution tape, and is available at CERN
as follows:
\begin{DLtt}{123456}
\item[IBM:]via \Ucom{GIME CERNPAMS}
\item[VXCERN:]in \Lit{CERN_ROOT:[PAM]GKSPACK.PAM}
\item[Apollo:]in \Lit{/cern/pro/pam/gkspack.pam}
\item[UNIX:]in \Lit{$CERN/pro/pam/gkspack.pam}
\end{DLtt}
The compiled version for DECGKS is available at CERN:
\begin{DLtt}{123456}
\item[VXCERN:] \Lit{GKS_ROOT:[LIB]GKSPACK_DEC.OLB}
\end{DLtt}
 
As mentioned above, GKSPACK includes some routines for which it may not
be possible to produce correctly working versions for implementations
other than GKSGRAL.
For example, this is the situation for GCATOG and GCGTOA with DECGKS.
In these cases GKSPACK contains dummy routines with the correct
calling sequences, but which write out an error message to a file
named GKSPACK.ERR.
In fact, for GCATOG and GCGTOA, calling the dummy routines
when using a terminal%
\footnote{As opposed to a using a workstation where the
Fortran and graphics I/O are directed at different windows.}
actually stops the application program as well. This is because if the
application mixes Fortran I/O and graphics without using correctly
working versions of GCATOG and GCGTOA then probably the terminal will
block and need to be re-set.
(If used via VM/CMS this also can block the communications.)
 
The GKSPACK routines which provide access to the implementation
dependant values for workstation types and connection identifiers
require access to a data file.
Examples of this file are distributed with GKSPACK,
and at CERN are available as follows:
\begin{DLtt}{123456}
\item[IBM]The file is called \Lit{GKS$IMPL DAT}.
A GTS-GRAL GKS version is available on the 'Q' disk, but users may provide
their own if they wish.
\item[VAX]The file is available via the Logical Name
\Lit{GKS_IMPLEMENTATION}.
Both GTS-GRAL and DECGKS versions of the file exist,
and users must assign the one they wish to use.
\begin{XMP}
GKS_ROOT:[DAT]GKS_IMPLEM.GTS
GKS_ROOT:[DAT]GKS_IMPLEM.DEC
\end{XMP}
\item[UNIX]The file is accessed via \Lit{$GKS_IMPLEM},
which must be defined as an environment variable.
A GTS-GRAL GKS version called \Lit{gks_implem.gts} is available in
\Lit{$gkshome}, or in \Lit{/cern/gks/pro/dat}.
\end{DLtt}
An example of such a file would be:
\begin{XMP}
DECGKS
NB WKTYPES    5
 
PSTSCR            61     9
T4107             82     0
VT340             17     0
VXUIS             41     0
WISS               5     1
\end{XMP}
\subsection{List of routines}
\begin{OL}
\item \Lit{CALL GCATOG(WKID)} or \Lit{CALL GCGTOA(WKID)}
\index{GKSPACK!{\protect\tt GCATOG}}
\index{GKS routine!{\protect\tt GCATOG}}
\index{GKSPACK!{\protect\tt GCGTOA}}
\index{GKS routine!{\protect\tt GCGTOA}}
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID]GKS workstation identifier of the terminal (INTEGER).
\end{DLtt}
 
\Lit{GCGTOA} and \Lit{GCATOG} work only on GKSGRAL with the CERN-supplied
driver versions as the routines require modifications to the driver code.
The DECGKS version tests the workstation type; if it is VXUIS or VXXW
it does nothing, otherwise it writes an error message on the file
GKSPACK.ERR.
 
The routines change a terminal from graphics to alpha mode (GCGTOA)
and from alpha to graphics mode (GCATOG). The terminal must be an
activated GKS workstation.
Thus they allow the application to perform FORTRAN I/O to
the terminal during a graphics session. The effect on the terminal
depends on its capabilities. For example, as Pericom PG terminals
do not have a dialog area, calling GCGTOA causes the bell to ring
and the program then halts until the operator presses return.
This gives the user time to look at the image drawn in graphics
mode before switching the screen to the alpha-numeric bit plane.
However, on terminals with a dialog area (e.g. Pericom
MG series and Tektronix 4107 compatible terminals),
the FORTRAN I/O will appear immediately overlayed with the graphics.
 
After the FORTRAN I/O has been performed the application
{\bf must} call GCATOG to reset the graphics environment.
Note that GCGTOA returns immediately, without waiting for a user
action. Thus, if one wishes the program to wait until the user has read
a message and is ready to continue, then it is essential to include
a READ statement, as the following program fragment illustrates:
\begin{XMP}
      CALL GCGTOA (WKID)
      WRITE(*,*) ' GIVE X COORDINATE: '
C  Wait for a reply
      READ (*,*) X
      CALL GCATOG (WKID)
\end{XMP}
\item {\bf CALL GCCDWN(WKID, RWIN, TITLE)}
\index{GKSPACK!{\protect\tt GCCDWN}}
\index{GKS routine!{\protect\tt GCCDWN}}
 
This routine is described fully in section on Page~\pageref{sec:vstnref}.
The DECGKS version is a dummy.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID (I)]Workstation Identifier
\item[RWIN (R*4)]Window Size
\item[TITLE (C)]Window title
\end{DLtt}
\item {\bf CALL GCINIT(IDTERM, TERMTP, IDFILE, LUFILE, KERFIL)}
\index{GKSPACK!{\protect\tt GCINIT}}
\index{GKS routine!{\protect\tt GCINIT}}
 
{\bf Input:}
\begin{DLtt}{123456}
\item[IDTERM]GKS workstation ID for terminal (INTEGER).
If $\leq0$ or in batch no terminal is assigned.
\item[TERMTP]GKS terminal workstation type (INTEGER).
Note that this number depends on the terminal {\it and} the
GKS implementation you are using.
\item[IDFILE]GKS workstation ID for disk file output (INTEGER).
No file is output if $\leq0$.
\item[LUFILE]FORTRAN logical unit number for disk file output (INTEGER).
Not used if IDFILE $\leq0$.
\item[KERFIL]FORTRAN logical unit number for the GKS error file (INTEGER).
\end{DLtt}
 
GCINIT provides an easy initialization of GKS for interactive or
batch applications.
If TERMTP=0 GCINIT will prompt the interactive user for the
terminal type and connection ID.
LUFILE and KERFIL are Fortran logical unit numbers and no file names
are assigned as these can easily be provided by the user.
Note that the logical unit numbers 91, 92, 93 are reserved for
GKSGRAL and, to avoid nasty surprises, do not use 5, 6 or 7.
The current values for LUFILE and their effect are:
\begin{XMP}
     LUFILE<=0    An interactive dialog will guide the user.
   0<LUFILE<100   GKS Appendix E metafile on unit LUFILE.
 100<LUFILE<200   PostScript file on unit LUFILE-100.
 200<LUFILE<300   Encapsulated PostScript file on LUFILE-200.
1000<LUFILE<1100  Tektronix 4014 style file on unit LUFILE-1000
\end{XMP}
For example, LUFILE=109 would produce PostScript output on the
Fortran file defined by logical unit=9.
\begin{note}
Output of Tektronix 4014 escape codes is available under VMS and Aegis.
It can be provided under VM/CMS if requested.
\end{note}
\item {\bf CALL GCGIMP (MAXTYP, GKSNWT, GKSSYN, GKSWCN, GKSWTP)}
\index{GKSPACK!{\protect\tt GCGIMP}}
\index{GKS routine!{\protect\tt GCGIMP}}
 
Supplies information in implementation file.
See introduction to this section for file naming details.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[MAXTYP (I)]maximum number of wk types
(i.e. dimension of output arrays)
\end{DLtt}
 
{\bf Output:}
\begin{DLtt}{123456}
\item[GKSNWT (I)]number of wk types in the implementation file
\item[GKSSYN (C*6)]array (dimension MAXTYP) with the workstation types names
(e.g. "VXUIS~")
\item[GKSWCN (I)]array (dimension MAXTYP) with the workstation connection id's
\item[GKSSYN (I)]array (dimension MAXTYP) with the workstation types integer
values (e.g. 41)
\end{DLtt}
\item {\bf CALL GCIMPL(IMPLEM)}
\index{GKSPACK!{\protect\tt GCIMPL}}
\index{GKS routine!{\protect\tt GCIMPL}}
 
Supplies implementation name string.
 
{\bf Output:}
\begin{DLtt}{123456}
\item[IMPLEM (C*6)]Name of implementation
\end{DLtt}
.pa
\item {\bf CALL GCGWTC(WKTYP, CONID)}
\index{GKSPACK!{\protect\tt GCGWTC}}
\index{GKS routine!{\protect\tt GCGWTC}}
 
Asks the user to enter interactively a workstation type, and
provides the list of the available workstation types if the user enters '?'.
Automatically returns to the program the connection id to be used
for the selected workstation type.
 
{\bf Output:}
\begin{DLtt}{123456}
\item[WKTYP (I)]Workstation Type
\item[CONID (I)]Connection Id
\end{DLtt}
\item {\bf CALL GCNAME(WKID, STRING)}
\index{GKSPACK!{\protect\tt GCNAME}}
\index{GKS routine!{\protect\tt GCNAME}}
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID (I)]GKS workstation identifier of the metafile
receiving the frame (INTEGER).
\item[STRING (C*7)]The name of the frame (CHARACTER*(*)).
\end{DLtt}
 
GCNAME enables the user to give the name 'STRING' to the current frame
when output to a metafile for inclusion in compound documents.
The name 'STRING' may also be used by GRVIEW and GRCONV
to select frames on the metafile.
Users of this facility {\bf must} place the call to GCNAME before
outputting any primitives to a new frame.
For examples of its use, see on Page~\pageref{sec:gcnref} and on Page~\pageref{sgmlgra}.
 
{\bf Restrictions:} Only the first 7 characters of 'STRING' are used.
If less than 7 characters are given 'STRING' will be padded with
\Lit{'$'}s (dollars).
For VM/CMS system reasons, the character set for 'STRING' can
only contain upper-case alphabetic, the digits 0-9, and the dollar
sign (\Lit{'$'}), so lower-case characters are converted to upper-case.
\item {\bf CALL GCQWKN(WKID, IERR, CONID, WKNAM)}
\index{GKSPACK!{\protect\tt GCQWKN}}
\index{GKS routine!{\protect\tt GCQWKN}}
 
Analog to the routine GQWKC but returns a workstation type name
instead of a workstation type integer value.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID (I)]Workstation Id
\end{DLtt}
 
{\bf Output:}
\begin{DLtt}{123456}
\item[IERR (I)]value returned by GQWKC
\item[CONID (I)]Connection Id
\item[WKNAM (C*6)]Workstation Name (e.g. "VXUIS~")
\end{DLtt}
\item {\bf CALL GCSDWN(WKTYP, RWIN, TITLE)}
\index{GKSPACK!{\protect\tt GCSDWN}}
\index{GKS routine!{\protect\tt GCSDWN}}
 
This routine is described fully in section on Page~\pageref{sec:vstnref}.
The DECGKS version is a dummy.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKTYP (I)]Workstation Type
\item[RWIN (R*4)]Window Size
\item[TITLE (C)]Window title
\end{DLtt}
\item {\bf CALL GCSTOP}
\index{GKSPACK!{\protect\tt GCSTOP}}
\index{GKS routine!{\protect\tt GCSTOP}}
 
GCSTOP deactivates and closes all GKS workstations and closes GKS.
\item {\bf CALL GCWTPC(WKTYP, WKTSYN)}
\index{GKSPACK!{\protect\tt GCWTPC}}
\index{GKS routine!{\protect\tt GCWTPC}}
 
Returns the workstation type name corresponding to a workstation
type integer value.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKTYP (I)]Workstation Type (e.g. 41 for DECGKS)
\end{DLtt}
 
{\bf Output:}
\begin{DLtt}{123456}
\item[WKSTYN (C*6)]Workstation Type Name (e.g. "VXUIS~")
\end{DLtt}
\item {\bf CALL GCWTPI(WKTSYN, CONID, WKTYP)}
\index{GKSPACK!{\protect\tt GCWTPI}}
\index{GKS routine!{\protect\tt GCWTPI}}
 
Get workstation type and connection id corresponding to a given
workstation type name (e.g. 'VXXW').
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKSTYN (C*6)]Workstation Type Name
\end{DLtt}
 
{\bf Output:}
\begin{DLtt}{123456}
\item[WKTYP (I)]Workstation Type
\item[CONID (I)]Connection Id
\end{DLtt}
\item {\bf CALL GPRMPT(WKID, PROMPT, LSTRI, REPLY)}
\index{GKSPACK!{\protect\tt GPRMPT}}
\index{GKS routine!{\protect\tt GPRMPT}}
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID]GKS workstation identifier of the terminal (INTEGER).
\item[PROMPT]Application prompt (CHARACTER *(*)).
\end{DLtt}
 
{\bf Output:}
\begin{DLtt}{123456}
\item[LSTRI]Length of reply (INTEGER).
\item[REPLY]User reply (CHARACTER).
\end{DLtt}
 
GPRMPT gives a prompt and waits for a reply from the user in a GKS
interactive graphics program.
As an example, GPRMPT could be used to hold a picture on
the screen until the user was ready to view the next one,
or terminate the program.
If the user hits only a Carriage Return then LSTRI=0 and 'REPLY' is not
defined.  For example:
\begin{XMP}
      CALL GPRMPT(WKID, 'Type RETURN or QUIT', LSTRI, REPLY)
      IF(LSTRI.GT.0) THEN
C       Call STOPPG to do whatever you want to do on QUIT
        IF REPLY(1:4) .EQ. 'QUIT') CALL STOPPG
      ENDIF
\end{XMP}
 
Currently the prompt is put into a GKS segment which is deleted
after the reply.  If a segment is open when GPRMPT is called,
the prompt will be added to it but it will not be deleted. This
could be confusing and should be avoided by closing an open
segment before calling GPRMPT.
If the workstation is not a terminal or the job is in batch
GPRMPT does nothing.
 
{\bf Restrictions:} If GPRMPT is used repeatedly within one picture,
the prompts will overprint if the terminal does not have selective erasure.
If long prompts and/or small workstation windows are used the
prompt will be truncated.
\item {\bf CALL GRQSK(WKID, LDSTK, NMAX, ISTATS, IT, NP, PX, PY)}
\index{GKSPACK!{\protect\tt GRQSK}}
\index{GKS routine!{\protect\tt GRQSK}}
 
Emulates the GTSGRAL request stroke (locator loop)
which requires a button push to input each point.
This is in contrast to the DECGKS implementation of GRQSK
which reads the current cursor position in a loop
with fixed time or position intervals.
\begin{note}
If it is intended to use this routine to replace the version of GRQSK in the
GKS library it must be linked ahead of the library.
\end{note}
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID (I)]Workstation Identifier
\item[LDSTK (I)]Stroke logical device
\item[NMAX (I)]Maximum number of points
\end{DLtt}
 
{\bf Output:}
\begin{DLtt}{123456}
\item[ISTATS (I)]Status
\item[IT (I)]Normalization Transformation Number
\item[NP (I)]Number of points returned
\item[PX (I*NMAX)]X coordinates
\item[PY (I*NMAX)]Y coordinates
\end{DLtt}
\item {\bf CALL GUARC(XM,YM,XP,YP,XH,YH,XQ,YQ)}
\index{GKSPACK!{\protect\tt GUARC}}
\index{GKS routine!{\protect\tt GUARC}}
 
Emulation of GTS-GRAL utility to draw a circular arc defined by 4 points.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[XM, YM]Mid point of arc
\item[XP, YP]Start point
\item[XH, YH]Point on arc
\item[XQ, YQ]Point on end radius of arc
\end{DLtt}
\item {\bf CALL GUBEZ1(N,XP,YP)}
\index{GKSPACK!{\protect\tt GUBEZ1}}
\index{GKS routine!{\protect\tt GUBEZ1}}
 
Emulation of GTS-GRAL utility to draw a Bezier curve defined by a
Bezier polygon.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[N (I)]Dimension of XP, YP
\item[XP, YP]Points on Bezier polygon
\end{DLtt}
.pa
\item {\bf CALL GUCIR1(XM,YM,XP,YP)}
\index{GKSPACK!{\protect\tt GUCIR1}}
\index{GKS routine!{\protect\tt GUCIR1}}
 
Emulation of GTS-GRAL utility to draw a circle defined by
(midpoint, peripheral point).
 
{\bf Input:}
\begin{DLtt}{123456}
\item[XM, YM]Mid point of circle
\item[XP, YP]Peripheral point on circle
\end{DLtt}
\item {\bf CALL GUCIR2(XM,YM,R)}
\index{GKSPACK!{\protect\tt GUCIR2}}
\index{GKS routine!{\protect\tt GUCIR2}}
 
Emulation of GTS-GRAL utility to draw a circle defined by
(midpoint, radius).
 
{\bf Input:}
\begin{DLtt}{123456}
\item[XM, YM]Mid point of circle
\item[R]Radius
\end{DLtt}
\item {\bf CALL GUCUR1(N,XP,YP)}
\index{GKSPACK!{\protect\tt GUCUR1}}
\index{GKS routine!{\protect\tt GUCUR1}}
 
Emulation of GTS-GRAL utility to draw a curve defined by interpolating points.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[N (I)]Dimension of XP, YP
\item[XP, YP]Points in polygon.
\end{DLtt}
\item {\bf CALL GUELL1(XM,YM,A,B)}
\index{GKSPACK!{\protect\tt GUELL1}}
\index{GKS routine!{\protect\tt GUELL1}}
 
Emulation of GTS-GRAL utility to draw an ellipse defined by
(midpoint, semi-axes).
An ellipse is drawn with midpoint XM,YM; the length of semi-axis
in the X-direction is A, and in the Y-direction is B.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[XM, YM] Midpoint of Ellipse
\item[A, B]Semi-axes of ellipse in X and Y directions
\end{DLtt}
\item {\bf CALL GUELL2(XM,YM,A,B,BEGRAD,ENDRAD,ROTATE)}
\index{GKSPACK!{\protect\tt GUELL2}}
\index{GKS routine!{\protect\tt GUELL2}}
 
Emulation of GTS-GRAL utility to draw an elliptical arc specified by the
midpoint XM,YM, the size of the semi-axes in direction X and Y (A, B),
and \Lit{BEGRAD} and \Lit{ENDRAD} which define the radius of the start and end points.
The ellipse is rotated with angle ROTATE in an anti-clockwise direction.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[XM, YM] Midpoint of Ellipse
\item[A, B]Semi-axes of ellipse in X and Y directions
\item[BEGRAD]Angle of arc start point
\item[ENDRAD]Angle of arc end point
\item[ROTATE]Angle of anti-clockwise rotation
\end{DLtt}
.pa
\item {\bf CALL GUMEN2(WK,DNR,CHECXL,CHECXH,CHECYL,CHECYH,MENU)}
\index{GKSPACK!{\protect\tt GUMEN2}}
\index{GKS routine!{\protect\tt GUMEN2}}
 
Emulation of GTS-GRAL utility to define a menu in a given echo area.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[WKID (I)]Workstation Id
\item[DNR (I)]Device Number
\item[CHECXL]Echo area X Lower Bound
\item[CHECHL]Echo area X Higher Bound
\item[CHECYL]Echo area Y Lower Bound
\item[CHECYL]Echo area Y Higher Bound
\item[MENU (C)]String of menu items separated by ',' and terminated
by '.'.
\end{DLtt}
\item {\bf CALL GUNERR(N)}
\index{GKSPACK!{\protect\tt GUNERR}}
\index{GKS routine!{\protect\tt GUNERR}}
 
Dummy routine which writes error message to file GTSTODEC.ERR.
 
{\bf Output:}
\begin{DLtt}{123456}
\item[N]Number of GKS errors which occurred.
\end{DLtt}
\item {\bf CALL GUSIGD(FLAG)}
\index{GKSPACK!{\protect\tt GUSIGD}}
\index{GKS routine!{\protect\tt GUSIGD}}
 
Dummy routine which writes error message to file GTSTODEC.ERR.
 
{\bf Input:}
\begin{DLtt}{123456}
\item[FLAG (L)]Set (.TRUE.) or reset (.FALSE.) simulation flag.
\end{DLtt}
\end{OL}
\subsection{GKSPACK Error Messages}
\index{GKSPACK!Error Messages}
 
\begin{DLtt}{123456}
\item[GTSGRAL]
If GOPKS has been called before any call to GKSPACK then any GKSPACK
errors will be written to the GKS error file. Otherwise, if an error occurs
from a call to a GKSPACK routine preceeding the GOPKS call, then the error
message will be sent to the screen.
\item[DECGKS]
All errors are written to GKSPACK.ERR.
\end{DLtt}
 
The list of GKSPACK error messages is as follows:
\begin{DLtt}{123456}
\item[-1]Cannot open implementation file.
The file does not exist or: (VMS) the logical name \Lit{GKS_IMPLEMENTATION}
is not correctly defined; or (UNIX) the environment variable \Lit{GKS_IMPLEM}
is not correctly defined.
\item[-2]Internal error in GCGIMP. The arrays are too small to contain
the information for all the workstations listed in the implementation file.
Contact Graphics Section at CERN (CN/US/GR).
\item[-3]The user arrays are too small to contain the information for all
the workstations listed in the implementation file .
\item[-4]The GKSPACK routine called is a dummy for this GKS implementation.
\item[-5]Error in GCNAME: invalid characters in frame name.
\end{DLtt}
\subsection{GKSPACK Example Program}
\index{GKSPACK!Example Program}
 
The following complete program illustrates the use of some
routines available in GKSPACK:
\begin{XMP}
      PROGRAM DEMOC1
*
*  Include file defines GKSGRAL workstation types
*
      INCLUDE  'GKS$GTSDEV'
      CHARACTER*80 REPLY
      REAL XSINX(51),XSINY(51)
      REAL XTWOPI
      DATA XTWOPI/6.28318/
*
*  DEFINE THE WORKSTATION TYPE (Pericom MG600) AND METAFILE
*
      CALL GCINIT (1, MG600, 2, 30, 11)
*
*  DEFINE AND SELECT A TRANSFORMATION THAT DIRECTS OUTPUT
*  TO A WINDOW OF (0.0, 1.0) X (-1.0, 1.0)
*
      CALL GCNAME (2, 'TITLE01')
      CALL GSWN   (1, 0.0, 1.0 ,-1.0, 1.0)
      CALL GSELNT (1)
*
*  BEGIN OUTPUT
*
      DO 10 K=1,51
       XSINX(K) = FLOAT(K-1)*0.02
       XSINY(K) = SIN(XSINX(K)*XTWOPI)
10    CONTINUE
      CALL GPL (51, XSINX, XSINY)
*
*  ALL DONE WITH GKS, CLOSE THE SYSTEM
*
      CALL GPRMPT (1, 'TYPE RETURN', LSTRI, REPLY)
      CALL GCSTOP
      END
\end{XMP}
\chapter{\protect\label{sec:gtschap}GKSGRAL and GKSGRAL-3D}
\index{GKSGRAL}
\index{GKSGRAL-3D}
\index{FORTRAN binding}
\index{levels of GKS}
 
GKSGRAL is a full implementations of the ISO GKS standard.
It is written in FORTRAN, and the application interface follows
the final version of the FORTRAN binding \cite{bib-gksftn}.
The kernel is written to the level '2c', although versions on
some systems (and some of the drivers) only support level '2b'.
In particular, the version on IBM is only '2b'.
 
\index{input!event mode}
\index{input!sample mode}
The main reason not to support '2c' is that Event Mode requires
the operating and communications systems to support asynchronous
interrupts. However, this feature is not required for Sample Mode.
Thus, although it requires 'bending' the standard slightly,
a pseudo Sample Mode is available on some devices which do not conform
to level '2c' using the following procedure:
\begin{XMP}
C     Set string mode to sample
      CALL GSSTM (WKID,1,1,0)
C     Request the locator position
      CALL GRQLC (WKID,1,STAT,TNR,PX,PY)
C     Sample the character typed
      CALL GSMST (WKID,1,1,NCH,STRING)
C     Set string mode back to request
      CALL GSSTM (WKID,1,0,1)
\end{XMP}
 
The current release of GKSGRAL-3D, Version 2.0, follows the final version of
the ISO functional standard. It is also very close to the final FORTRAN binding
apart from some minor differences which will be resolved at a future date.
\section{Devices Drivers}
\index{device drivers}
\index{MEGATEK}
\index{IBM!5080}
 
Both GKSGRAL and GKSGRAL-3D use the same 2D device drivers.
Thus, any 2D device supported by GKSGRAL can also be driven from
GKSGRAL-3D. In addition, GKSGRAL-3D supports the IBM~5080,
TEKTRONIX~4235/6, and the MEGATEK WHIZZARD series (models 72xx and 33xx)
which have 3D hardware transformations.
 
\index{include files}
The list of devices supported may be found in the include file
GTSDEV reproduced in Appendix on Page~\pageref{sec:gtstyp}.
although one should check the latest machine-readable version to see
if there have been any changes.
 
The precise definition of the facilities provided by each workstation
driver, such as the assignment of keys, number of available colours,
and so on, is given in the Workstation Description Tables.
An abridged version of the most common of these may be found in
Appendix on Page~\pageref{sec:wdtref}.
\section{\protect\label{sec:conref}Connection Identifiers}
\index{conid}
\index{connection identifier}
\index{GKS routine!{\protect\tt GOPWK}}
 
For terminal connections on VAX VMS and VM/CMS, assuming that there are
no special instructions in the Workstation Description Table for the
device, any number in the range from 1 to 90 may be used for the conid
in calls to GOPWK (but see note below).
On VAX VMS, GKSGRAL uses an automatically-generated logical name to connect
to the terminal, but it is possible to override this with the command:
\begin{XMP}
\Ucom{DEFINE   GKS_DEVICE_n   TTxx:}
\end{XMP}
where \Lit{n} is the conid to be used and \Lit{'TTxx'}
(or \Lit{'TXxx'}, \Lit{'LTxx'}, \Lit{'RTxx'}, \Lit{'NVxx'}, etc. 
depending on the type of controller)
is the name of the terminal.
Note that this will only allow use of a terminal other than the one on which
the user is logged in if the user has the requisite privileges,
or if the second terminal is not protected.
Moreover, if the second terminal is not hard-wired, for example, if it is
connected via a Local Area Network terminal server, then one must take care
at the time of use to find out the correct name of the controller and port
to which the physical terminal is connected.
 
If, for debugging or other purposes, one does not want to get any graphical
output on the terminal (and no graphical input is requested),
then one can connect to the NULL device with the command:
\begin{XMP}
DEFINE   GKS_DEVICE_n   NL:
\end{XMP}
where n is the conid to be used.
 
On VMS, it is possible to capture graphics output command sequences from the
HP Plotter, PostScript (see section on Page~\pageref{sec:epsref} for information
on Encapsulated PostScript) and Tektronix 4014 drivers on a file.
To do this, open a file with unit number~=~n and define the
connection identifier to be conid~=~(100~+~n),
where n is a small integer greater than 1.
If there is sufficient interest,
this feature could be extended to other devices.
\begin{note}
\index{FORTRAN Logical Unit Numbers}
At CERN, the GKSGRAL and GKSGRAL-3D packages reserve FORTRAN
Logical Unit Numbers (and hence conids) {\bf 91-93} for internal use.
Apart from these three numbers the actual range of permissible values
for connection identifiers is in fact 1-100.
\end{note}
\section{\protect\label{sec:impref1}Implementation-Dependent Features}
\index{implementation-dependent features}
\index{text fonts}
\index{fonts}
\index{italic text}
\index{proportionally spaced text}
\index{hatch styles}
\index{fill area styles}
\index{fill area limitation}
\index{maximum parameter values}
 
Although an ISO standard, GKS still includes some features which vary from
implementation to implementation or device to device.
The principle features to watch are text fonts and fill area hatch styles.
GKSGRAL supports 11 stroke-precision Latin text fonts plus Greek
\index{Greek text font}
and a solid filled font.
These are illustrated in \ref{fig:fonts}. The fonts are available
both in italic and non-italic scripts, as well as proportionally and
non-proportionally spaced.
The font indices are given in Appendix on Page~\pageref{sec:wdtref}.
 
At CERN, GKSGRAL has been modified to provide 24 Fill Area Hatch Styles
(indices -101 to -124), and these should produce the same result on all
workstations (see \ref{fig:hatch}).
Other parameters with which the package has currently been configured are:
\begin{DLtt}{123456}
\item[Workstations]10 simultaneously open workstations (6 on VM)
\item[Segments]2000 segments, names in range 1-32763
\item[Normalization Transformations]21 (0 to 20)
\item[Viewing Transformations]21 (0 to 20)
\item[Fill Area]The number of points in a Fill Area primitive
is limited to 300.
\item[Polyline]If the number of points in a Polyline is larger
than 300 then they will be split into several primitives.
\end{DLtt}
 
The actual values of these and other parameters
may be inquired at run-time by calling the routines:
\index{GKS routine!{\protect\tt GQWKM}}
\index{GKS routine!{\protect\tt GQMNTN}}
\index{GKS routine!{\protect\tt GQLWK}}
\index{GKS routine!{\protect\tt GQLWK3}}
\index{GKS routine!{\protect\tt GQSGS}}
\index{GKS routine!{\protect\tt GQSGP}}
\begin{XMP}
CALL GQWKM(ERRIND, MXOPWK, MXACWK, MXWKAS)
 
CALL GQMNTN(ERRIND, MAXTNR)
 
CALL GQLWK(WTYPE, ERRIND, MPLBTE, MPMBTE, MTXBTE, MFABTE, MPAI, MCOLI)
    or
CALL GQLWK3(WTYPE, ERRIND, MPLBTE, MPMBTE, MTXBTE, MFABTE, MPAI,
             MEDBTE, MCOLI, MVTE)
 
CALL GQSGP(WTYPE, ERRIND, NSGP)
\end{XMP}
where the parameters are as follows:
\begin{DLtt}{123456}
\item[WTYPE]workstation type (input parameter)
\item[ERRIND]error number
\item[MXOPWK]maximum number of simultaneously open workstations
\item[MXACWK]maximum number of simultaneously active workstations
\item[MXWKAS]maximum number of workstations associated with a segment
\item[MAXTNR]maximum normalization transformation number
\item[MPLBTE]maximum number of polyline bundle table entries
\item[MPMBTE]maximum number of polymarker bundle table entries
\item[MTXBTE]maximum number of text bundle table entries
\item[MFABTE]maximum number of fill area bundle table entries
\item[MPAI]maximum number of pattern indices
\item[MEDBTE]maximum number of edge bundle table entries
\item[MCOLI]maximum number of colour indices
\item[MVTE]maximum number of view table entries
\item[NSGP]maximum number of segment priorities
\end{DLtt}
There is unfortunately no function provided to inquire the maximum available
number of segments.
\begin{figure}[h]
\begin{verbatim}
picture name=FONTS$$S
\end{verbatim}
\caption{GTS-GRAL italic, proportionally-spaced fonts}
\label{fig:fonts}
\end{figure}
\begin{figure}[h]
\begin{verbatim}
picture name=HATCH$$S
\end{verbatim}
\caption{CERN-defined hatch patterns}
\label{fig:hatch}
\end{figure}
\section{System-Dependent Considerations}
\subsection{IBM}
\index{IBM!GKSGRAL on}
\index{GKSGRAL!on IBM}
\index{HPLOT}
\index{HIGZ}
\index{GKSPACK}
\index{GRAFLIB}
 
The recommended way of linking GKS is to use the GKS or GRAFLIB parameters
to the {\bf CERNLIB} command to provide automatic access to just
the GKS library, or to both GKS and various higher level graphics
packages which use GKS, notably the CERN Program Library packages
GKSPACK (J551), HPLOT (Y251) and HIGZ (Q120).
Further details on what follows may be obtained via the command
{\bf FIND~CERNLIB}.
\begin{XMP}
CERNLIB GKS
        or
CERNLIB GKS3D
        or
CERNLIB GRAFLIB (GTS2D       [or (GTS3D]
\end{XMP}
The optional parameter '(GTS2D' or '(GTS3D' gives access to the 2D or 3D
GTS-GRAL libraries. In addition, the CERNLIB command
provides access to three versions of each library: {\bf OLD},
{\bf PRO} (default), and {\bf NEW}.
For example, to access the previous library version use:
{\bf 'GRAFLIB!OLD~(GTS2D'}.
 
Application programs must use VS FORTRAN.
The optional INCLUDE files for the GKS parameters are kept in the data set
{\bf 'GKSINCL~MACLIB'} on the automatically accessed Q-Disk.
 
The basic commands and tools to use GKS are:
\begin{DLtt}{123456}
\item[CERNLIB GKS]
To access just GKS (or GKS3D for 3D)
\item[CERNLIB GRAFLIB (GTS2D or GTS3D]
To access the GKS and higher level packages
\item[VFORT gksprog]To compile.
\item[LOAD gksprog (START]To execute.
\end{DLtt}
These last two commands may be replaced by the sequence:
\begin{DLtt}{123456}
\item[VFORT gksprog (GO]To compile and go
\end{DLtt}
In this sequence the CERNLIB Exec makes available the VS FORTRAN libraries,
the CERN program library and the GKS library in the correct
order, as well as other associated files.
Any number of user libraries may be specified.
 
\index{include!on IBM}
To use the GKS include files one must give the command:
\begin{XMP}
GLOBAL MACLIB GKSINCL
\end{XMP}
before compiling the program. Within the code, the files may be included
by using the construct:
\index{include!enum}
\index{include!gtsdev}
\begin{XMP}
INCLUDE (ENUM)
INCLUDE (GTSDEV)
\end{XMP}
where the first file contains the ENUMeration types, and the second
contains the GTS-GRAL DEVice types. No compiler options are necessary.
 
An alternative method to access the information in the include files
would be via the PATCHY utility by using the KEEP sequences of
GTSDEV and ENUM stored in the PATCH GKSINCL on the GKSPACK Pam file.
To access this Pam file on IBM type GIME~CERNPAMS.
 
Full information on GKS under VM can be found by using the command
{\bf FIND~GKS} and for the higher level packages via
{\bf FIND~HPLOT}, {\bf FIND~GKSPACK},
{\bf FIND~NAGLIB}, {\bf FIND~HIGZ},
and {\bf FIND~PAW}.
The example programs listed in the Appendix of the
{\it GKS/GKS-3D Primer} are available on the disk accessed via
{\bf GIME~GKS} with the file names:
\index{exref}
\index{execution!on IBM}
\begin{XMP}
GKSEXn FORTRAN  (where n = 1, 6)
\end{XMP}
 
The GKS and GSK-3D libraries released in October 1989 are compatible with
the IBM XA exploitation mode.
\subsection{Use of Segment Storage on IBM}
 
The CERN GKS installation uses logical unit 91 for the dynamic segment
storage file.
A small file is created on the mini-disk with the largest free writeable
space, dynamically extended as necessary, and deleted when GKS is closed.
Jobs which crash or fail to call GCLKS will leave the file
GKSDYNAM~FT91F001 on a mini-disk and it is best to delete it.
Applications which create a large number of segments may require
up to 5 cylinders of free disk space which can be put on a temporary
disk for example.
\subsection{Debugging on IBM}
\index{Debugging on IBM}
\index{IBM!debugging}
\index{IBM!DIAL (use of)}
 
Debugging {\it interactive} graphics programs on VM is very difficult,
but by using two terminals it can be done more comfortably, and one can
also use the interactive debugger. The procedure is as follows:
\begin{OL}
\item Login on the alphanumeric terminal as usual, then inform VM that
the graphics output will be on another terminal by the command:
\index{DIAL}
\begin{XMP}
DEF GRAF 019 3270
\end{XMP}
(Where 019 is simply a free address.)
\item Then on the graphics terminal which probably has to be connected
through index class 125, connect using the DIAL command:
\begin{XMP}
DIAL userid
\end{XMP}
\end{OL}
Now all alphanumeric i/o, debug commands and FORTRAN run time errors
will be on the alpha terminal and only the graphics i/o on the DIALled
terminal.
\subsection{VAX/VMS}
\index{VAX!GKSGRAL on}
\index{GKSGRAL!on VAX/VMS}
\index{HPLOT}
\index{HIGZ}
\index{GKSPACK}
\index{GRAFLIB}
 
The recommended way of linking GKS is to use the GKS or GRAFLIB parameters
to the {\bf CERNLIB} command to define the symbol%
\footnote{These commands also define the logical name \Lit{GKS\_ROOT}.}
'\Lit{LIB$}' which provides access to just
the GKS library, or to both GKS and various higher level graphics
packages which use GKS, notably the CERN Program Library packages
GKSPACK (J551), HPLOT (Y251) and HIGZ (Q120).
Further details on what follows may be obtained via the command
\Ucom{HELP CERNLIB}.
\begin{XMP}
CERNLIB GKS
        or
CERNLIB GKS3D
        or
CERNLIB GRAFLIB/GTS2D        [or /GTS3D]
\end{XMP}
The optional parameter '/GTS2D' or '/GTS3D' gives access to the 2D or 3D
versions of the GTS-GRAL package.
In addition, the CERNLIB command provides access to three versions
of the libraries: {\bf OLD}, {\bf PRO} (default), and {\bf NEW}.
For example, to access the previous version of GRAFLIB use the switch
{\bf 'GRAFLIB/OLD'}.
The current default version of GKS is the version from GTS-GRAL,
and so the switch '/GTS2D' may be omitted.
 
The default situation is to link to shared versions of the libraries.
For non-shared versions it is necessary to add the extra switch
'/NOSH[AREABLE]'.
 
The basic commands and tools to use GKS are:
\begin{DLtt}{123456}
\item[CERNLIB GKS or GKS3D]
To access just GKS or GKS3D
\item[CERNLIB GKS/NOSH[AREABLE]
To access a non-shared version of GKS or GKS3D
\item[CERNLIB GRAFLIB/GTS2D or /GTS3D]
To access the GKS and higher level packages
\item[FOR gksprog]To compile.
\item[LINK gksprog,'LIB\$']To link.
\item[RUN gksprog.exe]To run.
\end{DLtt}
 
\index{include!on VAX/VMS}
The include files used when compiling graphics programs which
define the Workstation Types and GKS Parameters (Enumerated Types)
are accessed via the logical names:
\index{include!enum}
\index{include!gtsdev}
\begin{XMP}
      INCLUDE 'GKS$GTSDEV'
          and
      INCLUDE 'GKS$ENUM'
\end{XMP}
and the example programs listed in the appendix of the
{\it GKS/GKS-3D Primer} may be found in:
\index{execution!on VAX}
\begin{XMP}
GKS_ROOT:[DMO]GKSEXn.FOR (n = 1,6)
\end{XMP}
 
An alternative method to access the information in the include files
would be via the PATCHY utility by using the KEEP sequences of
GTSDEV and ENUM stored in the PATCH~GKSINCL on the GKSPACK Pam file.
On VAX VMS this is stored in:
\begin{XMP}
CERN_ROOT:[PAM]GKSPACK.PAM.
\end{XMP}
\subsection{\protect\label{sec:vstnref}VAXstation features}
\index{VAX!setting window size}
\index{VAXstation}
\index{X-Window}
 
In the PROduction version (3.2) of GKSGRAL the driver for the VAXStation
uses the UIS interface. To use the X-Window driver (for VAXStations
with DECWindows interface) one has to move to the new version of
GKSGRAL (3.4) which is only available on request.
The UIS driver allows a single process to
open multiple GKS workstations, each corresponding to a new window.
To use this feature it is necessary to call GOPWK once to open each workstation
with a different value in the series of UIS workstation types.
There are also several special features available for users of VAXstations
in order to manipulate the windows:
\begin{UL}
\item The logical name \Lit{GKS_WINDOW} set by the system startup procedure
\Lit{GKSSTART.COM} can point to any directory which contains a copy of
the file WINDOW.DAT. Users can redefine this logical name later
as they wish. However, if a private version of the file WINDOW.DAT
is found in the current working directory, then this one will be used
rather than \Lit{GKS_WINDOW:WINDOW.DAT}.
\item
\index{GKS routine!{\protect\tt GCSDWN}}
The CERN utility routine GCSDWN (Set Display Window) can be used for
VAXstations in order to set inside a program the display window size,
position and title (used by GOPWK), instead of using the  values stored
in the file WINDOW.DAT. The function must be called {\bf before}
calling GOPWK. The calling sequence is:
\begin{XMP}
SUBROUTINE GCSDWN (IWTYPE, RWIN, TITLE)
INTEGER       IWTYPE
REAL          RWIN(4)
CHARACTER*(*) TITLE
\end{XMP}
Where IWTYPE is the workstation type (8601, 8602, etc...),
RWIN is the window size and position, and TITLE contains the name given
to the window by the display manager.
\item
\index{GKS routine!{\protect\tt GCCDWN}}
The CERN utility routine GCCDWN (Change Display Window) can be used for
VAXstations in order to change interactively inside a program the display
window size and position after the window has been created.
The calling sequence is:
\begin{XMP}
SUBROUTINE GCCDWN (WKID, RWIN, CODE)
INTEGER       WKID
REAL          RWIN(4)
INTEGER       CODE
\end{XMP}
Where WKID is the workstation identifier, RWIN is the window size and
position, and CODE takes either the value '1' or '2'.
If CODE=1, then any window size can be defined but the workstation viewport
is not changed, which may change the aspect ratio.
If CODE=2, then there is a restriction placed on the window size that can be
chosen to ensure that the aspect ratio of the window contents remains
unchanged. The function uses the largest window that can fit into the size
the user has chosen and that has the same height/width ratio as the initial
window. The workstation viewport is automatically resized and the
workstation updated.
\end{UL}
For both GCSDWN and GCCDWN, the window size and position have to be given in
the same order as in the file WINDOW.DAT:
\begin{XMP}
RWIN(1) = window size in X in metres
RWIN(2) = window size in Y in metres
RWIN(3) = window position X on screen in metres
RWIN(4) = window position Y on screen in metres
\end{XMP}
\subsection{\protect\label{sec:unixlib}UNIX}
\Lit{$==>$} Uptodate ???
\index{Unix!GKSGRAL on}
\index{GKSGRAL!on UNIX}
\begin{note}
{\it File names and directory paths under UNIX}
\footnote{UNIX is a trade mark of AT\&T}
{\it are case sensitive.}
\end{note}
 
Since October 1989 the CERN GTS-GRAL licence has been extended to include
general use of the company's software on any UNIX platform, including
UNICOS on the CRAY. In addition, from July, 1990, GKSGRAL on Apollo
platforms is supported under UNIX, rather than Aegis. However, affiliated
institutes with a UNIX licence will still need a licence specifically for
Apollo if they wish to receive the Apollo screen drivers.
 
As the UNIX system runs on many hardware platforms, only a few of which
are available at CERN, it may not be possible for the CERN Program Library
to distribute binary libraries for the particular machine a user requires.
Thus, UNIX users may have to install the software from
\index{Unix!tar file}
\index{tar file}
a TAR file as explained in Appendix on Page~\pageref{sec:unixdis}.
 
To use GKSGRAL or GKSGRAL-3D one requires access
to the libraries, font files and include files.
These should be made available via environment variables provided
by the system manager. For example, if the C shell is being used,
the following should be included in the .login file:
\begin{XMP}
setenv gkshome   /user/gts-gral_root_directory
setenv gkslib    $gkshome/gks/libs/gkslib.a
setenv gksdriv   $gkshome/gks/libs/gksdriv.a
setenv gks3dlib  $gkshome/gks3d/libs/gks3d.a
setenv GKS_FONTS $gkshome/gks/fonts
\end{XMP}
Thus, all variables are defined in terms of \Lit{$gkshome}, which should
be set to point to the local root directory.
Conversely, one can also store the files in a way analogous
to that used for the CERN Program Library, in which case the
environment variables should be set to:
\begin{XMP}
setenv gkslib    /cern/gks/pro/lib/gkslib.a
setenv gksdriv   /cern/gks/pro/lib/gksdriv.a
setenv gks3dlib  /cern/gks/pro/lib/gks3dlib.a
setenv GKS_FONTS /cern/gks/pro/dat
\end{XMP}
Environment variables may be set under the Bourne or Aegis shells
as in the example:
\begin{XMP}
GKS_FONTS=/cern/gks/pro/dat; export GKS_FONTS      #Bourne
                  or
GKS_FONTS := '/cern/gks/pro/dat'; export GKS_FONTS #Aegis.
\end{XMP}
 
To drive terminals attached via RS232 terminal lines, it is necessary
also to make a logical connection between the Connection Identifier
specified in the call to Open Workstation and the device.
GKSGRAL communicates with a set of devices defined by environment
variables {\it gksch01} to {\it gksch18}, where the numbers
1 to 18 correspond to the connection identifier. Thus, if the
connection identifier is set to '1', and one wishes to perform graphics
on the same terminal used for alpha-numeric commands, then under
the C shell one would need to type:
\begin{XMP}
setenv gksch01   /dev/tty
\end{XMP}
 
To compile and link a Fortran program 'myprog.f' use the commands:
\begin{XMP}
f77 myprog.f $gkslib $gksdriv -o myprog.exe
\end{XMP}
In this case the f77 command is used both to compile and link the
program. One can also compile and link the program separately.
However, even in this case one should probably use the f77 command to
link, rather than ld. For example, on DECstations the f77 command
automatically includes all the system libraries, whilst ld does not.
\begin{XMP}
f77 -c myprog.f -o myprog.o
\end{XMP}
\begin{note}
In general under UNIX the linker searches libraries in order.
Thus, a reference from a library at the end of the sequence to a routine
stored in an earlier library will result in an unresolved external
reference. This is the case for GKS-3D. A solution is to specify
the earlier library twice:
\begin{XMP}
f77    myprog.o $gks3dlib $gksdriv $gks3dlib -o myprog.exe
\end{XMP}
\end{note}
 
\index{include!on UNIX}
The include files used when compiling graphics programs which
define the Workstation Types and GKS Parameters (Enumerated Types)
are to be found in the directory \Lit{$gkshome/utl}
 and/or, on systems which
follow the CERN library conventions, /cern/gks/pro/utl.
They may be accessed from a FORTRAN program as follows:
\index{include!enum}
\index{include!gtsdev}
\begin{XMP}
      INCLUDE '/cern/gks/pro/utl/gks_gtsdev'
       and
      INCLUDE '/cern/gks/pro/utl/gks_enum'
\end{XMP}
 
At run time GKS reads in the files defining the software fonts.
These are accessed via an environment variable \Lit{GKS_FONTS} which should
defined either by the system or user login procedure.
 
\index{execution!on UNIX}
The example programs listed in the appendix of the
{\it GKS/GKS-3D Primer} are available either in \Lit{$gkshome/dmo}
or in \Lit{/cern/gks/pro/dmo}, with the names gksexN.f (N=1 to 6).
However, one may need to edit them in order to set the desired workstation
type and to use the correct paths to the include files.
On some systems the top directory /cern may not exist, in which case
one should use the environment variable \Lit{$CERN} to point to the root
directory.
\begin{note}
{\it
File names and directory paths under UNIX are case sensitive;
\Lit{$CERN} is not equivalent to \Lit{$cern}!}
\end{note}
 
A selection of help files, including this one, are to be found
in \Lit{$gkshome/doc}.
\subsection{APOLLO}
\Lit{$==>$} Uptodate ???
\index{Apollo!GKSGRAL on}
\index{GKSGRAL!on APOLLO}
\index{Apollo!GPR}
\index{Apollo!GSR}
 
From July 1990 onwards only Aegis SR~10 and later system releases
will be supported. Aegis SR~9.7 library versions are obtainable,
but will not be updated. Aegis SR~10 is compatible with UNIX,
and so simplifies support. However, this affects file formats and access control,
as well as the case sensitivity of file names. Although earlier versions of AEGIS
were insensitive to the case of file names, this is no longer true from for
SR~10.0 onwards. Thus, for example, the program statement:
\begin{XMP}
      INCLUDE '/CERN/GKS/PRO/UTL/GKS_GTSDEV'
\end{XMP}
will not work with SR~10.0. The path name within quotes
{\bf must be in lower case}.
Other points to watch for are that a '/' character is used after the tilde
when accessing files via the naming directory,
and that when using UNIX shells every command creates a new process, so care must
be taken when using scripts to set variables that they run in the context
of the current process.
For example, by typing \Ucom{source my\_script} under the
C~shell, or \Ucom{. my\_script} under the Bourne shell.
 
Apart from the Appendix E metafile and PostScript drivers, the standard
CERN APOLLO libraries include drivers for both the GPR and GSR graphics
interfaces. For machines such as the DN590, with GSR hardware support,
the GSR driver will produce improved performance. This driver also
allows a single process to open multiple GKS workstations, each
corresponding to a new APOLLO window. The next release of this driver
is scheduled to support level C input, as well as a display surface size
which may be changed dynamically. To use multiple GSR windows from a single
graphics process it is necessary to call GOPWK once to open each workstation
with a different value in the series of GSR workstation types.
 
At run time GKS reads in the files defining the software fonts (which are
used by all drivers). These are accessed via an environment variable
\Lit{'GKS_FONTS'} which may be created by a command in the 
startup or \Lit{.login} files.
At CERN, this environment variable points to the cernlib directory
\Lit{/cern/gks/pro/dat} (or \Lit{.../new/dat} or \Lit{.../old/dat}, 
depending on the version
required). The fonts are distributed in the directory
\Lit{$gkshome/gks/fonts}.
(In addition to the software fonts used by all drivers, the GSR driver
can use also the hardware fonts described below.)
 
For use of the GPR interface, the user's home directory should contain a
file (or link) called \Lit{gks_characteristic} which contains set-up
information describing the display. An example of this file may be found in:
\begin{XMP}
/cern/gks/pro/dat/gks_characteristic
\end{XMP}
If the user does not have a link from the naming directory to a
private copy of \Lit{gks_characteristic}, then GKSGRAL will attempt to read a
default version which should be made available by creating the
following link:
\begin{XMP}
crl   /dev/gks_characteristic                   @
      /cern/gks/pro/dat/gks_characteristic
\end{XMP}
 
(As /dev is protected, this must be done from a privileged account.)
A private copy of the file may be edited to give the
desired window size. As an example, the Workstation Type 10002
corresponds to the second line of the file.
The standard versions of this file is distributed in
\Lit{$gkshome/gks/drivers/adgpr}.
 
The GSR driver requires access to two configuration files, one called
\Lit{gks_workstations.config} which is similar to the GPR
\Lit{gks_characteristic} file containing set-up information describing
the display, and one called \Lit{gks_fonts.config} which lists
the available hardware fonts. ~
Copies of these files, modified as necessary,
may be stored in (or pointed to by links from) the user's home directory,
or default versions should be made available by creating the links:
\begin{XMP}
crl /sys/node_data/gks_workstations.config       @
    /cern/gks/pro/dat/gks_workstations.config
      and
crl /sys/node_data/gks_fonts.config              @
    /cern/gks/pro/dat/gks_fonts.config
\end{XMP}
The standard versions of these files are distributed in
\Lit{$gkshome/gks/drivers/adgsr}.
 
As for other UNIX machines, the libraries are stored either in
\Lit{$gkshome/gks/libs} or /cern/gks/pro/lib, and it is easiest to access
them via environment variables:
\begin{XMP}
setenv gkslib    /cern/gks/pro/lib/gkslib_3000.a
setenv gksdriv   /cern/gks/pro/lib/gksdriv_3000.a
setenv gks3dlib  /cern/gks/pro/lib/gks3d_3000.a
\end{XMP}
Where the '3000' refers to the compiler option used to produce executable modules
targeted at the DN3000 style machines with a Motorola 68020/30/40. One
can replace '3000' by '10000' for the DN10000 library versions.
 
To compile and link directly to the libraries use:
\begin{XMP}
/com/ftn  myprog.ftn  -indexl
/com/bind myprog.bin  $gkslib $gksdriv -b myprog.exe
\end{XMP}
where the parameter '-indexl' is optional but recommended.
The parameter -save may also be used for safety if variables which must be
available on re-entry to a routine have not been stored in a COMMON BLOCK.
However, use of -save is very detrimental to code optimization,
especially on the DN10000. The Aegis versions of the Fortran compiler
must be used to ensure that the external global symbols use the same
naming conventions as for the libraries (i.e. lower case names with
no trailing underscore).
 
\index{include!on Apollo}
The include files used when compiling graphics programs which
define the Workstation Types and GKS Parameters (Enumerated Types)
are to be found in the directory '/cern/gks/pro/utl'.
(Distributed in \Lit{$gkshome/utl}.)
They may be accessed from a Fortran program as follows:
\index{include!enum}
\index{include!gtsdev}
\begin{XMP}
      INCLUDE '/cern/gks/pro/utl/gks_gtsdev'
 and
      INCLUDE '/cern/gks/pro/utl/gks_enum'
\end{XMP}
(Under SR~10.2 the Fortran compiler accepts VMS syntax for the
INCLUDE statement.)
 
\index{Apollo!inlib}
As linking to INLIB (shared) versions of the libraries takes up much less
space, and is much faster, INLIB libraries are defined as follows:
\begin{XMP}
setenv gkslib_inlib    /cern/gks/pro/lib/gkslib_3000.inlib
setenv gks3dlib_inlib  /cern/gks/pro/lib/gks3d_3000.inlib
\end{XMP}
These may be linked using the command:
\begin{XMP}
\Ucom{/com/bind myprog.o -b myprog.exe -inlib $gkslib_inlib}
                  or
\Ucom{/com/bind myprog.o -b myprog.exe -inlib $gks3dlib_inlib}
\end{XMP}
 
\index{execution!on APOLLO}
The example programs listed in the appendix of the
{\it GKS/GKS-3D Primer} may be found in:
\begin{XMP}
/cern/gks/pro/dmo/gksexN.ftn (N = 1,6)
\end{XMP}
They are distributed in \Lit{$gkshome/dmo}.
\subsubsection{APOLLO Models}
 
APOLLO nodes exit with various CPU options. The latest machine, the DN10000,
will only work with libraries compiled specifically for this hardware.
All other recent APOLLO models use the standard M68020 instruction set,
on which can be run libraries compiled with the '3000' option.
Note that CERN no longer produces libraries compiled with the 'any' switch.
\subsubsection{Apollo Workstation Types}
 
The following consists of a list of the workstation types for
the GTS-GRAL workstation drivers installed on Apollo.
The full list may be consulted in \Lit{gks_gtsdev}, or in
Appendix on Page~\pageref{sec:gtstyp}.
\begin{DLtt}{123456}
\item[3]WISS
\item[4]Metafile Output
\item[5]Metafile Input
\item[9701-9708]Apollo GSR interface
\item[10002]Apollo DN300, DN3000, Monochrome (GPR interface)
\item[10003]Apollo DN550, DN660, Colour (GPR interface)
\item[10004]Apollo DN3000/4000, Colour (GPR interface)
\item[12201]Postscript colour portrait
\item[12202]Postscript colour landscape
\item[12203]Postscript monochrome portrait
\item[12204]Postscript monochrome landscape
\item[10201]2D-Metafile for 3D GKS
\end{DLtt}
\subsection{CRAY under UNICOS}
\Lit{$==>$} Uptodate ???
\index{Cray!GKSGRAL on}
\index{GKSGRAL!on CRAY}
\index{Unix!on CRAY}
 
As the CRAY is used as a batch production service,
only the WISS and metafile workstations have been made available in the
GKSGRAL library, which should be accessed via the 'cernlib' command.
Detailed information on use of the 'cernlib' command for the CRAY is
available under VM/CMS by typing: {\bf FIND~CRAY~CERNLIB}.
However, for those users wishing simply to make use of GKS,
then the commands to type are:
\begin{XMP}
cernlib gks
   or
cernlib gks3d
\end{XMP}
which create a file \Lit{'LIB$'} in the user's working directory
which contains the required libraries (the case matters).
The cernlib command may take the switches {\bf -o} and {\bf -n}
to allow the selection of {\bf o}ld or {\bf n}ew library versions.
 
To compile and link the FORTRAN program 'myprog.ftn' use the commands:
\begin{XMP}
 cft77     myprog.ftn
 segldr -o myprog.exe   myprog.o  LIB$
\end{XMP}
 
At run time GKS reads in the files defining the software fonts.
These are accessed via a an environment variable \Lit{GKS_FONTS} which is
defined by the system login procedures.
 
\index{include!on CRAY}
The include files used when compiling graphics programs which
define the Workstation Types and GKS Parameters (Enumerated Types)
are to be found in the directory '/cern/gks/pro/utl'.
They may be accessed from a FORTRAN program as follows:
\index{include!enum}
\index{include!gtsdev}
\begin{XMP}
      INCLUDE '/cern/gks/pro/utl/gks_gtsdev'
       and
      INCLUDE '/cern/gks/pro/utl/gks_enum'
\end{XMP}
 
The example programs listed in the appendix of the
{\it GKS/GKS-3D Primer} are not available on the CRAY.
\section{\protect\label{sec:decgks}DECGKS: Coexistence with GKSGRAL and Implementation}
 
One of the  advantages of using an ISO standard graphics package
is that users are not limited to the products of a single supplier.
Thus, although the principal GKS implementation supported at CERN
is that of GTS-GRAL, users of Digital Equipment Corporation (DEC)
machines may wish to use the DEC implementation of GKS.
This might be because of the availability of drivers, or because
the performance of DEC software on the company's own machines is
likely to be better than that of third party software suppliers
who are constrained to ensure that their libraries operate in
many different environments.
 
Whilst there are no major problems in moving between DECGKS and GKSGRAL
there are several implementation dependencies, and these are documented
below. A large number of routines have been added to the set of tools
in GKSPACK (see section on Page~\pageref{sec:gkspref}).
Some of these have been written in order to aid the portability of applications
between different GKS implementations by supplying information
about the Workstation Types and Connection Identifiers of a particular
implementation. Other routines have been provided to emulate extensions of
GKS available in the GKSGRAL implementation. Whilst users of GKSGRAL
will have these routines available in the GKSGRAL library,
users of DECGKS will need to link to an additional library
containing a version of GKSPACK tailored for the DECGKS implementation.
This library is called \Lit{GKSPACK_DEC.OLB}, and on the CERN VAX cluster
may be found in:
\begin{XMP}
GKS_ROOT:[LIB]GKSPACK_DEC.OLB
\end{XMP}
Implementation Dependencies:
\begin{UL}
\item Workstation Types and Connection Ids
 
Implementations are free to choose whichever Workstation Types and
Connection Identifiers they wish. Thus, those in use by GKSGRAL and
DECGKS do not match. The routines in the library GKSPACK go some way to
alleviating this problem (see section on Page~\pageref{sec:gkspref}).
\item Fonts and Attributes
 
Neither GKS, nor any other Graphics Standard, defines the shapes of
the characters corresponding to a particular font number. In addition,
a particular implementation may provide access to hardware fonts
on some devices. This also applies to hatch styles and patterns, etc.
The fonts and hatch styles available from GKSGRAL are defined in
on Page~\pageref{sec:impref1}, and a brief comparison of the two implementations
follows:
\begin{XMP}
   GTSGRAL                    |         DECGKS
\end{XMP}
 
Hardware Fonts:
\begin{XMP}
See wk descr. tables          |  DECWINDOWS : -101 to -113
                              |  UIS        : -200 to -202
\end{XMP}
.pa
 
Software Fonts
\begin{XMP}
-1 to -11: normal,proport.    |  font 1 = font -1 = DEC GKS
                              |  multinational font
-13      : greek              |
-51      : solid filled font  |
same font numbers - 100:      |  -2 to -23: Hershey fonts
  idem but italics            |
same font numbers - 200:      |
  idem but monospaced         |
same font numbers - 300:      |
  idem but italics monospaced |
\end{XMP}
 
Line types
\begin{XMP}
                              |  -1 to -8  DEC specific
\end{XMP}
 
Marker Types
\begin{XMP}
-101 to -114 GKSGRAL specific |  -1 to -13 DEC specific
\end{XMP}
 
Fill Area Hatch Styles
\begin{XMP}
 -101 to -124 (CERN specific) |  -1 to -33 (UIS specific)
                              |  -1 to  -9 (DECwindows specific)
\end{XMP}
 
Fill Area Patterns
\begin{XMP}
      None                    |   1 to 196 (UIS specific)
                              |   1 to  28 (DECwindows specific)
                              | -29 to -58 (DECwindows specific)
\end{XMP}
\item Data Records
 
Both the contents and internal format of data records used by
GKSGRAL and DECGKS are different. The format should not affect the majority
of users, who would not require to access data record explicitly.
However, users will be affected by the differences in data record
contents if they make use of facilities to initialize input devices
or use GDPs.
 
To help solve this problem, higher-level routines have been provided
by GTS-GRAL which hide details of the data record contents.
These include GUARC, GUBEZ1, GUCIR1, GUCIR2, GUCUR1, GUELL1, GUELL2,
and GUMEN2. The library \Lit{GKSPACK_DEC.OLB}, described in section
on Page~\pageref{sec:gkspref}, contains
emulations of these routines which work with DECGKS.
\item Metafiles
 
Whilst the content of the GTS-GRAL and DECGKS metafiles are logically
the same, the file formats are not. In order that the CERN metafile
utility programs GRVIEW and GRPLOT may be used with metafiles produced
with DECGKS, an option will be introduced into GRCONV to convert them
to the same format as those written by GTS-GRAL (but not vice versa).
Until this feature is installed, anyone wishing to convert a DECGKS
metafile should contact the UCO.
.pa
\item Input
 
Whilst stroke input requires a trigger for each locator position in the
GTS-GRAL GKS implementation, that of DEC does not, but simply samples
the locator position at fixed time or distance intervals.
Thus, GTS-GRAL's stroke input is more or less equivalent to
calling Request Locator in a loop.
In order to provide functionality when using DECGKS equivalent to that
in GKSGRAL, a CERN-written version of GRQSK may be found in the library
\Lit{GKSPACK_DEC.OLB}.
 
The DECGKS implementation uses separate windows for messages and
also for string, choice, and valuator input.
The window size depends on the echo area specified in GINST, GINCH,
and GINVL.
\end{UL}
