head	1.2;
access;
symbols;
locks
	goossens:1.2; strict;
comment	@# @;


1.2
date	99.09.07.06.55.38;	author goossens;	state Exp;
branches;
next	1.1;

1.1
date	99.08.31.15.27.12;	author goossens;	state Exp;
branches;
next	;


desc
@Version before modifications for September 99 release
@


1.2
log
@mods for version 99b
@
text
@<?xml version="1.0" ?> 
<!-- Changed by: Michel Goossens, 12-Feb-1999 -->
<!DOCTYPE document SYSTEM "minilatex.dtd"[
<!ENTITY % MathML     "INCLUDE">
<!ENTITY % LaTeXmath  "IGNORE">
<!ENTITY quot "&#34;">
<!ENTITY GNU  "GNU">
<!ENTITY NICE "Nice">
<!ENTITY OBJ  "Objectivity/DB">
<!ENTITY UNIX "Unix">
<!ENTITY WNT  "Windows/NT">
<!ENTITY % misc.new "|minipage">
<!ELEMENT minipage (#PCDATA|includegraphics|caption)*>
<!ENTITY % likepara.new "|texonly|small">
<!ELEMENT texonly (#PCDATA|par|figure|ref)*>
<!ELEMENT small (#PCDATA|par|emph)*>
<!ENTITY % preformat.new "|alltt|listing">
<!ELEMENT alltt (#PCDATA|emph)*>
<!ELEMENT listing (#PCDATA|emph)*>
<!ENTITY % xref.new "|vref">
<!ELEMENT vref     EMPTY>
<!ATTLIST vref     refid IDREF #REQUIRED>
]>
<document class="lhcpp">
<bodymatter>
<chapter id="H1PresentingLHCPP">
<stitle>Presenting LHC++</stitle>
<section>
<stitle>A short historical introduction</stitle>
<index item="History of LHC++"/>
<index item="LHC++!history"/>

<par>In 1995 a working group, called <emph>LHC++</emph>, consisting of
representatives of IT Division's ASD Group and of the various LHC
experiments, was created to investigate how the approximate equivalent
of the current CERNLIB environment could be provided in the LHC
era. Although the primary objectives of the discussions concentrated
on proposing solutions for future LHC experiments, it is essential
that other HEP experiments which are coming online in the next couple
of years will also be able to benefit from the proposed strategy.</par>

<par>It is clear that (industry) standard solutions should be used
whenever possible. This is nothing new since in the past commercial
libraries or programs, such as GKS/GTS, Numerical Algorithms Group
(NAG) libraries, Phigs, Historian, and CMZ)
have been used in the CERNLIB environment.  Intensive investment of
manpower should only be made in HEP-specific developments, where the
needed functionality cannot be obtained <emph>off the shelf</emph> at
affordable prices. An instance of such a HEP development is the CLHEP
class library, which is also a nice example of reuse.</par>
<index item="CERNLIB"/>
<index item="NAG"/>
<index item="Numerical Algorithms Group Ltd"/>
<index item="GKS"/>
<index item="GTS"/>
<index item="Phigs"/>
<index item="Historian"/>
<index item="CMZ"/>
<index item="CERNLIB"/>

<par>Working closely with the LHC collaborations and other HEP
Laboratories in 1996 and 1997 an interim strategy was defined and a
number of licences for the commercial components was obtained.  When
several <emph>a priori</emph> solutions were available, a study was made
to determine which was the most suited in the HEP context.  We also
tested the proposed solutions at a few sites and ensured that it is a
workable environment.</par>

</section>
<section>
<stitle>Objectives</stitle>

<par>The main objective of LHC++ is to satisfy the requirements of the
LHC experiments in terms of the overall software environment that
today is provided by CERNLIB, as requested in these experiments'
<emph>Computing Technical Proposals</emph></par>
<index item="CERNLIB"/>

<par>This translates into the following key points for the short to
medium term:</par>

<itemize> 
<item>identify and provide key HEP-specific functions;</item>
<item>define affordable solutions for the non-HEP-specific parts;</item>
<item>monitor the non-HEP world for possible future useful
software;</item>
<item>study and understand the requirements of the LHC experiments for
C++-based mathematical libraries, and evaluate existing and future
developments, both commercial and otherwise in this area;</item>
<item>study the requirements for a minimisation package
(Minuit-replacement), in particular follow closely developments of
the STABLE project, which should provide the needed functionality,
both stand-alone and in the framework of IRIS Explorer;
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>
<index item="STABLE"/>
<index item="Minimisation!STABLE"/>
</item>
<item>undertake a number of pilot projects with the experiments 
to test the overall functionality of the LHC++ environment;</item>
<item>supplement, where necessary, the existing documentation, both 
printed and online, with a set of user guides and tutorials;</item>
<item>agree with the experiments and other HEP laboratories on
a scheme for managing licenses, so that the best possible deals 
can be negotiated.</item>
</itemize>

<par>The scope of the LHC++ project covers the following:</par>

<itemize>
<item>foundation level class libraries;</item>
<item>mathematical libraries;</item>
<item>graphical libraries;</item>
<item>visualisation tool-kits, data analysis, histograms;</item>
<item>event generators (in collaboration with, e.g., Lund);</item>
<item>detector simulation (GEANT-4);
<index item="GEANT 4"/>
</item>
<item>object persistency (&OBJ; via RD45 at present).
<index item="RD45 Project"/>
<index item="&OBJ;"/>
</item>
</itemize>

<par>The primary focus is on C++-based solutions, although, of course,
developments in the software arena, in particular the increased
importance of Java, are closely watched.</par>

</section>
<section>
<stitle>Collaboration with the experiments</stitle>

<par>The LHC++ project is a joint effort between IT Division (mainly
ASD Group), the LHC experiments, plus NA45, Compass,...  Andreas
Pfeiffer is responsible for its overall coordination.</par>

<par>Regular (bi-weekly) LHC++ and RD45 meetings are held in Building 40. This
is an ideal forum for communication with the physics community since
its allows us to bring our users regularly up to date with the latest
news. Also, and more importantly, it provides us with an input channel
from the experiments about how they use the software, which are
possible problem areas which have to be addressed, and what are the
future developments they would like to see.
The minutes as well as material presented on the progress
in the various areas are available on the web 
(see <url name="http://wwwinfo.cern.ch/asd/lhc++/meetings.html"/>).
</par> 
<index item="Regular meetings (LHC++, RD45)"/>
<index item="LHC++!Regular meetings"/>

<par>Twice a year a formal <emph>LHC++ Workshop</emph>
(see <url name="http://wwwinfo.cern.ch/asd/lhc++/workshops.html"/>)
take place where progress reports are presented by all HEP-wide
collaborations who are using LHC++ software. This Workshop provides an
efficient forum for feedback from the experiments and permits us to
steer long-term development in the right direction by taking into 
account constraints and requirements of as wide a user base as possible.</par>
<index item="LHC++!workshop"/>
<index item="Workshop (LHC++)"/>

<par>All three LCB common projects (GEANT-4, RD45, LHC++) stress the formal
gathering of use of requirements. Equally the priorities for these
projects, each of which is dominated by members of LHC and other
HEP experiments, are agreed at the level of the LCB, which is itself
mainly composed of experimental representatives.</par>

</section>
<section>
<stitle>Current Situation</stitle>

<par>
By using commodity solutions where-ever possible, we ensure that
the proposed solutions are widely used, well-debugged and well
documented, and are also more affordable. These solutions are being
complemented by HEP-specific components, where needed, by building a
HEP user-layer on top of standards-conforming products.
</par>

<par>
To ensure that the commercial components work well together, the
LHC++ strategy closely adheres to standards - both <emph>de-facto</emph>
and <emph>de-jure</emph>.  Examples of <emph>de-jure</emph> standards
include the <emph>Standard C++ Library</emph> (see 
<url name="http://www.objectspace.com/Products/CCS/Standards/standards.html"/>)
and ODMG-compliant Object Database Management
Systems (ODBMS), while instances of <emph>de-facto</emph> standards 
are industry standard graphics packages,
such as OpenGL, Open Inventor and IRIS Explorer
(see
<url name="http://www.nag.co.uk/visual/IE/iecbb/Tutorial/index.html"/> 
for a tutorial), all originally from Silicon Graphics (SGI).
<index item="Standard Library"/>
<index item="ODBMS"/>
<index item="Object Database Management System"/>
<index item="OpenGL"/>
<index item="Open Inventor"/>
<index item="IRIS Explorer"/>
<index item="SGI"/>
<index item="Silicon Graphics"/>
</par>

<par>
The table below shows this layered structure more schematically.
Licenses for all commercial components are available at CERN, where
the software has been installed on all &UNIX; platforms (Dec, HP, and
Sun for IRIS Explorer 3.9) on AFS in <texttt>/afs/cern.ch/sw/lhcxx</texttt>,
while on &NICE;/&WNT; it is available under <verb>z:\p32\lhcxx</verb>.
<index item="AFS"/>
<index item="&WNT;"/>
<index item="&NICE;"/>
</par>

<par>
<tabular border="1" preamble="|c|">
<row><cell>GEANT-4, MCLIBS++</cell></row>
<row><cell>HEPExplorer, IRIS Explorer</cell></row>
<row><cell>HepVis, HEPInventor</cell></row>
<row><cell>OpenGL, Open Inventor, Master Suite</cell></row>
<row><cell>HepMATH, including GEMINI</cell></row>
<row><cell>NAG C library (with C++ headers)</cell></row>
<row><cell>CLHEP</cell></row>
<row><cell>HTL</cell></row>
<row><cell>HEPODBMS</cell></row>
<row><cell>ODMG, ODBMS (&OBJ;) + persistent STL</cell></row>
<row><cell>Standard C++ Libraries</cell></row>
</tabular>
<index item="NAG"/>
<index item="GEANT 4"/>
</par>

<par>
All of the commercial LHC++ components come with excellent online
documentation. In most cases, printed documentation, often in the form
of published books, is also available and can be bought from the User
Consultancy Office (UCO) at CERN. HEP-specific examples and other
information specific to the HEP environment is clearly not available
from the vendors.
</par>

<par>
The main purpose of the present manual is to provide a tutorial
introduction to the use of LHC++ tools for physicist new to the LHC++
computing paradigm.  The current guide describes the present state of
some of the HEP extensions.  Their precise form and application
program interface (API) probably needs to be refined or extended in
a few places. Therefore we invite all users of the LHC++ software to
forward their comments and suggestions to the LHC++ team,
preferably at the LHC++ regular meetings mentioned above.
</par>
<index item="Regular meetings (LHC++, RD45)"/>
<index item="LHC++!Regular meetings"/>

</section>
<section>
<stitle>An overview of the commercial components</stitle>

<par>The commercial components of LHC++ are chosen because they offer a
coherent set of inter-operable solutions. They are built on standards
and often come as part of the standard hardware or software bundled
with the computer. Cost effectiveness has also been optimised both
for CERN and for the general CERN HEP program participants.
</par>

<subsection>
<stitle>OpenGL</stitle>
<index item="OpenGL|("/>

<par>
<emph>OpenGL</emph> (see 
<url name="http://www.sgi.com/Products/Dev_environ_ds.html"/>)
is a industry standard for graphics. It is vendor-neutral and
multi-platform, and is optimised for building environments for
developing 2D and 3D visual applications. Several vendors already
offer a hardware implementation of the standard, thus ensuring
that rendering speed will be optimal.</par>

<par>
The about 250 OpenGL procedures provide a wide range of graphics
features, such as a set of geometric and raster primitives, various
colour modes, display list or immediate mode, viewing and modelling
transformations, lighting and shading, hidden surface removal and
translucency, anti-aliasing, texture mapping, effects using fog,
smoke, or haze, etc.  As all licensed OpenGL implementations are
required to pass a set of conformance tests, and implement the same
specification and language binding document full portability between
multiple platforms is guaranteed.</par>

<par>Documentation is available as two books: the <emph>OpenGL Programming
Guide</emph>, and the <emph>OpenGL Reference Manual</emph>, both published
by Addison and Wesley (and available from the UCO at CERN).</par>
<index item="OpenGL|)"/>

</subsection>
<subsection>
<stitle>Open Inventor</stitle>
<index item="Open Inventor|("/>

<par>
<emph>Open Inventor</emph> (see
<url name="http://www.sgi.com/Technology/Inventor/index.html"/>) is an
object-oriented 3D toolkit to provide a comprehensive solution to
interactive graphics programming.  Its programming model is based on a
3D scene database optimised to ease building graphics applications. It
includes a large set of objects, such as cubes, polygons, text,
materials, cameras, lights, track-balls, handle boxes, 3D viewers, and
editors.</par>

<par>
Open Inventor is built on top of OpenGL. It defines a standard file
format (IV) for 3D data interchange and introduces a simple event
model for 3D interaction. Animation is provided with
<emph>Engines</emph>. Open Inventor offers a convenient multi-platform
3D graphics development environment, which allows efficient
manipulation of objects in a windows and operating system independent
way.</par>

<par>
Open Inventor's IV files serve as the basis for the <emph>VRML
(Virtual Reality Modelling Language)</emph> standard (see
<url name="http://vrml.wired.com"/>). The Open Inventor toolkit is
conveniently documented in three books <emph>The Inventor
Mentor</emph>, <emph>The Inventor Toolmaker</emph>, and <emph>The Open
Inventor C++ Reference Manual</emph> published by Addison-Wesley
(available from the UCO at CERN).</par> 
<index item="Open Inventor|)"/>
</subsection>

<subsection>
<stitle>MasterSuite</stitle>
<index item="MasterSuite|("/>

<par>
<emph>MasterSuite</emph> (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/MASTER_SUITE/MasterDocHTML/msuite.htm"/>)
is a C++ toolkit for data visualisation, containing class libraries
with extension nodes to Open Inventor. These extensions cover 2D
drawing and charting, 3D drawing, legends, etc., and provide a set of
input devices to ease cross-platform design of user interfaces, as
well as set of classes to develop viewers for scientific data for
output on screen as well as on several types of printers in
vector-graphics mode.  It supports vector graphics output, in
particular PostScript output and is easily extensible by programming
new user-defined customisable objects.
</par>

<par>
MasterSuite comes with four components, DialogMaster, PlotMaster,
GraphMaster, and 3DDataMaster.  Because it is built on top of Open
Inventor you always have access to all Open Inventor rendering
capabilities, such as camera, lighting, texturing, fog, etc. Similarly
Master Suite node fields can interact with Open Inventor engines for
providing animation of building sensors to change data values.  Data
can be saved in an Open Inventor database and metafile, in particular
in IV format, thus allowing one to distribute visualisation over the
Internet in a natural and straightforward way.
</par>
<index item="MasterSuite|)"/>
</subsection>

<subsection>
<stitle>IRIS Explorer</stitle> 
<index item="IRIS Explorer|("/>

<par>
<emph>IRIS Explorer</emph> (IE, see
<url name="http://www.sgi.com/Technology/explorer.html"/>) is a toolkit
for visualisation of scientific data, which can be manipulated via
visual programming tools.  Users analyse their data by connecting
building blocks, called <emph>modules</emph>.  Modules act like
<emph>filters</emph>: they read one of more streams of input data and
produce one of more streams of output data. The behaviour of modules
are controlled (interactively) by a set of parameters. IE comes will a
rather complete set of modules for performing basic data
transformations, and it is straightforward to create new modules.  It
is noteworthy that, because of its wide use, a lot of modules
developed by various user communities are available publicly, while
some can be obtained commercially (see below).
</par>

<par>
To transform user data, one constructs a <emph>map</emph>, which is a
network of interconnections between a set of modules. The various
components of a map can be manipulated individually and interactively,
and a map can be saved for later retrieval. If one of the modules is
time-consuming or needs special hardware then it can be run on a
different node of the network, thus parallel processing possibilities
are part of the system.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>

<par>
A well-written <emph>tutorial</emph> 
(see <url name="http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html"/>)
by the <emph>IRIS Explorer Centre of Excellence (IECOE)</emph> at the 
University of Leeds will you teach how to
master the basics of the program.
The <emph>IECOE website</emph> 
(<url name="http://www.scs.leeds.ac.uk/iecoe/"/>)
also provides a series of hyperlinks to other sites
from where IE modules can be downloaded. A printed and bound copy of
the <emph>IRIS Explorer User's Guide</emph> can be obtained from the
UCO.
<index item="IECOE!IRIS Explorer Centre of Excellence"/> 
<index item="IRIS Explorer|)"/>
</par>
</subsection>

<subsection>
<stitle>&OBJ;, the Object Database</stitle>
<index item="&OBJ;|("/>

<par>
In order to study solutions for storing and handling the
multi-Pbyte data samples expected with LHC, the <emph>RD45
Project</emph> (see 
<url name="http://wwwinfo.cern.ch/asd/cernlib/rd45/index.html"/>) 
was established in 1995.  The proposed solution
should also be able to cope with other persistent objects, such as
histograms, calibration monitoring data, etc. It was found that the
best candidate for handling this problem is a <emph>ODMG</emph>
(Object Database Management Group, see
<url name="http://www.odmg.org/"/>) compliant object database used
together with a mass storage system, based upon the IEEE reference
model for mass storage systems. After considering a few alternatives,
the presently favoured solution uses 
<emph>&OBJ;</emph> (see <url name="http://www.objy.com/"/>)
and <emph>HPSS</emph> (High Performance Storage System,
see <url name="http://www.sdsc.edu/hpss/"/>)
<index item="RD45 Project"/>
<index item="&OBJ;"/>
<index item="HPSS"/>
<index item="High Performance Storage System"/>
</par>

<par>
The &OBJ; database provides object-persistency services for GEANT-4
and the experimental data. It must fully support HEP meta-data, not
only the persistent data collections themselves, but it must also
handle the selections producing these collections, and the predicates
themselves. Replication of large database images on local area and
wide area network configurations containing heterogeneous hardware
must allow collaborators all over the world to actively participate in
data analysis. Given the large time scales (the lifetime of the LHC
software will span at least twenty years) schema evolution and
versioning are important aspects which must be taken into account.
&OBJ; comes with a set of administrative tools to ease database
management. &OBJ; also comes with an <emph>Advanced Multi-threaded
Server</emph> (AMS) and an interface to HPSS.
This provides fast access to data and offers a large performance
improvement when updating data stored in remote databases. It is
expected that each experiment will run starting in 1998 a production
service of one or more of these servers.
<index item="GEANT 4"/>
<index item="Advanced Multi-threaded Server"/>
<index item="&OBJ;"/>
<index item="AMS"/>
<index item="HPSS"/>
</par>

<par>
&OBJ; has a layered logical storage level, with at its top the
<emph>federated database</emph>. Each federated database logically
contains one or more <emph>databases</emph>, with the latter containing
the <emph>objects</emph>, which are clustered, for efficiency, inside
<emph>containers</emph>. An <emph>object</emph> itself consists of standard
C++ constructs, variable-size arrays, relationships and references to
other objects, and type constraints. Persistent objects can be created
and deleted dynamically by any application. The data model, or
<emph>schema</emph> is stored inside the federated database.
<index item="Object"/>
<index item="Federated database"/>
<index item="Database"/>
<index item="Container"/>
<index item="Data model"/>
<index item="Schema"/>
<index item="&OBJ;|)"/>
</par>
</subsection>

<subsection>
<stitle>Mathematical Libraries</stitle>
<index item="Mathematical libraries"/>

<par>
CERN no longer has any in-house mathematician supporting mathematics
libraries. Therefore, we shall have to rely on libraries developed
outside CERN, and it was decided to make the <emph>NAG
C-language</emph> (see
<url name="http://www.nag.co.uk/numeric/CL.html"/>) library available.
Although the NAG C Library provides the basic functionality required
by HEP, a small number of routines (basically special functions) are
currently unavailable.  A future release of the above library is
likely to incorporate these routines.
<index item="NAG"/>
<index item="Numerical Algorithms Group Ltd"/>
</par>
</subsection>

<subsection>
<stitle>Statistical Data Analysis: the Gemini package</stitle>
<index item="Gemini"/>
<index item="Minimisation!Gemini"/>

<par>
Gemini is a GEneral MINImization and error analysis package
implemented as a C++ class library. Minuit's functionality is provided
in a <emph>Minuit-style</emph> (even if, internally, another minimizer
may actually do the work) and new functionality offered by NAG C
minimizers is added. Gemini thus provides a unified C++ API both to
standard Minuit and to NAG C family of minimizers. For the common
subset of functionality, it is up to the user which minimization
engine does the work: Minuit or NAG C. The user can easily switch
between various minimizers without essential changes in the
application code. The currently supported set of minimizers (Minuit
and NAG C) can be extended without essential changes in the API.
</par>

<par>
The abstract base class <texttt>GEmini</texttt> defines an interface to the
common functionality. The <texttt>CMinuit</texttt> class is derived from
<texttt>GEmini</texttt> and provides a Minuit-based implementation of the
GEmini functionality plus Minuit-specific extensions. Similarly, the
<texttt>NAGmin</texttt> class is derived from <texttt>GEmini</texttt> as well and
provides a NAG-based implementation of the <texttt>GEmini</texttt>
functionality plus NAG-specific extensions.
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>
</par>

<par>
There is no single class which contains references both to Minuit and
to NAG C, so that orthodox Minuit or Nag C users are not forced to
link the other library.
</par>

<par>
Gemini finds a minimum of an objective function, possibly subject to
general constraints, and performs an error analysis. The concept of
errors is that of Minuit, so that it is the user's responsibility to
properly scale the inversed Hessian, and to properly interpret the
results. Both Hessian based errors and Minos errors are
implemented. Correspondingly, two types of function contours (or
confidence regions, in statistical problems) are available: elliptical
and Minos ones. Minos error analysis is, however, possible only for
bound constraint problems.
</par>

<par>On a longer timescale we are also following the STABLE Project,
which is funded by the European Commission and involves NAG and other
partners. The aim of the project is to design, build and demonstrate a
modern Statistical Application Building Environment.
</par>

<par>The STABLE project will integrate an existing application building
system, IRIS Explorer, and an existing widely used statistical
software system, Genstat, along with other available statistical
algorithms. The STABLE system will then be evaluated by constructing
end-user tools in different application areas.
</par>

</subsection>
</section>

<section>
<stitle>Overview of the HEP-specific components</stitle>

<par>
Although commercial and public-domain packages offer a great deal
of functionality, there is a clear need to supplement them with
HEP-specific extensions. Some of these extensions take the form of
complete class-libraries, such as CLHEP. Others represent large
toolkits, such as <emph>GEANT-4</emph> 
(see <url name="http://wwwinfo.cern.ch/asd/geant/geant4.html"/>).
Moreover, in areas such as graphics and visualisation, the basic
tools, such as Open Inventor for basic graphics and IRIS Explorer for
visualisation, need to be extended to cope with the specific needs of
the HEP experiments.
<index item="GEANT 4"/>
<index item="Open Inventor"/>
<index item="IRIS Explorer"/>
</par>

<subsection>
<stitle>HEPODBMS</stitle>
<index item="HEPODBMS|("/>

<par>
HepODBMS is a set of class libraries built on top of the ODMG C++
interface. Their purpose is to provide a higher level interface than
is specified by the ODMG, to simplify the porting of existing
applications and provide a minimum level of support for
transient-persistent switching. Furthermore, these libraries help to 
insulate applications against  changes between releases from 
a given vendor and between the products of different vendors.
<index item="ODMG"/>
<index item="HEPODBMS|)"/>
</par>

</subsection>
<subsection>
<stitle>CLHEP</stitle>
<index item="CLHEP|("/>

<par>
The <emph>CLHEP</emph> project (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/clhep/index.html"/>) was
initiated at CHEP'92; it intends to provide <emph>foundation
level</emph> classes required in HEP. At present they include:
<itemize>
<item><texttt>Alist</texttt> for lists and list iterators;</item>
<item><texttt>Combination</texttt>;</item>
<item><texttt>Geometry</texttt> for vectors, rotations, transformations;</item>
<item><texttt>Matrix</texttt> for matrix manipulations;</item>
<item><texttt>Random</texttt> for random numbers;</item>
<item><texttt>String</texttt> for different string types;</item>
<item><texttt>Units</texttt> for system of units and physical constants;</item>
<item><texttt>Vector</texttt> for vector operations (3-vector and Lorentz-type).</item>
</itemize>
</par>

<par>
CLHEP became formally part of LHC++ in 1995. The first official release
of CLHEP (V1.0) took place in April 1997 (CHEP'97). CLHEP-based
classes will be integrated in the beta-release of GEANT 4 early 1998.
The complete user documentation, with a detailed description of 
all classes is being written and will be available by the end of 1997.
<index item="GEANT 4"/>
<index item="CLHEP|)"/>
</par>

</subsection>

<subsection>
<stitle>The HTL class library</stitle>

<par>
The HTL class library provides Object Oriented histograms.
They come in two versions:
<itemize>
<item>Persistent histograms (based on &OBJ;)</item>
<item>Transient histograms (text file I/O)</item>
</itemize>
</par>

<par>
For HEPExplorer (see below) the persistent version of the library is
needed, since HTL histograms are passed among IRIS Explorer Modules as
&OBJ; objects, identified by their object identifier (&OBJ; is used as
an <emph>object broker</emph> by the IE modules).
</par>

</subsection>

<subsection>
<stitle>HEPInventor</stitle>
<index item="HEPInventor|("/>

<par><emph>HEPInventor</emph> (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/dat/hepinventor.html"/>)
proposes an easily understandable and user-friendly way to present
data in physics programs. It is implemented as a graphical class
library build on top of MasterSuite (TGS) to provide an interface
between data structures (like HTL) and graphics.
<index item="MasterSuite"/> 
<index item="HEPInventor|)"/>
</par> 

</subsection>
<subsection>

<stitle>HepVis</stitle>
<index item="HepVis|("/>

<par>
The goal of the <emph>HepVis Project</emph> (see
<url name="http://www.cern.ch/Physics/Workshops/HepVis/"/>) is to create
and distribute a toolkit library consisting of graphical objects
capable of representing the most common entities of a collider physics
experiment. Previous experience has shown that mere representations of
objects on a workstation screen is insufficient, and that native
support for picking objects with user-defined actions, and a
high-degree of interactivity, both local and global, is needed.
Therefore, the HepVis toolkit is being implemented as an extension to
Open Inventor, providing common physics objects as subclasses or as
real extensions.  Only the graphical representation of the objects
will be defined, leaving it up to the experiments to define physics
objects and their behaviour, and whether to integrate these with the
graphical objects in question.
<index item="HepVis|)"/>
</par>

</subsection>

<subsection>
<stitle>HEPExplorer</stitle>
<index item="HEPExplorer|("/>

<par>
<emph>HEPExplorer (HE)</emph> is a set of HEP-specific IRIS Explorer
modules, which help a physicist set up an environment to analyse
experimental data, produce histograms, fit models and prepare data
presentation plots using LHC++'s IE framework. It is based on
HEPInventor, HTL, and HepODBMS.
</par>

<par>
HEPExplorer consists of the following parts.
</par>

<itemize>
<item>
<par>
<emph>IRIS Explorer user types for HEP</emph>
</par> 
<par>
In order to extend
the type of data that can be passed among IRIS Explorer Modules, new
data types have been defined to deal with HEP objects.
</par>
</item>
<item>
<par><emph>IRIS Explorer HEP-specific modules</emph>
</par> 
<par>
A set of HEP-specific IRIS Explorer modules is stored on AFS/&NICE;
and is available after setting up your environment in an appropriate
way. These modules allow for histogram handling and Ntuple-like
analysis.
<index item="Ntuple"/>
</par>
</item>
</itemize>

<par>
Note that, since HE needs &OBJ; to store HTL histograms and their
associated schema, an &OBJ; database is a prerequisite for using
HEPExplorer with HTL.
<index item="HTL"/>
<index item="HEPExplorer|)"/>
</par> 

</subsection>
</section>

<section id="S-GNATS">
<stitle>Problem tracking</stitle>

<par>
LHC++ has been incorporated into the GNATS-based 
<emph>IT Problem Report Management
System</emph> (<url name="http://gnats.cern.ch/"/>), 
under the heading <emph>LHC++ Support Services</emph>.
<texonly>
The Web interface is shown in Figure <ref refid="GNATS"/>.
<figure loc="ht" id="GNATS">
<includegraphics width=".7\linewidth" file="gnats.eps"/>
<caption>LHC++ GNATS Web problem reporting system</caption>
<index item="GNATS"/>
<index item="Problem reporting"/>
</figure>
</texonly>
</par>
 
<par>
Users are invited to primarily use this system to submit problem
reports. This ensures that the problems are documented, can be easily
tracked, and also become available to other users, who can then browse
the problem database and profit from the proposed solutions.
</par>
</section>
</chapter>

<!--filename=LHCPPObjectModel.html-->
<chapter id="H1LHCPPObjectModel">
<stitle>LHC++ Object Model</stitle>

<section>
<stitle>A historical digression: Ntuples and PAW</stitle>

<par>
During the past decade, many HEP experiments  have based their
interactive data analysis on the following steps
(see the top half of Figure <ref refid="NTUPLETAGDB"/>).
</par>

<enumerate>
<item>
<emph>Raw and reconstructed</emph> data are stored in <emph>banks</emph> in an
experiment-specific hierarchical format.  Most of the time one uses
many different files on several distinct hosts.
</item>
<item>
These data are <emph>distilled</emph> and <emph>reclustered</emph> to obtain a
more compact and thus more efficient representation. This permits a
significant speed-up for the down-stream analysis compared to using
the data in their raw form as described in point 1.  This format
corresponds to the so-called HBOOK Ntuples.  One drawback of this
method is that the direct relation to the raw <emph>event data</emph> is
lost.
<index item="HBOOK"/>
<index item="Ntuple"/>
</item>
<item>
Ntuple files are analysed <emph>interactively</emph> with programs
like PAW. Plots of physics variables are produced by extracting
information contained in one or more of the Ntuple rows or columns,
binning them in HBOOK histograms and then operating on these histograms
to obtain the best representation. 
<index item="HBOOK"/>
</item>
</enumerate>

<par>
The advantage of Ntuples is that their format is known and simple enough, 
so that a general purpose analysis tool, such as PAW can cope with data
coming from any experiment. On the other hand, since no link to the
original data exists, Ntuples impose a limitation on the structure of
the data physicists can use for their analysis. On top of that, since
the data were copied from the original files into a dedicated Ntuple
file, each time original dataset changed most Ntuple files had to be
regenerated.
<index item="Ntuple"/>
<index item="PAW"/>
</par>
<par>
Two kinds of Ntuples exists. <emph>Row-Wise Ntuples</emph> transform a
complex data structure into a simple tabular form.  <emph>Column-Wise
Ntuples</emph> on the other hand improve the flexibility of the Ntuple data
model by allowing the definition of variable-length items, but they
still are difficult to use to describe complex data structures, like
those of the reconstructed data.  Moreover, the Ntuple Query language
is rather non-intuitive and complex to master.
</par>

</section>
<section id="SNEWDATAMODEL">
<stitle>The new Data Model</stitle>

<par>
Most new HEP experiments assume that it will be possible to make both
raw data and reconstructed data available <emph>on-line</emph> thanks to
the integration between &OBJ; and HPSS. Each experiment will
have its own data model and physicists should be able to
<emph>navigate</emph> through it. This is a major problem for a
general-purpose Interactive Analysis environment, since, unlike the
Ntuple case, there no longer exists a common and pre-defined data
model shared amongst all experiments. This problem can be solved but there
is no easy way out: the general-purpose tool should be able to access
the arbitrary experiment data model using some kind of run time type
information or the initial data model definition.
<index item="HPSS"/>
<index item="Ntuple"/>
</par>

<par>
Since all data is supposed to be <emph>on-line</emph>, the role of the Ntuple
replacement could be quite different. While reasonably small
<emph>personal</emph> data collections will still exist, the main concern
will probably be how to index large event stores to speed up the
analysis. 
</par>

<par>
The RD45 Project suggested one approach to deal with both problems.
The idea it to speed up queries by defining for each event a <emph>Tag</emph>, 
i.e., a small collection of its most important physics attributes plus
an association with the event where the Tag data come from. Such
<emph>Concrete</emph> Tags contain copies of data members of a 
persistent data class. A collection of tag objects 
is saved together in a Tag Database, something 
intermediate between an Event Directory and an Ntuple.
Since they are globally defined for the whole experiment, concrete
tags can be optimized so that they offer a very efficient way to make
initial cuts on attributes, thus achieving a high degree of
selectivity.  On top of that, at any moment you are able to cross the
association to the event if you want to retrieve any other details
about the full event, which are not contained in the Tag (see bottom
part of Figure <ref refid="NTUPLETAGDB"/>).
<index item="Tag"/>
<index item="Event"/>
<index item="RD45 Project"/>
<index item="Event association}\label{sec:eventassociation"/>
<index item="Concrete tag"/>
<index item="Tag!concrete"/>
<index item="Tag!database"/>
<index item="Ntuple"/>
<index item="Event association"/>
</par>
<figure id="NTUPLETAGDB" loc="ht">
<includegraphics width=".8\linewidth" file="ntuple_tagdb"/>
<caption>The Ntuple and TagDB models</caption>
<index item="Tag"/>
<index item="Ntuple"/>
<index item="Data model"/>
<index item="&OBJ;"/>
<small>
<par>
The <emph>top part</emph> of the picture shows schematically the present
<emph>traditional</emph> approach. The event data (raw, reconstructed
events, calibration constants, etc.) are represented at the left hand
side . They are distributed over many files residing on various hosts. 
An <emph>ad-hoc</emph> program reads a set of interesting quantities in
these files and writes the retrieved information into an Ntuple file.
In this Ntuple file data are reclustered most of the time 
according to a simple table structure (more complex arrangements are,
of course, possible). As the Ntuple file format is known, 
interactive visualisation programs can efficiently
read these data files, thus allowing a fast and convenient
physics data analysis system to be set up. Note, however, that these
Ntuple files are completely disconnected from the original data, so
that it is impossible to automatically update in the Ntuple files
information which changes in the original. Also, it is
not possible to retrieve transparently from the original files data
which were not saved in the Ntuple when it was created.
</par>
<par>
The <emph>lower part</emph> of the picture shows what the situation looks like in
the Tag model. In this case often-used data are once more reclustered
(using experiment-wide concrete tags or user-defined generic tags),
but all data remain inside the same federated database, and
there exists a bidirectional link between the reclustered and the
original data. In this way, when the original data are reprocessed, it
is trivial to update the tag data, so that they remain always
up-to-date.  Conversely, when for a given event the information in the
tag database is not sufficient, then the link to the complete event data
allows you to retrieve the supplementary information in a convenient
and straighforward way <emph>on the fly</emph>.
</par>
</small>
<index item="Federated database"/>
<index item="Database"/>
<index item="Ntuple"/>
</figure>

<par>
In general the selection of <emph>key</emph> attributes characterising 
events will be made by the experiment or group, so that concrete tags
are mostly defined for experiment-wide or
workgroup-wide data sets. However, individual physicists have
the possibility to define their own simpler data collection by using
the <emph>Generic Tag</emph> mechanism. This second light-weight procedure
allows you to define a tag <emph>on the fly</emph>, without creating a
persistent class. Compared to the concrete tag, there is, of course, a
small performance penalty, but this is most of the time balanced by
an increased flexibility, since at any time new fields can be added to
the tag and the association to the complete event data remains
available. Presently, both the concrete tag
and the generic tag are defined in a C++ program before being
used in the Interactive Analysis framework.
<index item="Tag!concrete"/>
<index item="Event association"/>
<index item="Tag!concrete"/>
<index item="Concrete tag"/>
<index item="Generic tag"/>
<index item="Tag!generic"/>
</par>
</section>

<section>
<stitle>Implementing the Data Model: explorable collections</stitle>

<par>
When creating a tag (either generic or concrete) a description of its
fields (name and type) must be provided. This information is used
later to access the data. The set of individual
tags is called an <emph>Explorable Collection</emph>,
i.e., a collection of objects implementing an IRIS Explorer access
interface.
<index item="Explorable collection"/>
<index item="IRIS Explorer"/>
<index item="Tag"/>
</par>

<par>
Explorable collections are data that you can analyse using
The principle of operation in described in 
Figure <ref refid="FIAM"/>.
HEPExplorer Interactive Analysis modules.
<index item="Explorable collection"/>
</par>
<figure id="FIAM" loc="h">
<includegraphics width="\linewidth" file="interactive-analysis-map"/>
<caption>Principle of operation of Interactive Analysis Map</caption>
<index item="Tag"/>
<index item="Data model"/>
<index item="&OBJ;"/>
<index item="Explorable collection"/>
</figure>
<par>
To plot an histogram, you start by picking your explorable collection
using the Browser, and then define your cuts and histogram variables
using the Selector, before filling your Histogram.  Apart from
accessing the data in the tag, you are able to invoke C++ methods that
implement, e.g., common physics or access the experiment specific
event object (by traversing the association between a tag and its
related event). User-defined functions can be used whenever a C++
expression is allowed.
All these possibilities are explained in much more detail
<!-- <A HREF="#HEPExplorerexplorable">here</A>-->
in Section <ref refid="HEPExplorerexplorable"/>.
<index item="Event association"/>
<index item="HEPExplorer"/>
<index item="Histogram!filling"/>
<index item="Explorable collection"/>
</par>
</section>
</chapter>

<!--filename=SetUpUserEnvironment.html-->
<chapter id="H1SetUpUserEnvironment">
<stitle>Setting up the user environment</stitle>

<par>
At the beginning of 1999 a central database service will be run for
the various experiments using &OBJ;. However, as we want users to be
able to test the LHC++ environment <emph>today</emph> the &UNIX;
installation procedure will presently create a database in your AFS
space <emph>on a given machine</emph>. So, until your experiment will
have set up its central &OBJ; database server, you <emph>must</emph>
always connect to that same machine if you want to access your
database. This inconvenience is only temporary and, apart from having
to connect to the given node, everything else is completely
transparent and all your C++ code will work unchanged in the future
configuration.
<index item="AMS"/>
<index item="&OBJ;"/>
<index item="Database"/>
</par>

<section>
<stitle>Installing for the first time</stitle>
<index item="HEPExplorer!installation"/>

<par>The HEPExplorer environment is essentially a combination of &OBJ;,
IRIS Explorer, and HEP-specific add-ons.  Therefore, you should first
check that the following preliminary conditions are met.</par>
<index item="&OBJ;"/>
<index item="HEPExplorer"/>
<index item="IRIS Explorer"/>

<itemize>
<item>Your computing platform is supported. At present it must be
one of the following:
HP-UX 10.20, Solaris 2.5 and 2.6, AIX 4.2, DEC UNIX 4.0, and
&WNT;.</item>
<item>You have an IRIS Explorer licence (only relevant outside CERN, 
    since CERN has a site licence).</item>
<item>You have a licence for &OBJ; (&OBJ; licenses are managed by the
    experiments; see below).
<index item="&OBJ;"/>
<index item="RD45 Project"/>
</item>
<item>At CERN, when on &UNIX;, your host must be connected to AFS or for
    &WNT; connected to &NICE;. Outside CERN, or on non-connected nodes at CERN,
    you must first get access to the distribution kit and then install it.
<index item="AFS"/>
<index item="&NICE;"/>
<index item="&WNT;"/>
</item>
</itemize>

<par>At CERN, IRIS Explorer is available centrally and some Work Group
Servers.</par>

<par>Thus, a prerequisite for using HEPExplorer is that you have access
to an &OBJ; database to contain your histograms and the proper schema
for the histogram classes.  If you do not yet have such a database set
up, you should contact your experiment's or group's &OBJ; coordinator,
who will take the necessary steps to register you for database use.
You will then be assigned a <emph>Federated Database IDentifier</emph>
(FDID), to uniquely identify your federated database to the &OBJ;
servers. This number should be specified when first installing the
database environment, as described below.
<index item="Registering for &OBJ; database use"/>
<index item="FDID"/>
<index item="Federated database!IDentifier (FDID)"/>
</par>

<par>
Once you are registered for use of the database, and you know your
unique database identifier <texttt>MY_FDID</texttt>, you can install the
database and the other parts of HEPExplorer. This mainly involves
copying something from the AFS or &NICE; space to your account, and
setting some environment variables.
</par>

<par>
The initial installation procedure does not require user
intervention. Whenever there's a choice and no further information is
provided, a reasonable default that should be satisfactory for most
users will be selected.
</par>

<subsection>
<stitle>&UNIX;-specific procedures</stitle>

<par>
To fully install the different components you need to use
HEPExplorer you should merely type two commands (the first defines 
your FDID, the second starts the intallation).
</par>

<itemize>
<item>csh flavour
<verbatim>
  setenv MY_FDID 99999 
  source /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.csh
</verbatim>
</item>
<item>ksh flavour
<verbatim>
  export MY_FDID=99999
  . /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.ksh
</verbatim>
</item>
</itemize>
<par>
Here the number <texttt>99999</texttt> is an invalid value (chosen on
purpose).  
</par>

<par>We have chosen the ksh variant while being logged on to the machine
<texttt>hpplus16</texttt> (this is important, since to use the database we
shall have to log in to this same node later). The following log shows
the various steps in the installation script.</par>

<alltt>
><emph>. /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.ksh</emph>
Installing IRIS Explorer user datatypes
Removing old types
Please wait...
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   genericOid.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   histOOgram.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   hepExplorable.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   hepSharedLibName.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   ObjyContainer.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
Installing IRIS Explorer DataFit environment
Removing old DataFit environment
Please wait...
Installing HepExplorer Interactive add-ons
IE add-ons installed

Objectivity/DB (TM) Lock Server Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1989, 1996. All rights reserved.

Lock Server is already running.
Installing HTL database: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP using FDID:  30500
get db from HISTO (new name will be HEPEXP)
End of HTL database installation

Making your startup script
Removing old startup script

***********************************************************
Your setup script is ~/$OS/hepexp.ksh
Don't forget to source it in your .profile script
***********************************************************
</alltt>
<index item="login@@{\texttt{.login} file}"/>
<index item="profile@@{\texttt{.profile} file}"/>

<par>
Let us have a look at what the installation script did (<emph>if you are
not interested in this, you can skip this paragraph; however, you
should still verify the last part of the output, as we shall explain
below.</emph>) The installation script starts by copying IRIS Explorer related
information, such as types, include files, man pages, DataFit 
and HEPExplorer files, into your IRIS Explorer directory (defined
with the <texttt>EXPLORERUSERHOME</texttt> environment variable).
Then it installs the &OBJ; database, in the <texttt>explorer</texttt> subdirectory
(<texttt>/afs/cern.ch/user/g/goossens/HP-UX/explorer</texttt> in our case).
The boot file is called <texttt>HEPEXP</texttt>, the federated database
itself <texttt>HEPEXP.FDDB</texttt> (see the directory listing below).</par>
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
<verbatim>
-rw-r--r--   1 goossens   dl             241 Oct 29 17:56 HEPEXP
-rw-rw-r--   1 goossens   dl         2080768 Oct 29 17:57 HEPEXP.FDDB
</verbatim>

<par>
It is the environment variable <texttt>OO_FD_BOOT</texttt>, containing
the full path name of the boot file, which will be used by &OBJ; to
get access to the database in subsequent sessions. Note that we have
specified our unique federated database identifier which we got from
our database administrator by setting the <texttt>MY_FDID</texttt>
variable (the value used was <texttt>30500</texttt>, which should
<emph>NEVER</emph> be used by anybody else).  Now that the database is
set up, a small test program is copied to the
<texttt>explorer</texttt> directory, compiled and run.
</par>

<par>
It is <emph>important</emph> that everybody checks whether the output
generated at the end of the installation corresponds to the lines
shown above. Also, the startup script (<texttt>hepexp.ksh</texttt>
above) will be prepared. This small script defines a set of
environment variables for IRIS Explorer, the
<texttt>OO_FD_BOOT</texttt> variable, identifying the &OBJ; boot file,
and checks whether you are logged in to the same node as where the
database was created (<texttt>hpplus16</texttt> in the example).
</par>

<par>
You <emph>must</emph> execute this small shell script 
every time you login on the system as described below.
</par>

<itemize>
<item>
<par>
<emph>csh flavour</emph>: the file is named
<texttt>~/$OS/hepexp.csh</texttt> and you should add to your
<texttt>.login </texttt>script the following line:
</par>
<par>
<texttt>source ~/$OS/hepexp.csh</texttt>
</par>
</item>
<item>
<par> <emph>ksh flavour</emph>: the file is named
<texttt>~/$OS/hepexp.ksh</texttt> and you should add to your
<texttt>.profile </texttt>script the following line:
</par>
<par>
<texttt>. ~/$OS/hepexp.ksh</texttt>
</par>
</item>
</itemize>

<par><emph>If you forget to update your startup script
(<texttt>.login</texttt> or <texttt>.profile</texttt>) you will not be
able to use any HEPExplorer component on your next login. On top of
that, to have the environment variables initialized correctly, you
must logout and then login again.</emph></par>
<index item="login@@{\texttt{.login} file}"/>
<index item="profile@@{\texttt{.profile} file}"/>

</subsection>
<subsection>
<stitle>&WNT;-specific procedures</stitle>

<par>In order to keep as many similarities as possible between the NT
and &UNIX; versions, we also chose to use &UNIX; tools on &WNT; (e.g.,
<texttt>gmake</texttt>), rather than go for a <emph>native</emph>
version. This policy could change in the future, according to general
guidelines for multiplatform support agreed with the experiments.
</par>

<subsubsection>
<stitle>&UNIX; utilities on NT</stitle>

<par>
The present general policy of IT division is to use the utilities
provided by Cygnus (see <url name="http://www.cygnus.com"/>).  They
are installed on &NICE; and provide the most common &GNU;/&UNIX;
tools, such as, <texttt>gmake</texttt>, <texttt>bash</texttt>,
<texttt>tar</texttt>, etc.  Users have the choice to work with &GNU;'s
<texttt>bash</texttt> shell, or &WNT;'s native <texttt>cmd</texttt>
shell.
</par>
</subsubsection>

<subsubsection>
<stitle>Locating the LHC++ components on &NICE;</stitle>

<par>
The directory structure of the LHC++ installation tree on &NICE;
mimics the structure of &UNIX; on AFS as closely as possible.
</par>

<par>
In particular, when procedures and examples for &UNIX; in this guide
refer to the path <texttt>/afs/cern.ch/sw/lhcxx</texttt>, then on
&NICE; the equivalent path is <verb>Z:\P32\lhcxx</verb>. This applies
to libraries, include files, etc. Moreover, uses of the environment
variable <texttt>LHCXXTOP</texttt>, which refer to the above path, on
&WNT; map to <verb>%LHCXXTOP%</verb> with the <texttt>cmd</texttt>
shell, and remain unchanged <texttt>$LHCXXTOP</texttt> with the
<texttt>bash</texttt> shell.
</par>

</subsubsection>

<subsubsection>
<stitle>Running the installation scripts</stitle>

<par>
Although the environment is installed on &NICE; disk servers, we do
not use &NICE; menus and scripts to access LHC++ components at
present. We follow a &UNIX;-like approach where the LHC++ applications
are executed inside an environment that is setup by a script.  This
allows quick and easy customization of the users' environment without
touching the general PC configuration.
</par>

<par>
Details on how to install LHC++ on your &WNT; system are
available in the following file on &NICE;.
</par>

<verbatim>
\P32\lhcxx\specific\windows_NT\Hepexplorer\dev\install\install_NT.txt
</verbatim>

</subsubsection>
</subsection>
</section>

<section>
<stitle>Full re-installation procedure on &UNIX;</stitle>

<par>
If you already had an &OBJ; database before, and want to reinstall
everything, you must clean up your environment first. Thus, if you
have any environment settings related to &OBJ; or IRIS Explorer you
should remove them (you can still customise your environment later).
Please check that your <texttt>PATH</texttt> environment variable and
the shared library path environment variable
(<texttt>SHLIB_PATH</texttt> or <texttt>LD_LIBRARY_PATH</texttt> or
<texttt>LIBPATH</texttt>, depending on your &UNIX; flavour) contain
just the minimum needed for your current needs.
<index item="Shared library"/>
</par>

</section>

<section>
<stitle>Customising the installation procedure on &UNIX;</stitle>

<par>
The installation procedure can be customised to provide different
locations for your IRIS Explorer home directory and for the Federated
Database.
<index item="Federated database"/>
<index item="Database"/>
<index item="Data model"/>
<index item="&OBJ;"/>
</par>

<itemize>
<item>
<par>
To define a different IRIS Explorer home directory set the 
<texttt>EXPLORERUSERHOME</texttt> environment variable, e.g.,
</par>
<par>csh flavour</par>
<verbatim>
  setenv EXPLORERUSERHOME ~/explorer
</verbatim>
<par>ksh flavour</par>
<verbatim>
  export EXPLORERUSERHOME=~/explorer
</verbatim>
</item>
<item>
<par>
To define a different location for your <emph>starter</emph> Federated
Database set the <texttt>OO_FD_BOOT</texttt> environment variable,
e.g.,</par>  
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
<par>csh flavour</par>
<verbatim>
  setenv OO_FD_BOOT ~/myfd/MYFDNAME
</verbatim>
<par>ksh flavour</par>
<verbatim>
  export OO_FD_BOOT=~/myfd/MYFDNAME
</verbatim>
</item>
</itemize>

<par>
By defining more environment variables the installation procedure
can be instructed to skip part of the installation.
</par>

<itemize>
<item><par>To skip the HEPExplorer setup (user types and fitting add-ons) set
the <texttt>NO_INSTALL_HEPEXP</texttt> environment variable, e.g.,</par>
<par>csh flavour</par>
<verbatim>
  setenv NO_INSTALL_HEPEXP 1
</verbatim>
<par>ksh flavour</par>
<verbatim>
  export NO_INSTALL_HEPEXP=1
</verbatim>
</item>
<item>To skip the installation of the <emph>starter</emph> Federated
Database set the <texttt>NO_INSTALL_HISTODB</texttt> environment variable,
e.g.,
<index item="Federated database"/>
<index item="Database"/>
<index item="Data model"/>
<index item="&OBJ;"/>
<par>csh flavour</par>
<verbatim>
  setenv NO_INSTALL_HISTODB 1
</verbatim>
<par>ksh flavour</par>
<verbatim>
  export NO_INSTALL_HISTODB=1
</verbatim>
</item>
</itemize>

</section>
<section>
<stitle>Check list on &UNIX;</stitle>
<index item="Check list"/>

<par>Right after logging in you should check that there are no warning
messages generated by the HEPExplorer startup script. In particular,
check whether you have no message of the type:</par>
<verbatim>
HEPExplorer message: you logged in on the wrong node
Please logout and login again on hpplus16
</verbatim>
<par>In this case, the original database was created on the node
<texttt>hpplus16</texttt>, so that only from that node you can read and
modify the database.</par>

<par>Similarly, using the <texttt>env</texttt> command, check that the following
environment variables are set (correctly):</par>

<itemize>
<item><texttt>OO_FD_BOOT</texttt></item>
<item><texttt>EXPLORERHOME</texttt></item>
<item><texttt>EXPLORERUSERHOME</texttt></item>
</itemize>

<par>If one of them is not set, then it is very likely that you forgot
to update your startup script (check your <texttt>.login</texttt> or 
<texttt>.profile</texttt> file).</par>
<index item="login@@{\texttt{.login} file}"/>
<index item="profile@@{\texttt{.profile} file}"/>

<subsection>
<stitle>Installation troubleshooting</stitle>
<index item="Installation!troubleshooting"/>
<index item="Troubleshooting"/>

<par>
Installation procedure failure is usually due to one of the following
reasons.
</par>

<itemize>
<item>
<emph>Missing access rights to the Objectivity package.</emph>
In this case the installation exits with an error message and you should
get your Objectivity licence before trying again.
</item>
<item>
<emph>Lockserver running in autorecovery mode.</emph>
Use the &UNIX; <texttt>ps</texttt> command to find out the lockserver's running mode:
<verbatim>
ps -ef | grep ools
</verbatim>
If you see something like:
<verbatim>
dinofm 20536 1 0 Oct 27 ? 1:37 ools
</verbatim>
restart the lockserver in the proper mode:
<verbatim>
> ookillls
> oolockserver -noautorecovery
> ps -ef | grep ools
</verbatim>
where the <texttt>ps</texttt> command should show something like:
<verbatim>
dinofm 20536 1 0 Oct 27 ? 1:37 ools -OO_NO_AUTOREC
</verbatim>
</item>
<item>
<emph>Polluted environment.</emph>
If your installation fails and you retry 
a reinstall immediately, there might still be some
environment variables set from your previous try. Therefore,
if your installation fails, it is advisable to logout and login again 
to try and install the system once more.
</item>
</itemize>
</subsection>
</section>
</chapter>

<!--filename=AccessOBJDatabase.html-->
<chapter id="H1AccessOBJDatabase">
<stitle>Accessing the &OBJ; database</stitle>

<section>
<stitle>What does the user have to know about the database?</stitle>

<par>
Ideally, the hierarchical structure of the data storage should be
completely transparent to the average user. Therefore, the LHC++ Team
has done its best to hide the impact of the database on the C++
user code to a minimum. However, it is best that the users of the
modules are aware of some basic principles, and how they relate to the
experimental data model used by the various analysis programs.
</par>

<par>
Let we have a look at Figure <ref refid="STORAGEUSER"/>.
It shows the storage hierarchy used to store event data at the
left, together with the user's view of these data at the right.
</par>
<figure id="STORAGEUSER" loc="ht">
<includegraphics width=".8\linewidth" file="storage_user"/>
<caption>The storage hierarchy and the user view</caption>
</figure>

<par>
We start with the user's view (right hand side of the picture).
The user likes to think in terms of events (the octagons), and wants
to deal with, for instance reconstructed tracks (the triangles), hits in
the forward calorimeter (the diamonds), or the calibration for the TPC
(the pentagons), etc. Users should not be directly concerned (apart
perhaps for efficiency considerations) how these various data elements
are actually stored in files and distributed over a network. They
prefer to have a <emph>logical</emph> view of their event and navigate
between its various componenents in a transparent way. It is up to the
data administrator to make sure that the data are stored in a way
optimising performance and throughput for the end user.
</par>

<par>
This is possible using an object oriented database system, such as
&OBJ; (left hand side of the picture). All data are kept in one
<emph>federated database</emph>, which is basically just a file containing
the catalog of the database files and the hostnames where they
reside. It also contains the <emph>schema</emph> (object model) used by
the data in the various databases.
<index item="Federated database"/>
<index item="Database"/>
<index item="Schema"/>
</par>

<par>
The <emph>databases</emph> themselves are also separate files, which can
reside on different nodes and they can consist of multiple
<emph>containers</emph>, that can be thought of a contiguous areas on a
file.
</par>
<index item="Data model"/>
<index item="Container"/>
<index item="&OBJ;"/>
<par>
Finally, each container consists of one or more <emph>persistent</emph>
objects (e.g., histograms, reconstructed tracks, fits). As seen in the
picture, the mapping of the event to its components is very flexible,
allowing different parts of an event to reside in different
containers, and/or databases (even on remote nodes). Moreover, since
the end users only access the full data through the logical structure,
they are never affected by changes in the physical layout of the
database.
</par>

</section>

<section>
<stitle>Getting access to an &OBJ; database</stitle>

<par>
In 1999 a central service will be run for the various experiments using &OBJ;
to provide access to their databases
from various platforms using AMS. However, at present, it is necessary to
associate a federated database with a given machine, so that you must
always connect to that same machine if you want to access that
database.
<index item="AMS"/>
<index item="&OBJ;"/>
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
</par>

<par>
In particular, when working on a cluster (such as hpplus) you must
remember the real node name (e.g., <texttt>hpplus16</texttt>, as in the
example in the previous chapter) of the machine which you used to
create the database.  When you want to use the database in a later
session, you must always connect to that node, otherwise you will not
be able to access your data (unless your experiment is running &OBJ;'s
AMS, a facility to share databases
across the network).</par>
<index item="&OBJ;"/>

<par>
The first step (after creating the database) is to tell &OBJ;
where it can be found. This is done with the environment variable
<texttt>OO_FD_BOOT</texttt>, which should be set to the full path name
of the boot file of the database that you want to access.  This boot
file is actually a small ASCII file, which contains valuable
information about your federated database.
<index item="OOFDBOOK@@{\ttfamily OO_FD_BOOT}"/>
<index item="&OBJ;"/>
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
</par>
<verbatim>
> more $OO_FD_BOOT 
ooFDNumber=30500
ooLFDNumber=65535
ooPageSize=8192
ooLockServerName=hpplus16
ooFDDBHost=hpplus16
ooFDDBFileName=/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
ooJNLHost=hpplus16
ooJNLPath=/afs/cern.ch/user/g/goossens/HP-UX/explorer
</verbatim>
<par>You should <emph>NEVER</emph> change its contents!</par>
<par>
In particular, changing the path of the federated database in this
file after you moved it will <emph>not</emph> work.
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
</par>

<par>
Once the <texttt>OO_FD_BOOT</texttt> variable is set correctly, you can
run the &OBJ; management tools. For instance the program
<texttt>oodumpcatalog</texttt> displays the catalog, showing the different
databases associated to the current federated database.
<index item="oodumpcatalog@@{\ttfamily oodumpcatalog}"/>
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
</par>
<verbatim>
> oodumpcatalog

Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.

FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16

DB Name   = SimpleTestDatabase
DB ID     = 3
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/SimpleTestDatabase.HEPEXP.DB
</verbatim>

<par>
Thus, in the example above, we see that we need to connect to the node
<texttt>hpplus16</texttt> (the so-called <emph>Lock Host</emph>).  It should also
be noted that each federated database should have a different
federated database number to enforce proper locking management when
the same lockserver is used by more than one federation (e.g., when
the lockserver is running on a central service, such as hpplus).  A
series of federated database numbers have been allocated to
experiments and user groups (a proposed list can be found at the URL 
<url name="http://wwwinfo.cern.ch/asd/cernlib/rd45/recommendations/dba.html"/>
). As explained above, when registering as
a database user with your experiment's or group's &OBJ;'s coordinator,
you get a unique number assigned to ensure the uniqueness of the
federated database number.
<index item="RD45 Project"/>
<index item="Federated database"/>
<index item="Database"/>
</par>

</section>

<section id="H2AccesssOBJ">
<stitle>Accessing the &OBJ; from inside a C++ program</stitle>

<par>After the initial installation, you have a federated database,
which has no associated databases yet. This can
be seen by using the &OBJ; tool <texttt>ootoolmgr</texttt> (<texttt>oobrowse</texttt>
on &WNT;), which allows you to browse the contents of all
databases (down to the object level) in a federated database.  If you
want to run <texttt>ootoolmgr</texttt> just type
<verbatim>
> ootoolmgr
</verbatim>
on the command line. You will then get an &OBJ; panel, as shown
in Figure <ref refid="OOTOOLMGRPANEL"/>.
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
<index item="ootoolmgr@@{\ttfamily ootoolmgr}"/>
</par>
<figure id="OOTOOLMGRPANEL" loc="ht">
<includegraphics width=".5\linewidth" file="ootoolmgrpanel"/>
<caption>The <texttt>ootoolmgr</texttt> initial panel</caption>
</figure>
<par>Then in the <texttt>File</texttt> pull-down menu you choose the
database (most of the time it is enough to click the default setting
at the bottom, which corresponds to the database selected with the
<texttt>OO_FD_BOOT</texttt> environment variable). Then you can go to
the <texttt>Tools</texttt> pull-down menu and choose <texttt>Browse
FD</texttt> at the top. Then you will see the <texttt>&OBJ; - Browse
FD</texttt> appear, with four main windows, namely the names of the
<emph>Databases</emph>, <emph>Containers</emph>, <emph>Basic
Objects</emph>, and finally, at the bottom, the contents of the
selected object. Just after initialisation, there are no databases
yet, as seen in Figure <ref refid="OOTOOLMGREMPTY"/>.
</par>
<figure id="OOTOOLMGREMPTY" loc="ht">
<includegraphics width=".5\linewidth" file="ootoolmgrempty"/>
<caption>Using the tool <texttt>ootoolmgr</texttt></caption>
<index item="ootoolmgr@@{\ttfamily ootoolmgr}"/>
</figure>

<par>
Before writing our first C++ program to use the database, let us
first establish three basic rules.
</par>
<enumerate>
<item>
One must first establish a connection to the database with the
<texttt>Init</texttt> method.
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
</item>
<item>
<emph>Transactions</emph> are used to retrieve or store persistent
objects.
<index item="&OBJ;!transaction"/>
<itemize>
<item>
A transaction is set up using the <texttt>startUpdate</texttt>
or <texttt>startRead</texttt> methods.
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="startread@@{\texttt{startRead}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startread@@{\texttt{startRead}}"/>
</item>
<item>
A transaction is terminated using the <texttt>commit</texttt>
or <texttt>abort</texttt> methods. The <texttt>commit</texttt> method
will save all changed objects in the database, whereas  <texttt>abort</texttt>
will revert the database to the state before the transaction was
initiated.
<index item="&OBJ;!transaction"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="abort@@{\texttt{abort}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!abort@@{\texttt{abort}}"/>
</item>
</itemize>
</item>
<item>
To access persistent objects <emph>smart</emph> pointers are provided.
They are indistinguishable from normal C++ pointers, they are merely
declared with a different syntax using <texttt>HepRef</texttt>, e.g.,
for a 1D histogram we would declare
<index item="Smart pointer"/>
<verbatim>
HepRefP(Histo1D) myHisto (...);
</verbatim>
while for a pointer to a non-persistent C++ object you would write
<verbatim>
Histo1D *myHisto ...
</verbatim>
Once you have declared your smart pointers to your persistent object,
all navigation between objects is completely like in the case of
normal pointers; whenever a reference is made to a smart pointer, a
callback to the database will automatically fetch the required
data. Moreover at the end of the transaction all modified objects will
automatically be stored in the database at commit time.
<index item="&OBJ;!transaction"/>
</item>
</enumerate>
<par>If, while reading through the examples, you want to know more
details about the HepODBMS classes, you can have a look at the
<emph>Class Reference Guide</emph> at the URL
<url name="http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/reference-manual/HepODBMS.html"/>.
</par>

</section>

<section>
<stitle>Manipulating the &OBJ; database and its containers in a C++ program</stitle>

<par>
To show a few more of the class methods available to manipulate an
&OBJ; database, we can look at the following code.
</par>
<listing>
<![CDATA[/* dbAccess.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepEvent.h"

class dbAccessApp : public HepTagDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  dbAccessApp(const char *name) : HepTagDbApplication(name)
  {};
  
  int run()
  {
    // print an 
    message("about to initialise the db connection");
    Init();        // initialise the db session
    message("starting an update transaction");
    startUpdate(); // start an update transaction

    // create a new database (file)
    HepDatabaseRef  myDb = db("MyDatabase");

    // if the database ref is not valid:
    // - print a message
    // - exit the application with an error code 
    if (myDb == 0)
      fatal("could not find or create MyDatabase");
    
    // create a new container in this database
    HepContainerRef cont = container("MyContainer"); 
    if (cont == 0 )
      fatal("could not find or create MyDatabase");

    // work with the container and database
    // (e.g. create histograms, tags or other persistent objects)
      
    for (short i=0; i<1000; i++)
    {
      // create a new event in my container
      HepRef(HepEvent) event = new(cont) HepEvent;
      if (event == 0) 
        fatal("could not create a new event");
    }
    message("created 1000 events");

    printContainerMap( ) ;

    // delete the container from the database
    // including all events
    HepDelete(cont);
    warning("deleted the container");

    // delete the database from the federation
    HepDelete(myDb);
    warning("deleted the database");

    // commit all changes made during this transaction
    commit();
    return 0;
  }
  
};

int main(int argc, const char *argv[])
{
  dbAccessApp myApp(argv[0]);  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="hepdbapplication@@{\texttt{HepDbApplication}} class (HEPODBMS)"/>
<index item="HEPODBMS!classes!hepdbapplication@@{\texttt{HepDbApplication}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="fatal@@{\texttt{fatal}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!fatal@@{\texttt{fatal}}"/>
<index item="warning@@{\texttt{warning}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!warning@@{\texttt{warning}}"/>
<index item="message@@{\texttt{message}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!message@@{\texttt{message}}"/>
<index item="HepDelete@@{\texttt{HepDelete}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!HepDelete@@{\texttt{HepDelete}}"/>
<index item="printcontainermap@@{\texttt{PrintContainerMap}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!printcontainermap@@{\texttt{PrintContainerMap}}"/>
<par>
The <texttt>HepDbApplication</texttt> class defines the transaction methods 
<texttt>abort</texttt>, <texttt>commit</texttt>, <texttt>startRead</texttt>, 
<texttt>startUpdate</texttt> (described already in Section
<ref refid="H2AccesssOBJ"/>),
as well as four methods for sending an informative string to the
user console: <texttt>fatal</texttt> (prints a fatal error message and
aborts), <texttt>error</texttt> and <texttt>warning</texttt>,  (prints an 
error and warning message and continue), and
<texttt>message</texttt> (just prints a message).
<index item="&OBJ;!transaction"/>
<index item="hepdbapplication@@{\texttt{HepDbApplication}} class (HEPODBMS)"/>
<index item="HEPODBMS!classes!hepdbapplication@@{\texttt{HepDbApplication}}"/>
<index item="abort@@{\texttt{abort}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!abort@@{\texttt{abort}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="startread@@{\texttt{startRead}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startread@@{\texttt{startRead}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="fatal@@{\texttt{fatal}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!fatal@@{\texttt{fatal}}"/>
<index item="warning@@{\texttt{warning}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!warning@@{\texttt{warning}}"/>
<index item="message@@{\texttt{message}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!message@@{\texttt{message}}"/>
<index item="error@@{\texttt{error}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!error@@{\texttt{error}}"/>
</par>
<par>
The <texttt>HepDatabaseRef</texttt> declaration sets up a database handle
<texttt>myDb</texttt> using the <texttt>db</texttt> method from the <texttt>ooSession</texttt>
class. Once we have opened a database, we declare a container with
<texttt>HepContainerRef</texttt>, which returns us a handle <texttt>cont</texttt>
using the <texttt>container</texttt> method from the <texttt>ooSession</texttt>
class. The container handle is then used to store one thousand events
of type <texttt>HepEvent</texttt> inside the <texttt>for</texttt> loop. Just before we
delete our database we print a map of the containers with the
<texttt>printContainerMap</texttt> method, which shows the containers together
with their object identifiers (the <texttt>HepSystem</texttt> and
<texttt>ExplorableDescr</texttt> containers are created when HEPODBMS is set
up in the <texttt>System</texttt> database).  Finally, we delete the container
and database by specifying their respective handles to the
<texttt>HepDelete</texttt> method. Below, the output generated by the above
C++ code is shown.
</par>
<verbatim>
dbAccess: about to initialise the db connection
dbAccess: starting an update transaction
dbAccess: created 1000 events
HepSystem --- #3-4-3-1
ExplorableDescr --- #3-5-3-1
MyContainer --- #12-3-1-1
WARNING: dbAccess: deleted the container
WARNING: dbAccess: deleted the database
</verbatim>

</section>

<section>
<stitle>&OBJ; administration tools</stitle>

<par>
&OBJ; provides a whole set of administration tools to manage a
federated database. These tools are described in detail in the
<emph>&OBJ; Administration</emph> manual. In this section we briefly
describe the more useful from the physicists' point of view.
</par>
<itemize>
<item><texttt>oodumpcatalog</texttt> provides summary information about a
    federated database;
<index item="oodumpcatalog@@{\ttfamily oodumpcatalog}"/>
<index item="&OBJ;"/>
</item> 
<item><texttt>ootoolmgr</texttt> (<texttt>oobrowse</texttt>
    on &WNT;) allows you to browse federated database schema and
    data;</item>
<item><texttt>oocleanup</texttt> resets pending locks;</item>
<item><texttt>oodeletedb</texttt> deletes a <emph>physical</emph> database.</item>
</itemize>
</section>
</chapter>

<!--filename=HistogramTagClasses.html-->

<chapter id="H1HistogramTagClasses">
<stitle>Histogram and tag classes</stitle>

<par>
All classes are being documented and a user guide and
reference manual for the available components will be available soon.
In this chapter we shall describe the main characteristics of the
HTL classes and also learn about the tag classes. 
As explained before, ready-to-run examples can be found in the 
following two directories.
</par>
<verbatim>
$LHCXXTOP/share/HepODBMS/pro/HepODBMS/examples
$LHCXXTOP/share/HTL/pro/HTL/examples/
</verbatim>
<par>
As already explained in the preface at the beginning of the 
document, each
example has its own subdirectory (corresponding to the first part
of the filename, i.e., preceding the suffix <texttt>.cpp</texttt>, specified
as a comment on the first line of the examples' C++ code in this
manual), which contains the C++ source code in a file with extension
<texttt>cpp</texttt>, as well as a <texttt>GNUmakefile</texttt> which will compile,
link and generate an executable if run with <texttt>gmake</texttt>. These
example programs should form an excellent basis to get started writing
your own application programs.
<index item="Examples!location"/>
<index item="Examples!running \~{}"/>
</par>

<section id="PERSISTENTHISTOS">
<stitle>The HTL package</stitle>

<par>
The Persistent HTL Package provides the basic histogramming
functionality of HBOOK along with some additional features.
See the <url name="http://wwwinfo.cern.ch/asd/lhc++/HTL/index.html"/>
for more details.
<index item="HBOOK"/>
</par>
</section>

<section>
<stitle>Converting an HBOOK file into an &OBJ; database</stitle>
<index item="HBOOK"/>

<par>The program <texttt>Hbook2Objy</texttt>
<!--/afs/cern.ch/sw/lhcxx/specific/@@sys/HEP_Explorer/3.9/bin/-->
converts histograms contained in an HBOOK file into persistent HTL
histograms that can be saved in an &OBJ; database. Only one- and
two-dimensional histograms are converted, Ntuples are ignored. To
execute the program you should type:</par>

<verbatim>
Hbook2Objy &lt;hfile> &lt;OBJ-federated-DB>
</verbatim>

<par>
Starting from the histograms in the HBOOK file <texttt>&lt;hfile></texttt>
the program will create a new database with as name the name of the
HBOOK file <texttt>&lt;hfile></texttt> inside the &OBJ; database pointed at by
the environment variable <texttt>OO_FD_BOOT</texttt>.  If <texttt>&lt;hfile></texttt>
already exists, then you will be asked whether you want to overwrite 
the original file.
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
</par>

<par>It should be noted that the hierarchical (directory) structure of
the HBOOK file is not preserved. Nevertheless, since the name of each
created persistent histogram corresponds to the full path name inside
the HBOOK hierarchy, it is easy to distinguish between histograms with
the same name but coming from different HBOOK directories.  An example
of the translation of a set of HBOOK histograms is shown 
in Figure <ref refid="PAW2HISTOO"/>.
</par>
<figure id="PAW2HISTOO" loc="ht">
<tabular preamble="c">
<row>
<cell><includegraphics width=".8\linewidth" file="H2OPaw"/></cell>
</row>
<row>
<cell><includegraphics width=".8\linewidth" file="H2OHistOOReader"/></cell>
</row>
</tabular>
<caption>Transforming HBOOK histograms into HTL histograms</caption>
<index item="HBOOK"/>
<small>
<par>
At the top we see some (1D and 2D) histograms with the HBOOK Directory
Browser, and at the bottom the same histograms after conversion as
viewed from the &OBJ; database with the <emph>HistOOgramReader</emph>
module.
</par> 
</small>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/> 
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</figure>
</section>

<section>
<stitle>The tag classes</stitle>
<index item="Tag|("/>

<subsection>
<stitle>Explaining the environment</stitle>

<par>The following <texttt>gmake</texttt> file supposes the &OBJ; database and
IRIS Explorer path and environment variables have been set up for
the current session.</par>

<verbatim>
# GNUmakefile for createTag example
# Dirk Duellmann

HEP_ODBMS_DIR=/afs/cern.ch/sw/lhcxx/specific/@@sys/HepODBMS/development
include $(HEP_ODBMS_DIR)/etc/HepODBMS.mk

APPL       = createTag
SRCS       = $(APPL).cpp 
OBJS	   = $(OS)/$(APPL).o

all : $(APPL)

$(APPL): GNUmakefile
	$(C++) $(C_FLAGS) -o $(APPL) $(OBJS) $(HEP_ODBMS_LIBS) $(OBJY_LIBS) $(RWTOOL_LIBS)
</verbatim>

</subsection>
<subsection>
<stitle>Writing tags</stitle>

<par>As explained earlier (see Section <ref refid="SNEWDATAMODEL"/>),
tags are a small collection of the most important physics attributes
of an event plus an association with the event in question.  Tags
provide a natural and efficient syntax for handling event data,
speeding up queries, cuts handling, etc., substantially, while at the
same time offering the possibility to easily access the original full
data. Usually, the event tags are chosen in such a way that a high
degree of selectivity can be obtained by first cutting on attributes
in the event tag, while, if needed, the association to the full event
can be exploited in order to retrieve any other information not
contained in the tag.</par>
<index item="Event association"/>
<index item="Event association"/>

<par>In workgroup-wide data sets, individual physicists should still be
able to have their own simpler data collection, so an easy-to-use
<emph>Generic Tag</emph> is defined as well.  Presently, both the Event Tag 
and the Generic Tag have to be created inside a C++ program before using
the Interactive Analysis framework.</par>
<index item="Tag!generic"/>

<par>
The data types that can be stored in a tag are <texttt>long</texttt> and
<texttt>short</texttt> integers, <texttt>float</texttt> and <texttt>double</texttt> real
numbers, and an 8-bit <texttt>char</texttt>. These types are recognised by the
<emph>HepExplorableBrowser</emph> module
(see Figure <ref refid="HEPEXPBROWSER"/>)
which lets you browse and select explorable collections and their tags.
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
<index item="Explorable collection"/>
</par>

<par>
Examples of the use of tags are given in the HEPODBMS manual (see the
URL <url
name="http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/user-guide/H1CollectionsTags.html"/>
for more details).
</par>
<index item="Tag|)"/>
</subsection>

<subsection>
<stitle>Converting HBOOK Ntuples to &OBJ;</stitle>

<par>
The LHC++ environment provides tools to convert existing HBOOK Ntuples
to &OBJ;. 
At the URL <url
name="http://wwwinfo.cern.ch/asd/lhc++/HepExplorer/ntkit/ntupleconv.html"/>
you can find more details.
</par>
</subsection>
</section>
</chapter>

<!--filename=HEPExplorerModules.html-->
<chapter id="H1HEPExplorerModules">
<stitle>HEPExplorer Modules</stitle>
<index item="IRIS Explorer|("/>
<index item="HEPExplorer|("/>

<section>
<stitle>Starting IRIS Explorer</stitle>

<par>
The environment variables needed to run the IRIS Explorer
components and get access to the relevant libraries and auxiliary
files have been setup on the central systems at CERN. Moreover, since
the HEP components use the &OBJ; database, you should have been
registered by your experiment for using that database (see the
previous chapter to find out how to handle &OBJ; database files).
</par>

<par>
Once your environment is set correctly, you can start up IRIS Explorer
by just typing <texttt>explorer</texttt>. You should then get a layout
of windows on your workstation as shown in Figure 
<ref refid="IRISEXPLORER"/>.
</par>
<figure id="IRISEXPLORER" loc="h">
<includegraphics width=".8\linewidth" file="irisexplorer"/>
<caption>IRIS Explorer startup screen</caption>
</figure>
<par>
You see three large components on your screen. First, at the left
we have the list of IRIS Explorer modules, the <emph>Librarian</emph>. 
In fact, in the figure we chose to highlight the HEP Explorer
modules, which will be described below. It should be noted that
several tens of IRIS Explorer modules come with the basic system,
and many more can be obtained from various public archives.
<index item="Librarian@@{\emph{Librarian} window}"/>
<index item="IRIS Explorer!Librarian@@{\emph{Librarian} window}"/>
</par>

<par>
The larger part of the screen is occupied by the <emph>Map Editor</emph>.
This is where the user builds or modifies maps, connects modules
together, or interacts with the various modules in the map.
<index item="Map editor@@{\emph{Map Editor} window}"/>
<index item="IRIS Explorer!Map editor@@{\emph{Map Editor} window}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>

<par>
Finally, just below the <emph>Map Editor</emph> you have the <emph>Explorer
Log</emph> window, where messages coming from IRIS Explorer modules
are displayed.  
<index item="Explorer Log@@{\emph{Explorer Log} window}"/>
<index item="IRIS Explorer!Explorer Log@@{\emph{Explorer Log} window}"/>
</par>

<subsection>
<stitle> For first time users of IRIS Explorer  </stitle>
 
<par>
If this is the first time that  you are using Iris Explorer (IE), there are
several choices open to you.  You can jump straight into the examples which
follow.  Since the IE interface is intuitive, you will probably learn
your way around quite quickly.  We provide below some hints which may
nevertheless be useful for beginners.  
</par>

<par>
Either before or after your first trials, you may be interested in
some more formal Web-based guidance concerning IE.  There are two such
tutorials accessible from CERN.  One, supplied by NAG, is rather
complete and thorough, and gives you a quick tour of most
possibilities of IRIS Explorer.  It is available 
<url name="http://www.nag.co.uk/0/visual/IE/iecbb/Tutorial/index.html"/>
The other, supplied by the University of Leeds, provides more of an
overview, and might be more suitable for physicists. It can be found 
<index item="IECOE!IRIS Explorer Centre of Excellence"/>
at the URL
<url name="http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html"/>.
<index item="NAG"/>
</par>

<par> 
The following knowledge can be useful for beginners.  By default,
the <texttt>Render</texttt> (output) window has a black background.  If you
want to look at histogram plots, much of the (default) output will
also be black, and thus potentially invisible!  You are therefore
recommended to change the <texttt>Render</texttt> window background to a
colour other than black before viewing histograms. To make that
change, in the <emph>Render</emph> module you need the <texttt>Viewing</texttt>
menu, and <texttt>Edit Background Colour</texttt>, to select the background of
your choice.  The black background can also be changed permanently to
some other colour via the X11 resources described in
Section <ref refid="SECHTLPLOT"/>.
These resources should be put in the <texttt>.Xdefaults</texttt> file like any
other X11 resources. If you want to change the fill colour of the
histograms themselves, you can do that from the
<emph>HistOOgramPlot</emph> module.  As you complete each example, and no
longer need the the current map, you can
re-initialise your IE session via the <emph>Map Editor</emph>, by
selecting <texttt>Destroy All</texttt> from the <texttt>Edit</texttt> menu.  </par>
<index item="Background colour"/>
<index item="Colour!background"/>
<index item="Render@@{\emph{Render} module}!menus!viewing@@{\texttt{Viewing}}"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
<index item="Background colour"/>
<index item="Colour!background"/>
<index item="X11 resources"/>
<index item="Fill colour"/>
<index item="Colour!fill"/>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
<index item="Destroy map"/>
<index item="Map editor@@{\emph{Map Editor} window}!menu!edit@@{\texttt{Edit}}"/>
<index item="IRIS Explorer!Map editor@@{\emph{Map Editor} window}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>

</subsection>
<subsection>
<stitle>What you should know about the IRIS Explorer user interface</stitle>

<par>
In this section we give some brief comments on the general rules
which you should be aware of when using the modules described in the
later sections.
</par>

<par>
Text typed in a widget is read only if you hit <texttt>Return</texttt>. If
you type some text in a widget without pressing the <texttt>Return</texttt>
key, the widget will look modified but it keeps the previous value
instead (if this is the first time you type in a widget it is quite
likely that the previous value is the empty string).
</par>

<par>
For instance, typing a C++ cut in the <texttt>Match</texttt> widget of
the <emph>HepMatchAndFill</emph> module without hitting
<texttt>Return</texttt>, the module will not 
recognize the <texttt>Match</texttt>
expression and will thus select all tags.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>

<par>
A slider widget allows you to vary a parameter between a minimum and a
maximum value using the mouse. If you prefer to use the keyboard
instead, you can directly type into the text field displaying the
current value.  The range limits can be changed in a similar way.
</par>

<par>
When you save a map after editing its modules' widgets, the values on
the widget are retained and will be shown again the next time when you
run the map. Be aware that a listbox is usually cleaned up, so that
you will have to select the item again.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>

<par>
Reference documentation on Iris Explorer is available 
online as follows.
<itemize>
<item>
<emph>IRIS Explorer Users' Guide.</emph> at the URL
The basic IRIS Explorer system, scripting, and DataScribe.
<url name="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/UG/CONTENTS.html"/>.
<index item="DataScripe!Component of IRIS Explorer"/>
<index item="IRIS Explorer!DataScribe"/>
<index item="IRIS Explorer!scripts"/>
<index item="IRIS Explorer"/>
</item>
<item>
<emph>IRIS Explorer Documentation.</emph>
<index item="NAG"/>
Pointers to all of NAG's IRIS Explorer documentation. See the URL
<url name="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/Index.html"/>.
<index item="IRIS Explorer"/>
</item>
</itemize>
</par>
</subsection>

<subsection>
<stitle>Appearance of IRIS Explorer modules</stitle>

<par>On &UNIX; systems, IRIS Explorer modules can appear in three different
ways on the Map Editor.
</par>
<itemize>
<item><emph>Minimized view</emph>: no user interface is visible.</item>
<item><emph>Diminutif view</emph>: a scaled-down version of the user interface is visible.</item>
<item><emph>Maximized view</emph>: the GUI is expanded to a full-size panel.</item>
</itemize>
<par>On &WNT; the diminutif view is not available, thus modules are either minimized
or maximized.
</par>

</subsection>
</section>

<section>
<stitle>Storing and deleting histograms</stitle>

<par>HBOOK and PAW used to deal with histograms in the
``traditional'' way:</par>
<index item="HBOOK"/>
<index item="Ntuple"/>
<index item="PAW"/>
<itemize> 
<item>all histograms are created in memory;</item> 
<item>interesting histograms are explicitly saved (explicit I/O).</item>
</itemize>

<par>An ODBMS such as &OBJ; works exactly the other way round:</par>
<index item="ODBMS"/>
<index item="Object Database Management System"/>
<itemize>
<item>all histograms are created in the database (implicit I/O);</item>
<item>uninteresting histograms are explicitly deleted.</item>
</itemize>

<par>There are different ways to manage the deletion of such histograms.</par>

<itemize>
 <item>In a C++ program the user can either:
  <itemize>
   <item>individually delete each histogram (using the <texttt>delete</texttt> method 
       or the <texttt>ooDelete</texttt> function);</item>
   <item>allocate ``temporary'' histograms in a well defined container and 
       at the end delete the whole container.</item>
  </itemize>
 </item>
 <item>In an IRIS Explorer map the user can either:
<index item="Map"/>
<index item="IRIS Explorer!map"/>
  <itemize> 
   <item>individually delete each histogram (using the
       <emph>HistOOgramDelete</emph> module);
<index item="HistOOgramDelete@@{\emph{HistOOgramDelete} module}"/>
<index item="HEPExplorer!modules!HistOOgramDelete@@{\emph{HistOOgramDelete}}"/>
   </item>
   <item>create ``temporary'' histograms in a well defined 
       container and at the end delete the whole container (using 
       the <emph>ContainerDelete</emph> module).
<index item="ContainerDelete@@{\emph{ContainerDelete} module}"/>
<index item="HEPExplorer!modules!ContainerDelete@@{\emph{ContainerDelete}}"/>
   </item>
  </itemize>
 </item>
</itemize>

<par>Modules such as <emph>HistOOgramFill</emph> (Ntuple-like analysis)
store their temporary histograms in a container named
<texttt>HistoDump_uid</texttt>, where <texttt>uid</texttt> stands for
the user's &UNIX; <texttt>uid</texttt>. The container is created in a
database called <texttt>UserDb</texttt>, as seen in Figure 
<ref refid="HISTSTORE"/>.
<index item="HistOOgramFill@@{\emph{HistOOgramFill} module}"/>
<index item="HEPExplorer!modules!HistOOgramFill@@{\emph{HistOOgramFill}}"/>
</par>

<figure id="HISTSTORE" loc="ht">
<includegraphics width=".6\linewidth" file="histstore"/>
<caption>Storing histograms in a container</caption>
</figure>

<par>
The cleanup of temporary histograms is managed by the <emph>HepMatchAndFill</emph>
and <emph>HepLoop</emph> modules. The user can either:
<index item="HistOOgramFill@@{\emph{HistOOgramFill} module}"/>
<index item="HEPExplorer!modules!HistOOgramFill@@{\emph{HistOOgramFill}}"/>
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<itemize>
<item>clean up the dump container immediately;</item>
<item>clean it up when the module leaves;</item>
<item>keep the dump contents across separate IRIS Explorer sessions.</item>
</itemize>

</section>
<section>
<stitle>Displaying histograms</stitle>

<par>Several HEP Explorer modules have been developed to handle histograms.
In the following sections we shall explore them each in turn.</par>

<subsection>
<stitle>The <emph>ContainerBrowser</emph> module</stitle>
<index item="ContainerBrowser@@{\emph{ContainerBrowser} module}"/>
<index item="HEPExplorer!modules!ContainerBrowser@@{\emph{ContainerBrowser}}"/>

<par>The <emph>ContainerBrowser</emph> module allows you to browse the
databases in the federated database defined by the <texttt>OO_FD_BOOT</texttt>
environment variable.  When the module starts, the list of the data
bases available in the <texttt>OO_FD_BOOT</texttt> federated database appears
in the <texttt>DB List</texttt> scroll field. A list of all the containers
available in a given database can be obtained by click on the database
name in question the <texttt>DB List</texttt> field.  You can also create a
new container belonging to the chosen database by typing the new
container's name in the <texttt>container</texttt> text field. The output of
this module is a container which can be connected to the <emph>Histogram
Reader</emph> module. The <emph>ContainerBrowser</emph> panel is shown in 
Figure <ref refid="HEPEXCONTAINER"/>.
<index item="Federated database"/>
<index item="Database"/>
</par>
<figure id="HEPEXCONTAINER" loc="ht">
<includegraphics width=".6\linewidth" file="hepex_container"/>
<caption><emph>ContainerBrowser</emph> panel</caption>
<index item="ContainerBrowser@@{\emph{ContainerBrowser} module}"/>
<index item="HEPExplorer!modules!ContainerBrowser@@{\emph{ContainerBrowser}}"/>
</figure>
</subsection>

<subsection id="HistOOgramReader">
<stitle>The <emph>HistOOgramReader</emph> module</stitle>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>

<par>The <emph>HistOOgramReader</emph> module receives a container from the
<emph>ContainerBrowser</emph> module and allows you to select a histogram
from that container.  The list of histograms appears in the
<texttt>Histograms</texttt> field. You can select the type of histogram should
be shown (1D, 2D or all) using the radio buttons on the right of the
<texttt>Histogram</texttt> list. By clicking on one of the histogram names in
that list, the selected histogram is send on the output port and can
be received by any module able to take an histogram as its input.
The <emph>HistOOgramReader</emph> panel is shown in 
Figure <ref refid="HEPEXREADER"/>.
</par>
<figure id="HEPEXREADER" loc="ht">
<includegraphics width=".55\linewidth" file="hepex_reader"/>
<caption><emph>HistOOgramReader</emph> panel</caption>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</figure>
</subsection>

<subsection id="SECHTLPLOT">
<stitle>The <emph>HistOOgramPlot</emph> module</stitle>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>

<par>This <emph>HistOOgramPlot</emph> module receives the histogram from
the <emph>HistOOgramReader</emph> module. It can also take lattices as
input as shown in the following example. It creates the geometry from
these data and sends them to the <emph>Render</emph> module, which shows
the result on screen. To save pictures as vector PostScript files, use the 
<emph>PostScript</emph> module. </par>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>

<par>
The <emph>HistOOgramPlot</emph> module 
shown in Figure <vref refid="HEPEXPLOT"/>
assumes that the background of the
Render window is white. It is possible to change this background colour
with the <texttt>Edit Background Color</texttt> option in the <texttt>Viewing</texttt>
<index item="Render@@{\emph{Render} module}!menus!viewing@@{\texttt{Viewing}}"/>
menu or by specifying a different colour in the X11 resources, 
as follows.</par>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
<index item="Background colour"/>
<index item="Colour!background"/>
<index item="X11 resources"/>
<verbatim>
*SoXtExaminerViewer*BackgroundColor: white
*SoXtFlyViewer*BackgroundColor: white
*SoXtPlaneViewer*BackgroundColor: white
*SoXtWalkViewer*BackgroundColor: white
</verbatim>

<par>
Various plot attributes can be changed via radio buttons or
pull-down menus. The action of the majority of the selectors is quite
obvious by just reading their names. We shall thus only say a few
words about the less trivial case of the <texttt>Plot mode</texttt>
selector.</par>

<subsubsection>
<stitle>The <texttt>Plot mode</texttt> selector</stitle>

<par>The default value of the <texttt>Plot mode</texttt> selector is <texttt>Start new
plot</texttt>. In this state, the last histogram or lattice entered in the
picture is deleted each time a new histogram or lattice is received by
the module. Another value for this selector is <texttt>Cumulate</texttt>.  In
this case each new histogram or lattice received by the module will be
drawn on the same plot. Finally, by pushing the <texttt>New page</texttt>
button you will start a new page, deleting all the current plots.</par>

<figure id="HEPEXPLOT">
<includegraphics width=".65\linewidth" file="hepex_plot"/>
<caption><emph>HistOOgramPlot</emph> panel</caption>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
</figure>

</subsubsection>
</subsection>

<subsection>
<stitle>How to Plot a histogram</stitle>

<par>When the map is ready on the <emph>Map Editor</emph>, you should
first select a database by just clicking on its name in the
<emph>ContainerBrowser</emph> panel and then go on to select a
container name. The list of histograms is now visible in the
<emph>HistOOgramReader</emph> panel. It suffices to select a histogram
by clicking on its name for it to be displayed in the
<texttt>Render</texttt> window. It can be useful to set the render
window background to white via the <texttt>edit background
color</texttt> option in the <texttt>Viewing</texttt> menu of the
<emph>Render</emph> window.</par>
<index item="Map editor@@{\emph{Map Editor} window}"/>
<index item="IRIS Explorer!Map editor@@{\emph{Map Editor} window}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
<index item="Render@@{\emph{Render} module}!menus!viewing@@{\texttt{Viewing}}"/>

<par>
The map and the PostScript output for a simple one-dimensional
histogram are shown in Figures <ref refid="HEPEX1MAP"/> and 
<ref refid="HEPEX1"/>.
</par>
<figure id="HEPEX1MAP" loc="ht">
<includegraphics width=".7\linewidth" file="hepex1map"/>
<caption>HEP Explorer histogram viewing screen</caption>
</figure>
<figure id="HEPEX1" loc="ht">
<includegraphics width=".5\linewidth" file="hepex1"/>
<caption>A histogram viewed with the HEP Explorer modules</caption>
</figure>

<par>
It is also possible to have several zone on the same plot by assigning
a <emph>HistOOgramPlot</emph> module to each zone and varying the zone
coordinates value. The map and the PostScript output for two
one-dimensional histograms are shown in 
Figures <ref refid="HEPEX2MAP"/> and <ref refid="HEPEX2"/>.  
</par>
<figure id="HEPEX2MAP" loc="ht">
<includegraphics width=".9\linewidth" file="hepex2map"/>
<caption>Map used to produce a ``2 zones'' plot</caption>
</figure> 
<figure id="HEPEX2" loc="ht">
<includegraphics width=".55\linewidth" file="hepex2"/>
<caption>Two histograms viewed with the HEP Explorer modules</caption>
</figure> 
</subsection>

<subsection>
<stitle>The <emph>PostScript</emph> module</stitle>

<par>
The <emph>PostScript</emph> module allows to generate vector PostScript
files from any Open Inventor geometry. This module is based on the
PlotMaster tools provided by Master Suite. With 3D geometries the
PostScript output generated by PlotMaster may be wrong therefore it is
preferable to restrict the usage of this module to 2D geometries.
</par>

<figure id="HEPEXPOSTSCRIPT" loc="h">
<includegraphics width=".45\linewidth" file="hepex_postscript"/>
<caption><emph>PostScript</emph> panel</caption>
<index item="PostScript@@{\emph{PostScript} module}"/>
<index item="HEPExplorer!modules!PostScript@@{\emph{PostScript}}"/>
</figure>

</subsection>
<subsection>
<stitle>Displaying a histogram as a Lego plot</stitle>
<index item="Lego plot"/>

<par>
Lauch the <texttt>histogramPlot3D</texttt> map, which consists of three components:
</par>
<itemize>
<item>the <texttt>SelectHisto</texttt> group, containing
the <emph>ContainerBrowser</emph> and <emph>HistOOgramReader</emph> modules;
<index item="ContainerBrowser@@{\emph{ContainerBrowser} module}"/>
<index item="HEPExplorer!modules!ContainerBrowser@@{\emph{ContainerBrowser}}"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</item>
<item>the <emph>HistOOgramLego</emph> module;
<index item="HistOOgramLego@@{\emph{HistOOgramLego} module}"/>
<index item="HEPExplorer!modules!HistOOgramLego@@{\emph{HistOOgramLego}}"/>
</item>
<item>the <emph>Render</emph> module.
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
</item>
</itemize>
<par>
By clicking on the <texttt>SelectHisto</texttt> widgets you can select
a 1D or 2D histogram that will be transformed in a Lego plot by the
<emph>HistOOgramLego</emph> module and finally displayed by the
<emph>Render</emph>. Whenever you change to another histogram, click
on the <texttt>View All</texttt> decoration (the small eye-shaped icon
on the right side of the <emph>Render</emph> window, sixth one from
the top) of the <emph>Render</emph> module to reset the camera
position.  An example is shown in Figure <ref
refid="HISTOGRAMPLOT3D"/>.
<index item="HistOOgramLego@@{\emph{HistOOgramLego} module}"/> 
<index item="HEPExplorer!modules!HistOOgramLego@@{\emph{HistOOgramLego}}"/>
</par>
<figure id="HISTOGRAMPLOT3D" loc="ht">
<includegraphics width=".7\linewidth" file="lego"/>
<caption>HEP Explorer map to display a Lego plot</caption>
<index item="Lego plot"/>
</figure>

</subsection>
</section>

<section>
<stitle>Deleting a histogram from a container</stitle>

<par>If you want to delete a histogram from a container you should
construct the map shown in Figure <ref refid="HEPDELHISTMAP"/>.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>
<figure id="HEPDELHISTMAP" loc="ht">
<includegraphics width=".7\linewidth" file="hepdelhistmap"/>
<caption>HEP Explorer map to delete a histogram from a
container</caption>
</figure>

<par>
The various steps to connect the modules in the map are first to
connect the <emph>HistOOgramDelete</emph> module to the output port of
the <emph>HistOOgramReader</emph> module. Then, you can select a
histogram by clicking on its name in the <emph>HistOOgramReader</emph>
panel's list.  The database identifier and name of the chosen
histogram will appear in the name fields of the
<emph>HistOOgramDelete</emph> modules. If you are sure you want to
drop the histogram from the selected container in the &OBJ; database,
confirm your choice by clicking the <texttt>Delete</texttt>
button. The situation after the deletion of the histogram selected in
the previous figure is shown in Figure <ref refid="HEPDELHISTMAP1"/>.
<index item="HistOOgramDelete@@{\emph{HistOOgramDelete} module}"/>
<index item="HEPExplorer!modules!HistOOgramDelete@@{\emph{HistOOgramDelete}}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</par>

<figure id="HEPDELHISTMAP1" loc="ht">
<includegraphics width=".7\linewidth" file="hepdelhistmap1"/>
<caption>The <emph>HistOOgramReader</emph> after the
histogram deletion</caption>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</figure>
</section>

<section>
<stitle>Creating a new histogram</stitle>
<index item="HistOOgramCreate@@{\emph{HistOOgramCreate} module}"/>
<index item="HEPExplorer!modules!HistOOgramCreate@@{\emph{HistOOgramCreate}}"/>

<par>
When you want to create a new histogram you can use the module
<emph>HistOOgramCreate</emph>, whose panels for the one- and two
dimensional cases are shown in Figure <ref refid="HEPHISTCREATE"/>.
</par>
<figure id="HEPHISTCREATE" loc="h">
<tabular preamble="cc">
<row>
<cell>
<includegraphics width=".49\linewidth" file="hephistcreate1"/>
</cell>
<cell>
<includegraphics width=".49\linewidth" file="hephistcreate2"/>
</cell>
</row>
</tabular>
<caption><emph>HistOOgramCreate</emph> panels (1D and 2D)</caption>
<index item="HistOOgramCreate@@{\emph{HistOOgramCreate} module}"/>
<index item="HEPExplorer!modules!HistOOgramCreate@@{\emph{HistOOgramCreate}}"/>
</figure>

<par>
The <emph>HistOOgramCreate</emph> module lets you create a new
histogram inside an existing container: the input port of this module
takes a container parameter. Therefore, it has to be connected to the
output port of the <emph>ContainerBrowser</emph> module.  The two maps
in Figure <ref refid="HEPHISTCREATEMAP"/> correspond to the situation
before and after the creation of a new one-dimensional histogram.  The
name chosen for the histogram is <texttt>New Histogram</texttt>, as
you can clearly see in the <emph>HistOOgramReader</emph> panel of the
map after the histogram creation.  (bottom part of Figure <ref
refid="HEPHISTCREATEMAP"/>).
<index item="HistOOgramCreate@@{\emph{HistOOgramCreate} module}"/>
<index item="HEPExplorer!modules!HistOOgramCreate@@{\emph{HistOOgramCreate}}"/>
<index item="ContainerBrowser@@{\emph{ContainerBrowser} module}"/>
<index item="HEPExplorer!modules!ContainerBrowser@@{\emph{ContainerBrowser}}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</par>
<figure id="HEPHISTCREATEMAP" loc="ht">
<tabular preamble="c">
<row>
<cell>
<includegraphics width=".7\linewidth" file="hephistcreatemap"/>
</cell>
</row>
<row>
<cell>
<includegraphics width=".7\linewidth" file="hephistcreatemap1"/>
</cell>
</row>
</tabular>
<caption>Map before (top) and after (bottom) creating a new histogram</caption>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</figure>
</section>

<section>
<stitle>Scalar transformations on histograms</stitle>
<index item="HistOOFunc@@{\emph{HistOOFunc} module}"/>
<index item="HEPExplorer!modules!HistOOFunc@@{\emph{HistOOFunc}}"/>

<par>Scalar transformations on histograms are the task of the
<emph>HistOOFunc</emph> module, whose panel is shown in Figure <ref
refid="HEPHISTFUNC"/>.  In the map (Figure <ref refid="HEPHISTFUNC"/>)
you can see how you connect the output port of
<emph>HistOOgramReader</emph> module, which sends a histogram to the
input port of the <emph>HistOOFunc</emph> module. After the needed
transformation the <emph>HistOOFunc</emph> module sends the histogram
further to the <emph>HistOOgramPlot</emph> module.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
</par>
<par>
An example of use of the <emph>HistOOFunc</emph> module is adding a
set of constants (selected on the dial of the
<texttt>inScalar</texttt> after first pushing the <texttt>Add</texttt>
on the <emph>HistOOFunc</emph> panel) to the same histogram (received
from the <emph>HistOOgramReader</emph> module) and plotting the
results in <texttt>cumulate</texttt> mode onto the same figure with
the <emph>HistOOgramPlot</emph> module, as shown in Figure <ref
refid="HEPHISTFUNCEXA"/>.
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</par>
<figure id="HEPHISTFUNC" loc="ht">
<tabular preamble="cc">
<row>
<cell>
<includegraphics height=".3\linewidth" file="hephistfunc"/>
</cell>
<cell>
<includegraphics width=".68\linewidth" file="hephistfuncmap"/>
</cell>
</row>
</tabular>
<caption><emph>HistOOFunc</emph> panel and 
    map structure for scalar histogram transformations</caption>
</figure>
<figure id="HEPHISTFUNCEXA" loc="htb">
<includegraphics width=".7\linewidth" file="hephistfuncexa"/>
<caption>Cumulating several histograms</caption>
</figure>
</section>

<section>
<stitle>Printing a histogram</stitle>
<index item="HistOOgramPrint@@{\emph{HistOOgramPrint} module}"/>
<index item="HEPExplorer!modules!HistOOgramPrint@@{\emph{HistOOgramPrint}}"/>

<par>Sometimes it can be interesting to actually <emph>print</emph> a
histogram. This is made possible by the <emph>HistOOgramPrint</emph>
module. The <emph>HistOOgramPrint</emph> module takes his input from
the <emph>HistOOgramReader</emph> module, as seen in the map shown in
Figure <ref refid="HEPPRINTHISTMAP"/>.  Then you will see information
(name, number of entries, bins, and parts) about the selected
histogram in the text fields of the <emph>HistOOgramReader</emph>
panel (Figure <ref refid="HEPPRINTHISTPANELLOG"/>).  After pushing the
<texttt>Print</texttt> button in the <emph>HistOOgramPrint</emph>
panel, the output generated by the module is written to the
<emph>Explorer Log</emph> window (Figure <ref
refid="HEPPRINTHISTPANELLOG"/>).
<index item="HistOOgramPrint@@{\emph{HistOOgramPrint} module}"/>
<index item="HEPExplorer!modules!HistOOgramPrint@@{\emph{HistOOgramPrint}}"/>
<index item="Explorer Log@@{\emph{Explorer Log} window}"/>
<index item="IRIS Explorer!Explorer Log@@{\emph{Explorer Log} window}"/>
<index item="HistOOgramPrint@@{\emph{HistOOgramPrint} module}"/>
<index item="HEPExplorer!modules!HistOOgramPrint@@{\emph{HistOOgramPrint}}"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
</par>
<figure id="HEPPRINTHISTMAP">
<includegraphics width=".9\linewidth" file="hepprinthistmap"/>
<caption>HEP Explorer map to print an histogram</caption>
</figure>
<figure id="HEPPRINTHISTPANELLOG" loc="ht">
<tabular preamble="cc">
<row>
<cell>
<includegraphics width=".3\linewidth" file="hepprinthistpanel"/>
</cell>
<cell>
<includegraphics width=".65\linewidth" file="hepprinthistlog"/>
</cell>
</row>
</tabular>
<caption><emph>HistOOgramPrint</emph> panel and output</caption>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="HistOOgramPrint@@{\emph{HistOOgramPrint} module}"/>
<index item="HEPExplorer!modules!HistOOgramPrint@@{\emph{HistOOgramPrint}}"/>
<index item="HistOOgramPrint@@{\emph{HistOOgramPrint} module}"/>
<index item="HEPExplorer!modules!HistOOgramPrint@@{\emph{HistOOgramPrint}}"/>
</figure>
</section>

<section>
<stitle>Turning a histogram into a lattice</stitle>
<index item="HistOOgram2Lat@@{\emph{HistOOgram2Lat} module}"/>
<index item="HEPExplorer!modules!HistOOgram2Lat@@{\emph{HistOOgram2Lat}}"/>

<par>To benefit fully from the many Iris Explorer modules which have
been developed in many different laboratories, research centres,
etc. worldwide, it is advantageous to provide a conversion tool to
translate the HEP-specific data types (i.e., histograms) into IRIS
Explorer generic data types (i.e., lattices).  The module
<emph>HistOOgram2Lat</emph> performs such a conversion.  The
corresponding <emph>HistOOgram2Lat</emph> panel is shown in Figure
<ref refid="HEPHIST2LAT"/>.  To show how this module is used let us
have a look at the map in Figure <ref refid="HEPHISTLATMAP"/>.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>
<figure id="HEPHIST2LAT" loc="h">
<includegraphics width=".65\linewidth" file="hephist2lat"/>
<caption><emph>HistOOgram2Lat</emph> panel</caption>
</figure>
<figure id="HEPHISTLATMAP" loc="h">
<includegraphics width=".85\linewidth" file="hephistlatmap"/>
<caption>Map of Histogram to lattice transformation</caption>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</figure>
<par>
We see that the <emph>HistOOgram2Lat</emph> module takes an histogram
as input and generates a lattice as output. The latter output stream
can be fed into any of a series of standard modules which consume
lattices. In particular, in the example map shown we decided to
visualise a HTL histogram with the standard <emph>NAGgraph</emph>
module.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="NAG"/>
<index item="naggraph@@{\texttt{NAGgraph}}"/>
</par>
</section>

<section id="MINUIT-GenDescription">
<stitle>Description of the IRIS 
Explorer <emph>DataFit</emph> Module</stitle>
<index item="dataFit@@{\emph{DataFit} module}"/>
<index item="HEPExplorer!modules!DataFit@@{\emph{DataFit}}"/>
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>

<par>
This module fits a mathematical model or a given user function to
data presented at its input ports. The underlying minimisation engine
is based on Minuit. The incoming data can be one- or two-dimensional
and can be presented as a lattice (any type, any coordinate type) or a
persistent histogram characterised by its &OBJ; object identifier. The
module always retains the data coming from the most recently updated
port.
</par>

<par>
After the data have been received, the module allows you to:
</par>

<itemize>
<item>give an expression for a mathematical model to use in the fit;</item>
<item>specify a filename containing a full user-defined function;</item>
<item>restrict the zone of interest of the data to fit;</item>
<item>import, export and control the parameters to be optimised;</item>
<item>launch the fit and retrieve the fitted parameters;</item>
<item>analyse the error matrix via calls to dedicated Minuit procedures.</item>
</itemize>
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>

<subsection id="MINUIT-Using">
<stitle>Using the <emph>DataFit</emph> module: a simple
example</stitle>

<par>
The layout of the <emph>DataFit</emph> panel is shown
in Figure <ref refid="HEPFITFITPANEL"/>.
</par>
<figure id="HEPFITFITPANEL" loc="ht">
<includegraphics width=".7\linewidth" file="hepfit_fitpanel"/>
<caption>Layout of the <emph>DataFit</emph> panel</caption>
</figure>

<par>On the fitting module's panel you can either specify as input the
object ID of the (one- or two-dimensional) persistent HTL histogram to be
fitted.  The center of each bin will be taken as reference for the
fit. Alternatively, you can use an IRIS Explorer lattice as input,
where for each lattice point two data values should be provided, first
the data and then the error value, in order to compute an accurate
chisquare. If there is only one data value per node, then a
non-weighted least mean square will be calculated.</par>

<par>The panel offers further various dials, sliders, input boxes, etc.,
to communicate with the fitting module. Each parameter in the fit is
identified by its name. A text input widget allows you to type in the
symbolic form of the model expression for the fit.  Available symbols
are: for one-dimensional fits: <texttt>g</texttt> or <texttt>G</texttt> for
<emph>Gaussian</emph>, <texttt>e</texttt> or <texttt>E</texttt> for <emph>Exponential</emph>,
and <texttt>pN</texttt> or <texttt>PN</texttt> (where <texttt>N</texttt> is a number) for a
<emph>Polynomial</emph> of degree <texttt>N</texttt>. For two-dimensional fits
only the Gaussian option (<texttt>g</texttt> or <texttt>G</texttt>) is available.
For instance one could write</par>
<verbatim>
 g+p3, g+G-e,
</verbatim>

<par>The module will generate the code for the function, compile it and
put it in a sharable library that will be be loaded dynamically. The
generated function will be a function of one or two variables
according to the dimension of the incoming data. If necessary, the
code for the function can be edited before compilation, or, more
generally, you can use your own function for fitting. This latter
possibility is facilitated by using the <texttt>UserFunction</texttt>
pull-down menu, which can generate a skeleton to ease editing. Once
are finished, and want want to fit with your own source code, you can
try to compile it. The module will then link it as a sharable library
and load it dynamically to update the function to minimize. Although
it can take some time, it is straightforward and does not request any
special intervention from the user, except, of course, if the
compilation fails.</par>

<par>For the fit itself there is the <texttt>Fit</texttt> menu, which
lets you launch fits with Minuit's <texttt>MIGRAD</texttt>,
<texttt>MINIMIZE</texttt>, <texttt>SIMPLEX</texttt>, and
<texttt>IMPROVE</texttt> procedures (see the Minuit documentation for
details). The covariance matrix of the fit is available via the
<texttt>Show</texttt> menu, while a more detailed
<texttt>HESSE</texttt> and <texttt>MINOS</texttt> error analysis can
is initiated via the <texttt>Errors</texttt> menu.
<index item="datafit@@{\emph{DataFit} module}!menus!fit@@{\texttt{Fit}}"/>
<index item="datafit@@{\emph{DataFit} module}!menus!show@@{\texttt{Show}}"/>
<index item="datafit@@{\emph{DataFit} module}!menus!errors@@{\texttt{Errors}}"/>
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>
</par>
</subsection>

<subsection id="MINUIT-parametersetting">
<stitle>Setting the right parameters</stitle>

<par>Sometimes there is a lack of coherency between the model you try
to fit and the current set of parameters. as the module does not erase
the previous set of parameters each time you change the model, you
must be careful to specify sensible starting values yourself.  If you
are using a combination of the <emph>standard</emph> functions, you
can set a default starting value by using the <texttt>Set Default from
Model</texttt> command from the <texttt>Parameters</texttt> menu. This
will parse the model expression and generate a set of parameters with
appropriate names, default values and behaviours. Alternatively, you
can use the ASCII file that describes the set of parameters and that
can be read (and written) by the module. This is especially useful if
you are using your own fit function. The format of the file is very
easy to understand. Don't forget to specify in the header the number
of parameters for the fit. As it can sometimes be rather tedious to
adjust the starting values via the user interface, even for the
standard functions, you will find very quickly that the same method
can also be advantageous in this case and that the ASCII file provides
you with an efficient and fast way to achieve a good initialisation,
whereas the GUI allows you to <emph>move around and play</emph> to
visually investigate the effect of parameter changes.in
real-time.
<index item="datafit@@{\emph{DataFit} module}!menus!parameters@@{\texttt{Parameters}}"/>
</par>

</subsection>

<subsection>
<stitle>Using the fitting module</stitle>

<par>
In this section we shall go through the various steps needed to fit
and then plot a simple one-dimensional histogram retrieved from an
&OBJ; database. The modules concerned can be found on the map shown in
Figure <ref refid="HEPFITMAP"/>.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>
<figure id="HEPFITMAP">
<includegraphics width=".7\linewidth" file="hepfitmap"/>
<caption>The IRIS Explorer map for fitting and plotting 
histograms</caption>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</figure>

<par>Most modules present in the Iris Explorer map needed to fit and
plot histograms, have already been described before.
Therefore we only turn our attention towards the 
<emph>DataFit</emph> module itself.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>

<par>
The <emph>DataFit</emph> module receives a histogram from the
<emph>HistOOgramReader</emph> and performs a fit on it. The output of
the module is a lattice that is fed into a <emph>HistOOgramPlot</emph>
lattice input.
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
</par>

<par>When the map is ready on the <emph>Map Editor</emph>, you can
click on histogram in the <emph>HistOOgramReader</emph>. At that point
it is possible to adjust various attributes and the effect of these
changes will be visible immediately in the <emph>Render</emph> window.
<index item="Map editor@@{\emph{Map Editor} window}"/>
<index item="IRIS Explorer!Map editor@@{\emph{Map Editor} window}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
</par>

<par>You are now ready to start a simple fit. Indeed, while sending
the data to the <emph>HistOOgramPlot</emph> module, they was also sent
to the <emph>DataFit</emph> module. Suppose we want to fit the
histogram to a Gaussian distribution. In this case it is enough to
type <texttt>G</texttt> in the <texttt>ModelExpression</texttt> text
field (lower left hand corner) of the <emph>DataFit</emph>
panel. After typing a carriage return, C++ source code corresponding
to the definition of a Gaussian parameter fit is generated, compiled
and loaded.
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
</par>

<par>
To have an acceptable set of starting values for the fit, it is
possible to adjust the fitting parameters visually. First in the
<texttt>Parameters</texttt> menu select <texttt>Set default from
model</texttt>.  This fills the <texttt>Parameters list</texttt> with
<texttt>MAX1</texttt>, <texttt>Mean1</texttt> and
<texttt>StdDev1</texttt>, corresponding to the three Gaussian
parameters. By clicking on one of them you can modify its value by
using the dials on the right of the <texttt>Parameters
list</texttt>. It is also possible to adjust the fitting interval with
the slider below the same <texttt>Parameters list</texttt>. If the
<texttt>Histogram/Lattice</texttt> button of the
<texttt>HistOOgramPlot</texttt> module is toggled to
<texttt>Lattice</texttt>, you will get the curve corresponding to the
actual parameter values displayed in the <texttt>Render</texttt>
window, as shown in Figure <ref refid="HEPFITEXA1"/>.
<index item="datafit@@{\emph{DataFit} module}!menus!parameters@@{\texttt{Parameters}}"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
</par>

<par>
When you are satisfied with the initial values for the parameters, you
can select the <texttt>Set into Minuit</texttt> option in the
<texttt>Parameters</texttt> menu and then choose the fitting method
(for example <texttt>MIGRAD</texttt>) in the <texttt>Fit</texttt> menu
to perform the fit. The result is immediately visualised as shown in
Figure <ref refid="HEPFITEXA2"/>.
<index item="datafit@@{\emph{DataFit} module}!menus!parameters@@{\texttt{Parameters}}"/>
<index item="datafit@@{\emph{DataFit} module}!menus!fit@@{\texttt{Fit}}"/>
</par>
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>
<figure id="HEPFITEXA1">
<includegraphics width=".6\linewidth" file="hepfitexa1"/>
<caption>Curve the initial values before the fit</caption>
</figure>
<figure id="HEPFITEXA2">
<includegraphics width=".6\linewidth" file="hepfitexa2"/>
<caption>Curve for the final values after the fit</caption>
</figure>
</subsection>

<subsection id="MINUIT-HowSetFitFunction">
<stitle>A more complex example:
     using your own fit function</stitle>

<par>As sometimes the predefined functions are not sufficient for your
needs, you will have to write and use your own model function. The
present section will guide you through the various steps you have to
take.</par>

<enumerate>
<item>
Specify the name of the C-file which want the module to use in the
<texttt>Source Input Filename</texttt> text widget.  If this file already
exists go to step 5 since steps 2 to 4 below explain how to create a
new file. Note, however, that the contents of an already existing file
will be overwritten with its new definition.
</item>
<item>
Specify the number of parameters your model will use in the <texttt>Nb of
parameters</texttt> text widget. This is not so important; if you do not
know exactly your number of parameters, just give an
approximation.
</item>
<item>
Choose <texttt>Generate Skeleton</texttt> from the
<texttt>UserFunction</texttt> menu. This should create the file
containing a skeleton implementation for your fit function in the
directory <texttt>$EXPLORERUSERHOME/fitting/lib</texttt>.
<index item="datafit@@{\emph{DataFit} module}!menus!UserFunction@@{\texttt{UserFunction}}"/>
</item>
<item>
Edit the file and write your function. You can always have a look at
the file <texttt>Minuit_fit_function</texttt> in the same directory.
If your model contains some of the standard functions you can try to
construct a formula using these standard functions which is close in
form to your model expression, then choose <texttt>Write model to User
File</texttt> from the <texttt>UserFunction</texttt> menu. This
replaces steps 2 and 3 and can let you gain some time. Below we show
an example of such a model function.
<index item="datafit@@{\emph{DataFit} module}!menus!UserFunction@@{\texttt{UserFunction}}"/>
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>
</item>
<item>
Choose <texttt>Compile User Function</texttt> from the
<texttt>UserFunction</texttt> menu. This should replace the old model
by your new one.
<index item="datafit@@{\emph{DataFit} module}!menus!UserFunction@@{\texttt{UserFunction}}"/>
</item>
<item>
Define the parameters via the option <texttt>Open Parameters
file</texttt> in the <texttt>Parameters</texttt> menu. If the file
exist, the fields <texttt>Par Filename Input</texttt> and
<texttt>Parameter List</texttt> at the top of the <emph>DataFit</emph>
panel will be updated. If the file does not exist you should create
it. The simplest procedure is to start from a parameter file created
form a standard model via the option <texttt>Save to Parameters
file</texttt> in the <texttt>Parameters</texttt> menu.
<index item="datafit@@{\emph{DataFit} module}!menus!parameters@@{\texttt{Parameters}}"/>
<index item="datafit@@{\emph{DataFit} module}!menus!parameters@@{\texttt{Parameters}}"/>
</item>
</enumerate>

<par>From here on the fitting procedure proceeds as in the case of a
standard expression (as explained 
in Section <ref refid="MINUIT-Using"/>)
</par>

<subsubsection>
<stitle>Example of a fit function</stitle>

<par>Below we show the example of a fit function which was automatically
generated by the <emph>DataFit</emph> module (in this case a second order
polynomial characterised by three parameters, the coefficients of the
terms). This source code can be edited as needed to implement the
desired function.</par>

<verbatim>
/**********************************************************************/
/*                                                                    */
/*   Here is defined the function the user wants to fit against his   */
/*   data                                                             */
/*   The call of this function is fixed                               */
/*      Arguments :                                                   */
/*          ndim : number of arguments the function needs             */
/*          coor : the coordinate of the point where the function is  */
/*                 computed                                           */
/*          nparam : nb of parameters the fit function depends on     */
/*          param   : set of parameters values                        */
/*                                                                    */
/*   This file may be automatically generated by the module           */
/*   DataFit or edited by the user                                    */
/*                                                                    */
/**********************************************************************/

#include &lt;values.h>
#include &lt;math.h>

double fit_function(int ndim, float *coor, int nparam, double *param)

{
	double result;
	double X;

	X=(double)(*coor);

	result =
	(param[0] +
	(param[1]*X) + 
	(param[2]*pow(X, 2.0))) ; 

	return (result);
}

 /*  Summary of the meaning of the parameters 
	  param[0] : c, constant value of polynom #1
	  param[1] : b, coefficient #1 of polynom #1
	  param[2] : a, coefficient #2 of polynom #1
 */ 
</verbatim>

<par>The <emph>DataFit</emph> module uses a parameter file, which contains
the values and other information for the parameters used in the fit.
The parameter file corresponding to the function described above is
shown below.</par>
<verbatim>
 Parameter Tables for MINUIT/EXPLORER Modules 
 Number of Defined Parameter 3 
  
 Parameter # 1 
     Name c
     Value 50000
     Old Value 1 
     Lower Limit 0 
     Upper Limit 100000 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 2 
     Name b
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 3 
     Name a
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
</verbatim>
<index item="Minuit"/>
<index item="Minimisation!Minuit"/>
</subsubsection>
</subsection>
</section>

<section id="HEPExplorerexplorable">
<stitle>Interactive analysis in IRIS Explorer</stitle>

<subsection>
<stitle>Introduction</stitle>


<par>HEP Interactive Analysis in IRIS Explorer is implemented by a set
of HEPExplorer Modules.  Generally speaking, the current set of
Modules allows you to extract data from an &OBJ; data store and
put them in a HTL histogram, using cuts on the data set expressed in C++
syntax. In particular modules implement the following 
functions (see Figure <vref refid="FIAM"/>):
</par>

<itemize>
<item>select an explorable collection;
<index item="Explorable collection"/>
</item>
<item>define a set of cuts over the collection;</item>
<item>define the input streams for the HTL histograms you will produce;</item>
<item>automatically generate and compile C++ code that implements the cuts;</item>
<item>fill the histogram with data retrieved from the collection.</item>
</itemize>

<par>Apart from accessing the data in the tag, users can invoke C++
functions that implement common physics or access the experiment
specific event object (by traversing the association between a tag and
its related event). User-defined functions can be used whenever a C++
expression is allowed.</par>
<index item="Event association"/>

<par>The modules can be grouped in an IRIS Explorer map to avoid redefining
every time the user's analysis setup and such a map can be executed in
a <emph>batch</emph> fashion using IRIS Explorer's script language.</par>
<index item="Map"/>
<index item="IRIS Explorer!map"/>

<subsubsection>
<stitle>The <emph>HepExplorableBrowser</emph> module</stitle>
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>

<par>The <emph>HepExplorableBrowser</emph> module lets you browse and
select explorable collections. In the <texttt>Explorable List</texttt>
text field you can select a tag, whose identifier will appear in the
<texttt>Selected</texttt> field. Then the <texttt>Field List</texttt>
will show you the various fields of the tag, and you can select one
and pass it on to the <emph>HepMatchAndFill</emph> module. The
<emph>HepExplorableBrowser</emph> panel is shown in Figure <ref
refid="HEPEXPBROWSER"/>.
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
<index item="Explorable collection"/>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
</par>
<figure id="HEPEXPBROWSER" loc="ht">
<includegraphics width=".6\linewidth" file="HepExplorableBrowser"/>
<caption><emph>HepExplorableBrowser</emph></caption>
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
</figure>
</subsubsection>

<subsubsection>
<stitle>The <emph>HepMatchAndFill</emph> module</stitle>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>

<par>
This new module offers the same features as the three former modules
<emph>HepExplorableSelector</emph>, <emph>LibMaker</emph> and
<emph>HistOOgramFill</emph>, and is equivalent to PAW's
<texttt>NT/PLOT</texttt>, <texttt>NT/PROJECT</texttt> commands.
Basically it:
<index item="LibMaker@@{\emph{LibMaker} module}"/>
<index item="HEPExplorer!modules!LibMaker@@{\emph{LibMaker}}"/>
<index item="HistOOgramFill@@{\emph{HistOOgramFill} module}"/>
<index item="HEPExplorer!modules!HistOOgramFill@@{\emph{HistOOgramFill}}"/>
<index item="PAW"/>
<index item="Ntuple"/>
<index item="Project Ntuple (PAW)"/>
</par>
<itemize>
<item>
	allows users to define specific cuts (<texttt>Match</texttt> field),
	values and weights for filling histograms (<texttt>X, Y</texttt> and 
	<texttt>W</texttt> fields).
</item>
<item>
	automatically generates C++ code to fill histograms according to the 
	information above, compiles this code and executes it.
</item>
</itemize>
<par>
As for the <emph>HepLoop</emph> module, histograms are created in a
default dump container if none is specified on the input port. When
leaving the module, users can have these histograms erased
automatically (default behavior) or left as is (just click on the
<texttt>Keep Dump</texttt> radio button); users can also erase them at
any time by clicking on the <texttt>Erase Now</texttt> button.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<par>The <emph>HepMatchAndFill</emph> panel is shown in Figure <ref
refid="HEPMATCHANDFILL"/>.
</par>
<figure id="HEPMATCHANDFILL" loc="ht">
<includegraphics width=".8\linewidth" file="HepMatchAndFill1"/>
<caption><emph>HepMatchAndFill</emph> panel</caption>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</figure>
</subsubsection>

<subsubsection>
<stitle>The <emph>HepLoop</emph> module</stitle>
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>

<par>
This module is equivalent to the <texttt>PAW NT/LOOP</texttt> command
and offers a framework to scan an explorable collection, apply a
certain cut/match to the collection (or to each of its items) and
execute a particular action each time this match succeeds. The action
may for instance be the filling of histograms.
<index item="PAW"/>
<index item="Ntuple"/>
<index item="Loop over Ntuple (PAW)"/>
<index item="Explorable collection"/>
</par>
<par>
Most of the code (both header file and source file) is automatically
generated: users only have to provide/write the relevant part of code
for the match/cut or action to be taken for instance.  As with
<emph>HepMatchAndFill</emph> symbolic constants are supported and may
be passed to the code without no extra compilation overhead.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>
<par>
Once the entire code meets the user's requirements,
<emph>HepLoop</emph> makes it possible to generate files and Makefile
for a standalone version corresponding to the current customized code
and setup. The standalone application may then be executed outside of
Iris Explorer like any other applications.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<par>The <emph>HepLoop</emph> panel is shown
in Figure <ref refid="HEPLOOP"/>.
</par>
<figure id="HEPLOOP" loc="ht">
<includegraphics width=".8\linewidth" file="HepLoop1"/>
<caption><emph>HepLoop</emph> panel</caption>
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</figure>
</subsubsection>
</subsection>

<subsection>
<stitle>The <emph>explorablePlot</emph> map</stitle>
<index item="explorableplot@@{\emph{explorablePlot} map}"/>
<index item="HEPExplorer!modules!explorableplot@@{\emph{explorablePlot}}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>

<par>
The <emph>explorablePlot</emph> map is an example of how to use HEP-Explorer 
modules; it produces HTL histograms out of an explorable collection.
You can think of this map as a <emph>NT/PL replacement</emph>.
<index item="Explorable collection"/>
<index item="PAW"/>
<index item="Ntuple"/>
<index item="Plot Ntuple (PAW)"/>
</par>
<par>
The map has three modules: <emph>HepExplorableBrowser</emph>,
<emph>HepMatchAndFill</emph>, and <emph>HistOOgramPlot</emph>.
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</par>

<itemize>
<item>
<emph>HepExplorableBrowser</emph>'s output port
<texttt>Explorable</texttt> is connected to
<emph>HepMatchAndFill</emph>'s input port <texttt>Explorable</texttt>;
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>

<item>
<emph>HepMatchAndFill</emph>'s output port <texttt>output
Histo</texttt> is connected to <emph>HistOOgramPlot</emph>'s input
port <texttt>inHisto</texttt>;
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>

<item>
<emph>HistOOgramPlot</emph>'s output port <texttt>OutputGeometry</texttt> is
connected to <emph>Render</emph>'s input port <texttt>Geometry</texttt>.
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
</item>
</itemize>

<par>
The details of the <emph>explorablePlot</emph> map can be seen
in Figure <ref refid="HEPEXPLORABLEMAP"/>).
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="explorableplot@@{\emph{explorablePlot} map}"/>
<index item="HEPExplorer!modules!explorableplot@@{\emph{explorablePlot}}"/>
</par>
<figure id="HEPEXPLORABLEMAP" loc="ht">
<includegraphics width=".8\linewidth" file="hepexplorablemap"/>
<caption>The <emph>explorablePlot</emph> map</caption>
<index item="explorableplot@@{\emph{explorablePlot} map}"/>
<index item="HEPExplorer!modules!explorableplot@@{\emph{explorablePlot}}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</figure>

<par>If you want to produce HTL histograms you should do the following.</par>

<enumerate>
<item>Select an explorable collection using the
<emph>HepExplorableBrowser</emph> module.  The selected item is passed
over to the <emph>HepMatchAndFill</emph> module.
<index item="Explorable collection"/>
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>
<item>Define your cuts on the explorable collection by typing a C++ expression
in the <texttt>Match</texttt> field of the <emph>HepMatchAndFill</emph> module.
<index item="Explorable collection"/>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>
<item>Define what you want to put in your HTL histograms as C++ expressions
in the <texttt>X</texttt>, <texttt>Y </texttt>and <texttt>W</texttt> fields of the
<emph>HepMatchAndFill</emph> module.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>
<item>Click on the <texttt>Execute</texttt> button of the
<emph>HepMatchAndFill</emph> module to generate the C++ code, compile
it, if need be, and then execute it.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>
<item>
The <emph>HistOOgramPlot</emph> module transforms the histogram data into
a graphics scene which is displayed by the <emph>Render</emph> module.
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
<index item="Render@@{\emph{Render} module}"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
</item>
</enumerate>

</subsection>
<subsection>
<stitle> Getting the most of <emph>HepMatchAndFill</emph></stitle>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>

<par>
<emph>HepMatchAndFill</emph> provides many other useful features including the
following.
</par>
<itemize>
<item>
The use of symbolic constants can avoid code recompilation overhead;
</item>
<item>
a customized pre-booked histogram can be specified instead of the
default one;
</item>
<item>
users can add extra C++ source files or includes files to define more
complex cuts or histogram variables;
</item>
<item>
users can directly access event data from an explorable collection.
<index item="Explorable collection"/>
</item>
</itemize>
<par>
Notice the use of the <emph>HistoryBox</emph> module to keep a history
of the cuts expressions, for instance.
<index item="HistoryBox@@{\emph{HistoryBox} module}"/>
<index item="HEPExplorer!modules!HistoryBox@@{\emph{HistoryBox}}"/>
</par>

<subsubsection>
<stitle> Using symbolic constants in <emph>HepMatchAndFill</emph></stitle>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>

<par>
Symbolic constants can be specified in the <texttt>Match</texttt>,
<texttt>X</texttt>, <texttt>Y</texttt> and <texttt>W</texttt> fields
instead of actual numerical values.  The main advantage with this
approach, apart from having simpler and clearer expressions, is that
whenever users want to modify the numerical values of these symbolic
constants to fit their needs, the C++ generated code is neither
regenerated nor recompiled: the compilation overhead is thus
eliminated.
</par>

<par>Such symbolic constants are defined in the
<texttt>Constants</texttt> field and obey the C++ numerical constants
assignment syntax: <texttt>name = value</texttt>.  For instance, the
following expression defines two symbolic constants (the last
semi-colon is optional):
</par>
<verbatim>
	PART_MIN = 45500; X_OFFSET = 36.462;
</verbatim>
<par>
Note that currently there is a limitation on the definition of
symbolic constants, namely <textbf>the order of the definitions in the
<texttt>Constants</texttt> field is significant. The order cannot be
changed unless the code is re-generated, otherwise consistency is not
assured.
</textbf>
</par>

</subsubsection>
<subsubsection>
<stitle>Specifying a pre-booked histogram</stitle>
<par>
By default <emph>HepMatchAndFill</emph> fills a histogram booked on the fly 
in a dump container. The min and max values of the default 
histogram are sampled from the data, while the number of bins is 100 for 
1D histograms and 40 by 40 for 2D histograms.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>
<par>
If a valid histogram is connected to the optional histogram input port
(<texttt>Input Histo</texttt>), then this histogram is used instead of
the default one.  Typically users can look up a histogram (via
<emph>HistOOgramReader</emph>) or create a new one (thanks to
<emph>HistOOgramCreate</emph>) and pass it to
<emph>HepMatchAndFill</emph>, when they want to fill their customized
histogram.
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="HistOOgramCreate@@{\emph{HistOOgramCreate} module}"/>
<index item="HEPExplorer!modules!HistOOgramCreate@@{\emph{HistOOgramCreate}}"/>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>
<par>
The panel in Figure <ref refid="HEPMATCHANDFILL4"/> shows how the
<texttt>Customized_Histo</texttt> HTL histogram (created by
<emph>HistOOgramCreate </emph>) can be specified and connected to the
input port <texttt>Input Histo</texttt> of
<emph>HepMatchAndFill</emph>.
<index item="HistOOgramCreate@@{\emph{HistOOgramCreate} module}"/>
<index item="HEPExplorer!modules!HistOOgramCreate@@{\emph{HistOOgramCreate}}"/>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>
<figure id="HEPMATCHANDFILL4" loc="ht">
<includegraphics width=".6\linewidth" file="HepMatchAndFill4"/>
<caption>Handling histograms with the <emph>HepMatchAndFill</emph> module</caption>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</figure>
</subsubsection>

<subsubsection>
<stitle>Invoking user defined methods and code</stitle>

<par>
When a cut becomes rather long and complex, users might find it useful
to be able to call a customized function that implements the tricky
cut.  If the routine is short enough, the easiest way to proceed is to
define it in a header file and specify the filename in the
<texttt>Include Files</texttt> widget.  However, If the code of the
function becomes larger, it might be better pratice to declare the
routine in a header file and implement it in a separate source
file. In this case the header filename (<texttt>.h</texttt>) and
source filename (<texttt>.cpp</texttt>) should be specified using the
<texttt>Include Files</texttt>, and <texttt>Source Files</texttt>
widgets, respectively.
</par>
<par>
You can specify extra compilation and linking options as follows:
</par>
<itemize>
<item>
the <texttt>Build Options</texttt> field lets you add extra
<texttt>includes</texttt> or <texttt>define</texttt> directives;
</item>
<item>
the <texttt>Libraries</texttt> field lets you add extra libraries.
</item>
</itemize>
<par>
The two panels of Figure <ref refid="HEPMATCHANDFILLCUT"/> show how to
use a customized cut function (<texttt>my_cut</texttt>) and the files
(<texttt>my_cut.h</texttt> and <texttt>my_cut.cpp</texttt>) that are
specified in the relevant widgets of the <emph>HepMatchAndFill</emph>
module.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>
<figure id="HEPMATCHANDFILLCUT" loc="ht">
<tabular preamble="cc">
<row>
<cell><includegraphics height="6cm" file="HepMatchAndFill2"/></cell>
<cell><includegraphics height="6cm" file="mycut"/></cell>
</row>
</tabular>
<index item="Cut function"/>
<caption>Specifying a customized cut function with
<emph>HepMatchAndFill</emph></caption>
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</figure>
</subsubsection>

<subsubsection>
<stitle>Accessing event data from an Explorable collection</stitle>
<index item="Explorable collection"/>

<par>
HEP-Explorer modules for interactive analysis allow you to easily
manipulate tag fields to define cuts, or to collect information in a
HTL histograms. As mentioned before, no knowledge of the specific
object model is required as long as you deal with attributes defined
in the tag. However, when you need to cross the association between a
tag and its related event in order to retrieve more information, the
HEP-Explorer modules have to get access to the object model.
</par>

<par>
Information about the object model is communicated to
<emph>HepMatchAndFill</emph> by specifying the following:
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</par>

<itemize>
<item>
the header file (<texttt>Include Files</texttt> field) that contains the 
declaration of your tag and the related event;
</item>
<item>
the name of the concrete tag (<texttt>Concrete Tag</texttt> field) to
be used, i.e., the name of the class implementing the tag;
</item>
<item>
the shared library (<texttt>Libraries</texttt> field) which contains
the code to access tag/event methods and attributes.
</item>
</itemize>

<par>
Figure <ref refid="HEPMATCHANDFILL3"/> shows an example using the
<texttt>AtlasProdTag</texttt> concrete tag. Its declaration is in the
header file <texttt>AtlasProd.h</texttt> and its associated library
has been specified in the <texttt>Libraries</texttt> field.
</par>
<figure id="HEPMATCHANDFILL3" loc="ht">
<includegraphics width=".8\linewidth" file="HepMatchAndFill3"/> 
<caption>Example of accessing event data  
         from an Explorable collection</caption>
<index item="Explorable collection"/>
</figure>

<par>
The <texttt>theTag</texttt> object is then ready for use, should you
want to access the concrete tag. You may ask for a reference to an
event using the <texttt>getEvent()</texttt> method. With this
reference you can then access each of the attributes as you would do
in a normal C++ program (in the <texttt>AtlasProd</texttt> example the
attribute is named <texttt>NgTrack</texttt> and corresponds to the
number of tracks in the event).
</par>

<par>
Note that your shared library should be placed in a directory included
in the shared library path (see Section <ref
refid="TROUBLESHAREDLIBRARIES"/> for more details).
</par>

</subsubsection>
</subsection>

<subsection>
<stitle> The <emph>HepLoopMap</emph> map</stitle>
<index item="heploopmap@@{\emph{HepLoopMap} map}"/>
<index item="HEPExplorer!modulesheploopmap@@{\emph{HepLoopMap}}"/>

<par>
This map shows an example of how to use the <emph>HepLoop</emph>
module with other HEP-Explorer modules to perform a custom interactive
analysis.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>

<par>
The <emph>HepLoopMap</emph> map shown in Figure <ref
refid="HEPLOOPMAP"/> consist of four modules:
<index item="heploopmap@@{\emph{HepLoopMap} map}"/>
<index item="HEPExplorer!modulesheploopmap@@{\emph{HepLoopMap}}"/>
</par>
<itemize>
<item>
<emph>HepExplorableBrowser</emph>.  This module provides an explorable
collection to be looped over.
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
<index item="Explorable collection"/>
</item>
<item>
<emph>HepLoop</emph>.  This module scans the collection, checks for
elements that match a specific user-defined cut and performs the
relevant user-defined action.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</item>
<item>
<emph>ContainerBrowser</emph>.  Most of the time users want to fill
HTL histograms. By default, such HTL histograms are created in a dump
container. However, users can also specify their own container
(obtained via <emph>ContainerBrowser</emph> for instance) by
connecting it to the optional input port <texttt>Container</texttt>.
<index item="ContainerBrowser@@{\emph{ContainerBrowser} module}"/>
<index item="HEPExplorer!modules!ContainerBrowser@@{\emph{ContainerBrowser}}"/>
</item>
<item>
<emph>HistOOgramReader</emph>.  The <emph>HepLoop</emph> module
provides on its output port the container (the default one or one
specified by the user) where all histograms have been created.  It is
then possible to display these histograms conveniently by connecting
this output port (<texttt>Out Container</texttt>) to
<emph>HistOOgramReader</emph>.
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</item>
</itemize>

<figure id="HEPLOOPMAP" loc="ht">
<includegraphics width="1.\linewidth" file="HepLoopMap"/> 
<caption>The <emph>HepLoopMap</emph> map</caption>
<index item="heploopmap@@{\emph{HepLoopMap} map}"/>
<index item="HEPExplorer!modulesheploopmap@@{\emph{HepLoopMap}}"/>
</figure>

</subsection>
<subsection>
<stitle> Getting the most of <emph>HepLoop</emph></stitle>

<par>
<emph>HepLoop</emph> provides various features that offer better
control over the generated and customized code.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<itemize>
<item>
Using symbolic constants can avoid recompilation overhead as explained
when discussing how to get the most of <emph>HepMatchAndFill</emph>.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>
<item>
Users can specify the actual number of events to be processed when fitting
the cut expression. By default (when nothing is entered in the text field
<texttt>Number of Events</texttt>) the full collection is scanned.
</item>
<item>
As with <emph>HepMatchAndFill</emph>, extra files or extra compilation
options can be added.
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
</item>
</itemize>

<par>
When clicking on the <texttt>Prototype</texttt> button,
<emph>HepLoop</emph> generates two skeleton files: a header (extension
<texttt>.h</texttt>) and a source (extension <texttt>.cpp</texttt>)
file. The basename is specified in the <texttt>Filename</texttt>
field. The header file contains the main class declaration and the
source file the implementation of its methods. Those parts of the
methods that users may want to alter by introducing customized code
are bracketed with comments, as shown below.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<alltt>
// *** BEGIN USER CODE ***
   <emph>user-modifiable code </emph>
// *** END USER CODE   ***
</alltt>
<par>
Both header and source files contain some hints to assist the user,
e.g., on how to declare and use histograms.
</par>

<par>
Figure <ref refid="GENERATEDCODE"/> shows two panels with an example
of a header (left) and part of a source file (right) that were
automatically generated.
</par>
<figure id="GENERATEDCODE" loc="ht">
<tabular preamble="cc">
<row>
<cell><includegraphics height="9cm" file="GeneratedCodeH"/></cell>
<cell><includegraphics height="9cm" file="GeneratedCodeCPP"/></cell>
</row>
</tabular>
<caption>Example of skeleton files generated by 
<emph>{HepLoop}</emph></caption>
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</figure>
<par>
The principal idea behind <emph>HepLoop</emph> and its generated
skeleton code is to scan (loop over) an explorable collection, <index
item="Explorable collection"/> apply a user-defined cut while trying
to match each of its items, then, when a match is successful, execute
a given action.  Note that customized actions can also be performed
once before the start of the loop (<texttt>preExecute</texttt> method)
and once after the loop terminates (<texttt>postExecute</texttt>).
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>

<par>
The main methods users might want to customize include:
</par>
<itemize>
<item>
<texttt>match</texttt>: define in this method the specific cut/match
that is applied to each item of the explorable
collection. <texttt>match</texttt> should return 0 when the cut was
unsuccessful, a non-zero value otherwise.
<index item="Explorable collection"/>
</item>
<item>
<texttt>action</texttt>: this method is executed whenever the
match/cut succeeds.  Typically users might want to fill histograms in
this method.
</item>
<item>
<texttt>preExecute</texttt>: this method is executed once before
scanning an Explorable collection. Typically, this is where you would
perform initializations or assign resources.
<index item="Explorable collection"/>
</item>
<item>
<texttt>postExecute</texttt>: this method is executed once after
scanning an Explorable collection. Typically, this is where you would
release the resources that were assigned in
<texttt>preExecute</texttt>.
</item>
</itemize>
<par>Figures <ref refid="CUSTOMIZEDGENERATEDCODE1"/> and <ref
refid="CUSTOMIZEDGENERATEDCODE2"/> show an implementation of some of
the methods described above, while Figure <ref
refid="CUSTOMIZEDGENERATEDCODE3"/> is the header file containing their
declaration.
</par>
<figure id="CUSTOMIZEDGENERATEDCODE1" loc="ht">
<includegraphics width=".5\linewidth" file="CustomizedGeneratedCode1"/>
<caption>Customized code: the <texttt>match</texttt> and
         <texttt>preExecute</texttt> methods</caption>
</figure>
<figure id="CUSTOMIZEDGENERATEDCODE2" loc="ht">
<includegraphics width=".95\linewidth" file="CustomizedGeneratedCode2"/>
<caption>Customized code: the <texttt>action</texttt> method</caption>
</figure>
<figure id="CUSTOMIZEDGENERATEDCODE3" loc="ht">
<includegraphics width=".95\linewidth" file="CustomizedGeneratedCode3"/>
<caption>Header file used with <emph>HepLoop</emph> customized code
         examples</caption>
</figure>
</subsection>

<subsection>
<stitle>The standalone version of <emph>HepLoop</emph></stitle>

<par>
Once the code generated by <emph>HepLoop</emph> has been modified and
customized, it is possible to build a standalone version of the code,
i.e., a version of <emph>HepLoop</emph> that can execute the
customized code outside of Iris Explorer.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<par>
In order to prepare such a standalone versin, users should click on
the <texttt>Generate Makefile</texttt> button. Then
<emph>HepLoop</emph> generates:
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<itemize>
<item>
a makefile (<texttt>GNUmakefile</texttt>) that registers the current
setup of the module (compilation options, include files, source files,
etc.);
</item>
<item>
the <texttt>main_HepLoop.cpp</texttt> file that can run the customized
code, which was prepared and tested previously.
</item>
</itemize>
<par>
Then a standalone version can be build by just typing the command:
</par>
<verbatim>
      gmake
</verbatim>
<par>
This will compile the customized code together with the file
<texttt>main_HepLoop.cpp</texttt> (and other C++ code, as needed)
using and environmental setup that was defined in
<emph>HepLoop</emph>.  The generated application is called
<texttt>main_HepLoop</texttt>, which can be executed by typing its
name:
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<verbatim>
      main_HepLoop
</verbatim>
<par>
This has the same effect as clicking on the <texttt>Execute</texttt> button of
<emph>HepLoop</emph> inside Iris Explorer.
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>

<par>
The standalone version of <emph>HepLoop</emph> accepts two optional arguments:
<index item="HepLoop@@{\emph{HepLoop} module}"/>
<index item="HEPExplorer!modules!HepLoop@@{\emph{HepLoop}}"/>
</par>
<enumerate>
<item>
The constants to be passed to the customized code. It is a string
(inside quotes) that has the same format as the one of the
<texttt>Constants</texttt> field in <emph>HepLoop</emph>.  e.g.,
<texttt>PART_MIN=45500; X_OFFSET 36.642;</texttt>, where the last
semi-colon is optional. Constants must be specified in the same order
as they were in the <texttt>Constants</texttt> field and their number
must also correspond; no consistency is assured when these
requirements are not fulfilled.
</item>
<item>
The number of actual events to be processed.
</item>
</enumerate>
<par>
As an example, the following command line executes the customized code
specifying two constants and looping will process a total of 65000
event.
</par>
<verbatim>
      main_HepLoop "PART_MIN=3455; X_OFFSET=24.78" 65000
</verbatim>

</subsection>

<subsection>
<stitle>The <emph>TagViewer</emph> module</stitle>
<index item="IRIS Explorer!troubleshooting"/>
<index item="Troubleshooting"/>

<par>
The <emph>TagViewer</emph> module allows users to apply simple range
cuts on tags value and visualize the result of the query as a
histogram.  Cuts can be specified as sequences of C++ expressions,
that are combined in <emph>and</emph> mode, so a cut is a valid C++
logical expression.  The BNF format of the cut is:
<verbatim>
<![CDATA[<var#1> <comp#1> <arg#1> && <var#2> <comp#2> <arg#2> ...]]>
</verbatim>
<texttt>&lt;var#i></texttt> is a tag attribute in the Field Lists.
<texttt>&lt;comp#i></texttt> is a comparison operator from the list:
<verbatim>
<![CDATA[> , < , >= , <= , == , != ]]>
</verbatim>
<texttt>&lt;arg#i></texttt> represents either a tag attribute
<texttt>&lt;var#j></texttt> or a numeric value. 
<texttt>&amp;&amp;</texttt> represents the <emph>and</emph>
operator that separate elementary cuts.
</par>

<par>
Examples of valid cuts are:
<verbatim>
<![CDATA[pT > 400

pt > 400 && pT < 800

px > py && E < 2.9 && deadChan == 0]]>
</verbatim>
The module supports on-the-fly rebinning of the histogram and
selection of a subset of tags. Figure <ref refid="TAGVIEWER"/> shows
an example of the usage of the <emph>TagViewer</emph> module.
</par>

<figure id="TAGVIEWER" loc="ht">
<includegraphics width=".95\linewidth" file="TagViewer"/>
<caption>The <emph>TagViewer</emph> module</caption>
</figure>

</subsection>
</section>

<section>
<stitle>Troubleshooting</stitle>
<index item="IRIS Explorer!troubleshooting"/>
<index item="Troubleshooting"/>

<subsection>
<stitle>The text in the menus of the <emph>Render</emph> module is
difficult to read</stitle>

<par>
Sometimes the text strings in the menus and subpanels of the
<emph>Render</emph> module are difficult to read since the actual
message text is not properly initialized (strings of the type
<texttt>ivxxx</texttt> are displayed).
<index item="Render@@{\emph{Render} module}!menus"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
</par>

<par>
To define the relevant text strings to be displayed, the corresponding
resources must be defined. These resources allow you to customize the
menus in question. For instance, you can change the language and
disable some of the menu items.
</par>

<par>
The <texttt>app-defaults/Inventor</texttt> directory contains the
default resource file for all standard viewers. System administrators
should copy this file into the directory
<texttt>/usr/lib/X11/app-defaults</texttt>.  For instance, a specific
language is chosen as follows.
<index item="X11 resources"/>
<index item="Open Inventor!resources"/>
</par>
<verbatim>
  ln -s Inventor.english Inventor
</verbatim>
<par>
One should also include the <texttt>$OIVHOME/app-defaults</texttt>
directory in the <texttt>XAPPLRESDIR</texttt> path variable.
</par>
<par>
If you already have a resource file then you can also merge 
the resource file <texttt>$OIVHOME/app-defaults/Inventor.xxx</texttt>
with yours (see the manual page of <texttt>xrdb</texttt>).
</par>
</subsection>

<subsection>
<stitle>What to do if a map does not react at all?</stitle>
<index item="Map"/>
<index item="IRIS Explorer!map"/>

<par>
IRIS Explorer maps obey the dataflow rule:
</par>

<enumerate>
<item>a module fires when one of its inputs changes;</item>
<item>the module can then change its outputs;</item>
<item>if another module's input is connected to the changed output,
then that module will fire as well (according to rule 1).</item>
</enumerate>

<par>You can check if a module is firing by verifying that its colour
turns yellow.  If the module does not fire then check the
following.</par>

<itemize>
<item>
All mandatory inputs are connected. For instance, if you do not
connect <emph>HistOOgramFill</emph>'s <texttt>LibraryName</texttt>
input to the corresponding <emph>LibMaker</emph>'s output, the module
will never activate.
<index item="HistOOgramFill@@{\emph{HistOOgramFill} module}"/>
<index item="HEPExplorer!modules!HistOOgramFill@@{\emph{HistOOgramFill}}"/>
<index item="LibMaker@@{\emph{LibMaker} module}"/>
<index item="HEPExplorer!modules!LibMaker@@{\emph{LibMaker}}"/>
</item>
<item>
All mandatory fields have been properly defined: a meaningful value is
typed and the Return key is pressed on the text fields, an item is
selected on the Listboxes.
</item>
<item>
There are no &OBJ; locks pending (just exit from IRIS Explorer and use
the &OBJ; <texttt>oocleanup</texttt> utility).
<index item="oocleanup@@{\ttfamily oocleanup}"/>
</item>
<item>
All modules are enabled (enabled modules have black titles on the
<emph>Map Editor</emph>, while disabled modules have grey title).  Be
aware that when a module crashes, IRIS Explorer will ask you whether
you want to replace the module with another instance. If you answer
positively, the newly loaded module will be disabled by default.  In
order to enable or disable a module you should click with the right
mouse button on the module's name in the <emph>Map Editor</emph>
window.
<index item="Map editor@@{\emph{Map Editor} window}"/>
<index item="IRIS Explorer!Map editor@@{\emph{Map Editor} window}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
<index item="Map editor@@{\emph{Map Editor}}"/>
<index item="IRIS Explorer!Map editor@@{\emph{Map Editor} window}"/>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</item>
</itemize>
</subsection>

<subsection id="TROUBLEEXCEED">
<stitle>The <emph>Render</emph> module dies when using 
Exceed</stitle>
<index item="Exceed"/>
<index item="X Window"/>
<index item="PC"/>

<par>
Exceed is the recommended X Window package on PCs at CERN.  If the
<emph>Render</emph> module dies immediately, try modifying the
configuration of your PC to use only 256 colours (from the <texttt>Control
Panel</texttt> window, select <texttt>Display</texttt> and then
<texttt>Appearance</texttt>).
<index item="Render@@{\emph{Render} module}!dies"/>
<index item="IRIS Explorer!modules!Render@@{\emph{Render}}"/>
</par>

<par>Otherwise, switch to Exceed V6.1 plus GL extensions.</par>
</subsection>
<subsection id="TROUBLESHAREDLIBRARIES">
<stitle>Shared libraries</stitle>
<index item="Shared library"/>

<par>
If you use HEPExplorer modules using shared libraries, e.g., to access
event data, it can happen that the module does not find a shared
library.  Although the details of shared library management differ
amongst &UNIX; flavours, the generic approach is to define a shared
library path environment variable containing the list of directories
that have to be to searched when looking for a shared library.  You
should check that the shared library you want to use is located in one
of these directories. If it is located in a different directory you
can use a simple workaround by creating a symbolic link to your
library in the <texttt>$EXPLORERUSERHOME/fitting/lib</texttt> directory,
which is always included in the shared library path, e.g.,
</par>
<verbatim>
> cd $EXPLORERUSERHOME/fitting/lib
> ln -s /afs/cern.ch/myproject/HP-UX/atlasprod/libAtlasSpy.sl libAtlasSpy.sl
</verbatim>
<par>
Now your library has a symbolic link in one directory that is always
searched for.
</par>
<par>
Note that in the example above we used the HP extension <texttt>.sl</texttt>
for shared library names; on other computer platforms a different
file extension might be required.
</par>

</subsection>
<subsection id="TROUBLEARENA">
<stitle>Shared memory</stitle>
<index item="Shared memory"/>

<par>
If when running Iris Explorer you get a message saying that the disk
where the shared memory <emph>arena</emph> resides is not large
enough, check the space available in <texttt>/usr/tmp</texttt> (the
location where IRIS Explorer by default creates its arena). If it is
too small you should enlarge it or change the directory where the
arena is created by specifying another
<emph><texttt>tempdir</texttt></emph> either in the system-wide
<texttt>Explorer.config</texttt> file or in your personal
<texttt>.explorerrc</texttt> e.g., by specifying a different directory
, (see IRIS ExplorerUser's Guide,
Appendix A at the URL <url
name="http://www.nag.co.uk:80/visual/IE/iecbb/DOC/UG/appa.html"/>).
<index item="Arena"/> 
<index item="IRIS Explorer!customization!explorerrc@@{\texttt{.explorerrc}}"/>
<index item="explorerrc@@{\texttt{.explorerrc}!IRIS
Explorer customization file file}"/>
</par>
<verbatim>
! Set the directory where the arena and pipes go
set tempdir /usr/tmp/explorer
</verbatim>
</subsection>

<subsection id="TROUBLEHPUX">
<stitle>Writing to <texttt>cout</texttt> on HPUX 10.20</stitle>

<par>
On HPUX 10.20 there are problems with writing to <texttt>cout</texttt>
when the library <texttt>libcx.a</texttt> (via the option
<texttt>-lcx</texttt>) is included when building an Iris Explorer
module. It is therefore advisable to use <texttt>printf</texttt>
rather than the C++ construct <texttt>cout &lt;&lt;</texttt> to print
program variables to the output stream.
</par>
</subsection>

<subsection>
<stitle>Unexpected error message at Render's startup on HP machines</stitle>

<par>
On HP systems when starting up the Renderer the following error
message can be printed.
</par>
<verbatim>
Render: TGS hostid open failed for '/dev/seah0':Permission denied
</verbatim>
<par>
The message is just a warning and it is due to the presence of a
non-Ethernet card on the system (typically a FDDI card).  Users can
safely ignore this message.
<index item="HEPExplorer|)"/>
<index item="IRIS Explorer|)"/>
</par>
</subsection>
</section>
</chapter>

<!--filename=Modulesdescription.html-->
<chapter id="H1ModulesDescription">
<stitle>Short description of <emph>HEPExplorer</emph> modules
        and maps</stitle>
<description>
<term><emph>ContainerBrowser</emph></term>
<item>Browse the databases in the federated database.</item>
<term><emph>ContainerDelete</emph></term>
<item>Delete a container.</item>
<term><emph>DataFit</emph></term>
<item>Fit a mathematical model or a given user function to
    data presented at the input ports.</item>
<term><emph>explorablePlot</emph></term>
<item>A map of HEP-Explorer modules producing HistOOgrams from
  an explorable collection.</item>
<term><emph>HepExplorableBrowser</emph></term>
<item>Browse and select explorable collections.</item>
<term><emph>HepLoop</emph></term>
<item>Scan an explorable collection, apply a certain cut/match to 
the collection (or to each of its items) and execute a 
particular action if a match occurs (equivalent to PAW's <texttt>NT/LOOP</texttt>).
</item>
<term><emph>HepLoopMap</emph></term>
<item>A map using the <emph>HepLoop</emph> module with
other HEP-Explorer modules to perform a custom interactive analysis.
</item>
<term><emph>HepMatchAndFill</emph></term>
<item>Define specific cuts, values and weights for filling histograms,
then automatically generate C++ code to fill those histograms
according to the specified information, compile and execute it.
</item>
<term><emph>HistOOgram2Lat</emph></term>
<item>
Convert a HistOOgram into an Iris Explorer lattice.
</item>
<term><emph>HistOOgramCreate</emph></term>
<item>
Create a new 1D or 2D histogram
inside an existing container.
</item>
<term><emph>HistOOgramDelete</emph></term>
<item>Delete an individual histogram.</item>
<term><emph>HistOOgramFill</emph></term>
<item>Store a histogram in a container.</item>
<term><emph>HistOOgramFunc</emph></term>
<item>Perform scalar transformation on a histogram.</item>
<term><emph>HistOOgramLego</emph></term>
<item>Transform a histogram into a Lego plot.</item>
<term><emph>HistOOgramPlot</emph></term>
<item>Plot a histogram according to various user-defined attributes.</item>
<term><emph>HistOOgramPrint</emph></term>
<item>Print a histogram (as in la HBOOK).</item>
<term><emph>HistOOgramReader</emph></term>
<item>Select a histogram  in a container from a list.
</item>
<term><emph>HistoryBox</emph></term>
<item>Keep the history of the cut expressions.</item>
<term><emph>PostScript</emph></term>
<item>Generate a vector PostScript file from an Open Inventor geometry.</item>
<term><emph>TagViewer</emph></term>
<item>Apply simple range cuts on tags values and
  visualize the result.
</item>
</description>
</chapter>

<!--filename=Glossary.html-->
<chapter id="H1Glossary">
<stitle>Glossary</stitle>

<description>
<term>AMS</term>
<item>Advanced Multi-threaded Server (&OBJ;).
<index item="AMS"/>
<index item="Advanced Multi-threaded Server"/>
</item>
<term>AFS</term>
<item>Andrew (distributed) Filesystem.
<index item="AFS"/>
<index item="Andrew Filesystem"/>
</item>
<term>CORBA</term>
<item>Common Object Request Broker Architecture, from the OMG.
<index item="CORBA"/>
<index item="OMG"/>
<index item="Common Object Request Broker Architecture"/>
</item>
<term>HPSS</term>
<item>High Performance Storage System. A high-end mass storage
system developed by a consortium consisting of end-user sites
and commercial companies.
<index item="HPSS"/>
<index item="High Performance Storage System"/>
</item>
<term>NFS</term>
<item>Network Filesystem, developed by Sun.
<index item="NFS"/>
<index item="Network Filesystem"/>
</item>
<term>&OBJ;</term>
<item>Vendor of an ODBMS. Chosen at CERN in the framework of RD45.
<index item="&OBJ;"/>
</item>
<term>ODBMS</term>
<item>Object Database Management System.
<index item="ODBMS"/>
<index item="Object Database Management System"/>
</item>
<term>ODL</term>
<item>Object Definition Language. Specification language defining the
interface to object types conforming to the ODMG Object Model.
<index item="ODL"/>
<index item="Object Definition Language"/>
</item>
<term>ODMG</term>
<item>Object Database Management Group. Develops standards for ODBMSes,
e.g., in the area of scalability, heterogeneity, WAN support
(distribution, replication, caching, recovery, etc.), and schema
evolution.
<index item="ODMG"/>
<index item="Object Database Management Group"/>
</item>
<term>OMG</term>
<item>Object Management Group.
Consortium of over 400 members from the software, hardware, and large
end-user communities, whose goal is to standardise and promote object
technology in all forms, in particular by proposing specific standards
which should increase portability of customer software across ODBMS
products.
<index item="OMG"/>
<index item="Object Management Group"/>
</item>
<term>ORB</term>
<item>Object Request Broker
<index item="ORB"/>
<index item="Object Request Broker"/>
</item>
<term>GEANT-4</term>
<item>Object-Oriented Toolkit for Simulation in HEP.
<index item="GEANT 4"/>
</item>
<term>RD45 Project</term>
<item>Research and Development project to investigate object persistency
for HEP.
<index item="RD45 Project"/>
</item>
</description>
</chapter>
</bodymatter>
<backmatter>
<theindex/>
</backmatter>
</document>

@


1.1
log
@Initial revision
@
text
@a36 1
<index item="CERNLIB"/>
d46 6
a58 1
have been used in the CERNLIB environment.  Intensive investment of
a59 4
manpower should only be made in HEP-specific developments, where the
needed functionality cannot be obtained <emph>off the shelf</emph> at
affordable prices. An instance of such a HEP development is the CLHEP
class library, which is also a nice example of reuse.</par>
d76 1
a77 1
<emph>Computing Technical Proposals</emph></par>
d92 2
a95 1
the STABLE project, which should provide the needed functionality,
d98 1
a98 1
both stand-alone and in the framework of IRIS Explorer;</item>
d116 1
a116 1
<item>detector simulation (GEANT-4 via RD44 at present);
a117 1
<index item="RD44 Project"/>
d133 3
a135 4
<par>The LHC++ project is a joint effort between IT Division (mainly ASD
Group), the LHC experiments, plus NA45, Compass,...  Jamie Shiers, as
LHC++ Librarian/Project Leader is responsible for its overall
coordination.</par>
a137 2
<index item="Regular meetings (LHC++, RD45)"/>
<index item="LHC++!Regular meetings"/>
d148 2
a152 2
<index item="LHC++!workshop"/>
<index item="Workshop (LHC++)"/>
d158 2
d161 1
a161 36
<par>The LHC++ Project also wrote a <emph>Project Execution
Plan</emph> or PEP (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/pep/pep97.html"/>) and as
such presents regularly reports to the <emph>LHC Computing
Board</emph>(LCB).</par>
<index item="LCB"/>
<index item="LHC Computing Board"/>

<par>In order to optimise communication and ensure that the development
team keeps synchronised with user demands and can react to them
quickly, each of the large experiments has a contact person inside ASD
Group.</par>

<par>It is important to note that BaBar and Compass, with whom we are in
close contact, have both chosen a similar software strategy, although
their priorities somewhat differ from ours since they face a much
tighter time-scale than the LHC. Of course, such collaborations with
similar activities at other laboratories is one of our main aims and
strengths.
</par>

<par>
Many of the members of the LHC++ development team are also active in
the GEANT-4 detector simulation collaboration (<url name="
http://wwwinfo.cern.ch/asd/geant/geant4.html"/>)
<index item="GEANT 4"/>
and the object persistency RD45 (&OBJ; at present) initiative
(<url name="http://wwwinfo.cern.ch/asd/cernlib/rd45/index.html"/>).
<index item="RD45 Project"/>
<index item="&OBJ;"/>
This symbiosis ensures that all these projects develop in a harmonious
and compatible way and exploit maximally the reuse of components.  In
particular, both RD44 and RD45 have contributed classes to CLHEP, a
component of LHC++.</par>

<par>All three LCB common projects (RD44, RD45, LHC++) stress the formal
a185 1
<index item="Standard Library"/>
a186 2
<index item="ODBMS"/>
<index item="Object Database Management System"/>
d192 3
d222 1
a222 1
<row><cell>HistOOgrams</cell></row>
a381 2
<index item="Map"/>
<index item="IRIS Explorer!map"/>
d388 2
a395 1
<index item="IECOE!IRIS Explorer Centre of Excellence"/> 
d404 1
a418 2
<index item="RD45 Project"/>
<index item="&OBJ;"/>
d430 2
a437 1
<index item="GEANT 4"/>
d450 5
a458 4
This provides fast access to data and offers a large performance
improvement when updating data stored in remote databases. It is
expected that each experiment will run starting in 1998 a production
service of one or more of these servers.
a574 1
<index item="GEANT 4"/>
d577 3
a581 2
visualisation, need to be extended to cope with the specific needs of
the HEP experiments.
a625 1
<index item="GEANT 4"/>
d628 1
d635 1
a635 1
<stitle>The HistOOgram class library</stitle>
d638 1
a638 1
The HistOOgram class library provides Object Oriented histograms.
d641 2
a642 2
<item>Persistent HistOOgrams (based on &OBJ;)</item>
<item>Transient HistOOgrams (text file I/O)</item>
d647 2
a648 2
For HEPExplorer (see below) the persistent version of the library
is needed, since HistOOgrams are passed among IRIS Explorer Modules as
d660 1
a660 1
<url name="http://wwwinfo.cern.ch/asd/lhc++/dat/hepinventor.html"/>
d664 1
a665 1
between data structures (like HistOOgrams) and graphics.
d677 1
a677 1
<url name="http://www.cern.ch/Physics/Workshops/HepVis/"/> is to create
d704 1
a704 1
HEPInventor, histOOgrams, and HepODBMS.
d736 1
a736 1
Note that, since HE needs &OBJ; to store HistOOgrams and their
d738 2
a739 1
HEPExplorer with histOOgrams.
a753 2
<index item="GNATS"/>
<index item="Problem reporting"/>
d759 2
a815 2
<index item="Ntuple"/>
<index item="PAW"/>
d823 2
a843 1
<index item="HPSS"/>
a847 1
<index item="Ntuple"/>
d852 2
a865 1
<index item="RD45 Project"/>
a866 2
<index item="Tag"/>
<index item="Event"/>
a868 1
<index item="Event association}\label{sec:eventassociation"/>
a869 1
<index item="Concrete tag"/>
a870 2
<index item="Tag!concrete"/>
<index item="Tag!database"/>
a872 1
<index item="Ntuple"/>
a877 1
<index item="Event association"/>
d880 9
a939 1
<index item="Tag!concrete"/>
d948 4
a952 1
available. Presently, both the concrete tag
a956 2
and the generic tag are defined in a C++ program before being
used in the Interactive Analysis framework.
a967 1
<index item="Explorable collection"/>
d970 1
a976 2
<index item="Explorable collection"/>
HEPExplorer Interactive Analysis modules.
d979 2
a991 1
<index item="Explorable collection"/>
a993 1
<index item="Histogram!filling"/>
a996 1
<index item="Event association"/>
d1002 1
d1004 2
d1153 1
a1153 1
Installing HistOOgram database: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP using FDID:  30500
d1155 1
a1155 45
End of HistOOgram database installation
HistOOgram test
Copying the testprogram and Makefile
Compiling the testprogram
CC example_filling.cpp -o example_filling -z \
  -I/afs/cern.ch/sw/lhcxx/specific/@@sys/RW/tools/7.0.2/rogue \
  -I/afs/cern.ch/sw/lhcxx/specific/hp/Objectivity/4.0.2/include \
  -I/afs/cern.ch/sw/lhcxx/specific/@@sys/HepODBMS/development/include \
  -g -I/afs/cern.ch/sw/lhcxx/specific/@@sys/HEPEXPLORER/pro/include \
  -L/afs/cern.ch/sw/lhcxx/specific/@@sys/HEPEXPLORER/pro/lib \
  -lHistoxx  -lm \
  -L/afs/cern.ch/sw/lhcxx/specific/@@sys/HepODBMS/development/lib \
  -lgoodies -L/afs/cern.ch/sw/lhcxx/specific/hp/Objectivity/4.0.2/lib \
  -loo.4.02

Running the testprogram
 Histogram name :  Test Histo1D 
 Nbins = 10 from: 0 to: 20

 no. of entries   : 50000
 total contents   : 1.66241e+06
 nequival         : 29886.3
 min bin contents : 22372
 max bin contents : 443399
 mean             : 8.09693
 rms              : 7.1173
 underflow        : 0
 overflow         : 0

 bin 0 contents = 443399 error = 6146.7
 bin 1 contents = 275044 error = 3824.79
 bin 2 contents = 148708 error = 2081.49
 bin 3 contents = 64484 error = 915.044
 bin 4 contents = 22372 error = 316.773
 bin 5 contents = 22372 error = 316.773
 bin 6 contents = 64459.5 error = 914.87
 bin 7 contents = 148652 error = 2081.09
 bin 8 contents = 274940 error = 3824.06
 bin 9 contents = 197983 error = 3859.82
Removing SimpleTestDatabase as required by the user

Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.

Deleted the Database "SimpleTestDatabase" (ID = 2).
a1159 2


d1179 1
a1182 1
itself <texttt>HEPEXP.FDDB</texttt> (see the directory listing below).</par>
d1196 2
a1197 3
set up, a small test program like the one described in Section <ref
refid="HIST1DEXA"/> is copied to the <texttt>explorer</texttt>
directory, compiled and run.
d1219 3
a1221 2
<emph>csh flavour</emph>: the file is named <texttt>~/$OS/hepexp.csh</texttt> and
you should add to your <texttt>.login </texttt>script the following line:
d1238 5
a1242 5
<par><emph>If you forget to update your startup script (<texttt>.login</texttt> or
<texttt>.profile</texttt>) you will not be able to use any HEPExplorer
component on your next login. On top of that, to have the environment
variables initialized correctly, you must logout and then login
again.</emph></par> 
d1251 2
a1252 2
and &UNIX; versions, we also chose to use &UNIX; tools on &WNT;
(e.g., <texttt>gmake</texttt>), rather than go for a <emph>native</emph>
d1280 8
a1287 8
Therefore, whenever the procedures and examples for &UNIX; in this
guide refer to the path <texttt>/afs/cern.ch/sw/lhcxx</texttt>, on
&NICE; the equivalent path is <verb>Z:\P32\lhcxx</verb>. This
applies to libraries, include files, etc. Moreover, uses of the
environment variable <texttt>LHCXXTOP</texttt>, which refer to the
above path, on &WNT; map to <verb>%LHCXXTOP%</verb> with the
<texttt>cmd</texttt> shell, and remain unchanged
<texttt>$LHCXXTOP</texttt> with the <texttt>bash</texttt> shell.
d1367 1
a1370 1
e.g.,</par>  
d1579 3
a1583 1
associate a federated database with a given machine, so that you must
a1586 2
always connect to that same machine if you want to access that
database.
d1597 1
a1598 1
across the network).</par>
a1603 2
<index item="OOFDBOOK@@{\ttfamily OO_FD_BOOT}"/>
<index item="&OBJ;"/>
d1607 2
d1627 1
a1630 1
file after you moved it will <emph>not</emph> work.
a1664 2
<index item="Federated database"/>
<index item="Database"/>
a1671 1
<index item="RD45 Project"/>
d1675 3
a1685 3
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
a1693 1
<index item="ootoolmgr@@{\ttfamily ootoolmgr}"/>
d1696 4
d1736 1
a1737 1
objects.
a1748 1
<index item="&OBJ;!transaction"/>
d1753 1
d1768 1
a1768 1
HepRef(Histo1D) myHisto (...);
d1779 1
a1780 1
automatically be stored in the database at commit time.
a1788 170
<par>
We are now finally ready to write a program to create a new database
and save an histogram in it (see the beginning of Chapter
<ref refid="H1HistogramTagClasses"/>
to find out how to get the code of an example and run it.)
</par>

<listing>
<![CDATA[/* simpleHisto.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h>
#include &lt;math.h>

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    HepDatabaseRef  MyDb = db("MyDB"); //create a new database
    HepRef(Histo1D) histo   = new(MyDb) Histo1D("Test_Histo1D",20,0.0,50000.0);
    
    for( int i = 0; i < 50000; i++)      // fill the histo in a loop
    {
        histo->fill(i,10*sin(i)+cos(i)*cos(i));  
    }

    // print global histogram properties
    cout << "Histogram name : " << histo->get_name()                     << endl
         << "No. of entries : " << histo->get_entries_number()           << endl
         << "Mean (bin cont): " << histo->compute_mean(bin_content_stats)<< endl
         << "RMS  (bin cont): " << histo->compute_RMS(bin_content_stats) << endl;

    commit();    // commit this transaction
    return 0;
  }
};
int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="histo1d@@{\texttt{Histo1D}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo1d@@{\texttt{Histo1D}}"/>
<index item="fill@@{\texttt{fill}} method (HistOOgram)"/>
<index item="HistOOgram!methods!fill@@{\texttt{fill}}"/>
<index item="getname@@{\texttt{get_name}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getname@@{\texttt{get_name}}"/>
<index item="getentriesnumber@@{\texttt{get_entries_number}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getentriesnumber@@{\texttt{get_entries_number}}"/>
<index item="computemean@@{\texttt{compute_mean}} method (HistOOgram)"/>
<index item="HistOOgram!methods!computemean@@{\texttt{compute_mean}}"/>
<index item="computerms@@{\texttt{compute_RMS}} method (HistOOgram)"/>
<index item="HistOOgram!methods!computerms@@{\texttt{compute_RMS}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>

<par>In the C++ program above, we start by initialising the database
session (as always, we implicitly use the federated database addressed
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
by the <texttt>OO_FD_BOOT</texttt> variable), and then start a transaction,
<index item="&OBJ;!transaction"/>
thus telling &OBJ; that we are going to update the database.</par>
<verbatim>
    Init();        // initialise the db session
    startUpdate(); // start an update transaction
</verbatim>
<par>
The next command creates a database <texttt>MyDB</texttt> 
(or opens it if it already exists) in the federated database.
</par>
<verbatim>
    HepDatabaseRef  MyDb = db("MyDB"); 
</verbatim>
<par>
Then, we create a histogram and fill it (this code will be explained in
a later chapter, so we will not go into any detail here).
We print some info about the histogram, then commit the changes to the
database.
</par>
<verbatim>
    commit();
</verbatim>
<par>
If, for some reason, the program aborts before reaching the commit
command, the database will <emph>not</emph> be changed. Nevertheless, you
might have to clean up the state of the federated database, since it
<index item="Federated database"/>
<index item="Database"/>
will still be waiting for the transaction to complete, thus possibly
<index item="&OBJ;!transaction"/>
preventing other processing from changing the database. In our case
everything went all right and we got the following output.
</par>
<verbatim>
Histogram name : Test_Histo1D
No. of entries : 50000
Mean (bin cont): 24996.6
RMS  (bin cont): 14427.1
</verbatim>

<par>
If you encounter problems during a transaction, then the proper way to
<index item="&OBJ;!transaction"/>
remove pending transactions is the &OBJ; utility <texttt>oocleanup</texttt>.
For instance, to remove pending transactions on the local node you can
issue the command:
</par>
<verbatim>
oocleanup -loc
</verbatim>
<index item="oocleanup@@{\ttfamily oocleanup}"/>
<index item="&OBJ;!transaction"/>

<par>
If we take another look at the databases with
<texttt>ootoolmgr</texttt>, then we indeed find our
<texttt>MyDB</texttt> database (plus <texttt>System</texttt>), as seen
in Figure <ref refid="OOTOOLMGR1"/>.
</par>
<figure id="OOTOOLMGR1" loc="!ht">
<includegraphics width=".7\linewidth" file="ootoolmgr1"/>
<caption>Selecting a database container with <texttt>ootoolmgr</texttt></caption>
<index item="ootoolmgr@@{\ttfamily ootoolmgr}"/>
</figure>
<par>
We select our database and the default container, plus one of the
basic objects (unfortunately, with the &OBJ; tools, we only see the
internal names of the objects). HEPExplorer, as explained later,
has a module
<emph>HistOOgramReader</emph> (see Section 
<ref refid="HISTOOGRAMREADER"/>),
<index item="HistOOgramReader@@{\emph{HistOOgramReader} module}"/>
<index item="HEPExplorer!modules!HistOOgramReader@@{\emph{HistOOgramReader}}"/>
which also shows the name of the objects (<texttt>Test_Histo1D</texttt> in our
example). Thus, in general, it is easier to use
the HEPExplorer tools to view the contents of a database.
Nevertheless, it is sometimes necessary to look inside a database,
and then <texttt>ootoolmgr</texttt> is a big help.
In particular, you can look at the detailed structure of an object in
the database, for instance the histogram object we created is shown
in Figure <ref refid="OOTOOLMGR2"/>
</par>
<figure id="OOTOOLMGR2" loc="!ht">
<includegraphics width=".7\linewidth" file="ootoolmgr2"/>
<caption>Viewing an object in the database with 
<texttt>ootoolmgr</texttt></caption> 
<index item="ootoolmgr@@{\ttfamily ootoolmgr}"/>
</figure>
<par>
We recognize the name of the histogram <texttt>Test_Histo1D</texttt>, the
number of data points (50000), etc., but more importantly, we can step
through all the bins and look at their contents (in the figure the
information for bin 10 is displayed and you see the value and the sum
of squares). More generally, the contents of every object in the
database can be studied in detail, thus facilitating debugging and
providing an interesting tool for studying the data model.
</par>

a1887 1
<index item="&OBJ;!transaction"/>
d1891 6
a1906 5
as well as four methods for sending an informative string to the
user console: <texttt>fatal</texttt> (prints a fatal error message and
aborts), <texttt>error</texttt> and <texttt>warning</texttt>,  (prints an 
error and warning message and continue), and
<texttt>message</texttt> (just prints a message).
d1957 1
d1960 1
a1960 1
    federated database;</item> 
d1979 1
a1979 1
HistOOgram classes and also learn about the tag classes. 
d1985 1
a1985 1
$LHCXXTOP/share/HISTOOGRAMS/pro/examples/
a1989 2
<index item="Examples!location"/>
<index item="Examples!running \~{}"/>
d1998 2
d2003 1
a2003 1
<stitle>The Persistent HistOOgram package</stitle>
d2006 4
a2009 2
The Persistent HistOOgram Package provides the basic histogramming
functionality of HBOOK along with some additional features:
d2012 5
a2016 2011

<itemize>
<item>booking and filling 1D, 2D histograms (equidistant binning);</item>
<item>storing errors at bin level;</item>
<item>computing mean and RMS at histogram level;</item>
<item>retrieving basic histogram characteristics;</item>
<item>histogram operations;</item>
<item>multidimensional histograms (dim&gt;2).</item>
</itemize>

<par>The package consists of several parts:</par>

<itemize>
<item>a histogram library (C++ binary code);</item>
<item>C++ header files;</item>
<item>an &OBJ; federated database prepared to be used with the histogram
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
library;</item>
<item>a <texttt>GNUmakefile</texttt> to simplify creating applications and
(re-)building the library;</item>
<item>examples of applications.</item>
</itemize>

<subsection id="HIST1DEXA">
<stitle>A one-dimensional histogram</stitle>

<par>
The source code for booking a one-dimensional histogram is shown
below.
</par>

<listing>
<![CDATA[/* createHisto1d.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int noOfBins=20;
    
    HepDatabaseRef  histoDb = db("HistoDB"); //create a new db or use an existing one
    HepRef(Histo1D) histo   = new(histoDb) Histo1D("Test_Histo1D",noOfBins,0.0,20.0);
    
    for( int i = 0; i &lt; 50000; i++) {   // fill histo in a loop
      double x = (i % 22) - 1;          // calculate x    
      histo-&gt;fill(x,(x-9.5)*(x-9.5)+3); // fill x with weights computed by dummy formula
    }
    
    // print global histogram properties
    cout &lt;&lt; " Histogram name : " &lt;&lt; histo-&gt;get_name() &lt;&lt; endl
         &lt;&lt; " Nbins = " &lt;&lt; histo-&gt;get_nBins() &lt;&lt; " from " &lt;&lt; histo-&gt;get_xmin()
         &lt;&lt; " to "      &lt;&lt; histo-&gt;get_xmax()  &lt;&lt; endl &lt;&lt; endl;
    
    // print histogram statistics
    cout &lt;&lt; " no. of entries   : " &lt;&lt; histo-&gt;get_entries_number()               &lt;&lt; endl
         &lt;&lt; " total contents   : " &lt;&lt; histo-&gt;get_all_bins()                     &lt;&lt; endl
         &lt;&lt; " nequival         : " &lt;&lt; histo-&gt;get_nequival()                     &lt;&lt; endl
         &lt;&lt; " min bin contents : " &lt;&lt; histo-&gt;find_min_bin()                     &lt;&lt; endl
         &lt;&lt; " max bin contents : " &lt;&lt; histo-&gt;find_max_bin()                     &lt;&lt; endl
         &lt;&lt; " mean (fill time) : " &lt;&lt; histo-&gt;compute_mean(filling_time_stats)   &lt;&lt; endl
         &lt;&lt; " rms  (fill time) : " &lt;&lt; histo-&gt;compute_RMS(filling_time_stats)    &lt;&lt; endl
         &lt;&lt; " mean (bin cont)  : " &lt;&lt; histo-&gt;compute_mean(bin_content_stats)    &lt;&lt; endl
         &lt;&lt; " rms  (bin cont)  : " &lt;&lt; histo-&gt;compute_RMS(bin_content_stats)     &lt;&lt; endl
         &lt;&lt; " underflow        : " &lt;&lt; histo-&gt;get_bin_value(underflow_bin)       &lt;&lt; endl
         &lt;&lt; " overflow         : " &lt;&lt; histo-&gt;get_bin_value(overflow_bin)        &lt;&lt; endl &lt;&lt; endl;
    
    // print histogram bin content
    for(i=0; i &lt; histo-&gt;get_nBins(); i++)
      cout &lt;&lt; " bin [" &lt;&lt; setw(2) &lt;&lt; i &lt;&lt;"] "
           &lt;&lt; "= "     &lt;&lt; setw(9) &lt;&lt; histo-&gt;get_bin_value(i)
           &lt;&lt; " +/- "  &lt;&lt; setprecision(4) &lt;&lt; histo-&gt;get_bin_error(i)   &lt;&lt; endl;

    commit();    // commit this transaction
    return 0;
  }
  
};

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="histo1d@@{\texttt{Histo1D}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo1d@@{\texttt{Histo1D}}"/>
<index item="fill@@{\texttt{fill}} method (HistOOgram)"/>
<index item="HistOOgram!methods!fill@@{\texttt{fill}}"/>
<index item="getname@@{\texttt{get_name}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getname@@{\texttt{get_name}}"/>
<index item="getnbins@@{\texttt{get_nBins}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getnbins@@{\texttt{get_nBins}}"/>
<index item="getxmin@@{\texttt{get_xmin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getxmin@@{\texttt{get_xmin}}"/>
<index item="getxmax@@{\texttt{get_xmax}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getxmax@@{\texttt{get_xmax}}"/>
<index item="getentriesnumber@@{\texttt{get_entries_number}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getentriesnumber@@{\texttt{get_entries_number}}"/>
<index item="getallbins@@{\texttt{get_all_bins}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getallbins@@{\texttt{get_all_bins}}"/>
<index item="getnequival@@{\texttt{get_nequival}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getnequival@@{\texttt{get_nequival}}"/>
<index item="findminbin@@{\texttt{find_min_bin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!findminbin@@{\texttt{find_min_bin}}"/>
<index item="findmaxbin@@{\texttt{find_max_bin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!findmaxbin@@{\texttt{find_max_bin}}"/>
<index item="computemean@@{\texttt{compute_mean}} method (HistOOgram)"/>
<index item="HistOOgram!methods!computemean@@{\texttt{compute_mean}}"/>
<index item="computerms@@{\texttt{compute_RMS}} method (HistOOgram)"/>
<index item="HistOOgram!methods!computerms@@{\texttt{compute_RMS}}"/>
<index item="getbinvalue@@{\texttt{get_bin_value}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getbinvalue@@{\texttt{get_bin_value}}"/>
<index item="getbinerror@@{\texttt{get_bin_error}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getbinerror@@{\texttt{get_bin_error}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>

<par>When everything ran all right, then you will see the output
below. Apart from the &OBJ; database-specific code, which will be
discussed below, you will have noticed the correspondence between
the C++ methods for the one-dimensional histogram <texttt>xhist</texttt> in
the source and the output it generated.
</par>

<verbatim>
 Histogram name : Test_Histo1D
 Nbins = 20 from 0 to 20

 no. of entries   : 50000
 total contents   : 2.16234e+06
 nequival         : 29609.4
 min bin contents : 7387.25
 max bin contents : 211957
 mean (fill time) : 9.49832
 rms  (fill time) : 8.36832
 mean (bin cont)  : 7.61848
 rms  (bin cont)  : 6.93551
 underflow        : 257417
 overflow         : 257304

 bin [ 0] =    211957 +/- 4446
 bin [ 1] =  1.71e+05 +/- 3588
 bin [ 2] = 1.347e+05 +/- 2825
 bin [ 3] = 1.029e+05 +/- 2157
 bin [ 4] = 7.558e+04 +/- 1585
 bin [ 5] = 5.285e+04 +/- 1108
 bin [ 6] = 3.466e+04 +/- 727.1
 bin [ 7] = 2.103e+04 +/- 441
 bin [ 8] = 1.193e+04 +/- 250.3
 bin [ 9] =      7387 +/- 154.9
 bin [10] =      7387 +/- 154.9
 bin [11] = 1.193e+04 +/- 250.3
 bin [12] = 2.103e+04 +/- 441
 bin [13] = 3.466e+04 +/- 727.1
 bin [14] = 5.285e+04 +/- 1108
 bin [15] = 7.554e+04 +/- 1585
 bin [16] = 1.028e+05 +/- 2157
 bin [17] = 1.346e+05 +/- 2824
 bin [18] =  1.71e+05 +/- 3587
 bin [19] = 2.119e+05 +/- 4445
</verbatim>

<par>After the run you should have an &OBJ; database named
<texttt>HistoDB.HEPEXP.DB</texttt> in your Explorer home directory. You can
now use this example program as a basis to write other C++ programs
using the HistOOgram library, which will be described in the following
sections. In particular, you should know that the C++ header files are
in the directory:</par>
<verbatim>
/afs/cern.ch/sw/lhcxx/specific/@@sys/HISTOOGRAMS/pro/code
</verbatim>

</subsection>

<subsection id="HistStatistics">
<stitle>Histogram statistics</stitle>
<index item="Histogram!statistics"/>
<index item="Histogram!bin contents"/>
<index item="Histogram!mean"/>
<index item="Histogram!RMS"/>
<index item="Bin contents"/>
<index item="Mean!histogram contents"/>
<index item="RMS!histogram contents"/>
<index item="Statistics!histogram contents"/>
<index item="Statistics!bin contents"/>

<par>Two methods have been implemented to compute histogram statistics.
They are identified by the enumeration <texttt>Histogram_stats_type</texttt>,
which can have the two values <texttt>filling_time_stats</texttt> and 
<texttt>bin_content_stats</texttt>. These types can be given as argument
to the methods <texttt>compute_mean</texttt> and <texttt>compute_RMS</texttt>, 
as seen in the example code above. Also, in the printout of the
histograms 
(see Section <ref refid="Printing-histograms"/>)
the mean value and the RMS of the histogram are calculated for both
methods (respectively labelled <texttt>MEAN F.T.</texttt>, <texttt>RMS F.T.</texttt>
for <emph>Filling Time</emph> and <texttt>MEAN B.C.</texttt>, <texttt>RMS B.C.</texttt> 
for <emph>Bin Content</emph>). The two methods are described below.</par>

<subsubsection>
<stitle>Fill time statistics (<texttt>filling_time_stats</texttt>)</stitle>
<index item="Histogram!fill time statistics"/>
<index item="fillingtimestats@@{\ttfamily filling_time_stats}"/>
<index item="Statistics!histogram!filling time"/>
<index item="Statistics!histogram!mean"/>
<index item="Statistics!histogram!RMS"/>

<itemize>
<item>the histogram statistics are calculated from each individual entry
stored in the histogram;</item>
<item>the information is stored and updated during filling time;</item>
<item>after filling the histogram the time required to extract the
<texttt>MEAN</texttt> and <texttt>RMS</texttt> is constant (and small).</item>
</itemize>

</subsubsection>
<subsubsection>
<stitle>Bin contents statistics (<texttt>bin_content_stats</texttt>)</stitle>
<index item="Histogram!bin contents statistics"/>
<index item="bin_contentstats@@{\ttfamily bin_content_stats}"/>
<index item="Statistics!histogram!bin contents"/>
<index item="Statistics!histogram!mean"/>
<index item="Statistics!histogram!RMS"/>

<itemize>
<item>the histogram statistics are calculated from information stored in
the bins;</item>
<item>the contents of special bins (underflow/overflow) is <emph>not</emph>
used during the computation;</item>
<item>the whole computation is performed on request after the histogram 
has been filled;</item>
<item>in the case of a one-dimensional histogram the position
of the bin is taken as the middle of the bin interval;</item>
<item>this method is less accurate than the previous one;</item>
<item>the computing time of <texttt>MEAN</texttt> and <texttt>RMS</texttt> is linear
with respect to the number of bins.</item>
</itemize>
</subsubsection>
</subsection>

<subsection id="Booking-and-accessing-histograms">
<stitle>Booking and accessing histograms</stitle>

<par>
The general syntax for creating a new histogram is:
</par>
<verbatim>
HepRef(HistogramClass) handle_name = new(object_handle) HistogramClass(...);
</verbatim>

<par>
<texttt>object_handle</texttt> can be a handle to a database, a container
or any ordinary object. In our examples we use a database handle
obtained via a command of the type:
</par>
<verbatim>
HepDatabaseRef  dbHist = db("MyDB"); //open the database
</verbatim>
<par>
In this case &OBJ; will open the database with name
<texttt>MyDB</texttt>. From now on inside our program we communicate with the
database using the database handle <texttt>dbHist</texttt>.
</par>

<par>
For a one-dimensional histogram (the class is <texttt>Histo1D</texttt>), this
becomes more explicitly something like:
</par>
<verbatim>
HepRef(Histo1D) histo = new(dbHist) Histo1D("Test_Histo1D",10,0.0,20.0);
</verbatim>

<par>
This creates a new persistent histogram, which will be addressed with
the <emph>smart</emph> pointer <texttt>histo</texttt> (declared with
<texttt>HepRef</texttt>).  Users can, however, use normal pointer syntax, so
that, for instance, to fill a histogram with the value of <texttt>X</texttt>,
you can write:
</par>
<verbatim>
histo-&gt;fill(X);
</verbatim>

<par>
Later, when the changes are committed, the histogram will be 
automatically saved in the database.
</par>
</subsection>

<subsection id="HBOOK-style-basic-histograms">
<stitle>HBOOK-style basic histograms</stitle>

<par>
This and the following sections will briefly review the various types
of histogram objects, which are available at present. They are
described in detail in the <emph>HistOOgram
Class Reference manual</emph>
(<url name="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html"/>).
<index item="HistOOgram!class reference"/>
</par>

<subsubsection>
<stitle>Simple one- and two-dimensional histograms</stitle>

<par>The classes 
<emph>Histo1D</emph>
<index item="histo1d@@{\texttt{Histo1D}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo1d@@{\texttt{Histo1D}}"/>
(for equidistant bins in one dimension), 
<emph>Histo1DVar</emph>
<index item="histo1dvar@@{\texttt{Histo1DVar}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo1dvar@@{\texttt{Histo1DVar}}"/>
(for non-equidistant bins in one dimension),
<emph>Histo2D</emph>
<index item="histo2d@@{\texttt{Histo2D}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo2d@@{\texttt{Histo2D}}"/>
(for equidistant bins in two dimensions), and
<emph>Histo2DVar</emph>
<index item="histo2dvar@@{\texttt{Histo2DVar}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo2dvar@@{\texttt{Histo2DVar}}"/>
(for non-equidistant bins in two dimensions)
offer a simple user interface, which make them easy to learn.  A rich
set of methods is available for these classes for getting access to
the characteristics of the histogram data.
</par>

<par>
We already looked at the one-dimensional case above, so let us
study a two-dimensional example.
</par>
<listing>
<![CDATA[/* createHisto2d.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h&gt;
#include "CLHEP/Random/Randomize.h"

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int Nbin = 10;

    HepDatabaseRef  myDb = db("MyDB"); //open the database

    HepRef(Histo2D) xhist = new(myDb) 
      Histo2D(" Test Histo2D ", Nbin, 5., 15., Nbin, 5., 15.);

/* -----Start of histogram manipulation-------------------------------- */

    cout &lt;&lt; endl &lt;&lt; " Histogram name : " &lt;&lt; xhist-&gt;get_name() &lt;&lt; endl;;

    cout &lt;&lt; " X axis : ";
    cout &lt;&lt; " Nbins = " &lt;&lt; xhist-&gt;get_nxBins() &lt;&lt; " from: " &lt;&lt; xhist-&gt;get_xmin()
         &lt;&lt; " to: " &lt;&lt; xhist-&gt;get_xmax() &lt;&lt; endl ;
  
    cout &lt;&lt; " Y axis : ";
    cout &lt;&lt; " Nbins = " &lt;&lt; xhist-&gt;get_nyBins() &lt;&lt; " from: " &lt;&lt; xhist-&gt;get_ymin()
         &lt;&lt; " to: " &lt;&lt; xhist-&gt;get_ymax() &lt;&lt; endl ;
 
    for(int i = 0;i &lt; 50000;i++)
    {
      double x  = RandFlat::shoot(20.);       // fnum  ]0,20[
     
      xhist-&gt;fill(x,x,0.5);    // fill diagonal
      xhist-&gt;fill(20-x,x,0.5); // fill anti-diagonal
    }

    cout &lt;&lt; endl &lt;&lt; " no. of entries   : " &lt;&lt; xhist-&gt;get_entries_number()
         &lt;&lt; endl &lt;&lt; " total contents   : " &lt;&lt; xhist-&gt;get_all_bins() 
         &lt;&lt; endl &lt;&lt; " nequival         : " &lt;&lt; xhist-&gt;get_nequival()
         &lt;&lt; endl &lt;&lt; " min bin contents : " &lt;&lt; xhist-&gt;find_min_bin()
         &lt;&lt; endl &lt;&lt; " max bin contents : " &lt;&lt; xhist-&gt;find_max_bin()
         &lt;&lt; endl &lt;&lt; " X-Y  underflow/overflow bins "
         &lt;&lt; endl &lt;&lt; " u-u        : " &lt;&lt; xhist-&gt;get_bin_value(underflow_bin,underflow_bin)
         &lt;&lt; endl &lt;&lt; " u-i        : " &lt;&lt; xhist-&gt;get_bin_value(underflow_bin,inrange_bin)
         &lt;&lt; endl &lt;&lt; " u-o        : " &lt;&lt; xhist-&gt;get_bin_value(underflow_bin,overflow_bin)
         &lt;&lt; endl &lt;&lt; " i-u        : " &lt;&lt; xhist-&gt;get_bin_value(inrange_bin,underflow_bin)
         &lt;&lt; endl &lt;&lt; " i-o        : " &lt;&lt; xhist-&gt;get_bin_value(inrange_bin,overflow_bin)
         &lt;&lt; endl &lt;&lt; " o-u        : " &lt;&lt; xhist-&gt;get_bin_value(overflow_bin,underflow_bin)
         &lt;&lt; endl &lt;&lt; " o-i        : " &lt;&lt; xhist-&gt;get_bin_value(overflow_bin,inrange_bin)
         &lt;&lt; endl &lt;&lt; " o-o        : " &lt;&lt; xhist-&gt;get_bin_value(overflow_bin,overflow_bin)
         &lt;&lt; endl;

    for(int ix=0;ix&lt;Nbin;ix++)
     for(int iy=0;iy&lt;Nbin;iy++)
     { 
       if (xhist-&gt;get_bin_value(ix,iy) &gt; 0.0)
       cout &lt;&lt; endl &lt;&lt; " bin (" &lt;&lt; ix &lt;&lt; "," &lt;&lt; iy 
	    &lt;&lt; ") contents = " &lt;&lt; xhist-&gt;get_bin_value(ix,iy)
            &lt;&lt; " error = "     &lt;&lt; xhist-&gt;get_bin_error(ix,iy);
     }              // end of for loop 
    cout &lt;&lt; endl;               

/*  -----End of histogram manipulation--------------------------------- */

    commit();    // commit this transaction
    return 0;
  }
};  // end of class definition 

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="fill@@{\texttt{fill}} method (HistOOgram)"/>
<index item="HistOOgram!methods!fill@@{\texttt{fill}}"/>
<index item="getbinvalue@@{\texttt{get_bin_value}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getbinvalue@@{\texttt{get_bin_value}}"/>
<index item="getentriesnumber@@{\texttt{get_entries_number}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getentriesnumber@@{\texttt{get_entries_number}}"/>
<index item="getbinerror@@{\texttt{get_bin_error}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getbinerror@@{\texttt{get_bin_error}}"/>
<index item="getallbins@@{\texttt{get_all_bins}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getallbins@@{\texttt{get_all_bins}}"/>
<index item="getname@@{\texttt{get_name}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getname@@{\texttt{get_name}}"/>
<index item="getnequival@@{\texttt{get_nequival}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getnequival@@{\texttt{get_nequival}}"/>
<index item="findminbin@@{\texttt{find_min_bin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!findminbin@@{\texttt{find_min_bin}}"/>
<index item="findmaxbin@@{\texttt{find_max_bin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!findmaxbin@@{\texttt{find_max_bin}}"/>
<index item="getnxbins@@{\texttt{get_nxBins}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getnxbins@@{\texttt{get_nxBins}}"/>
<index item="getnybins@@{\texttt{get_nyBins}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getnybins@@{\texttt{get_nyBins}}"/>
<index item="getxmin@@{\texttt{get_xmin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getxmin@@{\texttt{get_xmin}}"/>
<index item="getxmax@@{\texttt{get_xmax}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getxmax@@{\texttt{get_xmax}}"/>
<index item="getymin@@{\texttt{get_ymin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getymin@@{\texttt{get_ymin}}"/>
<index item="getymax@@{\texttt{get_ymax}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getymax@@{\texttt{get_ymax}}"/>
<index item="histo2d@@{\texttt{Histo2D}} method (HistOOgram)"/>
<index item="HistOOgram!methods!histo2d@@{\texttt{Histo2D}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="randflat@@{\texttt{RandFlat}} method (CLHEP)"/>
<index item="CLHEP!methods!randflat@@{\texttt{RandFlat}}"/>
<par>
In this example we create a two-dimensional histogram
with 10 bins in X and Y. We fill it along the diagonal and the
anti-diagonal, and then call some of the methods to access the
histogram statistics. Finally, before committing the histogram in the
dabatase, we print the non-empty bins. The output is shown below.
</par>
<verbatim>
 Histogram name :  Test Histo2D 
 X axis :  Nbins = 10 from: 5 to: 15
 Y axis :  Nbins = 10 from: 5 to: 15

 no. of entries   : 100000
 total contents   : 50000
 nequival         : 100000
 min bin contents : 0
 max bin contents : 1279
 X-Y  underflow/overflow bins 
 u-u        : 6308.5
 u-i        : 0
 u-o        : 6240
 i-u        : 0
 i-o        : 0
 o-u        : 6308.5
 o-i        : 0
 o-o        : 6240

 bin (0,0) contents = 1191.5 error = 24.408
 bin (0,9) contents = 1248.5 error = 24.985
 bin (1,1) contents = 1254.5 error = 25.045
 bin (1,8) contents = 1260.5 error = 25.1048
 bin (2,2) contents = 1250 error = 25
 bin (2,7) contents = 1239.5 error = 24.8948
 bin (3,3) contents = 1271 error = 25.2091
 bin (3,6) contents = 1244 error = 24.9399
 bin (4,4) contents = 1213 error = 24.6272
 bin (4,5) contents = 1279 error = 25.2883
 bin (5,4) contents = 1213 error = 24.6272
 bin (5,5) contents = 1279 error = 25.2883
 bin (6,3) contents = 1271 error = 25.2091
 bin (6,6) contents = 1244 error = 24.9399
 bin (7,2) contents = 1250 error = 25
 bin (7,7) contents = 1239.5 error = 24.8948
 bin (8,1) contents = 1254.5 error = 25.045
 bin (8,8) contents = 1260.5 error = 25.1048
 bin (9,0) contents = 1191.5 error = 24.408
 bin (9,9) contents = 1248.5 error = 24.985
</verbatim>
<par>
We filled the histogram along both diagonals with a
random number between zero and twenty. However, the boundary values of the
histogram were five and fifteen, so that we expect half of the 100000 entries
to be in the underflow and overflow bins, and the other half spread 
evenly along the twenty bins of the two diagonals. As the weight of the
events is 0.5, we indeed get about 1250 events inside the bins of the
histogram, and about 6250 in the four underflow/overflow bins
(<texttt>u-u</texttt>, <texttt>u-o</texttt>, <texttt>o-u</texttt> and <texttt>o-o</texttt>).
</par>
</subsubsection>
</subsection>

<subsection id="More-general-histograms">
<stitle>More general histograms</stitle>

<par>The classes described previously provide a HBOOK-like interface,
<index item="HBOOK"/>
which is familiar to most HEP physicists, thus allowing them to
develop applications rapidly and simply.  However, sometimes more
complex histograms are needed, and this simple interface is not
sufficient.
</par>

<par>
Therefore, we introduce a generalised type of histogram, whose
basic component is the <texttt>Partition</texttt> class. It defines the
following:
</par>
<index item="partition@@{\texttt{Partition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!partition@@{\texttt{Partition}}"/>

<itemize>
<item>the dimension of the problem space;</item> 
<item>the data type for each dimensional component (in the current
    version only real numbers of type <texttt>double</texttt> are provided);</item>
<item>the description of the bins (partition).</item>
</itemize>

<par>Data type information and the bin description is supplied by
classes derived from 
<emph>ElementaryPartition</emph>.
<index item="elementarypartition@@{\texttt{ElementaryPartition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!elementarypartition@@{\texttt{ElementaryPartition}}"/>
Each <emph>ElementaryPartition</emph> represents one dimension in the problem
space. Presently, one can use the following elementary partitions:
</par>

<itemize>
<item>
<emph>FixedLengthPartition</emph>
<index item="fixedlengthpartition@@{\texttt{FixedLengthPartition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!fixedlengthpartition@@{\texttt{FixedLengthPartition}}"/>
for <emph>equidistant bins</emph> over the real axis;</item> 
<item>
<emph>VariableLengthPartition</emph>
<index item="variablelengthpartition@@{\texttt{VariableLengthPartition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!variablelengthpartition@@{\texttt{VariableLengthPartition}}"/>
for <emph>variable length bins</emph>, where each one has to be defined
separately.</item>
</itemize>

<subsubsection>
<stitle>Standard way to book a general histogram</stitle>
<index item="Histogram!general"/>

<enumerate>
<item>Create any number of elementary partitions:
<index item="Partition!elementary!create"/>
<verbatim>
HepRef(ElemPartType1) p1 = new (myDB) ElemPartType1(...);
   ...
HepRef(ElemPartTypeN) pN = new (myDB) ElemPartTypeN(...);
</verbatim>
</item>
<item>Create a <emph>partition</emph> and insert the elementary partitions created in
the first step (the order of adding elementary partitions is
significant);
<index item="Partition!creation"/>
<index item="Partition!elementary!add"/>
<verbatim>
HepRef(Partition) part = new (myDB) Partition();
part->add_part( p1 ); 
     ... 
part->add_part( pN );
</verbatim>
<index item="addpart@@{\texttt{add_part}} method (HistOOgram)"/>
<index item="HistOOgram!methods!addpart@@{\texttt{add_part}}"/>
</item>
<item>Create a <emph>DataHistogram</emph> using the partition above.
<index item="DataHistogram!creation"/>
<verbatim>
HepRef(DataHistogram) hist = new (myDB) DataHistogram("name",part);
</verbatim></item>
</enumerate>

</subsubsection>
<subsubsection id="Misc-Bins-endpoint-conventions">
<stitle>A note on endpoint conventions</stitle>
<index item="Endpoint convention"/>

<par>The <emph>endpoint convention</emph> specifies to which of two
neighbouring intervals (<texttt>LEFT</texttt> chooses the interval to the left
of the endpoint, <texttt>RIGHT</texttt> the one to the right) the given endpoint
belongs. 
For instance, suppose we have <texttt>N</texttt> bins. Then we could
specify an array like,
<verbatim>
side eps[N+1] = {LEFT,LEFT,...,LEFT,RIGHT};
</verbatim>
which would yield the following pattern (the square brackets signaling
which side the endpoint is included).
<verbatim>
-und-]1(--]2(--]3( .... ]N-1(--)N[-ovr-
</verbatim>
Note that since we specify a characteristic of the endpoint rather
than the bin we must give <texttt>N+1</texttt> values.
The notation <texttt>-und-</texttt>, <texttt>-ovr-</texttt> stands for 
underflow, overflow, respectively.
</par>

</subsubsection>
<subsubsection>
<stitle>Example of a Data Histogram</stitle>

<par>Let us look at an example of the use of partitions and data
histograms. The source of the program will be shown first.</par>

<listing>
<![CDATA[/* dataHistogram.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;math.h&gt;
#include &lt;iostream.h&gt;
#include "CLHEP/Random/Randomize.h"

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    HepDatabaseRef  myDb = db("HistoDB"); //create or open db "HistoDB"

    const int Nbinx = 10, Nbiny = 10, Nbinz = 5;

    // Create elementary partitions

    HepRef(FixedLengthPartition) 
     p1 = new (myDb) FixedLengthPartition(Nbinx, 0., 1.0, LEFT );

    HepRef(FixedLengthPartition) 
     p2 = new (myDb) FixedLengthPartition(Nbiny, 0., 1.0, RIGHT );

    double ep_list[Nbinz+1] = {0.,0.25,0.5,0.7,0.85,1.};
    side   ep_conv_list[Nbinz+1] = {LEFT,LEFT,RIGHT,LEFT,LEFT,LEFT};

    HepRef(VariableLengthPartition) 
     p3 = new (myDb) VariableLengthPartition(ep_list,Nbinz+1, ep_conv_list, Nbinz+1);

    // Create partition

    HepRef(Partition) part = new (myDb) Partition();

    // Add elementary partitions in partition

    part-&gt;add_part( p1 );
    part-&gt;add_part( p2 );
    part-&gt;add_part( p3 );

    // Create datahistogram    

    HepRef(DataHistogram) 
     xhist = new(myDb) DataHistogram(" Test General 3D Histo  ", part);

/* -----Start of histogram manipulation-------------------------------- */

    printf(" Histogram name : %s \n",xhist-&gt;get_name());

    for(int i = 1;i &lt;= 50000;i++)
    {
      double x[3];
      double ran;
      ran  = RandFlat::shoot(1.);       // fnum  ]0,1[
      x[0] = ran;
      ran  = RandFlat::shoot(1.);       // fnum  ]0,1[
      x[1] = pow(ran,2);
      ran  = RandFlat::shoot(1.);       // fnum  ]0,1[
      x[2] = pow(ran,0.3);
 
      xhist-&gt;add_data_point(x,1.0);  // fill 3D datahistogram
   
    }

    cout &lt;&lt; endl &lt;&lt; " no. of entries   : " &lt;&lt; xhist-&gt;get_entries_number()
         &lt;&lt; endl &lt;&lt; " total contents   : " &lt;&lt; xhist-&gt;get_all_bins() 
         &lt;&lt; endl &lt;&lt; " nequival         : " &lt;&lt; xhist-&gt;get_nequival()
         &lt;&lt; endl &lt;&lt; " min bin contents : " &lt;&lt; xhist-&gt;find_min_bin()
         &lt;&lt; endl &lt;&lt; " max bin contents : " &lt;&lt; xhist-&gt;find_max_bin()
         &lt;&lt; endl;

    for(int ix=0;ix&lt;Nbinx;ix++)
     for(int iy=0;iy&lt;Nbiny;iy++)
      for(int iz=0;iz&lt;Nbinz;iz++)
      {
        int a[3];
        a[0] = ix; a[1] = iy; a[2] = iz;

        cout &lt;&lt; endl &lt;&lt; " bin (" &lt;&lt; ix &lt;&lt; "," &lt;&lt; iy &lt;&lt; "," &lt;&lt; iz
                     &lt;&lt; ") contents = " &lt;&lt; xhist-&gt;get_bin_value(a);
      }
       
    cout &lt;&lt; endl;               

/*  -----End of histogram manipulation--------------------------------- */
    
    commit();    // commit this transaction
    return 0;
  }
  
};   // end of class definition


int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="fixedlengthpartition@@{\texttt{FixedLengthPartition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!fixedlengthpartition@@{\texttt{FixedLengthPartition}}"/>
<index item="variablelengthpartition@@{\texttt{VariableLengthPartition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!variablelengthpartition@@{\texttt{VariableLengthPartition}}"/>
<index item="partition@@{\texttt{Partition}} class (HistOOgram)"/>
<index item="HistOOgram!classes!partition@@{\texttt{Partition}}"/>
<index item="datahistogram@@{\texttt{DataHistogram}} class (HistOOgram)"/>
<index item="HistOOgram!classes!datahistogram@@{\texttt{DataHistogram}}"/>
<index item="addpart@@{\texttt{add_part}} method (HistOOgram)"/>
<index item="HistOOgram!methods!addpart@@{\texttt{add_part}}"/>
<index item="adddatapoint@@{\texttt{add_data_point}} method (HistOOgram)"/>
<index item="HistOOgram!methods!adddatapointe@@{\texttt{add_data_point}}"/>
<index item="getentriesnumber@@{\texttt{get_entries_number}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getentriesnumber@@{\texttt{get_entries_number}}"/>
<index item="getbinvalue@@{\texttt{get_bin_value}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getbinvalue@@{\texttt{get_bin_value}}"/>
<index item="getallbins@@{\texttt{get_all_bins}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getallbins@@{\texttt{get_all_bins}}"/>
<index item="getnequival@@{\texttt{get_nequival}} method (HistOOgram)"/>
<index item="HistOOgram!methods!getnequival@@{\texttt{get_nequival}}"/>
<index item="findminbin@@{\texttt{find_min_bin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!findminbin@@{\texttt{find_min_bin}}"/>
<index item="findmaxbin@@{\texttt{find_max_bin}} method (HistOOgram)"/>
<index item="HistOOgram!methods!findmaxbin@@{\texttt{find_max_bin}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="randflat@@{\texttt{RandFlat}} method (CLHEP)"/>
<index item="CLHEP!methods!randflat@@{\texttt{RandFlat}}"/>

<par>In the above program we declare two fixed length (<texttt>p1</texttt> and
<texttt>p2</texttt>) and a variable length elementary partitions
(<texttt>p3</texttt>), then a base partition <texttt>part</texttt>, to which the three
elementary partitions are added with the <texttt>add_part</texttt> method. A
3-dimensional data histogram <texttt>xhist</texttt> is declared next, and we
fill it with some random data. Finally, before committing the
histogram to the database, we print some statistical information, as
well as the contents of the bins. The output is (partially) reproduced
below.
</par>
<alltt>
 Histogram name :  Test General 3D Histo   

 no. of entries   : 50000
 total contents   : 50000
 nequival         : 50000
 min bin contents : 1
 max bin contents : 707

 bin (0,0,0) contents = 9
 bin (0,0,1) contents = 154
 bin (0,0,2) contents = 329
 bin (0,0,3) contents = 425
 bin (0,0,4) contents = 658
     <emph>.... many lines omitted</emph>
 bin (9,9,0) contents = 4
 bin (9,9,1) contents = 29
 bin (9,9,2) contents = 53
 bin (9,9,3) contents = 63
 bin (9,9,4) contents = 116
</alltt>
</subsubsection>
</subsection>

<subsection id="Printing-histograms">
<stitle>Printing histograms</stitle>

<par>You can create text-graphics printouts on standard C++ streams of
<texttt>Histo1D</texttt> and <texttt>Histo2D</texttt> histograms
with the class <emph>HistPrintout</emph>
<index item="histprintout@@{\texttt{HistPrintout}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histprintout@@{\texttt{HistPrintout}}"/>
is responsible for creating printouts . You can specify the page size
into which the printed output must fit. In case the graph does not fit
on the page a warning message is issued and inserted on the top
of the printout. The page size restriction affects only the graph
itself and not the additional textual information which is printed
next to the graph.</par>

<par>The way how to use this functionality is shown in the following
source code example.</par>

<listing>
<![CDATA[/* printHistos.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include "CLHEP/Random/Randomize.h"
#include &lt;iostream.h&gt;
#include &lt;math.h&gt;

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int NBins = 10;

    HepDatabaseRef  histoDb = db("HistoDB"); //create or open "HistoDB" db
  
    HepRef(Histo1D) xhist = 
      new(histoDb) Histo1D("1D Histo",NBins,0.0,20.0);

    double epl[10] = { 0.0, 1.0, 2.0, 4.0, 8.0, 10.0, 11.0, 20.0, 30.0, 100.0 };

    HepRef(Histo1DVar) xhistvar = 
      new(histoDb) Histo1DVar("Variable bin Histo1D", epl, 10, RIGHT);

    HepRef(Histo2D) xyhist = 
      new(histoDb) Histo2D("2D Histo", 40, -0.1, 0.5, 30, -.1, 0.5);

    HepRef(Histo2DVar) xyhistvar = 
      new (histoDb) Histo2DVar("Variable bin Histo2D", epl, 10, LEFT, epl, 10, LEFT);

/* -----Start of histogram manipulation-------------------------------- */

    for(int i = 0;i &lt; 50000;i++)
    {
      double x,y;

      x  = double(i%19);  
      xhist-&gt;fill(x, abs(sin(i)));

      x  = RandFlat::shoot(100.);       // fnum  ]0,100[
      xhistvar-&gt;fill(x,1/(x+1));

      x  = RandFlat::shoot(3.14159);    // fnum  ]0,2pi[
      x  = 0.5*cos(x); 
      y  = RandFlat::shoot(3.14159);    // fnum  ]0,2pi[
      y  = 0.5*sin(y);
      xyhist-&gt;fill(x*x+x*y,y*y-x*y,y*y);

      x  = RandGauss::shoot(15.,16.);   // (mean=15, stDev=16)
      y  = RandGauss::shoot(16.,7.);    // (mean=16, stDev=7)
      xyhistvar-&gt;fill(x,y,1);
    }

    // Print histograms (first 1D, then 2D)

    HistPrintout p(cout);

    p.print(*xhist);    cout &lt;&lt; endl; 
    p.print(*xhistvar); cout &lt;&lt; endl; 
    p.print(*xyhist);   cout &lt;&lt; endl; 
    p.print(*xyhistvar);

/*  -----End of histogram manipulation--------------------------------- */
    
    commit();    // commit this transaction
    return 0;
  }
  
};  // end of class definition

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="fill@@{\texttt{fill}} method (HistOOgram)"/>
<index item="HistOOgram!methods!fill@@{\texttt{fill}}"/>
<index item="print@@{\texttt{print}} method (HistOOgram)"/>
<index item="HistOOgram!methods!print@@{\texttt{print}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="randflat@@{\texttt{RandFlat}} method (CLHEP)"/>
<index item="CLHEP!methods!randflat@@{\texttt{RandFlat}}"/>
<index item="randgauss@@{\texttt{RandGauss}} method (CLHEP)"/>
<index item="CLHEP!methods!randgauss@@{\texttt{RandGauss}}"/>

<par>Let us have a closer look at this code. After the usual
initialisation of the &OBJ; database, we generate two one- and
two-dimensional histograms (one with fixed and one with variable bins
for each). Then we fill these histograms with a combination of
trigonometric mathematical functions and random numbers. 
If we want to print these
histograms to standard output (<texttt>cout</texttt>) then the following steps
must be taken:</par>

<enumerate>
<item>Create a printout object <texttt>p</texttt>, which will use <texttt>cout</texttt>
as output stream.
<verbatim>
  HistPrintout p(cout);
</verbatim>
</item>
<item>Set the page size. A page size has 80 columns by default, while
its depth (number of lines) is at first 0 (unlimited).
<verbatim>
  p.columns = 120; // any numbers of your choice
  p.lines = 0;     // unlimited
</verbatim>
Of course, any values can be chosen for these numbers.  In particular,
the page size can be adjusted automatically to fill the width of
the terminal window.
<verbatim>
  p.auto_setup();  // get COLUMNS and LINES from environment variables
</verbatim>
</item>
<item>Printing out the histograms. This is quite simple: just
call the <texttt>print</texttt> message, with as argument the dereferenced
pointer to the histogram object. 
<verbatim>
  p.print( *xhist ); // *xhist dereferences the pointer to type HepRef.
</verbatim>
Note that only one- and two-dimensional histograms can be printed in
this way.
</item>
</enumerate>
<par>The output generated by the code above is seen below.
We note in particular the way the definition of the variable-width
bins are printed in the output, together with the end-point definitions.</par>
<index item="Endpoint convention"/>
<verbatim>
BINS' ENDPTS: -und-)0[--)1[--)2[--)4[--)8[--)10[--)11[--)20[--)30[--)100[-ovr-
</verbatim>
<par>
This corresponds to the definition for the variable-bin 1-D histogram of
our example program, where the bins indeed correspond to those defined
with the <texttt>epl</texttt> array.
</par>
<par>
You should also note the two calculated values for the mean
and RMS values of the contents of the histogram. These values
are calculated at fill time (label <texttt>F.T.</texttt>)
and after filling the histogram from the bin contents
themselves (label <texttt>B.C.</texttt>), respectively. See
Section <ref refid="HistStatistics"/>
for a detailed explanation. The differences between the two values are
small in most cases, although the value calculated at filling time
should be the more precise.</par>
<index item="Histogram!statistics"/>
<index item="Histogram!bin contents"/>
<index item="Histogram!mean"/>
<index item="Histogram!RMS"/>
<index item="Bin contents"/>
<index item="Mean!histogram contents"/>
<index item="RMS!histogram contents"/>
<index item="Statistics!histogram contents"/>
<index item="Statistics!bin contents"/>

<verbatim>
TYPE       : Histo1D
TITLE      : 1D Histo
BIN NUMBER : 10
BIN WIDTH  : 2

                           1.67e+03                        3.35e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   1     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   2     3.352e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   3     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   4     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+01   5     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.200e+01   6     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.400e+01   7     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   8     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   9     1.675e+03|
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  3.183e+04 NEQUIVAL :  4.053e+04
 MEAN F.T.:  8.999e+00 MEAN B.C.:  9.526e+00 UNDERFLOW:  0.000e+00
 RMS F.T. :  5.477e+00 RMS B.C. :  5.500e+00 OVERFLOW :  0.000e+00

TYPE        : Histo1D Variable Length Bins
TITLE       : Variable bin Histo1D
BIN NUMBER  : 9
BINS' ENDPTS: -und-)0.000e+00[--)1.000e+00[--)2.000e+00[--)4.000e+00[
                 --)8.000e+00[--)1.000e+01[--)1.100e+01[
                 --)2.000e+01[--)3.000e+01[--)1.000e+02[-ovr-

                           4.50e+01                        5.89e+02 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     3.618e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.945e+02|XXXXXXXXXXXXXX
 2.000e+00   2     2.565e+02|XXXXXXXXXXXXXXXXXXX
 4.000e+00   3     3.034e+02|XXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   4     1.055e+02|XXXXX
 1.000e+01   5     4.504e+01|
 1.100e+01   6     2.816e+02|XXXXXXXXXXXXXXXXXXXXXX
 2.000e+01   7     1.929e+02|XXXXXXXXXXXXX
 3.000e+01   8     5.891e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  2.330e+03 NEQUIVAL :  1.067e+04
 MEAN F.T.:  2.045e+01 MEAN B.C.:  2.230e+01 UNDERFLOW:  0.000e+00
 RMS F.T. :  2.512e+01 RMS B.C. :  2.575e+01 OVERFLOW :  0.000e+00

TYPE     : Histo2D
TITLE    : 2D Histo
X:  BINS :    40  WIDTH  : 1.500e-02  MIN    : -1.000e-01  MAX    : 5.000e-01
Y:  BINS :    30  WIDTH  : 2.000e-02  MIN    : -1.000e-01  MAX    : 5.000e-01


         0         1         2         3           
         0123456789012345678901234567890123456789  
        ******************************************
       *                                          *
   0  *  ........................................  *
   1  *  ........................................  *
   2  *  ..........................++++++2222....  *
   3  *  ................................+++234..  *
   4  *  .............................+++++++2378  *
   5  *  .............................+++++234444  *
   6  *  .........................++.++++332+....  *
   7  *  ......+................+..++222+........  *
   8  *  ......+...............++++2++...........  *
   9  *  .....++.........+..+++22+...............  *
  10  *  .....++......+..+++22+..................  *
  11  *  .....2++......+++2+.....................  *
  12  *  .....2+..+.+++22+.......................  *
  13  *  ....+2++++++22+.........................  *
  14  *  ....22+++222............................  *
  15  *  ....322232+.............................  *
  16  *  ....52242...............................  *
  17  *  ...2433.....+...........................  *
  18  *  ...454..................................  *
  19  *  ...75......+............................  *
  20  *  ...B+.....+.............................  *
  21  *  ..45++...++.............................  *
  22  *  ..62++..+++.............................  *
  23  *  ..63++.++2..............................  *
  24  *  ..53++++2+..............................  *
  25  *  ..252+++3...............................  *
  26  *  ...53223+...............................  *
  27  *  ...+6323................................  *
  28  *  ....2653................................  *
  29  *  .....3F.................................  *
       *                                          *
        ******************************************

ENTRIES  :      50000   Z MIN    :          0
TOTAL C. :   6.26e+03   Z STEP   :         10
NEQUIVAL :   3.34e+04   Z SCALE  : .+23456789ABCDE

             0 |          0 |          0
    -----------|------------|-----------
             0 |   6.26e+03 |          0
    -----------|------------|-----------
             0 |          0 |          0

TYPE     : Histo2D
TITLE    : Variable bin Histo2D
X:  BINS :     9    -und-]0.000e+00(--]1.000e+00(--]2.000e+00(--]4.000e+00(
                       --]8.000e+00(--]1.000e+01(--]1.100e+01(
                       --]2.000e+01(--]3.000e+01(--]1.000e+02(-ovr-
Y:  BINS :     9    -und-]0.000e+00(--]1.000e+00(--]2.000e+00(--]4.000e+00(
                       --]8.000e+00(--]1.000e+01(--]1.100e+01(
                       --]2.000e+01(--]3.000e+01(--]1.000e+02(-ovr-

         012345678  
        ***********
       *           *
   0  *  .........  *
   1  *  .........  *
   2  *  .........  *
   3  *  ......222  *
   4  *  ......22+  *
   5  *  ......+++  *
   6  *  ++253+FEB  *
   7  *  ..+3+.876  *
   8  *  .........  *
       *           *
        ***********

ENTRIES  :      50000   Z MIN    :          3
TOTAL C. :      5e+04   Z STEP   :        345
NEQUIVAL :      5e+04   Z SCALE  : .+23456789ABCDE

             0 |          0 |          0
    -----------|------------|-----------
      8.72e+03 |   4.07e+04 |          0
    -----------|------------|-----------
            87 |        448 |          0
</verbatim>


</subsection>
<subsection id="Histogram-operations">
<stitle>Histogram operations</stitle>

<par>To combine histograms using arithmetic operations one must satisfy
a few basic rules, which are explained below. In case one of the
conditions is violated, a run-time error will occur, the program will
abort, and display a diagnostic message on standard output.  In future
versions exceptions will be implemented to handle such run-time
errors.</par>

<subsubsection>
<stitle>Any arithmetic operations between two histograms</stitle>

<par>
The partitions used by both histograms must either be the same
physical object (see Section <ref refid="Copying-histograms"/> for
information how one partition can be shared between many histograms)
or must have the same structure (<emph>structural identity</emph>
between histograms), i.e.,
</par>
<itemize>
<item>the same number of elementary partitions;</item>
<item>corresponding elementary partitions must have the same number of bins;</item>
<item>corresponding bins in elementary partitions must be of the same size
and location.</item>
</itemize>

</subsubsection>
<subsubsection>
<stitle>Division of two histograms</stitle>

<par>
In the case of normal division of two histograms, the denominator
should contain no bins with zero contents.  For binomial division, the
denominator should have no bins which have zero error. Finally, when
dividing a histogram by a real number, it is evident that this number
should be different from zero.</par>

</subsubsection>
</subsection>

<subsection id="Copying-histograms">
<stitle>Copying histograms</stitle>

<par>It is forbidden to use the equal operator <texttt>=</texttt> or to use the
<emph>copy constructor</emph> to copy histograms. In the case of
<emph>transient</emph> objects histograms should be passed by reference,
for persistent objects by means of a <texttt>HepRef</texttt> handle. It is
possible, however, to obtain identical copies of a histogram using the
<texttt>clone</texttt> and <texttt>cloneNull</texttt> methods. The advantage of this
latter approach is that all copies of a histogram share one, physical
partition object. From this point of view all copies of a histogram
are <emph>structurally identical</emph> although they remain different physical
objects with different contents.</par>

<par>Any number of histograms can share one partition. To achieve
this:</par>

<itemize>
<item>use the <texttt>clone</texttt> (or <texttt>cloneNull</texttt>) method (see
the <texttt>Histogram</texttt> class description for more details)
<verbatim>
         HepRef(Histo1D) x = new(myDB) Histo1D(...);
         HepRef(Histo1D) y = x.clone();
</verbatim></item>
<item>explicitly reuse a partition 
    (not available for <texttt>Histo1D</texttt> and <texttt>Histo2D</texttt>)
<alltt>
  HepRef(Partition) <emph>part</emph> = new(myDB) Partition();
         ...
  HepRef(DataHistogram) x = new(myDB) DataHistogram(...,<emph>part</emph>);
  HepRef(DataHistogram) y = new(myDB) DataHistogram(...,<emph>part)</emph>;
</alltt>
</item>
</itemize>

</subsection>
<subsection>
<stitle>Example of histogram copy and operations</stitle>

<par>Let us consider the following code, which shows how we cloned
histogram <texttt>xhist</texttt> into <texttt>x2hist</texttt>, then filled the
<texttt>xhist</texttt> with a uniform random number, and <texttt>x2hist</texttt> with
two Gaussians.  We next add the two histograms together into
<texttt>x2hist</texttt> and divide each bin by the mean number in each bin in
<texttt>xhist</texttt> (2500.). We use the histogram printing facilities to
show the effect of these operations, getting at the same time the
statistics associated with each histogram.</par>

<listing>
<![CDATA[/* copyHistos.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h&gt;
#include "CLHEP/Random/Randomize.h"

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int Nbin = 10;

    HepDatabaseRef  myDb = db("MyDB"); //open the database

    HepRef(Histo1D) xhist = new(myDb) Histo1D(" Random Numbers ",40,0.0,20.0);

    HepRef(Histo1D) x2hist = xhist-&gt;clone(); // Clone histogram

/* -----Start of histogram manipulation-------------------------------- */

    // Fill histograms with random number 

    for(int i = 1;i &lt;= 100000;i++)
    {
      double x  = RandFlat::shoot(20.);       // fnum  ]0,20[
      double n1 = RandGauss::shoot(5.,1.6);   // (mean=5, stDev=1.6)
      double n2 = RandGauss::shoot(15.2,0.7); // (mean=15.2, stDev=.7)
      xhist-&gt;fill(x,1.);
      x2hist-&gt;fill(n1,1.);
      x2hist-&gt;fill(n2,0.5);
    }

    cout &lt;&lt; "Graphical Histogram Printout" &lt;&lt; endl;

    HistPrintout p(cout);

    p.print(*xhist); cout &lt;&lt; endl; p.print(*x2hist); 

    // Add x2hist to xhist, then divide by 2500 

    x2hist-&gt;add(*xhist);
    x2hist-&gt;div(2500.);      

    cout &lt;&lt; endl 
         &lt;&lt; "Graphical Histogram Printout of xhist2 after operations"
         &lt;&lt; endl;

    p.print(*x2hist); 

/*  -----End of histogram manipulation--------------------------------- */

    commit();     // commit transaction
    return 0;
  }
};  // end of class definition

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}]]>
</listing>
<index item="histo1d@@{\texttt{Histo1D}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histo1d@@{\texttt{Histo1D}}"/>
<index item="fill@@{\texttt{fill}} method (HistOOgram)"/>
<index item="HistOOgram!methods!fill@@{\texttt{fill}}"/>
<index item="clone@@{\texttt{clone}} method (HistOOgram)"/>
<index item="HistOOgram!methods!clone@@{\texttt{clone}}"/>
<index item="add@@{\texttt{add}} method (HistOOgram)"/>
<index item="HistOOgram!methods!add@@{\texttt{add}}"/>
<index item="div@@{\texttt{div}} method (HistOOgram)"/>
<index item="HistOOgram!methods!div@@{\texttt{div}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>
<index item="randflat@@{\texttt{RandFlat}} method (CLHEP)"/>
<index item="CLHEP!methods!randflat@@{\texttt{RandFlat}}"/>
<index item="randgauss@@{\texttt{RandGauss}} method (CLHEP)"/>
<index item="CLHEP!methods!randgauss@@{\texttt{RandGauss}}"/>

<par>Note that we had to include a reference to the CLHEP classes via the
include file <texttt>CLHEP/Random/Randomize.h</texttt>, and that we also have
to include the path of the CLHEP directory where these include files
are kept, as well, when building the executable, we have to specify
where the CLHEP libraries are. In this example we use the
<texttt>shoot</texttt> methods of two of the random number generators of
CLHEP, namely <texttt>RandFlat</texttt> (uniform distribution), and
<texttt>RandGauss</texttt> (Gaussian distribution). The output generated 
by the code shown is below.</par>

<verbatim>

Graphical Histogram Printout
TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN NUMBER : 40
BIN WIDTH  : 0.5

                           2.33e+03                        2.59e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.511e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e-01   1     2.491e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   2     2.434e+03|XXXXXXXXXXXXXXXXXXXXX
 1.500e+00   3     2.537e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   4     2.510e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.500e+00   5     2.485e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   6     2.448e+03|XXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     2.547e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     2.542e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     2.565e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    2.532e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    2.328e+03|
 6.000e+00   12    2.543e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    2.534e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    2.529e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.500e+00   15    2.535e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   16    2.508e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.500e+00   17    2.504e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.000e+00   18    2.473e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.500e+00   19    2.457e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+01   20    2.585e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.050e+01   21    2.524e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.100e+01   22    2.473e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.150e+01   23    2.490e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.200e+01   24    2.425e+03|XXXXXXXXXXXXXXXXXXX
 1.250e+01   25    2.500e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.300e+01   26    2.576e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.350e+01   27    2.448e+03|XXXXXXXXXXXXXXXXXXXXXXX
 1.400e+01   28    2.483e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    2.581e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    2.447e+03|XXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    2.555e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    2.585e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.650e+01   33    2.431e+03|XXXXXXXXXXXXXXXXXXXX
 1.700e+01   34    2.480e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.750e+01   35    2.549e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   36    2.429e+03|XXXXXXXXXXXXXXXXXXXX
 1.850e+01   37    2.494e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   38    2.541e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.950e+01   39    2.391e+03|XXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :     100000 TOTAL C. :  1.000e+05 NEQUIVAL :  1.000e+05
 MEAN F.T.:  9.991e+00 MEAN B.C.:  9.991e+00 UNDERFLOW:  0.000e+00
 RMS F.T. :  5.766e+00 RMS B.C. :  5.764e+00 OVERFLOW :  0.000e+00

TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN NUMBER : 40
BIN WIDTH  : 5.000e-01

                           0.00e+00                        1.40e+04 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     1.330e+02|
 5.000e-01   1     3.590e+02|X
 1.000e+00   2     8.710e+02|XXX
 1.500e+00   3     1.676e+03|XXXXXX
 2.000e+00   4     2.812e+03|XXXXXXXXXX
 2.500e+00   5     4.732e+03|XXXXXXXXXXXXXXXXX
 3.000e+00   6     6.835e+03|XXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     9.271e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     1.117e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     1.214e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    1.237e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    1.106e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   12    9.104e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    6.935e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    4.599e+03|XXXXXXXXXXXXXXXX
 7.500e+00   15    2.897e+03|XXXXXXXXXX
 8.000e+00   16    1.532e+03|XXXXX
 8.500e+00   17    8.560e+02|XXX
 9.000e+00   18    3.230e+02|X
 9.500e+00   19    1.440e+02|
 1.000e+01   20    5.700e+01|
 1.050e+01   21    2.000e+01|
 1.100e+01   22    5.000e+00|
 1.150e+01   23    2.000e+00|
 1.200e+01   24    1.500e+00|
 1.250e+01   25    4.650e+01|
 1.300e+01   26    3.340e+02|X
 1.350e+01   27    1.751e+03|XXXXXX
 1.400e+01   28    5.794e+03|XXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    1.140e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    1.403e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    1.039e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    4.743e+03|XXXXXXXXXXXXXXXXX
 1.650e+01   33    1.270e+03|XXXX
 1.700e+01   34    2.105e+02|
 1.750e+01   35    2.300e+01|
 1.800e+01   36    2.000e+00|
 1.850e+01   37    0.000e+00|
 1.900e+01   38    0.000e+00|
 1.950e+01   39    0.000e+00|
                          X |
                            V
 ENTRIES  :     200000 TOTAL C. :  1.500e+05 NEQUIVAL :  1.800e+05
 MEAN F.T.:  8.394e+00 MEAN B.C.:  8.394e+00 UNDERFLOW:  9.100e+01
 RMS F.T. :  5.001e+00 RMS B.C. :  4.998e+00 OVERFLOW :  0.000e+00

Graphical Histogram Printout of xhist2 after operations
TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN NUMBER : 40
BIN WIDTH  : 5.000e-01

                           9.56e-01                        6.59e+00 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     1.058e+00|
 5.000e-01   1     1.140e+00|X
 1.000e+00   2     1.322e+00|XXX
 1.500e+00   3     1.685e+00|XXXXXX
 2.000e+00   4     2.129e+00|XXXXXXXXXX
 2.500e+00   5     2.887e+00|XXXXXXXXXXXXXXXXX
 3.000e+00   6     3.713e+00|XXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     4.727e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     5.486e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     5.882e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    5.960e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    5.357e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   12    4.659e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    3.788e+00|XXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    2.851e+00|XXXXXXXXXXXXXXXXX
 7.500e+00   15    2.173e+00|XXXXXXXXXXX
 8.000e+00   16    1.616e+00|XXXXX
 8.500e+00   17    1.344e+00|XXX
 9.000e+00   18    1.118e+00|X
 9.500e+00   19    1.040e+00|
 1.000e+01   20    1.057e+00|
 1.050e+01   21    1.018e+00|
 1.100e+01   22    9.912e-01|
 1.150e+01   23    9.968e-01|
 1.200e+01   24    9.706e-01|
 1.250e+01   25    1.019e+00|
 1.300e+01   26    1.164e+00|X
 1.350e+01   27    1.680e+00|XXXXXX
 1.400e+01   28    3.311e+00|XXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    5.593e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    6.590e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    5.179e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    2.931e+00|XXXXXXXXXXXXXXXXX
 1.650e+01   33    1.480e+00|XXXX
 1.700e+01   34    1.076e+00|X
 1.750e+01   35    1.029e+00|
 1.800e+01   36    9.724e-01|
 1.850e+01   37    9.976e-01|
 1.900e+01   38    1.016e+00|
 1.950e+01   39    9.564e-01|
                          X |
                            V
 ENTRIES  :     200000 TOTAL C. :  1.500e+05 NEQUIVAL :  1.800e+05
 MEAN F.T.:  8.394e+00 MEAN B.C.:  6.022e-03 UNDERFLOW:  3.640e-02
 RMS F.T. :  5.001e+00 RMS B.C. :  2.713e-01 OVERFLOW :  0.000e+00
</verbatim>

</subsection>
<subsection id="Stream-IO">
<stitle>Stream input/output</stitle>

<par>In parallel to persistent storage provided with &OBJ;,
there is the possibility to use C++ based Standard Stream IO for
histograms. In particular, this feature lets you save histograms to a
file and retrieve them back. There exist two specialised
<emph>stream</emph> classes: <emph>HistInputStream</emph> and
<index item="histinputstream@@{\texttt{HistInputStream}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histinputstream@@{\texttt{HistInputStream}}"/>
<emph>HistOutputStream</emph>.
<index item="histoutputstream@@{\texttt{HistOutputStream}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histoutputstream@@{\texttt{HistOutputStream}}"/>
Let us look how to use them.</par>

<par>
After getting an database handle <texttt>myDB</texttt> in the usual way, let
us assume that we have created two histograms which are referenced by
handles <texttt>hist1</texttt> and <texttt>hist2</texttt>. We decide to save them in
the file <texttt>simple_test.txt</texttt>.
</par>

<verbatim>
  HepRef(Histogram) hist1 = new(myDB) Histo1D("test",10,0.0,20.0);
  HepRef(Histo1D) hist2 = new(myDB) Histo1D("test",20,-10.0,10.0);
</verbatim>

<par>
First, we have to create an <texttt>HistOutputStream</texttt>
<index item="histoutputstream@@{\texttt{HistOutputStream}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histoutputstream@@{\texttt{HistOutputStream}}"/>
object, which is to open our file <texttt>simple_test.txt</texttt> in output
mode, so that we can save the histograms using the class instance
<texttt>hos</texttt> in the code below.  Note that by enclosing everything
inside a compound statement, which is exited by the closing brace, the
output file is automatically closed (since <texttt>hos</texttt> is going out
of scope).
</par>

<verbatim>
 {
     HistOutputStream hos("simple_test.txt");

   /* We save histograms in 'hos' */

     if( !hos.write(*hist1) ) error();
     if( !hos.write(*hist2) ) error();
 }
</verbatim>

<par>
Next, when we want to retrieve histograms from the file
<texttt>simple_test.txt</texttt>, we should first create an <texttt>HistInputStream</texttt>
<index item="histinputstream@@{\texttt{HistInputStream}} class (HistOOgram)"/>
<index item="HistOOgram!classes!histinputstream@@{\texttt{HistInputStream}}"/>
object. This opens the file <texttt>simple_test.txt</texttt> in input mode.
The histograms will be written into &OBJ;'s persistent storage
using the database whose handle was obtained before.
</par>

<verbatim>
 {
    HistInputStream his("simple_test.txt");

    HepRef(Histogram) hist3 = his.read_new();
    HepRef(Histogram) hist4 = his.read_new();

    if( !hist3 || !hist4 ) error();
 }
</verbatim>

<!--
<par>In the previous examples Histogram Stream objects are creating and
destroy file streams (ifstream,ofstream) automatically. However, in 
some cases we may want to use already existing streams, which in general 
do not need to be file streams. Let us look at an example:</par>

<verbatim>
  fstream *my_sp = new fstream("simple_test.txt",ios::in|ios::out);

  HistInputStream his(*my_sp,myDB);
  HistOutputStream hos(*my_sp,myDB);

  /* now both Histogram Streams use the same C++ stream for input/output

     ...

  /* you can use any kind of stream, even 'cout' */

  ostrstream my_memory_stream(buffer);
  HistOutputStream hos2(my_memory_stream);

  HistOutputStream hos3(cout);

  delete my_sp;
</verbatim>

<par>The last line above is needed since it is our responsibility to 
destroy streams we created. Therefore, in this case we must explicitly
delete <texttt>my_sp</texttt>, because it is a dynamic object, 
while we need to do nothing for <texttt>my_memory_stream</texttt>, which
is an automatic object and will thus be deleted automatically.
Similarly, <texttt>cout</texttt> is a global object and
is automatically deleted when the program terminates.</par>
-->

<par>
We now are ready to look at a complete example. To simplify the code
we will either read 1D histograms from an &OBJ; database (the
generalisation to other histogram kinds is trivial) and save in a text
file, or alternatively, read all histograms stored in a text file
and save them into an &OBJ; database.
</par>

<listing>
<![CDATA[/* ioHistos.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;fstream.h&gt;
#include &lt;iostream.h&gt;
#include &lt;ctype.h&gt;

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    char opt;

    cout &lt;&lt; endl &lt;&lt; "db to file (D) or File -&gt; db (F)?" &lt;&lt; " &gt; ";
    cin  &gt;&gt; opt;
    if (opt!='D'&amp;&amp;opt!='F') return 0;

    char dbname[255];

    cout &lt;&lt; endl &lt;&lt; "Please type database name "        &lt;&lt; " &gt; ";
    cin  &gt;&gt; dbname;

    HepDatabaseRef  myDb = db(dbname); //create or open db "HistoDB"
    HistInputStream::oo_clustering_dir = myDb;

    char fname[255];

    cout &lt;&lt; endl &lt;&lt; "Please type filename "             &lt;&lt; " &gt; ";
    cin  &gt;&gt; fname;

    cout &lt;&lt; endl &lt;&lt; "Federated DB boot: " &lt;&lt; getenv("OO_FD_BOOT");
    cout &lt;&lt; endl &lt;&lt; "Database name    : " &lt;&lt; dbname;
    cout &lt;&lt; endl &lt;&lt; "Filename         : " &lt;&lt; fname;
    cout &lt;&lt; endl;

    HistPrintout printfile(cout);

    switch(opt)
    {
      case 'D' : // save histograms from database to file
      {
        HistOutputStream hos(fname);
        ooItr(Histo1D) histI;    // declare iterator over 1D histograms
        
        if( histI.scan(myDb) != oocSuccess ) cerr &lt;&lt; "Iterator::scan failed";
          else
            while(histI.next())  // iterate over 1D histograms in db
            {
              HepRef(Histo1D) hist = histI;
              printfile.print(*hist);
              if(hos.write(*hist))
              { 
   	      cout &lt;&lt; endl &lt;&lt; "Success - histogram " &lt;&lt; hist-&gt;get_name() 
                           &lt;&lt; " written on file "    &lt;&lt; endl;
              }
            else	  
                cout &lt;&lt; "Saving Error!";
            }                    // end of while, end of if
        break;                   // break out of case 
      }                          // end fo case 'D'
      case 'F' :                 // save histograms from file to database
      { 
        HistInputStream  his(fname);
        HepRef(Histogram) hist;
        while (1)                // loop "forever"
        {
          hist = his.read_new();  
          cout &lt;&lt; endl;
          if(hist == 0) break;       // no more histograms or read error on file
            else
            {
              cout &lt;&lt; "Success - histogram " &lt;&lt; hist-&gt;get_name() 
                   &lt;&lt; " read from file "     &lt;&lt; endl &lt;&lt; endl;
              printfile.print(*hist);
            }                    // end of if 
        }                        // end of while
        break;                   // break out of case 
      }                          // end of case 'F'
    }                            // end fo switch
/*  -----End of histogram manipulation--------------------------------- */
    
    commit();                    // commit this transaction
    return 0;
  }
  
};  // end of class definition

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call its run method
}]]>
</listing>
<par>
The above program has two modes of operation, namely <texttt>D</texttt> to
save all one-dimensional histograms read in an &OBJ; database into a
text file, and <texttt>F</texttt> to do the reverse, namely, read all
histograms saved in a text file and save commit them to an &OBJ;
database. The user is first asked to choose the mode, and is then
invited to provide the names of the database and the text file.
</par>

<par>Below we show the first step, where we save all
one-dimensional histograms from the database <texttt>HistoDB</texttt> to the
text file <texttt>histo1d.txt</texttt>. We in fact used the single histogram
saved in the
example in Section <vref refid="HIST1DEXA"/>.
We print the histogram to compare it with the one we will read back
afterwards from the text file.</par>
<alltt>
db to file (D) or File -> db (F)?
 > <emph>D</emph>
Please type database name 
 > <emph>HistoDB</emph>
Please type filename 
 > <emph>histo1d.txt</emph>

Federated DB boot: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Database name    : HistoDB
Filename         : histo1d.txt
TYPE       : Histo1D
TITLE      : Test_Histo1D
BIN NUMBER : 20
BIN WIDTH  : 1
                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  2.162e+06 NEQUIVAL :  2.961e+04
 MEAN F.T.:  9.498e+00 MEAN B.C.:  7.618e+00 UNDERFLOW:  2.574e+05
 RMS F.T. :  8.368e+00 RMS B.C. :  6.936e+00 OVERFLOW :  2.573e+05

Success - histogram Test_Histo1D written on file 
</alltt>

<par>
Now that we saved the 1D histogram on the text file
<texttt>histo1d.txt</texttt> we want to read it back and save it
into another database <texttt>MyDB</texttt>. We therefore rerun the
same program, specifying this time the <texttt>F</texttt> option. 
</par>

<alltt>
db to file (D) or File -> db (F)?
 > <emph>F</emph>
Please type database name 
 > <emph>MyDB</emph>
Please type filename 
 > <emph>histo1d.txt</emph>

Federated DB boot: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Database name    : HistoDB
Filename         : histo1d.txt

Success - histogram Test_Histo1D read from file 
TYPE       : Histo1D
TITLE      : Test_Histo1D
BIN NUMBER : 20
BIN WIDTH  : 1
                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  2.162e+06 NEQUIVAL :  2.961e+04
 MEAN F.T.:  9.498e+00 MEAN B.C.:  7.618e+00 UNDERFLOW:  2.574e+05
 RMS F.T. :  8.368e+00 RMS B.C. :  6.936e+00 OVERFLOW :  2.573e+05
</alltt>

<par>
From the printout of the histogram we see that we retrieved the
histogram from the text file without problems.
</par>

</subsection>
<subsection>
<stitle>Reading back and deleting histograms from an &OBJ;</stitle>

<par>
Histograms produced in a C++ program are automatically stored in the
current federated database and the programmer can specify exactly in
which database or container the object will be created. If the user
knows where the histograms were created, reading them back is pretty
simple by taking advantage of &OBJ;'s scan methods. The purpose of the
scan method is to iterate over all objects of a given class in a
well-defined scope. The scope defines the extent of the search. It can
include the whole federated database, a particular database, or a
specific container (of course larger scopes imply a longer search).
</par>
<par>The <texttt>readHistogram</texttt> example below shows you how to retrieve
a specific histogram by specifying its title and the name of the
container where it is stored. The program consists of three parts. Its
first part creates three histograms with different titles in the same
container and fills them with a different contents. The second part
opens a new transaction, scans the container for all histograms of the
given type, and compares the histogram title to select only the second
histogram, which is finally printed on the output stream. The third
part removes the objects created in part one from the database. It
shows how the scan method can be used to remove objects of a given
class from the chosen scope.
</par>

<par>
It is important to realize that histograms are written, read back, and
deleted in separate transactions. This means that the three parts of
the code shown can be run as independent programs.
</par>

<subsubsection>
<stitle>Example code</stitle>
<listing>
<![CDATA[#include "histograms.h"
#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;
#include "HepODBMS/clustering/HepDbApplication.h"

class readHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
private :
  HepDatabaseRef  histoDb;
  HepContainerRef histoCont;
protected:
  void create() {
    const int noOfBins=20;
    histoDb = db("HistoDB"); //create or reuse a db 
    histoCont = container("HistoCont"); //create or reuse a container
    // Create three histograms with different names
    cout &lt;&lt; "Create histogram no. 1" &lt;&lt; endl;
    HepRef(Histo1D) h1 = new(histoCont) Histo1D("Histo 1",noOfBins,0.0,20.0);
    cout &lt;&lt; "Create histogram no. 2" &lt;&lt; endl;
    HepRef(Histo1D) h2 = new(histoCont) Histo1D("Histo 2",noOfBins,0.0,20.0);
    cout &lt;&lt; "Create histogram no. 3" &lt;&lt; endl;
    HepRef(Histo1D) h3 = new(histoCont) Histo1D("Histo 3",noOfBins,0.0,20.0);
    // Histos are filled with different weights
    for( int i = 0; i &lt; 50000; i++) {   
      double x = (i % 22) - 1;          
      h1-&gt;fill(x,(x-9.5)*(x-9.5)+3);
      h2-&gt;fill(x,(x-9.5)*(x-9.5)+30);
      h3-&gt;fill(x,(x-9.5)*(x-9.5)+300);      
    }
  }

  // Read back an histogram from the database
  void read() {
    // Declare an iterator over 1D histograms
    ooItr(Histo1D)  histo1D_itr;
    // Retrieve by name the Database &amp; the Container
    histoDb = db("HistoDB"); 
    histoCont = container("HistoCont"); 
    // Apply the iterator over our container
    histo1D_itr.scan(histoCont);
    for(int i = 1;histo1D_itr.next();i++){ 
      // Just look for histogram no. 2
      if (strcmp(histo1D_itr-&gt;get_name(),"Histo 2") == 0) {
	// Print it
	cout &lt;&lt; histo1D_itr-&gt;get_name() &lt;&lt; " found!" &lt;&lt; endl &lt;&lt; endl;
	HistPrintout p(cout);
	p.print(*histo1D_itr);    
	cout &lt;&lt; endl;
      }
    }
  }

  void cleanup() {
    // Declare an iterator over 1D histograms
    ooItr(Histo1D)  histo1D_itr;
    // Retrieve by name the Database &amp; the Container
    histoDb = db("HistoDB"); 
    histoCont = container("HistoCont"); 
    // Apply the iterator over our container
    histo1D_itr.scan(histoCont);
    for(int i = 1;histo1D_itr.next();i++){ 
      HepRef(Histo1D) h;
      histo1D_itr-&gt;ooThis( h );
      cout &lt;&lt; "Delete histogram no. " &lt;&lt; i &lt;&lt; endl;
      ooDelete( h );
    }
  }]]>
</listing>

<par>Transaction management and histogram creation have already been
explained in previous sections, so the interesting part of the code
corresponds to the <texttt>read</texttt> and <texttt>cleanup</texttt> methods. Both
methods declare an iterator over objects of type <texttt>Histo1D</texttt>,
locate the container, and apply the iterator over the container.
</par>

<verbatim>
    // Declare an iterator over 1D histograms
    ooItr(Histo1D)  histo1D_itr;
    // Retrieve by name the Database &amp; the Container
    histoDb = db("HistoDB"); 
    histoCont = container("HistoCont"); 
    // Apply the iterator over our container
    histo1D_itr.scan(histoCont);
    for(int i = 1;histo1D_itr.next();i++){ 
    ... 
    }
</verbatim>
<par>An iterator over 2D histograms is declared as follows.</par>
<verbatim>
    // Declare an iterator over 2D histograms
    ooItr(Histo2D) histo2D_itr;
</verbatim>
<par>An iterator over a whole database rather than over single
 container should use the database handle.</par>
<verbatim>
     // Apply the iterator over our Database
     histo1D_itr.scan(histoDb);
</verbatim>
<par>The output of running the program is shown below.</par>
<listing>
Create histogram no. 1
Create histogram no. 2
Create histogram no. 3
Histo 2 found!

TYPE       : Histo1D
TITLE      : Histo 2
BIN NUMBER : 20
BIN WIDTH  : 1

                           6.88e+04                        2.73e+05 Y
X POSITION   BIN       VALUE|---------------------------------------------------&gt;
 0.000e+00   0     2.733e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     2.324e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.960e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.642e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     1.369e+05|XXXXXXXXXXXXXXXXX
 5.000e+00   5     1.142e+05|XXXXXXXXXXX
 6.000e+00   6     9.603e+04|XXXXXX
 7.000e+00   7     8.240e+04|XXX
 8.000e+00   8     7.330e+04|X
 9.000e+00   9     6.876e+04|
 1.000e+01   10    6.876e+04|
 1.100e+01   11    7.330e+04|X
 1.200e+01   12    8.240e+04|XXX
 1.300e+01   13    9.603e+04|XXXXXX
 1.400e+01   14    1.142e+05|XXXXXXXXXXX
 1.500e+01   15    1.369e+05|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.642e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.960e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    2.323e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.732e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
 ENTRIES  :      50000 TOTAL C. :  2.875e+06 NEQUIVAL :  3.728e+04
 MEAN F.T.:  9.499e+00 MEAN B.C.:  9.999e+00 UNDERFLOW:  3.188e+05
 RMS F.T. :  6.865e+00 RMS B.C. :  6.865e+00 OVERFLOW :  3.186e+05

Delete histogram no. 1
Delete histogram no. 2
Delete histogram no. 3
</listing>

</subsubsection>
</subsection>
</section>

<section>
<stitle>Converting an HBOOK file into an &OBJ; database</stitle>
<index item="HBOOK"/>
d2020 3
a2022 3
converts histograms contained in an HBOOK file into persistent
<emph>HistOOgrams</emph> that can be saved in an &OBJ; database. Only one-
and two-dimensional histograms are converted, Ntuples are ignored. To
d2058 1
a2058 1
<caption>Transforming HBOOK histograms into HistOO histograms</caption>
d2084 3
a2086 378
<verbatim>
# GNUmakefile for createTag example
# Dirk Duellmann

HEP_ODBMS_DIR=/afs/cern.ch/sw/lhcxx/specific/@@sys/HepODBMS/development
include $(HEP_ODBMS_DIR)/etc/HepODBMS.mk

APPL       = createTag
SRCS       = $(APPL).cpp 
OBJS	   = $(OS)/$(APPL).o

all : $(APPL)

$(APPL): GNUmakefile
	$(C++) $(C_FLAGS) -o $(APPL) $(OBJS) $(HEP_ODBMS_LIBS) $(OBJY_LIBS) $(RWTOOL_LIBS)
</verbatim>

</subsection>
<subsection>
<stitle>Writing tags</stitle>

<par>As explained earlier (see Section <ref refid="SNEWDATAMODEL"/>),
tags are a small collection of the most important physics attributes
of an event plus an association with the event in question.  Tags
<index item="Event association"/>
provide a natural and efficient syntax for handling event data,
speeding up queries, cuts handling, etc., substantially, while at the
same time offering the possibility to easily access the original full
data. Usually, the event tags are chosen in such a way that a high
degree of selectivity can be obtained by first cutting on attributes
in the event tag, while, if needed, the association to the full event
<index item="Event association"/>
can be exploited in order to retrieve any other information not
contained in the tag.</par>

<par>In workgroup-wide data sets, individual physicists should still be
able to have their own simpler data collection, so an easy-to-use
<emph>Generic Tag</emph> is defined as well.  Presently, both the Event Tag 
<index item="Tag!generic"/>
and the Generic Tag have to be created inside a C++ program before using
the Interactive Analysis framework.</par>




<par>
The data types that can be stored in a tag are <texttt>long</texttt> and
<texttt>short</texttt> integers, <texttt>float</texttt> and <texttt>double</texttt> real
numbers, and an 8-bit <texttt>char</texttt>. These types are recognised by the
<emph>HepExplorableBrowser</emph> module
<index item="HepExplorableBrowser@@{\emph{HepExplorableBrowser} module}"/>
<index item="HEPExplorer!modules!HepExplorableBrowser@@{\emph{HepExplorableBrowser}}"/>
(see Figure <ref refid="HEPEXPBROWSER"/>)
which lets you browse and select explorable collections and their tags.
<index item="Explorable collection"/>
</par>

<listing>
<![CDATA[/* createTag.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepExplorableGenericTags.h"
#include "HepODBMS/tagdb/HepExplorableAttribute.h"
#include &lt;math.h>

class createTagsApp : public HepTagDbApplication {
  // inherits session control from HepTagDbApplication
public:
  // this application implements just one method: 
  int run()
  {
    const long   maxEvents = 1000;
    
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    HepExplorableGenericTags genTag; // create a tag collection

    if (!genTag.createDescription("generator tag")) // start creating a new field description
      fatal("could not create new generator tag");  // print the message and stop the application

    // define fields all fields that belong to genTag
    HepExplorableAttribute&lt;long>  eventNo (genTag,"event_number");    
    
    /* particle 1*/
    HepExplorableAttribute&lt;float> et1 (genTag,"Et_part1");    
    HepExplorableAttribute&lt;float> phi1(genTag,"phi_part1");
    HepExplorableAttribute&lt;short> pid1(genTag,"pdg_part1");    
    
    /* particle 2*/
    HepExplorableAttribute&lt;float> et2 (genTag,"Et_part2");
    HepExplorableAttribute&lt;float> phi2(genTag,"phi_part2");
    HepExplorableAttribute&lt;short> pid2(genTag,"pdg_part2");        

    cout << endl;
    // Fill 1000 tags
    for (short i=0; i&lt;maxEvents; i++)
    {
      genTag.newTag();      // create a new tag (all fields have default values)

      if (! (i % 100))      cout << "\revent " << i << flush;
      
      eventNo = i;          // set the event number field
      et1 = i * 5.0;        // calculate some quantity
      et2 = sqrt(et1);      // re-use one field to define another

      phi1 =  (i * 2 * M_PI) / maxEvents; // invent some phi value
      phi2 = -phi1;                // balance the directions

      pid1 = (short) 22;           // both particles are photons 
      pid2 = (short) 22;
    }
    cout << "\r" << eventNo+1 << " events written." << endl;
    // commit this transaction
    commit();
    return 0;
  }
  
};

int main()
{
  createTagsApp myApp;  // create an application object
  return myApp.run();   // run it
}]]>
</listing>
<index item="Tag!generic"/>
<index item="newtag@@{\texttt{newtag}} method (Generic tag)"/>
<index item="Tag!generic!newtag@@{\texttt{newtag}} method"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startupdate@@{\texttt{startUpdate}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startupdate@@{\texttt{startUpdate}}"/>

<par>When you compile and run this program then you will see the
following output on your screen.
</par>
<verbatim>
> createTag 
created new ContainerGroup for class "EventTags" ClusteringHint
created new ContainerGroup for class "PersistentEventCollections" ClusteringHint
created new ContainerGroup for class "Events" ClusteringHint
created new ContainerGroup for class "generator tag" ClusteringHint

1000 events written.
</verbatim>
<par>
First the <texttt>EventTags</texttt>,
<texttt>PersistentEventCollections</texttt>, <texttt>Events</texttt>,
and <texttt>generator tag</texttt> are entered as container groups
into the &OBJ; database. Then a Generic tag is created, consisting of
seven components, namely the <texttt>event_number</texttt> (integer of
type <texttt>long</texttt>), and two <emph>particles</emph>,
characterised each by their transverse energy and phi angle (two reals
of type <texttt>float</texttt>, <texttt>Et_part1/2</texttt> and
<texttt>phi_part1/2</texttt>), and an identifier (a
<texttt>short</texttt> integer <texttt>pdg_part1/2</texttt>).
</par>

<par>
Before reading back the tags in the next example program, we can
have a look into the database with the <texttt>ootoolmgr</texttt> program (see
Figure <ref refid="OOTOOLMGRTAG"/>).
</par>
<figure id="OOTOOLMGRTAG">
<includegraphics width=".8\linewidth" file="ootoolmgrtag"/>
<caption>Using the program <texttt>ootoolmgr</texttt> to view tags in a
         database</caption>
<index item="ootoolmgr@@{\ttfamily ootoolmgr}"/>
</figure>
<par>We look in the <texttt>Events</texttt> database, inside the <texttt>generator
tag</texttt> container and go to the last stored <emph>Basic Object</emph>.
Then in the bottom window we can see the contents of the seven tag
components, in particular we find the only <texttt>int32</texttt> component
(<texttt>event_number</texttt>) has indeed a value of 999. The two
<texttt>int16</texttt> components (<texttt>pdg_part1/2</texttt>) are both 22, while
the four <texttt>float32</texttt> components have the values
<texttt>Et_part1=4995</texttt>, <texttt>phi_part1=6.2769</texttt>, 
<texttt>Et_part2=70.6753</texttt> and <texttt>phi_part2=-6.2769</texttt>. This
general-purpose &OBJ; tool does not show the names of the variables
(for this a HEPExplorer module should be used), but one can still
understand in this simple case the contents of the object in the
database and the C++ code used to generate it.
</par>
<par>
The same three databases <texttt>System</texttt>, <texttt>Tag</texttt>, and
<texttt>Events</texttt> can also be seen with the <texttt>oodumpcatalog</texttt> tool.
<index item="oodumpcatalog@@{\ttfamily oodumpcatalog}"/>
<index item="&OBJ;"/>
</par>
<verbatim>
> oodumpcatalog

Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.

FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16

DB Name   = System
DB ID     = 17
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/System.HEPEXP.DB

DB Name   = Tag
DB ID     = 20
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/Tag.HEPEXP.DB

DB Name   = Events
DB ID     = 21
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/Events.HEPEXP.DB
</verbatim>

</subsection>
<subsection>
<stitle>Reading tags</stitle>

<par>Once we have written the tag, let us show how to read and use
it. Therefore let us look at the following example.</par>

<listing>
<![CDATA[/* readTag.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepExplorable.h"
#include "HepODBMS/tagdb/HepExplorableAttribute.h"
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"

class readTagsApp : public HepTagDbApplication {
  // inherits session control from HepTagDbApplication
public:
  // this application implements just one method: 
  int run()
  {
    Init();        // initialise the db session
    startRead();   // start a read transaction

    HepExplorable *genTag =
      HepExplorable::findExplorable("generator tag"); // find a tag by name

    if (!genTag)
      fatal("could not find generator tag!"); // use fatalmethod defined on HepDbApplication
        
    // define fields all fields that belong to genTag
    HepExplorableAttribute&lt;long>  eventNo (genTag,"event_number");    
    
    /* particle 1*/
    HepExplorableAttribute&lt;float> et1 (genTag,"Et_part1");    
    HepExplorableAttribute&lt;float> phi1(genTag,"phi_part1");
    HepExplorableAttribute&lt;short> pid1(genTag,"pdg_part1");    
    
    /* particle 2*/
    HepExplorableAttribute&lt;float> et2 (genTag,"Et_part2");
    HepExplorableAttribute&lt;float> phi2(genTag,"phi_part2");
    HepExplorableAttribute&lt;short> pid2(genTag,"pdg_part2");        

    HepDatabaseRef  histoDb = db("HistoDB"); // go to DB HistoDB
    HepRef(Histo1D) xhist = new(histoDb) Histo1D(" Et1 and Et2 ",8,0.0,80.0);

    // print a few tag values and histogram Et1 and Et2
    for (int rc=genTag->start(); rc != 0; rc = genTag->next())
    {
          xhist->fill(et1,1.);
          xhist->fill(et2,1.);
	  if ((eventNo<2)||(eventNo>997)) //print first and last two events
          { cout << "Event No. " << eventNo << endl
                 << "Particle 1: Et=" << et1 << " phi=" << phi1 
                                      << " pgd code= " << pid1 << endl
                 << "Particle 2: Et=" << et2 << " phi=" << phi2 
                                      << " pgd code= " << pid2 << endl;
	  }
    }
    HistPrintout p(cout);
    p.print(*xhist);

    commit();        // commit this transaction
    return 0;
  }
  
};

int main()
{
  readTagsApp myApp;   // create an application object
  return myApp.run(); // run it
}]]>
</listing>
<index item="Tag!generic"/>
<index item="fill@@{\texttt{fill}} method (HistOOgram)"/>
<index item="HistOOgram!methods!fill@@{\texttt{fill}}"/>
<index item="print@@{\texttt{print}} method (HistOOgram)"/>
<index item="HistOOgram!methods!print@@{\texttt{print}}"/>
<index item="commit@@{\texttt{commit}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!commit@@{\texttt{commit}}"/>
<index item="init@@{\texttt{Init}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!init@@{\texttt{Init}}"/>
<index item="startread@@{\texttt{startRead}} method (HEPODBMS)"/>
<index item="HEPODBMS!methods!startread@@{\texttt{startRead}}"/>

<par>We recognise the same attribute definitions for the tag elements,
as in the <texttt>createTag</texttt> program, which allows us to use them in
our code in a convenient way. We then attach the <texttt>HistoDB</texttt>
database and declare an histogram, which we shall use via its
reference <texttt>xhist</texttt>. Before then loop over the generic tag
events, using the <texttt>next</texttt> method of the generic tag class until
the return code <texttt>rc</texttt> is different from zero. We print out the
parameters of the first and last two events, and enter the <texttt>Et1</texttt>
and <texttt>Et2</texttt> values of all events into the <texttt>xhist</texttt>
histogram. After exiting the loop, the output file for the histogram
is initialised to <texttt>cout</texttt>, and the histogram <texttt>xhist</texttt>
is printed on that output stream.</par>

<par>
The output generated by the <texttt>readTAG</texttt> program first
shows the parameters of the events o, 1, 998, and 999 (the latter can
be compared in detail with Figure <ref refid="OOTOOLMGRTAG"/>, showing
the dump of that event in the database).  Then the histogram of
<texttt>Et1</texttt> and <texttt>Et2</texttt> is printed, and, as
expected, almost half of the contents are in the overflow bin, since
the value of <texttt>Et1</texttt> was five times the event number (see
the code of <texttt>createTag</texttt>.
</par>
<verbatim>
Event No. 0
Particle 1: Et=0 phi=0 pgd code= 22
Particle 2: Et=0 phi=0 pgd code= 22
Event No. 1
Particle 1: Et=5 phi=0.00628319 pgd code= 22
Particle 2: Et=2.23607 phi=-0.00628319 pgd code= 22
Event No. 998
Particle 1: Et=4990 phi=6.27062 pgd code= 22
Particle 2: Et=70.6399 phi=-6.27062 pgd code= 22
Event No. 999
Particle 1: Et=4995 phi=6.2769 pgd code= 22
Particle 2: Et=70.6753 phi=-6.2769 pgd code= 22
TYPE       : Histo1D
TITLE      :  Et1 and Et2 
BIN NUMBER : 8
BIN WIDTH  : 10

                           2.20e+01                        2.62e+02 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.200e+01|
 1.000e+01   1     6.200e+01|XXXXXXXX
 2.000e+01   2     1.020e+02|XXXXXXXXXXXXXXXXX
 3.000e+01   3     1.420e+02|XXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+01   4     1.820e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+01   5     2.220e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+01   6     2.620e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+01   7     2.200e+01|
                          X |
                            V
 ENTRIES  :       2000 TOTAL C. :  2.000e+03 NEQUIVAL :  2.000e+03
 MEAN F.T.:  1.272e+03 MEAN B.C.:  2.382e+01 UNDERFLOW:  0.000e+00
 RMS F.T. :  1.595e+03 RMS B.C. :  2.037e+01 OVERFLOW :  9.840e+02
</verbatim>

<par>Now that we are finished with our tags, we can decide to delete
them from our federated database. Therefore, we can issue the
<index item="Federated database"/>
<index item="Database"/>
<index item="&OBJ;"/>
<texttt>oodeletedb</texttt> command. However, you should be careful not to
<index item="oodeletedb@@{\ttfamily oodeletedb}"/>
delete still useful information, so it is probably good practice to
save different datasets in separate databases to provide a suffient
level of granularity. In our case we decide
the get rid of the <texttt>Tag</texttt>, and <texttt>Events</texttt> databases.
</par>
<alltt>
> <emph>oodeletedb -db Tag</emph>

Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.
d2088 2
a2089 2
Are you sure you want to delete the Database?
[Y-N]=> <emph>y</emph>
d2091 3
a2093 1
Deleted the Database "Tag" (ID = 20).
d2095 1
a2095 1
> <emph>oodeletedb -db Events -f</emph>
d2097 3
a2099 2
Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.
d2101 3
a2103 1
Deleted the Database "Events" (ID = 21).
d2105 13
a2117 1
> <emph>oodumpcatalog</emph>
d2119 6
a2124 2
Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.
d2126 11
a2136 6
FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16
a2137 4
DB Name   = System
DB ID     = 17
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/System.HEPEXP.DB
</alltt>
d2139 4
a2142 7
The first <texttt>oodeletetb</texttt> command specifies the <texttt>Tag</texttt>
database, and the program ask for confirmation. In the second
commands, where we specify the <texttt>Events</texttt> database, we also 
give the <texttt>-f</texttt> (force) switch, so that <texttt>oodeletetb</texttt>
deletes de database in question without further query. Finally, we
dump once more the catalog of the database, to see that, indeed,
only the <texttt>System</texttt> database is still present.
a2143 4
<index item="oodumpcatalog@@{\ttfamily oodumpcatalog}"/>
<index item="&OBJ;"/>
<index item="oodeletedb@@{\ttfamily oodeletedb}"/>
<index item="&OBJ;"/>
a2191 2
<index item="Librarian@@{\emph{Librarian} window}"/>
<index item="IRIS Explorer!Librarian@@{\emph{Librarian} window}"/>
d2196 2
a2234 1
<index item="NAG"/>
d2241 1
a2246 2
<index item="Background colour"/>
<index item="Colour!background"/>
d2252 13
a2267 1
menu, and <texttt>Edit Background Colour</texttt>, to select the background of
a2269 2
your choice.  The black background can also be changed permanently to
some other colour via the X11 resources described in
a2270 3
Section <ref refid="SECHISTOOGRAMPLOT"/>.
These resources should be put in the <texttt>.Xdefaults</texttt> file like any
other X11 resources. If you want to change the fill colour of the
a2272 2
histograms themselves, you can do that from the
<emph>HistOOgramPlot</emph> module.  As you complete each example, and no
a2274 3
longer need the the current map, you can
re-initialise your IE session via the <emph>Map Editor</emph>, by
selecting <texttt>Destroy All</texttt> from the <texttt>Edit</texttt> menu.  </par>
d2302 3
a2306 2
<texttt>Return</texttt>, the module will not recognize the <texttt>Match</texttt>
expression and will thus select all tags.
a2317 2
<index item="Map"/>
<index item="IRIS Explorer!map"/>
d2321 2
d2332 1
a2336 1
<url name="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/UG/CONTENTS.html"/>.
d2342 1
a2343 1
<url name="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/Index.html"/>.
a2418 2
<index item="HistOOgramFill@@{\emph{HistOOgramFill} module}"/>
<index item="HEPExplorer!modules!HistOOgramFill@@{\emph{HistOOgramFill}}"/>
d2424 2
d2435 1
a2437 1
and <emph>HepLoop</emph> modules. The user can either:
a2460 2
<index item="Federated database"/>
<index item="Database"/>
d2471 2
d2482 1
a2482 1
<subsection id="HISTOOGRAMREADER">
d2506 1
a2506 1
<subsection id="SECHISTOOGRAMPLOT">
d2513 4
a2518 2
input as shown in the following example. It creates the geometry from
these data and sends them to the <emph>Render</emph> module, which shows
a2520 2
the result on screen. To save pictures as vector PostScript files, use the 
<emph>PostScript</emph> module. </par>
a2524 2
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
a2526 2
<index item="Background colour"/>
<index item="Colour!background"/>
d2531 4
d2574 10
a2583 1
<par>When the map is ready on the <emph>Map Editor</emph>, you should first select a
a2587 3
database by just clicking on its name in the <emph>ContainerBrowser</emph>
panel and then go on to select a container name. The list of
histograms is now visible in the <emph>HistOOgramReader</emph> panel. It
a2589 2
suffices to select a histogram by clicking on its name for it to be
displayed in the <texttt>Render</texttt> window. It can be useful to set the
a2591 2
render window background to white via the <texttt>edit background color</texttt>
option in the <texttt>Viewing</texttt> menu of the <emph>Render</emph> window.</par>
a2594 1

d2669 10
a2678 4
By clicking on the <texttt>SelectHisto</texttt> widgets you can select a 1D or
2D histogram that will be transformed in a Lego plot by the
<emph>HistOOgramLego</emph> module and
<index item="HistOOgramLego@@{\emph{HistOOgramLego} module}"/>
a2679 6
finally displayed by the <emph>Render</emph>. Whenever you change to
another histogram, click on the <texttt>View All</texttt> decoration (the small
eye-shaped icon on the right side of the <emph>Render</emph> window, sixth one from
the top) of the <emph>Render</emph> module to reset the camera position.
An example is shown
in Figure <ref refid="HISTOGRAMPLOT3D"/>.
d2694 1
a2694 1
construct the map shown 
a2696 1
in Figure <ref refid="HEPDELHISTMAP"/>.
d2700 2
a2701 2
<caption>HEP Explorer map to delete a
histogram from a container</caption>
d2705 11
a2717 1
The various steps to connect the modules in the map are first to
a2719 2
connect the <emph>HistOOgramDelete</emph> module to the output port of the
<emph>HistOOgramReader</emph> module. Then, you can select a histogram by
a2721 8
clicking on its name in the <emph>HistOOgramReader</emph> panel's list.
The database identifier and name of the chosen histogram will appear in the
name fields of the <emph>HistOOgramDelete</emph> modules. If you are sure
you want to drop the histogram from the selected container in the
&OBJ; database, confirm your choice by clicking the <texttt>Delete</texttt>
button. The situation after the deletion of the histogram selected
in the previous figure is shown
in Figure <ref refid="HEPDELHISTMAP1"/>.
d2754 1
a2754 1
<caption><emph>HistOOgramCreate</emph> panels (!D and 2D)</caption>
d2760 10
a2769 1
The <emph>HistOOgramCreate</emph> module lets you create a new histogram
a2771 3
inside an existing container: the input port of this module takes a
container parameter. Therefore, it has to be connected to the output
port of the <emph>ContainerBrowser</emph> module.
a2773 1
The two maps in Figure <ref refid="HEPHISTCREATEMAP"/>
a2775 5
correspond to the situation before and after the creation of a new
one-dimensional histogram.  The name chosen for the histogram is
<texttt>New Histogram</texttt>, as you can clearly see in the
<emph>HistOOgramReader</emph> panel of the map after the histogram
creation.
a2777 1
(bottom part of Figure <ref refid="HEPHISTCREATEMAP"/>).
d2800 2
a2801 2
<index item="HistOOgramFunc@@{\emph{HistOOgramFunc} module}"/>
<index item="HEPExplorer!modules!HistOOgramFunc@@{\emph{HistOOgramFunc}}"/>
d2803 8
a2810 4
<par>Scalar transformations on histograms are the task 
of the <emph>HistOOgramFunc</emph> module, whose panel is shown 
in Figure <ref refid="HEPHISTFUNC"/>.
In the map (Figure <ref refid="HEPHISTFUNC"/>)
a2812 2
you can see how you connect the output port of 
<emph>HistOOgramReader</emph> module, which sends a histogram to the
a2814 3
input port of the <emph>HistOOgramFunc</emph> module. After the
needed transformation the <emph>HistOOgramFunc</emph> module sends the
histogram further to the <emph>HistOOgramPlot</emph> module.
d2819 10
a2828 4
An example of use of the <emph>HistOOgramFunc</emph> module is adding a
set of constants (selected on the dial of the <texttt>inScalar</texttt> after
first pushing the <texttt>Add</texttt> on the <emph>HistOOgramFunc</emph> panel)
to the same histogram (received from the <emph>HistOOgramReader</emph>
a2830 5
module) and plotting the results in <texttt>cumulate</texttt> mode onto the
same figure with the <emph>HistOOgramPlot</emph> module, as shown
<index item="HistOOgramPlot@@{\emph{HistOOgramPlot} module}"/>
<index item="HEPExplorer!modules!HistOOgramPlot@@{\emph{HistOOgramPlot}}"/>
in Figure <ref refid="HEPHISTFUNCEXA"/>.
d2843 1
a2843 1
<caption><emph>HistOOgramFunc</emph> panel and 
d2859 14
a2872 3
module, which implements the histogram printing routines described
in Section <ref refid="Printing-histograms"/>.
The <emph>HistOOgramPrint</emph> module takes his input from the 
a2874 1
<emph>HistOOgramReader</emph> module, as seen in the map shown
a2878 4
in Figure <ref refid="HEPPRINTHISTMAP"/>.
Then you will see information (name, number of entries, bins, and parts) 
about the selected histogram in the text fields of the 
<emph>HistOOgramReader</emph>
a2880 9
panel (Figure <ref refid="HEPPRINTHISTPANELLOG"/>).
After pushing the <texttt>Print</texttt> button in the
<emph>HistOOgramPrint</emph> panel, the output generated by the module is
<index item="HistOOgramPrint@@{\emph{HistOOgramPrint} module}"/>
<index item="HEPExplorer!modules!HistOOgramPrint@@{\emph{HistOOgramPrint}}"/>
written to the <emph>Explorer Log</emph>
<index item="Explorer Log@@{\emph{Explorer Log} window}"/>
<index item="IRIS Explorer!Explorer Log@@{\emph{Explorer Log} window}"/>
window (Figure <ref refid="HEPPRINTHISTPANELLOG"/>).
d2915 6
a2920 6
translate the HEP-specific data types (i.e., histograms) into IRIS Explorer
generic data types (i.e., lattices).
The module <emph>HistOOgram2Lat</emph> performs such a conversion.
The corresponding <emph>HistOOgram2Lat</emph> panel is shown
in Figure <ref refid="HEPHIST2LAT"/>.
To show how this module is used let us have a look at the map
a2922 1
in Figure <ref refid="HEPHISTLATMAP"/>.
d2935 3
a2937 3
We see that the <emph>HistOOgram2Lat</emph> module takes an histogram as
input and generates a lattice as output. The latter output stream can
be fed into any of a series of standard modules which consume
d2939 2
a2942 1
visualise a histOOgram with the standard <emph>NAGgraph</emph> module.
d2995 1
a2995 1
object ID of the (one- or two-dimensional) persistent histOOgram to be
d3032 8
a3039 1
<par>For the fit itself there is the <texttt>Fit</texttt> menu, which lets you
a3040 4
launch fits with Minuit's <texttt>MIGRAD</texttt>, <texttt>MINIMIZE</texttt>,
<texttt>SIMPLEX</texttt>, and <texttt>IMPROVE</texttt> procedures (see the Minuit
documentation for details). The covariance matrix of the fit is
available via the <texttt>Show</texttt> menu, while a more detailed
a3041 2
<texttt>HESSE</texttt> and <texttt>MINOS</texttt> error analysis can is initiated via
the <texttt>Errors</texttt> menu.
d3051 2
a3052 2
<par>Sometimes there is a lack of coherency between the model you try to
fit and the current set of parameters. as the module does not erase
d3055 10
a3064 11
are using a combination of the <emph>standard</emph> functions, you can
set a default starting value by using the <texttt>Set Default from
Model</texttt> command from the <texttt>Parameters</texttt> menu. This will parse
<index item="datafit@@{\emph{DataFit} module}!menus!parameters@@{\texttt{Parameters}}"/>
the model expression and generate a set of parameters with appropriate
names, default values and behaviours. Alternatively, you can use the
ASCII file that describes the set of parameters and that can be read
(and written) by the module. This is especially useful if you are
using your own fit function. The format of the file is very easy to
understand. Don't forget to specify in the header the number of
parameters for the fit. As it can sometimes be rather tedious to
d3070 5
a3074 1
visually investigate the effect of parameter changes.in real-time.</par>
d3083 2
a3084 1
&OBJ; database. The modules concerned can be found on the map
a3086 1
shown in Figure <ref refid="HEPFITMAP"/>.
a3096 2
<index item="Map"/>
<index item="IRIS Explorer!map"/>
d3100 2
d3106 3
a3108 1
<emph>HistOOgramReader</emph> and performs a fit on it. The output of the
a3110 1
module is a lattice that is fed into a <emph>HistOOgramPlot</emph> lattice input.
d3115 4
a3118 1
<par>When the map is ready on the <emph>Map Editor</emph>, you can click on histogram
a3122 3
in the <emph>HistOOgramReader</emph>. At that point it is possible to
adjust various attributes and the effect of these changes will be
visible immediately in the <emph>Render</emph> window.
d3127 9
a3135 8
<par>You are now ready to start a simple fit. Indeed, while sending the
data to the <emph>HistOOgramPlot</emph> module, they was also sent to the
<emph>DataFit</emph> module. Suppose we want to fit the histogram to a
Gaussian distribution. In this case it is enough to type <texttt>G</texttt> in
the <texttt>ModelExpression</texttt> text field (lower left hand corner) of
the <emph>DataFit</emph> panel. After typing a carriage return, C++ source
code corresponding to the definition of a Gaussian parameter fit is
generated, compiled and loaded.
d3143 13
a3155 1
<texttt>Parameters</texttt> menu select <texttt>Set default from model</texttt>.  This
a3156 9
fills the <texttt>Parameters list</texttt> with <texttt>MAX1</texttt>, <texttt>Mean1</texttt>
and <texttt>StdDev1</texttt>, corresponding to the three Gaussian
parameters. By clicking on one of them you can modify its value by
using the dials on the right of the <texttt>Parameters list</texttt>. It is
also possible to adjust the fitting interval with the slider below the
same <texttt>Parameters list</texttt>. If the <texttt>Histogram/Lattice</texttt>
button of the <texttt>HistOOgramPlot</texttt> module is toggled to
<texttt>Lattice</texttt>, you will get the curve corresponding to the actual
parameter values displayed in the <texttt>Render</texttt> window, as shown in
a3160 1
Figure <ref refid="HEPFITEXA1"/>.
d3164 6
a3169 3
When you are satisfied with the initial values for the parameters,
you can select the <texttt>Set into Minuit</texttt> option in the
<texttt>Parameters</texttt> menu and then choose the fitting method (for
a3170 1
example <texttt>MIGRAD</texttt>) in the <texttt>Fit</texttt> menu to perform the
a3171 2
fit. The result is immediately visualised as shown in
Figure <ref refid="HEPFITEXA2"/>.
d3209 4
a3212 1
Choose <texttt>Generate Skeleton</texttt> from the <texttt>UserFunction</texttt>
a3213 3
menu. This should create the file containing a skeleton implementation
for your fit function in the directory
<texttt>$EXPLORERUSERHOME/fitting/lib</texttt>.
d3217 7
a3223 5
the file <texttt>Minuit_fit_function</texttt> in the same directory.  If your
model contains some of the standard functions you can try to construct
a formula using these standard functions which is close in form to
your model expression, then choose <texttt>Write model to User File</texttt>
from the <texttt>UserFunction</texttt> menu. This replaces steps 2 and 3 and
a3224 2
can let you gain some time. Below we show an example of such a model
function.
d3229 3
a3231 1
Choose <texttt>Compile User Function</texttt> from the <texttt>UserFunction</texttt>
a3232 1
menu. This should replace the old model by your new one.
d3235 8
a3242 3
Define the parameters via the option <texttt>Open Parameters file</texttt> in
the <texttt>Parameters</texttt> menu. If the file exist, the fields <texttt>Par
Filename Input</texttt> and <texttt>Parameter List</texttt> at the top of the
a3243 4
<emph>DataFit</emph> panel will be updated. If the file does not exist you
should create it. The simplest procedure is to start from a parameter
file created form a standard model via the option <texttt>Save to Parameters
file</texttt> in the <texttt>Parameters</texttt> menu.
d3358 1
a3358 1
put them in a HistOOgram, using cuts on the data set expressed in C++
d3368 1
a3368 1
<item>define the input streams for the HistOOgram you will produce;</item>
a3375 1
<index item="Event association"/>
d3378 1
d3381 2
a3384 2
every time the user's analysis setup and such a map can be executed in
a <emph>batch</emph> fashion using IRIS Explorer's script language.</par>
d3391 8
a3398 1
<par>The <emph>HepExplorableBrowser</emph> module lets you browse and select
a3400 1
explorable collections. In the <texttt>Explorable List</texttt> text field you
a3401 4
can select a tag, whose identifier will appear in the
<texttt>Selected</texttt> field. Then the <texttt>Field List</texttt> will show you
the various fields of the tag, and you can select one and pass it
on to the <emph>HepMatchAndFill</emph> module. The
a3403 1
<emph>HepExplorableBrowser</emph> panel is shown
a3405 1
in Figure <ref refid="HEPEXPBROWSER"/>.
d3421 5
a3425 2
This new module offers the same features as the three former modules 
<emph>HepExplorableSelector</emph>, <emph>LibMaker</emph> and <emph>HistOOgramFill</emph>, 
a3429 2
and is equivalent to PAW's <texttt>NT/PLOT</texttt>, <texttt>NT/PROJECT</texttt>
commands. 
a3432 1
Basically it:
d3446 6
a3451 1
As for the <emph>HepLoop</emph> module, histograms are created in a default dump 
a3453 4
container if none is specified on the input port. When leaving the module,
users can have these histograms erased automatically (default behavior) or
left as is (just click on the <texttt>Keep Dump</texttt> radio button); users can also
erase them at any time by clicking on the <texttt>Erase Now</texttt> button.
d3455 2
a3456 2
<par>The <emph>HepMatchAndFill</emph> panel is shown
in Figure <ref refid="HEPMATCHANDFILL"/>.
d3472 5
a3476 2
This module is equivalent to the <texttt>PAW NT/LOOP</texttt>
command and offers a framework to
a3479 1
scan an explorable collection, apply a certain cut/match to the collection
a3480 2
(or to each of its items) and execute a particular action each time this 
match succeeds. The action may for instance be the filling of histograms.
d3483 5
a3487 3
Most of the code (both header file and source file) is automatically generated:
users only have to provide/write the relevant part of code for the match/cut 
or action to be taken for instance.  As with <emph>HepMatchAndFill</emph> symbolic
a3489 2
constants are supported and may be passed to the code without no extra 
compilation overhead.
d3492 5
a3496 1
Once the entire code meets the user's requirements, <emph>HepLoop</emph> makes it 
a3498 3
possible to generate files and Makefile for a standalone version corresponding 
to the current customized code and setup. The standalone application may then 
be executed outside of Iris Explorer like any other applications.
d3521 2
a3522 1
modules; it produces HistOOgrams out of an explorable collection.
a3523 1
You can think of this map as a <emph>NT/PL replacement</emph>.
d3537 3
a3539 1
<emph>HepExplorableBrowser</emph>'s output port <texttt>Explorable</texttt> is
a3541 1
connected to <emph>HepMatchAndFill</emph>'s input port <texttt>Explorable</texttt>;
d3547 3
a3549 1
<emph>HepMatchAndFill</emph>'s output port <texttt>output Histo</texttt> is connected to
a3551 1
<emph>HistOOgramPlot</emph>'s input port <texttt>inHisto</texttt>;
d3556 1
a3558 1
connected to <emph>Render</emph>'s input port <texttt>Geometry</texttt>.
d3566 1
a3570 1
in Figure <ref refid="HEPEXPLORABLEMAP"/>).
d3581 1
a3581 1
<par>If you want to produce a HistOOgram you should do the following.</par>
d3585 2
a3587 1
<emph>HepExplorableBrowser</emph> module.  The selected item is passed
a3589 1
over to the <emph>HepMatchAndFill</emph> module.
d3594 1
a3595 1
in the <texttt>Match</texttt> field of the <emph>HepMatchAndFill</emph> module.
d3599 1
a3599 1
<item>Define what you want to put in your HistOOgram as C++ expressions
d3606 2
a3607 1
<emph>HepMatchAndFill</emph> module to 
a3609 1
generate the C++ code, compile it, if need be, and then execute it.
d3649 2
a3650 1
Notice the use of the <emph>HistoryBox</emph> module to keep a history of the cuts 
a3652 1
expressions, for instance.
d3661 8
a3668 7
Symbolic constants can be specified in the <texttt>Match</texttt>, <texttt>X</texttt>,
<texttt>Y</texttt> and <texttt>W</texttt> fields instead of actual numerical values.
The main advantage with this approach, apart from having simpler and
clearer expressions, is that whenever users want to modify the
numerical values of these symbolic constants to fit their needs, the
C++ generated code is neither regenerated nor recompiled: the
compilation overhead is thus eliminated.
d3671 5
a3675 4
<par>Such symbolic constants are defined in the <texttt>Constants</texttt> field
and obey the C++ numerical constants assignment syntax: <texttt>name =
value</texttt>.  For instance, the following expression defines two symbolic
constants (the last semi-colon is optional):
d3683 3
a3685 2
<texttt>Constants</texttt> field is significant. The order cannot be changed
unless the code is re-generated, otherwise consistency is not assured.
a3693 2
<index item="HepMatchAndFill@@{\emph{HepMatchAndFill} module}"/>
<index item="HEPExplorer!modules!HepMatchAndFill@@{\emph{HepMatchAndFill}}"/>
d3697 2
d3701 7
a3707 4
If a valid histogram is connected to the optional histogram input port 
(<texttt>Input Histo</texttt>), then this histogram is used instead of the 
default one.
Typically users can look up a histogram (via <emph>HistOOgramReader</emph>) or
a3709 1
create a new one (thanks to <emph>HistOOgramCreate</emph>) and pass it to
a3711 1
<emph>HepMatchAndFill</emph>, when they want to fill their customized histogram.
d3716 5
a3720 3
The panel in Figure <ref refid="HEPMATCHANDFILL4"/>
shows how the <texttt>Customized_Histo</texttt> 
HistOOgram (created by <emph>HistOOgramCreate </emph>) can be specified and 
a3722 1
connected to the input port <texttt>Input Histo</texttt> of <emph>HepMatchAndFill</emph>.
d3741 8
a3748 7
define it in a header file and specify the filename in the <texttt>Include
Files</texttt> widget.  However, If the code of the function becomes
larger, it might be better pratice to declare the routine in a header
file and implement it in a separate source file. In this case the
header filename (<texttt>.h</texttt>) and source filename (<texttt>.cpp</texttt>)
should be specified using the <texttt>Include Files</texttt>, and 
<texttt>Source Files</texttt> widgets, respectively.
d3755 2
a3756 2
the <texttt>Build Options</texttt> field lets you add extra <texttt>includes</texttt>
or <texttt>define</texttt> directives;
d3763 5
a3767 5
The two panels of Figure <ref refid="HEPMATCHANDFILLCUT"/>
show how to use a customized cut function 
(<texttt>my_cut</texttt>) and the files (<texttt>my_cut.h</texttt> and <texttt>my_cut.cpp</texttt>)
that are specified in the relevant widgets of the
<emph>HepMatchAndFill</emph> module.
d3793 4
a3796 4
HistOOgram. As mentioned before, no knowledge of the specific object
model is required as long as you deal with attributes defined in the
tag. However, when you need to cross the association between a tag and
its related event in order to retrieve more information, the
d3801 2
a3802 1
Information about the object model is communicated to <emph>HepMatchAndFill</emph>
a3804 1
by specifying the following:
d3813 2
a3814 2
the name of the concrete tag (<texttt>Concrete Tag</texttt> field) to be
used, i.e., the name of the class implementing the tag;
d3817 2
a3818 2
the shared library (<texttt>Libraries</texttt> field) which contains the 
code to access tag/event methods and attributes.
d3823 4
a3826 4
Figure <ref refid="HEPMATCHANDFILL3"/>
shows an example using the <texttt>AtlasProdTag</texttt> concrete tag. Its
declaration is in the header file <texttt>AtlasProd.h</texttt> and its associated
library has been specified in the <texttt>Libraries</texttt> field.
d3836 7
a3842 7
The <texttt>theTag</texttt> object is then ready for use, should you want to
access the concrete tag. You may ask for a reference to an event using
the <texttt>getEvent()</texttt> method. With this reference you can then
access each of the attributes as you would do in a normal C++ program
(in the <texttt>AtlasProd</texttt> example the attribute is named
<texttt>NgTrack</texttt> and corresponds to the number of tracks in the
event).
d3860 3
a3862 1
This map shows an example of how to use the <emph>HepLoop</emph> module with
a3864 1
other HEP-Explorer modules to perform a custom interactive analysis.
d3868 2
a3869 2
The  <emph>HepLoopMap</emph> map
shown in Figure <ref refid="HEPLOOPMAP"/>
a3871 1
consist of four modules:
d3875 2
a3876 1
<emph>HepExplorableBrowser</emph>.
a3878 1
This module provides an explorable collection to be looped over.
d3882 3
a3884 1
<emph>HepLoop</emph>.
a3886 3
This module scans the collection, checks for elements that
match a specific user-defined cut and performs the relevant
user-defined action.
d3889 5
a3893 1
<emph>ContainerBrowser</emph>.
a3895 4
Most of the time users want to fill HistOOgrams. By default, such
HistOOgrams are created in a dump container. However, users can also
specify their own container (obtained via <emph>ContainerBrowser</emph>
for instance) by connecting it to the optional input port <texttt>Container</texttt>.
d3898 5
a3905 2
The <emph>HepLoop</emph> module
provides on its output port the container (the default one
a3907 3
or one specified by the user) where all histograms have been created.
It is then possible to display these histograms conveniently by connecting 
this output port (<texttt>Out Container</texttt>) to <emph>HistOOgramReader</emph>.
d3923 2
a3924 1
<emph>HepLoop</emph> provides various features that offer better control over
a3926 1
the generated and customized code.
d3942 1
a3944 1
options can be added.
d3949 8
a3956 1
When clicking on the <texttt>Prototype</texttt> button, <emph>HepLoop</emph> generates
a3958 6
two skeleton files: a header (extension <texttt>.h</texttt>) and a source
(extension <texttt>.cpp</texttt>) file. The basename is specified in
the <texttt>Filename</texttt> field. The header file contains the main class
declaration and the source file the implementation of its methods. Those
parts of the methods that users may want to alter by introducing
customized code are bracketed with comments, as shown below.
d3971 3
a3973 3
Figure <ref refid="GENERATEDCODE"/> shows two panels with an example 
of a header (left) and part of a source file (right)
that were automatically generated.
d3989 6
a3996 7
skeleton code is to scan (loop over) an explorable collection, 
<index item="Explorable collection"/>
apply a user-defined cut while trying to match each of its items,
then, when a match is successful, execute a given action.  Note that
customized actions can also be performed once before the start of the
loop (<texttt>preExecute</texttt> method) and once after the loop terminates
(<texttt>postExecute</texttt>).
d4004 4
a4007 2
<texttt>match</texttt>: define in this method the specific cut/match that is applied
to each item of the explorable collection. <texttt>match</texttt> should return 0
a4008 1
when the cut was unsuccessful, a non-zero value otherwise.
d4011 3
a4013 2
<texttt>action</texttt>: this method is executed whenever the match/cut succeeds.
Typically users might want to fill histograms in this method.
d4016 3
a4018 2
<texttt>preExecute</texttt>: this method is executed once before scanning
an Explorable collection. Typically, this is where you would perform
a4019 1
initializations or assign resources.
d4022 4
a4025 3
<texttt>postExecute</texttt>: this method is executed once after scanning an
Explorable collection. Typically, this is where you would release the
resources that were assigned in <texttt>preExecute</texttt>.
d4028 5
a4032 5
<par>Figures <ref refid="CUSTOMIZEDGENERATEDCODE1"/> and
<ref refid="CUSTOMIZEDGENERATEDCODE2"/> show an implementation of 
some of the methods described above, while
Figure <ref refid="CUSTOMIZEDGENERATEDCODE3"/> is the header file
containing their declaration.
d4054 4
a4057 1
Once the code generated by <emph>HepLoop</emph> has been modified and customized,
a4059 3
it is possible to build a standalone version of the code, i.e., a
version of <emph>HepLoop</emph> that can execute the customized code outside
of Iris Explorer.
d4062 3
a4064 2
In order to prepare such a standalone versin, users should 
click on the <texttt>Generate Makefile</texttt> button. Then <emph>HepLoop</emph>
a4066 1
generates:
d4070 3
a4072 2
a makefile (<texttt>GNUmakefile</texttt>) that registers the current setup
of the module (compilation options, include files, source files, etc.);
d4075 2
a4076 2
the <texttt>main_HepLoop.cpp</texttt> file that can run the customized code,
which was prepared and tested previously.
d4087 5
a4091 2
<texttt>main_HepLoop.cpp</texttt> (and other C++ code, as needed) using and
environmental setup that was defined in <emph>HepLoop</emph>. 
a4093 2
The generated application is called <texttt>main_HepLoop</texttt>, which
can be executed by typing its name:
d4115 5
a4119 5
<texttt>PART_MIN=45500; X_OFFSET 36.642;</texttt>,  where the last semi-colon
is optional. Constants must be specified in the same order as
they were in the <texttt>Constants</texttt> field and their number must also
correspond; no consistency is assured when these requirements are not
fulfilled.
d4135 46
d4182 1
d4195 2
a4198 2
message text is not properly initialized
(strings of the type <texttt>ivxxx</texttt> are displayed).
d4202 4
a4205 4
To define the relevant text strings to be displayed, 
the corresponding resources must be defined. These resources
allow you to customize the menus in question. For instance, you can
change the language and disable some of the menu items.
d4209 5
a4213 4
The <texttt>app-defaults/Inventor</texttt> directory 
contains the default resource file for
all standard viewers. System administrators should copy this file into
the directory <texttt>/usr/lib/X11/app-defaults</texttt>.
a4214 1
For instance, a specific language is chosen as follows.
d4221 2
a4222 2
One should also include the <texttt>$OIVHOME/app-defaults</texttt> directory
in the <texttt>XAPPLRESDIR</texttt> path variable.
d4253 4
a4256 2
All mandatory inputs are connected. For instance, if you do
not connect <emph>HistOOgramFill</emph>'s <texttt>LibraryName</texttt> input to
a4258 1
the corresponding <emph>LibMaker</emph>'s output, the module will never
a4260 1
activate.
d4263 3
a4265 3
All mandatory fields have been properly defined: a meaningful value
is typed and the Return key is pressed on the text fields, an item is selected
on the Listboxes.
d4268 2
a4269 2
There are no &OBJ; locks pending (just exit from IRIS Explorer and
use the &OBJ; <texttt>oocleanup</texttt> utility).
d4275 6
a4284 5
aware that when a module crashes, IRIS Explorer will ask you whether
you want to replace the module with another instance. If you answer
positively, the newly loaded module will be disabled by default.  In
order to enable or disable a module you should click with the right
mouse button on the module's name in the <emph>Map Editor</emph> window.
d4310 1
d4349 6
a4354 8
If when running Iris Explorer you get a message saying that
the disk where the shared memory <emph>arena</emph> resides is not
large 
<index item="Arena"/> 
enough, check the space available in
<texttt>/usr/tmp</texttt> (the location where IRIS Explorer by default
creates its arena). If it is too small you should enlarge it or change
the directory where the arena is created by specifying another
d4358 4
d4364 1
a4364 3
Explorer customization file file}"/>, 
(see IRIS ExplorerUser's Guide, Appendix A at the URL 
<url name="http://www.nag.co.uk:80/visual/IE/iecbb/DOC/UG/appa.html"/>).
d4377 5
a4381 4
when the library <texttt>libcx.a</texttt> (via the option <texttt>-lcx</texttt>)
is included when building an Iris Explorer module. It is therefore
advisable to use <texttt>printf</texttt> rather than the C++ construct
<texttt>cout &lt;&lt;</texttt> to print program variables to the output stream.
a4405 55
<!--filename=NonHEPIEModules.html-->
<chapter id="H1NonHEPIEModules">
<stitle>Overview of non-HEP-specific IRIS Explorer modules</stitle>

<figure id="DATAFIT" loc="!h">
<includegraphics width=".9\linewidth" file="twodfit_map"/>
<caption>Fit 2D histogram with <emph>DataFit</emph> module</caption>
<small>
<par>
This application allows the user to read in a 2D histogram and fit it
using the <emph>DataFit</emph> module which is an interface to Minuit.
The <emph>DataFit</emph> module outputs a lattice which is then re-scaled
by <emph>Rescale2D</emph>.  The <emph>Lego+surface</emph> module group
generates a lego plot for the original histogram and a smooth surface
representing the fit function.
</par>
</small>
<index item="Map"/>
<index item="IRIS Explorer!map"/>
</figure>
<figure id="LEGOSURFACE" loc="!h">
<index item="Lego plot"/>
<includegraphics width=".7\linewidth" file="lego+surface"/>
<caption>User Interface for the <emph>Lego+Surface</emph> module group
</caption>
<small>
<par>
The GUI for the <emph>Lego+Surface</emph> module group 
(see the map in Figure <ref refid="DATAFIT"/>)
is split into two halves. The left-hand side is related to the surface
normally used to visualise the fit function. The right-hand side
relates to the lego plot used to visualise the histogram contents.
</par>
</small>
<index item="Lego plot"/>
</figure>

<figure id="TWODAXES" loc="p">
<includegraphics width=".7\linewidth" file="TwoDAxes"/>
<caption>User Interface for the <emph>TwoDAxes</emph> module group</caption>
<small>
<par>
The module group produces 3D axis geometry from 2D histograms. Widgets
are fairly self explanatory.
</par>
</small>
</figure>

<figure id="TWODFIT" loc="p">
<includegraphics width="\linewidth" file="twoDfit_render"/>
<caption>Result of a Gaussian fit to (part of) a 2D histogram</caption>
</figure>

</chapter>

d4428 4
d4465 3
a4467 3
<term><emph>HepLoopMap</emph></term>
<item>A map using the <emph>HepLoop</emph> module with
other HEP-Explorer modules to perform a custom interactive analysis.
d4543 1
a4543 1
<term>RD44 Project</term>
d4545 1
a4545 1
<index item="RD44 Project"/>
@
