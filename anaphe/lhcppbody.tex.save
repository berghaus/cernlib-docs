\chapter{Presenting LHC++\label{H1PresentingLHCPP}}
\section{A short historical introduction}
\index{History of LHC++}%
\index{LHC++!history}%

\par
In 1995 a working group, called \emph{LHC++}, consisting of
representatives of IT Division's ASD Group and of the various LHC
experiments, was created to investigate how the approximate equivalent
of the current CERNLIB environment could be provided in the LHC
era. Although the primary objectives of the discussions concentrated
on proposing solutions for future LHC experiments, it is essential
that other HEP experiments which are coming online in the next couple
of years will also be able to benefit from the proposed strategy.
\par
It is clear that (industry) standard solutions should be used
whenever possible. This is nothing new since in the past commercial
libraries or programs, such as GKS/GTS, Numerical Algorithms Group
(NAG) libraries, Phigs, Historian, and CMZ)
have been used in the CERNLIB environment.  Intensive investment of
manpower should only be made in HEP-specific developments, where the
needed functionality cannot be obtained \emph{off the shelf} at
affordable prices. An instance of such a HEP development is the CLHEP
class library, which is also a nice example of reuse.\index{CERNLIB}%
\index{NAG}%
\index{Numerical Algorithms Group Ltd}%
\index{GKS}%
\index{GTS}%
\index{Phigs}%
\index{Historian}%
\index{CMZ}%
\index{CERNLIB}%

\par
Working closely with the LHC collaborations and other HEP
Laboratories in 1996 and 1997 an interim strategy was defined and a
number of licences for the commercial components was obtained.  When
several \emph{a priori} solutions were available, a study was made
to determine which was the most suited in the HEP context.  We also
tested the proposed solutions at a few sites and ensured that it is a
workable environment.\section{Objectives}

\par
The main objective of LHC++ is to satisfy the requirements of the
LHC experiments in terms of the overall software environment that
today is provided by CERNLIB, as requested in these experiments'
\emph{Computing Technical Proposals}\index{CERNLIB}%

\par
This translates into the following key points for the short to
medium term:
\begin{itemize}

\item identify and provide key HEP-specific functions;
\item define affordable solutions for the non-HEP-specific parts;
\item monitor the non-HEP world for possible future useful
software;
\item study and understand the requirements of the LHC experiments for
C++-based mathematical libraries, and evaluate existing and future
developments, both commercial and otherwise in this area;
\item study the requirements for a minimisation package
(Minuit-replacement), in particular follow closely developments of
the STABLE project, which should provide the needed functionality,
both stand-alone and in the framework of IRIS Explorer;
\index{Minuit}%
\index{Minimisation!Minuit}%
\index{STABLE}%
\index{Minimisation!STABLE}%

\item undertake a number of pilot projects with the experiments 
to test the overall functionality of the LHC++ environment;
\item supplement, where necessary, the existing documentation, both 
printed and online, with a set of user guides and tutorials;
\item agree with the experiments and other HEP laboratories on
a scheme for managing licenses, so that the best possible deals 
can be negotiated.\end{itemize}

\par
The scope of the LHC++ project covers the following:
\begin{itemize}

\item foundation level class libraries;
\item mathematical libraries;
\item graphical libraries;
\item visualisation tool-kits, data analysis, histograms;
\item event generators (in collaboration with, e.g., Lund);
\item detector simulation (GEANT-4);
\index{GEANT 4}%

\item object persistency (Objectivity/DB via RD45 at present).
\index{RD45 Project}%
\index{Objectivity/DB}%
\end{itemize}

\par
The primary focus is on C++-based solutions, although, of course,
developments in the software arena, in particular the increased
importance of Java, are closely watched.\section{Collaboration with the experiments}

\par
The LHC++ project is a joint effort between IT Division (mainly
ASD Group), the LHC experiments, plus NA45, Compass,...  Andreas
Pfeiffer is responsible for its overall coordination.
\par
Regular (bi-weekly) LHC++ and RD45 meetings are held in Building 40. This
is an ideal forum for communication with the physics community since
its allows us to bring our users regularly up to date with the latest
news. Also, and more importantly, it provides us with an input channel
from the experiments about how they use the software, which are
possible problem areas which have to be addressed, and what are the
future developments they would like to see.
The minutes as well as material presented on the progress
in the various areas are available on the web 
(see \url{http://wwwinfo.cern.ch/asd/lhc++/meetings.html}).
\index{Regular meetings (LHC++, RD45)}%
\index{LHC++!Regular meetings}%

\par
Twice a year a formal \emph{LHC++ Workshop}
(see \url{http://wwwinfo.cern.ch/asd/lhc++/workshops.html})
take place where progress reports are presented by all HEP-wide
collaborations who are using LHC++ software. This Workshop provides an
efficient forum for feedback from the experiments and permits us to
steer long-term development in the right direction by taking into 
account constraints and requirements of as wide a user base as possible.\index{LHC++!workshop}%
\index{Workshop (LHC++)}%

\par
All three LCB common projects (GEANT-4, RD45, LHC++) stress the formal
gathering of use of requirements. Equally the priorities for these
projects, each of which is dominated by members of LHC and other
HEP experiments, are agreed at the level of the LCB, which is itself
mainly composed of experimental representatives.\section{Current Situation}

\par

By using commodity solutions where-ever possible, we ensure that
the proposed solutions are widely used, well-debugged and well
documented, and are also more affordable. These solutions are being
complemented by HEP-specific components, where needed, by building a
HEP user-layer on top of standards-conforming products.

\par

To ensure that the commercial components work well together, the
LHC++ strategy closely adheres to standards - both \emph{de-facto}
and \emph{de-jure}.  Examples of \emph{de-jure} standards
include the \emph{Standard C++ Library} (see 
\url{http://www.objectspace.com/Products/CCS/Standards/standards.html})
and ODMG-compliant Object Database Management
Systems (ODBMS), while instances of \emph{de-facto} standards 
are industry standard graphics packages,
such as OpenGL, Open Inventor and IRIS Explorer
(see
\url{http://www.nag.co.uk/visual/IE/iecbb/Tutorial/index.html} 
for a tutorial), all originally from Silicon Graphics (SGI).
\index{Standard Library}%
\index{ODBMS}%
\index{Object Database Management System}%
\index{OpenGL}%
\index{Open Inventor}%
\index{IRIS Explorer}%
\index{SGI}%
\index{Silicon Graphics}%

\par

The table below shows this layered structure more schematically.
Licenses for all commercial components are available at CERN, where
the software has been installed on all Unix platforms (Dec, HP, and
Sun for IRIS Explorer 3.9) on AFS in \texttt{/afs/cern.ch/sw/lhcxx},
while on Nice/Windows/NT it is available under \verb|z:\p32\lhcxx|.
\index{AFS}%
\index{Windows/NT}%
\index{Nice}%

\par

\begin{center}
\begin{tabular}{|c|}
GEANT-4, MCLIBS++\\
HEPExplorer, IRIS Explorer\\
HepVis, HEPInventor\\
OpenGL, Open Inventor, Master Suite\\
HepMATH, including GEMINI\\
NAG C library (with C++ headers)\\
CLHEP\\
HTL\\
HEPODBMS\\
ODMG, ODBMS (Objectivity/DB) + persistent STL\\
Standard C++ Libraries\\
\end{tabular}
\index{NAG}%
\index{GEANT 4}%
\end{center}
\par

All of the commercial LHC++ components come with excellent online
documentation. In most cases, printed documentation, often in the form
of published books, is also available and can be bought from the User
Consultancy Office (UCO) at CERN. HEP-specific examples and other
information specific to the HEP environment is clearly not available
from the vendors.

\par

The main purpose of the present manual is to provide a tutorial
introduction to the use of LHC++ tools for physicist new to the LHC++
computing paradigm.  The current guide describes the present state of
some of the HEP extensions.  Their precise form and application
program interface (API) probably needs to be refined or extended in
a few places. Therefore we invite all users of the LHC++ software to
forward their comments and suggestions to the LHC++ team,
preferably at the LHC++ regular meetings mentioned above.
\index{Regular meetings (LHC++, RD45)}%
\index{LHC++!Regular meetings}%
\section{An overview of the commercial components}

\par
The commercial components of LHC++ are chosen because they offer a
coherent set of inter-operable solutions. They are built on standards
and often come as part of the standard hardware or software bundled
with the computer. Cost effectiveness has also been optimised both
for CERN and for the general CERN HEP program participants.
\subsection{OpenGL}
\index{OpenGL|(}%

\par
\emph{OpenGL} (see 
\url{http://www.sgi.com/Products/Dev_environ_ds.html})
is a industry standard for graphics. It is vendor-neutral and
multi-platform, and is optimised for building environments for
developing 2D and 3D visual applications. Several vendors already
offer a hardware implementation of the standard, thus ensuring
that rendering speed will be optimal.
\par

The about 250 OpenGL procedures provide a wide range of graphics
features, such as a set of geometric and raster primitives, various
colour modes, display list or immediate mode, viewing and modelling
transformations, lighting and shading, hidden surface removal and
translucency, anti-aliasing, texture mapping, effects using fog,
smoke, or haze, etc.  As all licensed OpenGL implementations are
required to pass a set of conformance tests, and implement the same
specification and language binding document full portability between
multiple platforms is guaranteed.
\par
Documentation is available as two books: the \emph{OpenGL Programming
Guide}, and the \emph{OpenGL Reference Manual}, both published
by Addison and Wesley (and available from the UCO at CERN).\index{OpenGL|)}%
\subsection{Open Inventor}
\index{Open Inventor|(}%

\par
\emph{Open Inventor} (see
\url{http://www.sgi.com/Technology/Inventor/index.html}) is an
object-oriented 3D toolkit to provide a comprehensive solution to
interactive graphics programming.  Its programming model is based on a
3D scene database optimised to ease building graphics applications. It
includes a large set of objects, such as cubes, polygons, text,
materials, cameras, lights, track-balls, handle boxes, 3D viewers, and
editors.
\par

Open Inventor is built on top of OpenGL. It defines a standard file
format (IV) for 3D data interchange and introduces a simple event
model for 3D interaction. Animation is provided with
\emph{Engines}. Open Inventor offers a convenient multi-platform
3D graphics development environment, which allows efficient
manipulation of objects in a windows and operating system independent
way.
\par

Open Inventor's IV files serve as the basis for the \emph{VRML
(Virtual Reality Modelling Language)} standard (see
\url{http://vrml.wired.com}). The Open Inventor toolkit is
conveniently documented in three books \emph{The Inventor
Mentor}, \emph{The Inventor Toolmaker}, and \emph{The Open
Inventor C++ Reference Manual} published by Addison-Wesley
(available from the UCO at CERN).\index{Open Inventor|)}%
\subsection{MasterSuite}
\index{MasterSuite|(}%

\par
\emph{MasterSuite} (see
\url{http://wwwinfo.cern.ch/asd/lhc++/MASTER_SUITE/MasterDocHTML/msuite.htm})
is a C++ toolkit for data visualisation, containing class libraries
with extension nodes to Open Inventor. These extensions cover 2D
drawing and charting, 3D drawing, legends, etc., and provide a set of
input devices to ease cross-platform design of user interfaces, as
well as set of classes to develop viewers for scientific data for
output on screen as well as on several types of printers in
vector-graphics mode.  It supports vector graphics output, in
particular PostScript output and is easily extensible by programming
new user-defined customisable objects.

\par

MasterSuite comes with four components, DialogMaster, PlotMaster,
GraphMaster, and 3DDataMaster.  Because it is built on top of Open
Inventor you always have access to all Open Inventor rendering
capabilities, such as camera, lighting, texturing, fog, etc. Similarly
Master Suite node fields can interact with Open Inventor engines for
providing animation of building sensors to change data values.  Data
can be saved in an Open Inventor database and metafile, in particular
in IV format, thus allowing one to distribute visualisation over the
Internet in a natural and straightforward way.
\index{MasterSuite|)}%
\subsection{IRIS Explorer}
\index{IRIS Explorer|(}%

\par
\emph{IRIS Explorer} (IE, see
\url{http://www.sgi.com/Technology/explorer.html}) is a toolkit
for visualisation of scientific data, which can be manipulated via
visual programming tools.  Users analyse their data by connecting
building blocks, called \emph{modules}.  Modules act like
\emph{filters}: they read one of more streams of input data and
produce one of more streams of output data. The behaviour of modules
are controlled (interactively) by a set of parameters. IE comes will a
rather complete set of modules for performing basic data
transformations, and it is straightforward to create new modules.  It
is noteworthy that, because of its wide use, a lot of modules
developed by various user communities are available publicly, while
some can be obtained commercially (see below).

\par

To transform user data, one constructs a \emph{map}, which is a
network of interconnections between a set of modules. The various
components of a map can be manipulated individually and interactively,
and a map can be saved for later retrieval. If one of the modules is
time-consuming or needs special hardware then it can be run on a
different node of the network, thus parallel processing possibilities
are part of the system.
\index{Map}%
\index{IRIS Explorer!map}%

\par

A well-written \emph{tutorial} 
(see \url{http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html})
by the \emph{IRIS Explorer Centre of Excellence (IECOE)} at the 
University of Leeds will you teach how to
master the basics of the program.
The \emph{IECOE website} 
(\url{http://www.scs.leeds.ac.uk/iecoe/})
also provides a series of hyperlinks to other sites
from where IE modules can be downloaded. A printed and bound copy of
the \emph{IRIS Explorer User's Guide} can be obtained from the
UCO.
\index{IECOE!IRIS Explorer Centre of Excellence}%
\index{IRIS Explorer|)}%
\subsection{Objectivity/DB, the Object Database}
\index{Objectivity/DB|(}%

\par

In order to study solutions for storing and handling the
multi-Pbyte data samples expected with LHC, the \emph{RD45
Project} (see 
\url{http://wwwinfo.cern.ch/asd/cernlib/rd45/index.html}) 
was established in 1995.  The proposed solution
should also be able to cope with other persistent objects, such as
histograms, calibration monitoring data, etc. It was found that the
best candidate for handling this problem is a \emph{ODMG}
(Object Database Management Group, see
\url{http://www.odmg.org/}) compliant object database used
together with a mass storage system, based upon the IEEE reference
model for mass storage systems. After considering a few alternatives,
the presently favoured solution uses 
\emph{Objectivity/DB} (see \url{http://www.objy.com/})
and \emph{HPSS} (High Performance Storage System,
see \url{http://www.sdsc.edu/hpss/})
\index{RD45 Project}%
\index{Objectivity/DB}%
\index{HPSS}%
\index{High Performance Storage System}%

\par

The Objectivity/DB database provides object-persistency services for GEANT-4
and the experimental data. It must fully support HEP meta-data, not
only the persistent data collections themselves, but it must also
handle the selections producing these collections, and the predicates
themselves. Replication of large database images on local area and
wide area network configurations containing heterogeneous hardware
must allow collaborators all over the world to actively participate in
data analysis. Given the large time scales (the lifetime of the LHC
software will span at least twenty years) schema evolution and
versioning are important aspects which must be taken into account.
Objectivity/DB comes with a set of administrative tools to ease database
management. Objectivity/DB also comes with an \emph{Advanced Multi-threaded
Server} (AMS) and an interface to HPSS.
This provides fast access to data and offers a large performance
improvement when updating data stored in remote databases. It is
expected that each experiment will run starting in 1998 a production
service of one or more of these servers.
\index{GEANT 4}%
\index{Advanced Multi-threaded Server}%
\index{Objectivity/DB}%
\index{AMS}%
\index{HPSS}%

\par

Objectivity/DB has a layered logical storage level, with at its top the
\emph{federated database}. Each federated database logically
contains one or more \emph{databases}, with the latter containing
the \emph{objects}, which are clustered, for efficiency, inside
\emph{containers}. An \emph{object} itself consists of standard
C++ constructs, variable-size arrays, relationships and references to
other objects, and type constraints. Persistent objects can be created
and deleted dynamically by any application. The data model, or
\emph{schema} is stored inside the federated database.
\index{Object}%
\index{Federated database}%
\index{Database}%
\index{Container}%
\index{Data model}%
\index{Schema}%
\index{Objectivity/DB|)}%
\subsection{Mathematical Libraries}
\index{Mathematical libraries}%

\par

CERN no longer has any in-house mathematician supporting mathematics
libraries. Therefore, we shall have to rely on libraries developed
outside CERN, and it was decided to make the \emph{NAG
C-language} (see
\url{http://www.nag.co.uk/numeric/CL.html}) library available.
Although the NAG C Library provides the basic functionality required
by HEP, a small number of routines (basically special functions) are
currently unavailable.  A future release of the above library is
likely to incorporate these routines.
\index{NAG}%
\index{Numerical Algorithms Group Ltd}%
\subsection{Statistical Data Analysis: the Gemini package}
\index{Gemini}%
\index{Minimisation!Gemini}%

\par

Gemini is a GEneral MINImization and error analysis package
implemented as a C++ class library. Minuit's functionality is provided
in a \emph{Minuit-style} (even if, internally, another minimizer
may actually do the work) and new functionality offered by NAG C
minimizers is added. Gemini thus provides a unified C++ API both to
standard Minuit and to NAG C family of minimizers. For the common
subset of functionality, it is up to the user which minimization
engine does the work: Minuit or NAG C. The user can easily switch
between various minimizers without essential changes in the
application code. The currently supported set of minimizers (Minuit
and NAG C) can be extended without essential changes in the API.

\par

The abstract base class \texttt{GEmini} defines an interface to the
common functionality. The \texttt{CMinuit} class is derived from
\texttt{GEmini} and provides a Minuit-based implementation of the
GEmini functionality plus Minuit-specific extensions. Similarly, the
\texttt{NAGmin} class is derived from \texttt{GEmini} as well and
provides a NAG-based implementation of the \texttt{GEmini}
functionality plus NAG-specific extensions.
\index{Minuit}%
\index{Minimisation!Minuit}%

\par

There is no single class which contains references both to Minuit and
to NAG C, so that orthodox Minuit or Nag C users are not forced to
link the other library.

\par

Gemini finds a minimum of an objective function, possibly subject to
general constraints, and performs an error analysis. The concept of
errors is that of Minuit, so that it is the user's responsibility to
properly scale the inversed Hessian, and to properly interpret the
results. Both Hessian based errors and Minos errors are
implemented. Correspondingly, two types of function contours (or
confidence regions, in statistical problems) are available: elliptical
and Minos ones. Minos error analysis is, however, possible only for
bound constraint problems.

\par
On a longer timescale we are also following the STABLE Project,
which is funded by the European Commission and involves NAG and other
partners. The aim of the project is to design, build and demonstrate a
modern Statistical Application Building Environment.

\par
The STABLE project will integrate an existing application building
system, IRIS Explorer, and an existing widely used statistical
software system, Genstat, along with other available statistical
algorithms. The STABLE system will then be evaluated by constructing
end-user tools in different application areas.
\section{Overview of the HEP-specific components}

\par

Although commercial and public-domain packages offer a great deal
of functionality, there is a clear need to supplement them with
HEP-specific extensions. Some of these extensions take the form of
complete class-libraries, such as CLHEP. Others represent large
toolkits, such as \emph{GEANT-4} 
(see \url{http://wwwinfo.cern.ch/asd/geant/geant4.html}).
Moreover, in areas such as graphics and visualisation, the basic
tools, such as Open Inventor for basic graphics and IRIS Explorer for
visualisation, need to be extended to cope with the specific needs of
the HEP experiments.
\index{GEANT 4}%
\index{Open Inventor}%
\index{IRIS Explorer}%
\subsection{HEPODBMS}
\index{HEPODBMS|(}%

\par

HepODBMS is a set of class libraries built on top of the ODMG C++
interface. Their purpose is to provide a higher level interface than
is specified by the ODMG, to simplify the porting of existing
applications and provide a minimum level of support for
transient-persistent switching. Furthermore, these libraries help to 
insulate applications against  changes between releases from 
a given vendor and between the products of different vendors.
\index{ODMG}%
\index{HEPODBMS|)}%
\subsection{CLHEP}
\index{CLHEP|(}%

\par

The \emph{CLHEP} project (see
\url{http://wwwinfo.cern.ch/asd/lhc++/clhep/index.html}) was
initiated at CHEP'92; it intends to provide \emph{foundation
level} classes required in HEP. At present they include:

\begin{itemize}

\item \texttt{Alist} for lists and list iterators;
\item \texttt{Combination};
\item \texttt{Geometry} for vectors, rotations, transformations;
\item \texttt{Matrix} for matrix manipulations;
\item \texttt{Random} for random numbers;
\item \texttt{String} for different string types;
\item \texttt{Units} for system of units and physical constants;
\item \texttt{Vector} for vector operations (3-vector and Lorentz-type).\end{itemize}

\par

CLHEP became formally part of LHC++ in 1995. The first official release
of CLHEP (V1.0) took place in April 1997 (CHEP'97). CLHEP-based
classes will be integrated in the beta-release of GEANT 4 early 1998.
The complete user documentation, with a detailed description of 
all classes is being written and will be available by the end of 1997.
\index{GEANT 4}%
\index{CLHEP|)}%
\subsection{The HTL class library}

\par

The HTL class library provides Object Oriented histograms.
They come in two versions:

\begin{itemize}

\item Persistent histograms (based on Objectivity/DB)
\item Transient histograms (text file I/O)\end{itemize}

\par

For HEPExplorer (see below) the persistent version of the library is
needed, since HTL histograms are passed among IRIS Explorer Modules as
Objectivity/DB objects, identified by their object identifier (Objectivity/DB is used as
an \emph{object broker} by the IE modules).
\subsection{HEPInventor}
\index{HEPInventor|(}%

\par
\emph{HEPInventor} (see
\url{http://wwwinfo.cern.ch/asd/lhc++/dat/hepinventor.html})
proposes an easily understandable and user-friendly way to present
data in physics programs. It is implemented as a graphical class
library build on top of MasterSuite (TGS) to provide an interface
between data structures (like HTL) and graphics.
\index{MasterSuite}%
\index{HEPInventor|)}%
\subsection{HepVis}
\index{HepVis|(}%

\par

The goal of the \emph{HepVis Project} (see
\url{http://www.cern.ch/Physics/Workshops/HepVis/}) is to create
and distribute a toolkit library consisting of graphical objects
capable of representing the most common entities of a collider physics
experiment. Previous experience has shown that mere representations of
objects on a workstation screen is insufficient, and that native
support for picking objects with user-defined actions, and a
high-degree of interactivity, both local and global, is needed.
Therefore, the HepVis toolkit is being implemented as an extension to
Open Inventor, providing common physics objects as subclasses or as
real extensions.  Only the graphical representation of the objects
will be defined, leaving it up to the experiments to define physics
objects and their behaviour, and whether to integrate these with the
graphical objects in question.
\index{HepVis|)}%
\subsection{HEPExplorer}
\index{HEPExplorer|(}%

\par
\emph{HEPExplorer (HE)} is a set of HEP-specific IRIS Explorer
modules, which help a physicist set up an environment to analyse
experimental data, produce histograms, fit models and prepare data
presentation plots using LHC++'s IE framework. It is based on
HEPInventor, HTL, and HepODBMS.

\par

HEPExplorer consists of the following parts.

\begin{itemize}

\item 
\par
\emph{IRIS Explorer user types for HEP}
\par

In order to extend
the type of data that can be passed among IRIS Explorer Modules, new
data types have been defined to deal with HEP objects.

\item 
\par
\emph{IRIS Explorer HEP-specific modules}
\par

A set of HEP-specific IRIS Explorer modules is stored on AFS/Nice
and is available after setting up your environment in an appropriate
way. These modules allow for histogram handling and Ntuple-like
analysis.
\index{Ntuple}%
\end{itemize}

\par

Note that, since HE needs Objectivity/DB to store HTL histograms and their
associated schema, an Objectivity/DB database is a prerequisite for using
HEPExplorer with HTL.
\index{HTL}%
\index{HEPExplorer|)}%
\section{Problem tracking\label{S-GNATS}}

\par

LHC++ has been incorporated into the GNATS-based 
\emph{IT Problem Report Management
System} (\url{http://gnats.cern.ch/}), 
under the heading \emph{LHC++ Support Services}.

The Web interface is shown in Figure \ref{GNATS}.

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{gnats.eps}
\caption{LHC++ GNATS Web problem reporting system\label{GNATS}}
\index{GNATS}%
\index{Problem reporting}%
\end{figure}

\par

Users are invited to primarily use this system to submit problem
reports. This ensures that the problems are documented, can be easily
tracked, and also become available to other users, who can then browse
the problem database and profit from the proposed solutions.
\chapter{LHC++ Object Model\label{H1LHCPPObjectModel}}
\section{A historical digression: Ntuples and PAW}

\par

During the past decade, many HEP experiments  have based their
interactive data analysis on the following steps
(see the top half of Figure \ref{NTUPLETAGDB}).

\begin{enumerate}

\item \emph{Raw and reconstructed} data are stored in \emph{banks} in an
experiment-specific hierarchical format.  Most of the time one uses
many different files on several distinct hosts.

\item 
These data are \emph{distilled} and \emph{reclustered} to obtain a
more compact and thus more efficient representation. This permits a
significant speed-up for the down-stream analysis compared to using
the data in their raw form as described in point 1.  This format
corresponds to the so-called HBOOK Ntuples.  One drawback of this
method is that the direct relation to the raw \emph{event data} is
lost.
\index{HBOOK}%
\index{Ntuple}%

\item 
Ntuple files are analysed \emph{interactively} with programs
like PAW. Plots of physics variables are produced by extracting
information contained in one or more of the Ntuple rows or columns,
binning them in HBOOK histograms and then operating on these histograms
to obtain the best representation. 
\index{HBOOK}%
\end{enumerate}

\par

The advantage of Ntuples is that their format is known and simple enough, 
so that a general purpose analysis tool, such as PAW can cope with data
coming from any experiment. On the other hand, since no link to the
original data exists, Ntuples impose a limitation on the structure of
the data physicists can use for their analysis. On top of that, since
the data were copied from the original files into a dedicated Ntuple
file, each time original dataset changed most Ntuple files had to be
regenerated.
\index{Ntuple}%
\index{PAW}%

\par

Two kinds of Ntuples exists. \emph{Row-Wise Ntuples} transform a
complex data structure into a simple tabular form.  \emph{Column-Wise
Ntuples} on the other hand improve the flexibility of the Ntuple data
model by allowing the definition of variable-length items, but they
still are difficult to use to describe complex data structures, like
those of the reconstructed data.  Moreover, the Ntuple Query language
is rather non-intuitive and complex to master.
\section{The new Data Model\label{SNEWDATAMODEL}}

\par

Most new HEP experiments assume that it will be possible to make both
raw data and reconstructed data available \emph{on-line} thanks to
the integration between Objectivity/DB and HPSS. Each experiment will
have its own data model and physicists should be able to
\emph{navigate} through it. This is a major problem for a
general-purpose Interactive Analysis environment, since, unlike the
Ntuple case, there no longer exists a common and pre-defined data
model shared amongst all experiments. This problem can be solved but there
is no easy way out: the general-purpose tool should be able to access
the arbitrary experiment data model using some kind of run time type
information or the initial data model definition.
\index{HPSS}%
\index{Ntuple}%

\par

Since all data is supposed to be \emph{on-line}, the role of the Ntuple
replacement could be quite different. While reasonably small
\emph{personal} data collections will still exist, the main concern
will probably be how to index large event stores to speed up the
analysis. 

\par

The RD45 Project suggested one approach to deal with both problems.
The idea it to speed up queries by defining for each event a \emph{Tag}, 
i.e., a small collection of its most important physics attributes plus
an association with the event where the Tag data come from. Such
\emph{Concrete} Tags contain copies of data members of a 
persistent data class. A collection of tag objects 
is saved together in a Tag Database, something 
intermediate between an Event Directory and an Ntuple.
Since they are globally defined for the whole experiment, concrete
tags can be optimized so that they offer a very efficient way to make
initial cuts on attributes, thus achieving a high degree of
selectivity.  On top of that, at any moment you are able to cross the
association to the event if you want to retrieve any other details
about the full event, which are not contained in the Tag (see bottom
part of Figure \ref{NTUPLETAGDB}).
\index{Tag}%
\index{Event}%
\index{RD45 Project}%
\index{Event association}\label{sec:eventassociation}%
\index{Concrete tag}%
\index{Tag!concrete}%
\index{Tag!database}%
\index{Ntuple}%
\index{Event association}%

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{ntuple_tagdb}
\caption{The Ntuple and TagDB models\label{NTUPLETAGDB}}
\index{Tag}%
\index{Ntuple}%
\index{Data model}%
\index{Objectivity/DB}%
\begin{small}

\par

The \emph{top part} of the picture shows schematically the present
\emph{traditional} approach. The event data (raw, reconstructed
events, calibration constants, etc.) are represented at the left hand
side . They are distributed over many files residing on various hosts. 
An \emph{ad-hoc} program reads a set of interesting quantities in
these files and writes the retrieved information into an Ntuple file.
In this Ntuple file data are reclustered most of the time 
according to a simple table structure (more complex arrangements are,
of course, possible). As the Ntuple file format is known, 
interactive visualisation programs can efficiently
read these data files, thus allowing a fast and convenient
physics data analysis system to be set up. Note, however, that these
Ntuple files are completely disconnected from the original data, so
that it is impossible to automatically update in the Ntuple files
information which changes in the original. Also, it is
not possible to retrieve transparently from the original files data
which were not saved in the Ntuple when it was created.

\par

The \emph{lower part} of the picture shows what the situation looks like in
the Tag model. In this case often-used data are once more reclustered
(using experiment-wide concrete tags or user-defined generic tags),
but all data remain inside the same federated database, and
there exists a bidirectional link between the reclustered and the
original data. In this way, when the original data are reprocessed, it
is trivial to update the tag data, so that they remain always
up-to-date.  Conversely, when for a given event the information in the
tag database is not sufficient, then the link to the complete event data
allows you to retrieve the supplementary information in a convenient
and straighforward way \emph{on the fly}.
\end{small}
\index{Federated database}%
\index{Database}%
\index{Ntuple}%
\end{figure}

\par

In general the selection of \emph{key} attributes characterising 
events will be made by the experiment or group, so that concrete tags
are mostly defined for experiment-wide or
workgroup-wide data sets. However, individual physicists have
the possibility to define their own simpler data collection by using
the \emph{Generic Tag} mechanism. This second light-weight procedure
allows you to define a tag \emph{on the fly}, without creating a
persistent class. Compared to the concrete tag, there is, of course, a
small performance penalty, but this is most of the time balanced by
an increased flexibility, since at any time new fields can be added to
the tag and the association to the complete event data remains
available. Presently, both the concrete tag
and the generic tag are defined in a C++ program before being
used in the Interactive Analysis framework.
\index{Tag!concrete}%
\index{Event association}%
\index{Tag!concrete}%
\index{Concrete tag}%
\index{Generic tag}%
\index{Tag!generic}%
\section{Implementing the Data Model: explorable collections}

\par

When creating a tag (either generic or concrete) a description of its
fields (name and type) must be provided. This information is used
later to access the data. The set of individual
tags is called an \emph{Explorable Collection},
i.e., a collection of objects implementing an IRIS Explorer access
interface.
\index{Explorable collection}%
\index{IRIS Explorer}%
\index{Tag}%

\par

Explorable collections are data that you can analyse using
The principle of operation in described in 
Figure \ref{FIAM}.
HEPExplorer Interactive Analysis modules.
\index{Explorable collection}%

\begin{figure}\centering

\includegraphics[width=\linewidth, scale=.5]{interactive-analysis-map}
\caption{Principle of operation of Interactive Analysis Map\label{FIAM}}
\index{Tag}%
\index{Data model}%
\index{Objectivity/DB}%
\index{Explorable collection}%
\end{figure}

\par

To plot an histogram, you start by picking your explorable collection
using the Browser, and then define your cuts and histogram variables
using the Selector, before filling your Histogram.  Apart from
accessing the data in the tag, you are able to invoke C++ methods that
implement, e.g., common physics or access the experiment specific
event object (by traversing the association between a tag and its
related event). User-defined functions can be used whenever a C++
expression is allowed.
All these possibilities are explained in much more detail

in Section \ref{HEPExplorerexplorable}.
\index{Event association}%
\index{HEPExplorer}%
\index{Histogram!filling}%
\index{Explorable collection}%
\chapter{Setting up the user environment\label{H1SetUpUserEnvironment}}

\par

At the beginning of 1999 a central database service will be run for
the various experiments using Objectivity/DB. However, as we want users to be
able to test the LHC++ environment \emph{today} the Unix
installation procedure will presently create a database in your AFS
space \emph{on a given machine}. So, until your experiment will
have set up its central Objectivity/DB database server, you \emph{must}
always connect to that same machine if you want to access your
database. This inconvenience is only temporary and, apart from having
to connect to the given node, everything else is completely
transparent and all your C++ code will work unchanged in the future
configuration.
\index{AMS}%
\index{Objectivity/DB}%
\index{Database}%
\section{Installing for the first time}
\index{HEPExplorer!installation}%

\par
The HEPExplorer environment is essentially a combination of Objectivity/DB,
IRIS Explorer, and HEP-specific add-ons.  Therefore, you should first
check that the following preliminary conditions are met.\index{Objectivity/DB}%
\index{HEPExplorer}%
\index{IRIS Explorer}%

\begin{itemize}

\item Your computing platform is supported. At present it must be
one of the following:
HP-UX 10.20, Solaris 2.5 and 2.6, AIX 4.2, DEC UNIX 4.0, and
Windows/NT.
\item You have an IRIS Explorer licence (only relevant outside CERN, 
    since CERN has a site licence).
\item You have a licence for Objectivity/DB (Objectivity/DB licenses are managed by the
    experiments; see below).
\index{Objectivity/DB}%
\index{RD45 Project}%

\item At CERN, when on Unix, your host must be connected to AFS or for
    Windows/NT connected to Nice. Outside CERN, or on non-connected nodes at CERN,
    you must first get access to the distribution kit and then install it.
\index{AFS}%
\index{Nice}%
\index{Windows/NT}%
\end{itemize}

\par
At CERN, IRIS Explorer is available centrally and some Work Group
Servers.
\par
Thus, a prerequisite for using HEPExplorer is that you have access
to an Objectivity/DB database to contain your histograms and the proper schema
for the histogram classes.  If you do not yet have such a database set
up, you should contact your experiment's or group's Objectivity/DB coordinator,
who will take the necessary steps to register you for database use.
You will then be assigned a \emph{Federated Database IDentifier}
(FDID), to uniquely identify your federated database to the Objectivity/DB
servers. This number should be specified when first installing the
database environment, as described below.
\index{Registering for Objectivity/DB database use}%
\index{FDID}%
\index{Federated database!IDentifier (FDID)}%

\par

Once you are registered for use of the database, and you know your
unique database identifier \texttt{MY_FDID}, you can install the
database and the other parts of HEPExplorer. This mainly involves
copying something from the AFS or Nice space to your account, and
setting some environment variables.

\par

The initial installation procedure does not require user
intervention. Whenever there's a choice and no further information is
provided, a reasonable default that should be satisfactory for most
users will be selected.
\subsection{Unix-specific procedures}

\par

To fully install the different components you need to use
HEPExplorer you should merely type two commands (the first defines 
your FDID, the second starts the intallation).

\begin{itemize}

\item csh flavour

\begin{verbatim}
  setenv MY_FDID 99999 
  source /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.csh
\end{verbatim}

\item ksh flavour

\begin{verbatim}
  export MY_FDID=99999
  . /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.ksh
\end{verbatim}
\end{itemize}

\par

Here the number \texttt{99999} is an invalid value (chosen on
purpose).  

\par
We have chosen the ksh variant while being logged on to the machine
\texttt{hpplus16} (this is important, since to use the database we
shall have to log in to this same node later). The following log shows
the various steps in the installation script.
\begin{alltt}
>\emph{. /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.ksh}
Installing IRIS Explorer user datatypes
Removing old types
Please wait...
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \bs
   genericOid.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \bs
   histOOgram.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \bs
   hepExplorable.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \bs
   hepSharedLibName.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \bs
   ObjyContainer.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
Installing IRIS Explorer DataFit environment
Removing old DataFit environment
Please wait...
Installing HepExplorer Interactive add-ons
IE add-ons installed

Objectivity/DB (TM) Lock Server Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1989, 1996. All rights reserved.

Lock Server is already running.
Installing HTL database: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP using FDID:  30500
get db from HISTO (new name will be HEPEXP)
End of HTL database installation

Making your startup script
Removing old startup script

***********************************************************
Your setup script is ~/$OS/hepexp.ksh
Don't forget to source it in your .profile script
***********************************************************
\end{alltt}
\index{login@{\texttt{.login} file}}%
\index{profile@{\texttt{.profile} file}}%

\par

Let us have a look at what the installation script did (\emph{if you are
not interested in this, you can skip this paragraph; however, you
should still verify the last part of the output, as we shall explain
below.}) The installation script starts by copying IRIS Explorer related
information, such as types, include files, man pages, DataFit 
and HEPExplorer files, into your IRIS Explorer directory (defined
with the \texttt{EXPLORERUSERHOME} environment variable).
Then it installs the Objectivity/DB database, in the \texttt{explorer} subdirectory
(\texttt{/afs/cern.ch/user/g/goossens/HP-UX/explorer} in our case).
The boot file is called \texttt{HEPEXP}, the federated database
itself \texttt{HEPEXP.FDDB} (see the directory listing below).\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\begin{verbatim}
-rw-r--r--   1 goossens   dl             241 Oct 29 17:56 HEPEXP
-rw-rw-r--   1 goossens   dl         2080768 Oct 29 17:57 HEPEXP.FDDB
\end{verbatim}

\par

It is the environment variable \texttt{OO_FD_BOOT}, containing
the full path name of the boot file, which will be used by Objectivity/DB to
get access to the database in subsequent sessions. Note that we have
specified our unique federated database identifier which we got from
our database administrator by setting the \texttt{MY_FDID}
variable (the value used was \texttt{30500}, which should
\emph{NEVER} be used by anybody else).  Now that the database is
set up, a small test program is copied to the
\texttt{explorer} directory, compiled and run.

\par

It is \emph{important} that everybody checks whether the output
generated at the end of the installation corresponds to the lines
shown above. Also, the startup script (\texttt{hepexp.ksh}
above) will be prepared. This small script defines a set of
environment variables for IRIS Explorer, the
\texttt{OO_FD_BOOT} variable, identifying the Objectivity/DB boot file,
and checks whether you are logged in to the same node as where the
database was created (\texttt{hpplus16} in the example).

\par

You \emph{must} execute this small shell script 
every time you login on the system as described below.

\begin{itemize}

\item 
\par
\emph{csh flavour}: the file is named
\texttt{~/$OS/hepexp.csh} and you should add to your
\texttt{.login }script the following line:

\par
\texttt{source ~/$OS/hepexp.csh}
\item 
\par
\emph{ksh flavour}: the file is named
\texttt{~/$OS/hepexp.ksh} and you should add to your
\texttt{.profile }script the following line:

\par
\texttt{. ~/$OS/hepexp.ksh}\end{itemize}

\par
\emph{If you forget to update your startup script
(\texttt{.login} or \texttt{.profile}) you will not be
able to use any HEPExplorer component on your next login. On top of
that, to have the environment variables initialized correctly, you
must logout and then login again.}\index{login@{\texttt{.login} file}}%
\index{profile@{\texttt{.profile} file}}%
\subsection{Windows/NT-specific procedures}

\par
In order to keep as many similarities as possible between the NT
and Unix versions, we also chose to use Unix tools on Windows/NT (e.g.,
\texttt{gmake}), rather than go for a \emph{native}
version. This policy could change in the future, according to general
guidelines for multiplatform support agreed with the experiments.
\subsubsection{Unix utilities on NT}

\par

The present general policy of IT division is to use the utilities
provided by Cygnus (see \url{http://www.cygnus.com}).  They
are installed on Nice and provide the most common GNU/Unix
tools, such as, \texttt{gmake}, \texttt{bash},
\texttt{tar}, etc.  Users have the choice to work with GNU's
\texttt{bash} shell, or Windows/NT's native \texttt{cmd}
shell.
\subsubsection{Locating the LHC++ components on Nice}

\par

The directory structure of the LHC++ installation tree on Nice
mimics the structure of Unix on AFS as closely as possible.

\par

In particular, when procedures and examples for Unix in this guide
refer to the path \texttt{/afs/cern.ch/sw/lhcxx}, then on
Nice the equivalent path is \verb|Z:\P32\lhcxx|. This applies
to libraries, include files, etc. Moreover, uses of the environment
variable \texttt{LHCXXTOP}, which refer to the above path, on
Windows/NT map to \verb|%LHCXXTOP%| with the \texttt{cmd}
shell, and remain unchanged \texttt{$LHCXXTOP} with the
\texttt{bash} shell.
\subsubsection{Running the installation scripts}

\par

Although the environment is installed on Nice disk servers, we do
not use Nice menus and scripts to access LHC++ components at
present. We follow a Unix-like approach where the LHC++ applications
are executed inside an environment that is setup by a script.  This
allows quick and easy customization of the users' environment without
touching the general PC configuration.

\par

Details on how to install LHC++ on your Windows/NT system are
available in the following file on Nice.

\begin{verbatim}
\P32\lhcxx\specific\windows_NT\Hepexplorer\dev\install\install_NT.txt
\end{verbatim}
\section{Full re-installation procedure on Unix}

\par

If you already had an Objectivity/DB database before, and want to reinstall
everything, you must clean up your environment first. Thus, if you
have any environment settings related to Objectivity/DB or IRIS Explorer you
should remove them (you can still customise your environment later).
Please check that your \texttt{PATH} environment variable and
the shared library path environment variable
(\texttt{SHLIB_PATH} or \texttt{LD_LIBRARY_PATH} or
\texttt{LIBPATH}, depending on your Unix flavour) contain
just the minimum needed for your current needs.
\index{Shared library}%
\section{Customising the installation procedure on Unix}

\par

The installation procedure can be customised to provide different
locations for your IRIS Explorer home directory and for the Federated
Database.
\index{Federated database}%
\index{Database}%
\index{Data model}%
\index{Objectivity/DB}%

\begin{itemize}

\item 
\par

To define a different IRIS Explorer home directory set the 
\texttt{EXPLORERUSERHOME} environment variable, e.g.,

\par
csh flavour
\begin{verbatim}
  setenv EXPLORERUSERHOME ~/explorer
\end{verbatim}

\par
ksh flavour
\begin{verbatim}
  export EXPLORERUSERHOME=~/explorer
\end{verbatim}

\item 
\par

To define a different location for your \emph{starter} Federated
Database set the \texttt{OO_FD_BOOT} environment variable,
e.g.,\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\par
csh flavour
\begin{verbatim}
  setenv OO_FD_BOOT ~/myfd/MYFDNAME
\end{verbatim}

\par
ksh flavour
\begin{verbatim}
  export OO_FD_BOOT=~/myfd/MYFDNAME
\end{verbatim}
\end{itemize}

\par

By defining more environment variables the installation procedure
can be instructed to skip part of the installation.

\begin{itemize}

\item 
\par
To skip the HEPExplorer setup (user types and fitting add-ons) set
the \texttt{NO_INSTALL_HEPEXP} environment variable, e.g.,
\par
csh flavour
\begin{verbatim}
  setenv NO_INSTALL_HEPEXP 1
\end{verbatim}

\par
ksh flavour
\begin{verbatim}
  export NO_INSTALL_HEPEXP=1
\end{verbatim}

\item To skip the installation of the \emph{starter} Federated
Database set the \texttt{NO_INSTALL_HISTODB} environment variable,
e.g.,
\index{Federated database}%
\index{Database}%
\index{Data model}%
\index{Objectivity/DB}%

\par
csh flavour
\begin{verbatim}
  setenv NO_INSTALL_HISTODB 1
\end{verbatim}

\par
ksh flavour
\begin{verbatim}
  export NO_INSTALL_HISTODB=1
\end{verbatim}
\end{itemize}
\section{Check list on Unix}
\index{Check list}%

\par
Right after logging in you should check that there are no warning
messages generated by the HEPExplorer startup script. In particular,
check whether you have no message of the type:
\begin{verbatim}
HEPExplorer message: you logged in on the wrong node
Please logout and login again on hpplus16
\end{verbatim}

\par
In this case, the original database was created on the node
\texttt{hpplus16}, so that only from that node you can read and
modify the database.
\par
Similarly, using the \texttt{env} command, check that the following
environment variables are set (correctly):
\begin{itemize}

\item \texttt{OO_FD_BOOT}
\item \texttt{EXPLORERHOME}
\item \texttt{EXPLORERUSERHOME}\end{itemize}

\par
If one of them is not set, then it is very likely that you forgot
to update your startup script (check your \texttt{.login} or 
\texttt{.profile} file).\index{login@{\texttt{.login} file}}%
\index{profile@{\texttt{.profile} file}}%
\subsection{Installation troubleshooting}
\index{Installation!troubleshooting}%
\index{Troubleshooting}%

\par

Installation procedure failure is usually due to one of the following
reasons.

\begin{itemize}

\item \emph{Missing access rights to the Objectivity package.}
In this case the installation exits with an error message and you should
get your Objectivity licence before trying again.

\item \emph{Lockserver running in autorecovery mode.}
Use the Unix \texttt{ps} command to find out the lockserver's running mode:

\begin{verbatim}
ps -ef | grep ools
\end{verbatim}

If you see something like:

\begin{verbatim}
dinofm 20536 1 0 Oct 27 ? 1:37 ools
\end{verbatim}

restart the lockserver in the proper mode:

\begin{verbatim}
> ookillls
> oolockserver -noautorecovery
> ps -ef | grep ools
\end{verbatim}

where the \texttt{ps} command should show something like:

\begin{verbatim}
dinofm 20536 1 0 Oct 27 ? 1:37 ools -OO_NO_AUTOREC
\end{verbatim}

\item \emph{Polluted environment.}
If your installation fails and you retry 
a reinstall immediately, there might still be some
environment variables set from your previous try. Therefore,
if your installation fails, it is advisable to logout and login again 
to try and install the system once more.
\end{itemize}
\chapter{Accessing the Objectivity/DB database\label{H1AccessOBJDatabase}}
\section{What does the user have to know about the database?}

\par

Ideally, the hierarchical structure of the data storage should be
completely transparent to the average user. Therefore, the LHC++ Team
has done its best to hide the impact of the database on the C++
user code to a minimum. However, it is best that the users of the
modules are aware of some basic principles, and how they relate to the
experimental data model used by the various analysis programs.

\par

Let we have a look at Figure \ref{STORAGEUSER}.
It shows the storage hierarchy used to store event data at the
left, together with the user's view of these data at the right.

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{storage_user}
\caption{The storage hierarchy and the user view\label{STORAGEUSER}}
\end{figure}

\par

We start with the user's view (right hand side of the picture).
The user likes to think in terms of events (the octagons), and wants
to deal with, for instance reconstructed tracks (the triangles), hits in
the forward calorimeter (the diamonds), or the calibration for the TPC
(the pentagons), etc. Users should not be directly concerned (apart
perhaps for efficiency considerations) how these various data elements
are actually stored in files and distributed over a network. They
prefer to have a \emph{logical} view of their event and navigate
between its various componenents in a transparent way. It is up to the
data administrator to make sure that the data are stored in a way
optimising performance and throughput for the end user.

\par

This is possible using an object oriented database system, such as
Objectivity/DB (left hand side of the picture). All data are kept in one
\emph{federated database}, which is basically just a file containing
the catalog of the database files and the hostnames where they
reside. It also contains the \emph{schema} (object model) used by
the data in the various databases.
\index{Federated database}%
\index{Database}%
\index{Schema}%

\par

The \emph{databases} themselves are also separate files, which can
reside on different nodes and they can consist of multiple
\emph{containers}, that can be thought of a contiguous areas on a
file.
\index{Data model}%
\index{Container}%
\index{Objectivity/DB}%

\par

Finally, each container consists of one or more \emph{persistent}
objects (e.g., histograms, reconstructed tracks, fits). As seen in the
picture, the mapping of the event to its components is very flexible,
allowing different parts of an event to reside in different
containers, and/or databases (even on remote nodes). Moreover, since
the end users only access the full data through the logical structure,
they are never affected by changes in the physical layout of the
database.
\section{Getting access to an Objectivity/DB database}

\par

In 1999 a central service will be run for the various experiments using Objectivity/DB
to provide access to their databases
from various platforms using AMS. However, at present, it is necessary to
associate a federated database with a given machine, so that you must
always connect to that same machine if you want to access that
database.
\index{AMS}%
\index{Objectivity/DB}%
\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\par

In particular, when working on a cluster (such as hpplus) you must
remember the real node name (e.g., \texttt{hpplus16}, as in the
example in the previous chapter) of the machine which you used to
create the database.  When you want to use the database in a later
session, you must always connect to that node, otherwise you will not
be able to access your data (unless your experiment is running Objectivity/DB's
AMS, a facility to share databases
across the network).\index{Objectivity/DB}%

\par

The first step (after creating the database) is to tell Objectivity/DB
where it can be found. This is done with the environment variable
\texttt{OO_FD_BOOT}, which should be set to the full path name
of the boot file of the database that you want to access.  This boot
file is actually a small ASCII file, which contains valuable
information about your federated database.
\index{OOFDBOOK@{\ttfamily OO_FD_BOOT}}%
\index{Objectivity/DB}%
\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\begin{verbatim}
> more $OO_FD_BOOT 
ooFDNumber=30500
ooLFDNumber=65535
ooPageSize=8192
ooLockServerName=hpplus16
ooFDDBHost=hpplus16
ooFDDBFileName=/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
ooJNLHost=hpplus16
ooJNLPath=/afs/cern.ch/user/g/goossens/HP-UX/explorer
\end{verbatim}

\par
You should \emph{NEVER} change its contents!
\par

In particular, changing the path of the federated database in this
file after you moved it will \emph{not} work.
\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\par

Once the \texttt{OO_FD_BOOT} variable is set correctly, you can
run the Objectivity/DB management tools. For instance the program
\texttt{oodumpcatalog} displays the catalog, showing the different
databases associated to the current federated database.
\index{oodumpcatalog@{\ttfamily oodumpcatalog}}%
\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\begin{verbatim}
> oodumpcatalog

Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.

FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16

DB Name   = SimpleTestDatabase
DB ID     = 3
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/SimpleTestDatabase.HEPEXP.DB
\end{verbatim}

\par

Thus, in the example above, we see that we need to connect to the node
\texttt{hpplus16} (the so-called \emph{Lock Host}).  It should also
be noted that each federated database should have a different
federated database number to enforce proper locking management when
the same lockserver is used by more than one federation (e.g., when
the lockserver is running on a central service, such as hpplus).  A
series of federated database numbers have been allocated to
experiments and user groups (a proposed list can be found at the URL 
\url{http://wwwinfo.cern.ch/asd/cernlib/rd45/recommendations/dba.html}
). As explained above, when registering as
a database user with your experiment's or group's Objectivity/DB's coordinator,
you get a unique number assigned to ensure the uniqueness of the
federated database number.
\index{RD45 Project}%
\index{Federated database}%
\index{Database}%
\section{Accessing the Objectivity/DB from inside a C++ program\label{H2AccesssOBJ}}

\par
After the initial installation, you have a federated database,
which has no associated databases yet. This can
be seen by using the Objectivity/DB tool \texttt{ootoolmgr} (\texttt{oobrowse}
on Windows/NT), which allows you to browse the contents of all
databases (down to the object level) in a federated database.  If you
want to run \texttt{ootoolmgr} just type

\begin{verbatim}
> ootoolmgr
\end{verbatim}

on the command line. You will then get an Objectivity/DB panel, as shown
in Figure \ref{OOTOOLMGRPANEL}.
\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%
\index{ootoolmgr@{\ttfamily ootoolmgr}}%

\begin{figure}\centering

\includegraphics[width=.5\linewidth, scale=.5]{ootoolmgrpanel}
\caption{The \texttt{ootoolmgr} initial panel\label{OOTOOLMGRPANEL}}
\end{figure}

\par
Then in the \texttt{File} pull-down menu you choose the
database (most of the time it is enough to click the default setting
at the bottom, which corresponds to the database selected with the
\texttt{OO_FD_BOOT} environment variable). Then you can go to
the \texttt{Tools} pull-down menu and choose \texttt{Browse
FD} at the top. Then you will see the \texttt{Objectivity/DB - Browse
FD} appear, with four main windows, namely the names of the
\emph{Databases}, \emph{Containers}, \emph{Basic
Objects}, and finally, at the bottom, the contents of the
selected object. Just after initialisation, there are no databases
yet, as seen in Figure \ref{OOTOOLMGREMPTY}.

\begin{figure}\centering

\includegraphics[width=.5\linewidth, scale=.5]{ootoolmgrempty}
\caption{Using the tool \texttt{ootoolmgr}\label{OOTOOLMGREMPTY}}
\index{ootoolmgr@{\ttfamily ootoolmgr}}%
\end{figure}

\par

Before writing our first C++ program to use the database, let us
first establish three basic rules.

\begin{enumerate}

\item 
One must first establish a connection to the database with the
\texttt{Init} method.
\index{init@{\texttt{Init}} method (HEPODBMS)}%
\index{HEPODBMS!methods!init@{\texttt{Init}}}%

\item \emph{Transactions} are used to retrieve or store persistent
objects.
\index{Objectivity/DB!transaction}%

\begin{itemize}

\item 
A transaction is set up using the \texttt{startUpdate}
or \texttt{startRead} methods.
\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
\index{startread@{\texttt{startRead}} method (HEPODBMS)}%
\index{HEPODBMS!methods!startread@{\texttt{startRead}}}%

\item 
A transaction is terminated using the \texttt{commit}
or \texttt{abort} methods. The \texttt{commit} method
will save all changed objects in the database, whereas  \texttt{abort}
will revert the database to the state before the transaction was
initiated.
\index{Objectivity/DB!transaction}%
\index{commit@{\texttt{commit}} method (HEPODBMS)}%
\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
\index{abort@{\texttt{abort}} method (HEPODBMS)}%
\index{HEPODBMS!methods!abort@{\texttt{abort}}}%
\end{itemize}

\item 
To access persistent objects \emph{smart} pointers are provided.
They are indistinguishable from normal C++ pointers, they are merely
declared with a different syntax using \texttt{HepRef}, e.g.,
for a 1D histogram we would declare
\index{Smart pointer}%

\begin{verbatim}
HepRefP(Histo1D) myHisto (...);
\end{verbatim}

while for a pointer to a non-persistent C++ object you would write

\begin{verbatim}
Histo1D *myHisto ...
\end{verbatim}

Once you have declared your smart pointers to your persistent object,
all navigation between objects is completely like in the case of
normal pointers; whenever a reference is made to a smart pointer, a
callback to the database will automatically fetch the required
data. Moreover at the end of the transaction all modified objects will
automatically be stored in the database at commit time.
\index{Objectivity/DB!transaction}%
\end{enumerate}

\par
If, while reading through the examples, you want to know more
details about the HepODBMS classes, you can have a look at the
\emph{Class Reference Guide} at the URL
\url{http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/reference-manual/HepODBMS.html}.
\section{Manipulating the Objectivity/DB database and its containers in a C++ program}

\par

To show a few more of the class methods available to manipulate an
Objectivity/DB database, we can look at the following code.
\begin{listing}

/* dbAccess.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepEvent.h"

class dbAccessApp : public HepTagDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  dbAccessApp(const char *name) : HepTagDbApplication(name)
  {};
  
  int run()
  {
    // print an 
    message("about to initialise the db connection");
    Init();        // initialise the db session
    message("starting an update transaction");
    startUpdate(); // start an update transaction

    // create a new database (file)
    HepDatabaseRef  myDb = db("MyDatabase");

    // if the database ref is not valid:
    // - print a message
    // - exit the application with an error code 
    if (myDb == 0)
      fatal("could not find or create MyDatabase");
    
    // create a new container in this database
    HepContainerRef cont = container("MyContainer"); 
    if (cont == 0 )
      fatal("could not find or create MyDatabase");

    // work with the container and database
    // (e.g. create histograms, tags or other persistent objects)
      
    for (short i=0; i<1000; i++)
    {
      // create a new event in my container
      HepRef(HepEvent) event = new(cont) HepEvent;
      if (event == 0) 
        fatal("could not create a new event");
    }
    message("created 1000 events");

    printContainerMap( ) ;

    // delete the container from the database
    // including all events
    HepDelete(cont);
    warning("deleted the container");

    // delete the database from the federation
    HepDelete(myDb);
    warning("deleted the database");

    // commit all changes made during this transaction
    commit();
    return 0;
  }
  
};

int main(int argc, const char *argv[])
{
  dbAccessApp myApp(argv[0]);  // create an application object
  return myApp.run();    // call it's run method
}
\end{listing}
\index{hepdbapplication@{\texttt{HepDbApplication}} class (HEPODBMS)}%
\index{HEPODBMS!classes!hepdbapplication@{\texttt{HepDbApplication}}}%
\index{commit@{\texttt{commit}} method (HEPODBMS)}%
\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
\index{init@{\texttt{Init}} method (HEPODBMS)}%
\index{HEPODBMS!methods!init@{\texttt{Init}}}%
\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
\index{fatal@{\texttt{fatal}} method (HEPODBMS)}%
\index{HEPODBMS!methods!fatal@{\texttt{fatal}}}%
\index{warning@{\texttt{warning}} method (HEPODBMS)}%
\index{HEPODBMS!methods!warning@{\texttt{warning}}}%
\index{message@{\texttt{message}} method (HEPODBMS)}%
\index{HEPODBMS!methods!message@{\texttt{message}}}%
\index{HepDelete@{\texttt{HepDelete}} method (HEPODBMS)}%
\index{HEPODBMS!methods!HepDelete@{\texttt{HepDelete}}}%
\index{printcontainermap@{\texttt{PrintContainerMap}} method (HEPODBMS)}%
\index{HEPODBMS!methods!printcontainermap@{\texttt{PrintContainerMap}}}%

\par

The \texttt{HepDbApplication} class defines the transaction methods 
\texttt{abort}, \texttt{commit}, \texttt{startRead}, 
\texttt{startUpdate} (described already in Section
\ref{H2AccesssOBJ}),
as well as four methods for sending an informative string to the
user console: \texttt{fatal} (prints a fatal error message and
aborts), \texttt{error} and \texttt{warning},  (prints an 
error and warning message and continue), and
\texttt{message} (just prints a message).
\index{Objectivity/DB!transaction}%
\index{hepdbapplication@{\texttt{HepDbApplication}} class (HEPODBMS)}%
\index{HEPODBMS!classes!hepdbapplication@{\texttt{HepDbApplication}}}%
\index{abort@{\texttt{abort}} method (HEPODBMS)}%
\index{HEPODBMS!methods!abort@{\texttt{abort}}}%
\index{commit@{\texttt{commit}} method (HEPODBMS)}%
\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
\index{startread@{\texttt{startRead}} method (HEPODBMS)}%
\index{HEPODBMS!methods!startread@{\texttt{startRead}}}%
\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
\index{fatal@{\texttt{fatal}} method (HEPODBMS)}%
\index{HEPODBMS!methods!fatal@{\texttt{fatal}}}%
\index{warning@{\texttt{warning}} method (HEPODBMS)}%
\index{HEPODBMS!methods!warning@{\texttt{warning}}}%
\index{message@{\texttt{message}} method (HEPODBMS)}%
\index{HEPODBMS!methods!message@{\texttt{message}}}%
\index{error@{\texttt{error}} method (HEPODBMS)}%
\index{HEPODBMS!methods!error@{\texttt{error}}}%

\par

The \texttt{HepDatabaseRef} declaration sets up a database handle
\texttt{myDb} using the \texttt{db} method from the \texttt{ooSession}
class. Once we have opened a database, we declare a container with
\texttt{HepContainerRef}, which returns us a handle \texttt{cont}
using the \texttt{container} method from the \texttt{ooSession}
class. The container handle is then used to store one thousand events
of type \texttt{HepEvent} inside the \texttt{for} loop. Just before we
delete our database we print a map of the containers with the
\texttt{printContainerMap} method, which shows the containers together
with their object identifiers (the \texttt{HepSystem} and
\texttt{ExplorableDescr} containers are created when HEPODBMS is set
up in the \texttt{System} database).  Finally, we delete the container
and database by specifying their respective handles to the
\texttt{HepDelete} method. Below, the output generated by the above
C++ code is shown.

\begin{verbatim}
dbAccess: about to initialise the db connection
dbAccess: starting an update transaction
dbAccess: created 1000 events
HepSystem --- #3-4-3-1
ExplorableDescr --- #3-5-3-1
MyContainer --- #12-3-1-1
WARNING: dbAccess: deleted the container
WARNING: dbAccess: deleted the database
\end{verbatim}
\section{Objectivity/DB administration tools}

\par

Objectivity/DB provides a whole set of administration tools to manage a
federated database. These tools are described in detail in the
\emph{Objectivity/DB Administration} manual. In this section we briefly
describe the more useful from the physicists' point of view.

\begin{itemize}

\item \texttt{oodumpcatalog} provides summary information about a
    federated database;
\index{oodumpcatalog@{\ttfamily oodumpcatalog}}%
\index{Objectivity/DB}%

\item \texttt{ootoolmgr} (\texttt{oobrowse}
    on Windows/NT) allows you to browse federated database schema and
    data;
\item \texttt{oocleanup} resets pending locks;
\item \texttt{oodeletedb} deletes a \emph{physical} database.\end{itemize}
\chapter{Histogram and tag classes\label{H1HistogramTagClasses}}

\par

All classes are being documented and a user guide and
reference manual for the available components will be available soon.
In this chapter we shall describe the main characteristics of the
HTL classes and also learn about the tag classes. 
As explained before, ready-to-run examples can be found in the 
following two directories.

\begin{verbatim}
$LHCXXTOP/share/HepODBMS/pro/HepODBMS/examples
$LHCXXTOP/share/HTL/pro/HTL/examples/
\end{verbatim}

\par

As already explained in the preface at the beginning of the 
document, each
example has its own subdirectory (corresponding to the first part
of the filename, i.e., preceding the suffix \texttt{.cpp}, specified
as a comment on the first line of the examples' C++ code in this
manual), which contains the C++ source code in a file with extension
\texttt{cpp}, as well as a \texttt{GNUmakefile} which will compile,
link and generate an executable if run with \texttt{gmake}. These
example programs should form an excellent basis to get started writing
your own application programs.
\index{Examples!location}%
\index{Examples!running \~{}}%
\section{The HTL package\label{PERSISTENTHISTOS}}

\par

The Persistent HTL Package provides the basic histogramming
functionality of HBOOK along with some additional features.
See the \url{http://wwwinfo.cern.ch/asd/lhc++/HTL/index.html}
for more details.
\index{HBOOK}%
\section{Converting an HBOOK file into an Objectivity/DB database}
\index{HBOOK}%

\par
The program \texttt{Hbook2Objy}
converts histograms contained in an HBOOK file into persistent HTL
histograms that can be saved in an Objectivity/DB database. Only one- and
two-dimensional histograms are converted, Ntuples are ignored. To
execute the program you should type:
\begin{verbatim}
Hbook2Objy <hfile> <OBJ-federated-DB>
\end{verbatim}

\par

Starting from the histograms in the HBOOK file \texttt{<hfile>}
the program will create a new database with as name the name of the
HBOOK file \texttt{<hfile>} inside the Objectivity/DB database pointed at by
the environment variable \texttt{OO_FD_BOOT}.  If \texttt{<hfile>}
already exists, then you will be asked whether you want to overwrite 
the original file.
\index{Federated database}%
\index{Database}%
\index{Objectivity/DB}%

\par
It should be noted that the hierarchical (directory) structure of
the HBOOK file is not preserved. Nevertheless, since the name of each
created persistent histogram corresponds to the full path name inside
the HBOOK hierarchy, it is easy to distinguish between histograms with
the same name but coming from different HBOOK directories.  An example
of the translation of a set of HBOOK histograms is shown 
in Figure \ref{PAW2HISTOO}.

\begin{figure}\centering

\begin{tabular}{c}

\includegraphics[width=.8\linewidth, scale=.5]{H2OPaw}
\\

\includegraphics[width=.8\linewidth, scale=.5]{H2OHistOOReader}
\\

\end{tabular}
\caption{Transforming HBOOK histograms into HTL histograms\label{PAW2HISTOO}}
\index{HBOOK}%
\begin{small}

\par

At the top we see some (1D and 2D) histograms with the HBOOK Directory
Browser, and at the bottom the same histograms after conversion as
viewed from the Objectivity/DB database with the \emph{HistOOgramReader}
module.
\end{small}
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\end{figure}
\section{The tag classes}
\index{Tag|(}%
\subsection{Explaining the environment}

\par
The following \texttt{gmake} file supposes the Objectivity/DB database and
IRIS Explorer path and environment variables have been set up for
the current session.
\begin{verbatim}
# GNUmakefile for createTag example
# Dirk Duellmann

HEP_ODBMS_DIR=/afs/cern.ch/sw/lhcxx/specific/@sys/HepODBMS/development
include $(HEP_ODBMS_DIR)/etc/HepODBMS.mk

APPL       = createTag
SRCS       = $(APPL).cpp 
OBJS	   = $(OS)/$(APPL).o

all : $(APPL)

$(APPL): GNUmakefile
	$(C++) $(C_FLAGS) -o $(APPL) $(OBJS) $(HEP_ODBMS_LIBS) $(OBJY_LIBS) $(RWTOOL_LIBS)
\end{verbatim}
\subsection{Writing tags}

\par
As explained earlier (see Section \ref{SNEWDATAMODEL}),
tags are a small collection of the most important physics attributes
of an event plus an association with the event in question.  Tags
provide a natural and efficient syntax for handling event data,
speeding up queries, cuts handling, etc., substantially, while at the
same time offering the possibility to easily access the original full
data. Usually, the event tags are chosen in such a way that a high
degree of selectivity can be obtained by first cutting on attributes
in the event tag, while, if needed, the association to the full event
can be exploited in order to retrieve any other information not
contained in the tag.\index{Event association}%
\index{Event association}%

\par
In workgroup-wide data sets, individual physicists should still be
able to have their own simpler data collection, so an easy-to-use
\emph{Generic Tag} is defined as well.  Presently, both the Event Tag 
and the Generic Tag have to be created inside a C++ program before using
the Interactive Analysis framework.\index{Tag!generic}%

\par

The data types that can be stored in a tag are \texttt{long} and
\texttt{short} integers, \texttt{float} and \texttt{double} real
numbers, and an 8-bit \texttt{char}. These types are recognised by the
\emph{HepExplorableBrowser} module
(see Figure \ref{HEPEXPBROWSER})
which lets you browse and select explorable collections and their tags.
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
\index{Explorable collection}%

\par

Examples of the use of tags are given in the HEPODBMS manual (see the
URL \url{http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/user-guide/H1CollectionsTags.html}
for more details).
\index{Tag|)}%
\subsection{Converting HBOOK Ntuples to Objectivity/DB}

\par

The LHC++ environment provides tools to convert existing HBOOK Ntuples
to Objectivity/DB. 
At the URL \url{http://wwwinfo.cern.ch/asd/lhc++/HepExplorer/ntkit/ntupleconv.html}
you can find more details.
\chapter{HEPExplorer Modules\label{H1HEPExplorerModules}}
\index{IRIS Explorer|(}%
\index{HEPExplorer|(}%
\section{Starting IRIS Explorer}

\par

The environment variables needed to run the IRIS Explorer
components and get access to the relevant libraries and auxiliary
files have been setup on the central systems at CERN. Moreover, since
the HEP components use the Objectivity/DB database, you should have been
registered by your experiment for using that database (see the
previous chapter to find out how to handle Objectivity/DB database files).

\par

Once your environment is set correctly, you can start up IRIS Explorer
by just typing \texttt{explorer}. You should then get a layout
of windows on your workstation as shown in Figure 
\ref{IRISEXPLORER}.

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{irisexplorer}
\caption{IRIS Explorer startup screen\label{IRISEXPLORER}}
\end{figure}

\par

You see three large components on your screen. First, at the left
we have the list of IRIS Explorer modules, the \emph{Librarian}. 
In fact, in the figure we chose to highlight the HEP Explorer
modules, which will be described below. It should be noted that
several tens of IRIS Explorer modules come with the basic system,
and many more can be obtained from various public archives.
\index{Librarian@{\emph{Librarian} window}}%
\index{IRIS Explorer!Librarian@{\emph{Librarian} window}}%

\par

The larger part of the screen is occupied by the \emph{Map Editor}.
This is where the user builds or modifies maps, connects modules
together, or interacts with the various modules in the map.
\index{Map editor@{\emph{Map Editor} window}}%
\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
\index{Map}%
\index{IRIS Explorer!map}%

\par

Finally, just below the \emph{Map Editor} you have the \emph{Explorer
Log} window, where messages coming from IRIS Explorer modules
are displayed.  
\index{Explorer Log@{\emph{Explorer Log} window}}%
\index{IRIS Explorer!Explorer Log@{\emph{Explorer Log} window}}%
\subsection{ For first time users of IRIS Explorer  }

\par

If this is the first time that  you are using Iris Explorer (IE), there are
several choices open to you.  You can jump straight into the examples which
follow.  Since the IE interface is intuitive, you will probably learn
your way around quite quickly.  We provide below some hints which may
nevertheless be useful for beginners.  

\par

Either before or after your first trials, you may be interested in
some more formal Web-based guidance concerning IE.  There are two such
tutorials accessible from CERN.  One, supplied by NAG, is rather
complete and thorough, and gives you a quick tour of most
possibilities of IRIS Explorer.  It is available 
\url{http://www.nag.co.uk/0/visual/IE/iecbb/Tutorial/index.html}
The other, supplied by the University of Leeds, provides more of an
overview, and might be more suitable for physicists. It can be found 
\index{IECOE!IRIS Explorer Centre of Excellence}%

at the URL
\url{http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html}.
\index{NAG}%

\par
 
The following knowledge can be useful for beginners.  By default,
the \texttt{Render} (output) window has a black background.  If you
want to look at histogram plots, much of the (default) output will
also be black, and thus potentially invisible!  You are therefore
recommended to change the \texttt{Render} window background to a
colour other than black before viewing histograms. To make that
change, in the \emph{Render} module you need the \texttt{Viewing}
menu, and \texttt{Edit Background Colour}, to select the background of
your choice.  The black background can also be changed permanently to
some other colour via the X11 resources described in
Section \ref{SECHTLPLOT}.
These resources should be put in the \texttt{.Xdefaults} file like any
other X11 resources. If you want to change the fill colour of the
histograms themselves, you can do that from the
\emph{HistOOgramPlot} module.  As you complete each example, and no
longer need the the current map, you can
re-initialise your IE session via the \emph{Map Editor}, by
selecting \texttt{Destroy All} from the \texttt{Edit} menu.  \index{Background colour}%
\index{Colour!background}%
\index{Render@{\emph{Render} module}!menus!viewing@{\texttt{Viewing}}}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
\index{Background colour}%
\index{Colour!background}%
\index{X11 resources}%
\index{Fill colour}%
\index{Colour!fill}%
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
\index{Destroy map}%
\index{Map editor@{\emph{Map Editor} window}!menu!edit@{\texttt{Edit}}}%
\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
\index{Map}%
\index{IRIS Explorer!map}%
\subsection{What you should know about the IRIS Explorer user interface}

\par

In this section we give some brief comments on the general rules
which you should be aware of when using the modules described in the
later sections.

\par

Text typed in a widget is read only if you hit \texttt{Return}. If
you type some text in a widget without pressing the \texttt{Return}
key, the widget will look modified but it keeps the previous value
instead (if this is the first time you type in a widget it is quite
likely that the previous value is the empty string).

\par

For instance, typing a C++ cut in the \texttt{Match} widget of
the \emph{HepMatchAndFill} module without hitting
\texttt{Return}, the module will not 
recognize the \texttt{Match}
expression and will thus select all tags.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par

A slider widget allows you to vary a parameter between a minimum and a
maximum value using the mouse. If you prefer to use the keyboard
instead, you can directly type into the text field displaying the
current value.  The range limits can be changed in a similar way.

\par

When you save a map after editing its modules' widgets, the values on
the widget are retained and will be shown again the next time when you
run the map. Be aware that a listbox is usually cleaned up, so that
you will have to select the item again.
\index{Map}%
\index{IRIS Explorer!map}%

\par

Reference documentation on Iris Explorer is available 
online as follows.

\begin{itemize}

\item \emph{IRIS Explorer Users' Guide.} at the URL
The basic IRIS Explorer system, scripting, and DataScribe.
\url{http://www.nag.co.uk/0/visual/IE/iecbb/DOC/UG/CONTENTS.html}.
\index{DataScripe!Component of IRIS Explorer}%
\index{IRIS Explorer!DataScribe}%
\index{IRIS Explorer!scripts}%
\index{IRIS Explorer}%

\item \emph{IRIS Explorer Documentation.}\index{NAG}%

Pointers to all of NAG's IRIS Explorer documentation. See the URL
\url{http://www.nag.co.uk/0/visual/IE/iecbb/DOC/Index.html}.
\index{IRIS Explorer}%
\end{itemize}
\subsection{Appearance of IRIS Explorer modules}

\par
On Unix systems, IRIS Explorer modules can appear in three different
ways on the Map Editor.

\begin{itemize}

\item \emph{Minimized view}: no user interface is visible.
\item \emph{Diminutif view}: a scaled-down version of the user interface is visible.
\item \emph{Maximized view}: the GUI is expanded to a full-size panel.\end{itemize}

\par
On Windows/NT the diminutif view is not available, thus modules are either minimized
or maximized.
\section{Storing and deleting histograms}

\par
HBOOK and PAW used to deal with histograms in the
``traditional'' way:\index{HBOOK}%
\index{Ntuple}%
\index{PAW}%

\begin{itemize}

\item all histograms are created in memory;
\item interesting histograms are explicitly saved (explicit I/O).\end{itemize}

\par
An ODBMS such as Objectivity/DB works exactly the other way round:\index{ODBMS}%
\index{Object Database Management System}%

\begin{itemize}

\item all histograms are created in the database (implicit I/O);
\item uninteresting histograms are explicitly deleted.\end{itemize}

\par
There are different ways to manage the deletion of such histograms.
\begin{itemize}

\item In a C++ program the user can either:
  
\begin{itemize}

\item individually delete each histogram (using the \texttt{delete} method 
       or the \texttt{ooDelete} function);
\item allocate ``temporary'' histograms in a well defined container and 
       at the end delete the whole container.\end{itemize}

\item In an IRIS Explorer map the user can either:
\index{Map}%
\index{IRIS Explorer!map}%

\begin{itemize}

\item individually delete each histogram (using the
       \emph{HistOOgramDelete} module);
\index{HistOOgramDelete@{\emph{HistOOgramDelete} module}}%
\index{HEPExplorer!modules!HistOOgramDelete@{\emph{HistOOgramDelete}}}%

\item create ``temporary'' histograms in a well defined 
       container and at the end delete the whole container (using 
       the \emph{ContainerDelete} module).
\index{ContainerDelete@{\emph{ContainerDelete} module}}%
\index{HEPExplorer!modules!ContainerDelete@{\emph{ContainerDelete}}}%
\end{itemize}
\end{itemize}

\par
Modules such as \emph{HistOOgramFill} (Ntuple-like analysis)
store their temporary histograms in a container named
\texttt{HistoDump_uid}, where \texttt{uid} stands for
the user's Unix \texttt{uid}. The container is created in a
database called \texttt{UserDb}, as seen in Figure 
\ref{HISTSTORE}.
\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%

\begin{figure}\centering

\includegraphics[width=.6\linewidth, scale=.5]{histstore}
\caption{Storing histograms in a container\label{HISTSTORE}}
\end{figure}

\par

The cleanup of temporary histograms is managed by the \emph{HepMatchAndFill}
and \emph{HepLoop} modules. The user can either:
\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\begin{itemize}

\item clean up the dump container immediately;
\item clean it up when the module leaves;
\item keep the dump contents across separate IRIS Explorer sessions.\end{itemize}
\section{Displaying histograms}

\par
Several HEP Explorer modules have been developed to handle histograms.
In the following sections we shall explore them each in turn.\subsection{The \emph{ContainerBrowser} module}
\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%

\par
The \emph{ContainerBrowser} module allows you to browse the
databases in the federated database defined by the \texttt{OO_FD_BOOT}
environment variable.  When the module starts, the list of the data
bases available in the \texttt{OO_FD_BOOT} federated database appears
in the \texttt{DB List} scroll field. A list of all the containers
available in a given database can be obtained by click on the database
name in question the \texttt{DB List} field.  You can also create a
new container belonging to the chosen database by typing the new
container's name in the \texttt{container} text field. The output of
this module is a container which can be connected to the \emph{Histogram
Reader} module. The \emph{ContainerBrowser} panel is shown in 
Figure \ref{HEPEXCONTAINER}.
\index{Federated database}%
\index{Database}%

\begin{figure}\centering

\includegraphics[width=.6\linewidth, scale=.5]{hepex_container}
\caption{\emph{ContainerBrowser} panel\label{HEPEXCONTAINER}}
\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
\end{figure}
\subsection{The \emph{HistOOgramReader} module\label{HistOOgramReader}}
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

\par
The \emph{HistOOgramReader} module receives a container from the
\emph{ContainerBrowser} module and allows you to select a histogram
from that container.  The list of histograms appears in the
\texttt{Histograms} field. You can select the type of histogram should
be shown (1D, 2D or all) using the radio buttons on the right of the
\texttt{Histogram} list. By clicking on one of the histogram names in
that list, the selected histogram is send on the output port and can
be received by any module able to take an histogram as its input.
The \emph{HistOOgramReader} panel is shown in 
Figure \ref{HEPEXREADER}.

\begin{figure}\centering

\includegraphics[width=.55\linewidth, scale=.5]{hepex_reader}
\caption{\emph{HistOOgramReader} panel\label{HEPEXREADER}}
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\end{figure}
\subsection{The \emph{HistOOgramPlot} module\label{SECHTLPLOT}}
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

\par
This \emph{HistOOgramPlot} module receives the histogram from
the \emph{HistOOgramReader} module. It can also take lattices as
input as shown in the following example. It creates the geometry from
these data and sends them to the \emph{Render} module, which shows
the result on screen. To save pictures as vector PostScript files, use the 
\emph{PostScript} module. \index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%

\par

The \emph{HistOOgramPlot} module 
shown in Figure 
assumes that the background of the
Render window is white. It is possible to change this background colour
with the \texttt{Edit Background Color} option in the \texttt{Viewing}\index{Render@{\emph{Render} module}!menus!viewing@{\texttt{Viewing}}}%

menu or by specifying a different colour in the X11 resources, 
as follows.\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
\index{Background colour}%
\index{Colour!background}%
\index{X11 resources}%

\begin{verbatim}
*SoXtExaminerViewer*BackgroundColor: white
*SoXtFlyViewer*BackgroundColor: white
*SoXtPlaneViewer*BackgroundColor: white
*SoXtWalkViewer*BackgroundColor: white
\end{verbatim}

\par

Various plot attributes can be changed via radio buttons or
pull-down menus. The action of the majority of the selectors is quite
obvious by just reading their names. We shall thus only say a few
words about the less trivial case of the \texttt{Plot mode}
selector.\subsubsection{The \texttt{Plot mode} selector}

\par
The default value of the \texttt{Plot mode} selector is \texttt{Start new
plot}. In this state, the last histogram or lattice entered in the
picture is deleted each time a new histogram or lattice is received by
the module. Another value for this selector is \texttt{Cumulate}.  In
this case each new histogram or lattice received by the module will be
drawn on the same plot. Finally, by pushing the \texttt{New page}
button you will start a new page, deleting all the current plots.
\begin{figure}\centering

\includegraphics[width=.65\linewidth, scale=.5]{hepex_plot}
\caption{\emph{HistOOgramPlot} panel\label{HEPEXPLOT}}
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
\end{figure}
\subsection{How to Plot a histogram}

\par
When the map is ready on the \emph{Map Editor}, you should
first select a database by just clicking on its name in the
\emph{ContainerBrowser} panel and then go on to select a
container name. The list of histograms is now visible in the
\emph{HistOOgramReader} panel. It suffices to select a histogram
by clicking on its name for it to be displayed in the
\texttt{Render} window. It can be useful to set the render
window background to white via the \texttt{edit background
color} option in the \texttt{Viewing} menu of the
\emph{Render} window.\index{Map editor@{\emph{Map Editor} window}}%
\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
\index{Map}%
\index{IRIS Explorer!map}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
\index{Render@{\emph{Render} module}!menus!viewing@{\texttt{Viewing}}}%

\par

The map and the PostScript output for a simple one-dimensional
histogram are shown in Figures \ref{HEPEX1MAP} and 
\ref{HEPEX1}.

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{hepex1map}
\caption{HEP Explorer histogram viewing screen\label{HEPEX1MAP}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.5\linewidth, scale=.5]{hepex1}
\caption{A histogram viewed with the HEP Explorer modules\label{HEPEX1}}
\end{figure}

\par

It is also possible to have several zone on the same plot by assigning
a \emph{HistOOgramPlot} module to each zone and varying the zone
coordinates value. The map and the PostScript output for two
one-dimensional histograms are shown in 
Figures \ref{HEPEX2MAP} and \ref{HEPEX2}.  

\begin{figure}\centering

\includegraphics[width=.9\linewidth, scale=.5]{hepex2map}
\caption{Map used to produce a ``2 zones'' plot\label{HEPEX2MAP}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.55\linewidth, scale=.5]{hepex2}
\caption{Two histograms viewed with the HEP Explorer modules\label{HEPEX2}}
\end{figure}
\subsection{The \emph{PostScript} module}

\par

The \emph{PostScript} module allows to generate vector PostScript
files from any Open Inventor geometry. This module is based on the
PlotMaster tools provided by Master Suite. With 3D geometries the
PostScript output generated by PlotMaster may be wrong therefore it is
preferable to restrict the usage of this module to 2D geometries.

\begin{figure}\centering

\includegraphics[width=.45\linewidth, scale=.5]{hepex_postscript}
\caption{\emph{PostScript} panel\label{HEPEXPOSTSCRIPT}}
\index{PostScript@{\emph{PostScript} module}}%
\index{HEPExplorer!modules!PostScript@{\emph{PostScript}}}%
\end{figure}
\subsection{Displaying a histogram as a Lego plot}
\index{Lego plot}%

\par

Lauch the \texttt{histogramPlot3D} map, which consists of three components:

\begin{itemize}

\item the \texttt{SelectHisto} group, containing
the \emph{ContainerBrowser} and \emph{HistOOgramReader} modules;
\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

\item the \emph{HistOOgramLego} module;
\index{HistOOgramLego@{\emph{HistOOgramLego} module}}%
\index{HEPExplorer!modules!HistOOgramLego@{\emph{HistOOgramLego}}}%

\item the \emph{Render} module.
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
\end{itemize}

\par

By clicking on the \texttt{SelectHisto} widgets you can select
a 1D or 2D histogram that will be transformed in a Lego plot by the
\emph{HistOOgramLego} module and finally displayed by the
\emph{Render}. Whenever you change to another histogram, click
on the \texttt{View All} decoration (the small eye-shaped icon
on the right side of the \emph{Render} window, sixth one from
the top) of the \emph{Render} module to reset the camera
position.  An example is shown in Figure \ref{HISTOGRAMPLOT3D}.
\index{HistOOgramLego@{\emph{HistOOgramLego} module}}%
\index{HEPExplorer!modules!HistOOgramLego@{\emph{HistOOgramLego}}}%

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{lego}
\caption{HEP Explorer map to display a Lego plot\label{HISTOGRAMPLOT3D}}
\index{Lego plot}%
\end{figure}
\section{Deleting a histogram from a container}

\par
If you want to delete a histogram from a container you should
construct the map shown in Figure \ref{HEPDELHISTMAP}.
\index{Map}%
\index{IRIS Explorer!map}%

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{hepdelhistmap}
\caption{HEP Explorer map to delete a histogram from a
container\label{HEPDELHISTMAP}}
\end{figure}

\par

The various steps to connect the modules in the map are first to
connect the \emph{HistOOgramDelete} module to the output port of
the \emph{HistOOgramReader} module. Then, you can select a
histogram by clicking on its name in the \emph{HistOOgramReader}
panel's list.  The database identifier and name of the chosen
histogram will appear in the name fields of the
\emph{HistOOgramDelete} modules. If you are sure you want to
drop the histogram from the selected container in the Objectivity/DB database,
confirm your choice by clicking the \texttt{Delete}
button. The situation after the deletion of the histogram selected in
the previous figure is shown in Figure \ref{HEPDELHISTMAP1}.
\index{HistOOgramDelete@{\emph{HistOOgramDelete} module}}%
\index{HEPExplorer!modules!HistOOgramDelete@{\emph{HistOOgramDelete}}}%
\index{Map}%
\index{IRIS Explorer!map}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{hepdelhistmap1}
\caption{The \emph{HistOOgramReader} after the
histogram deletion\label{HEPDELHISTMAP1}}
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\end{figure}
\section{Creating a new histogram}
\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%

\par

When you want to create a new histogram you can use the module
\emph{HistOOgramCreate}, whose panels for the one- and two
dimensional cases are shown in Figure \ref{HEPHISTCREATE}.

\begin{figure}\centering

\begin{tabular}{cc}

\includegraphics[width=.49\linewidth, scale=.5]{hephistcreate1}
&
\includegraphics[width=.49\linewidth, scale=.5]{hephistcreate2}
\\

\end{tabular}
\caption{\emph{HistOOgramCreate} panels (1D and 2D)\label{HEPHISTCREATE}}
\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
\end{figure}

\par

The \emph{HistOOgramCreate} module lets you create a new
histogram inside an existing container: the input port of this module
takes a container parameter. Therefore, it has to be connected to the
output port of the \emph{ContainerBrowser} module.  The two maps
in Figure \ref{HEPHISTCREATEMAP} correspond to the situation
before and after the creation of a new one-dimensional histogram.  The
name chosen for the histogram is \texttt{New Histogram}, as
you can clearly see in the \emph{HistOOgramReader} panel of the
map after the histogram creation.  (bottom part of Figure \ref{HEPHISTCREATEMAP}).
\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
\index{Map}%
\index{IRIS Explorer!map}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

\begin{figure}\centering

\begin{tabular}{c}

\includegraphics[width=.7\linewidth, scale=.5]{hephistcreatemap}
\\

\includegraphics[width=.7\linewidth, scale=.5]{hephistcreatemap1}
\\

\end{tabular}
\caption{Map before (top) and after (bottom) creating a new histogram\label{HEPHISTCREATEMAP}}
\index{Map}%
\index{IRIS Explorer!map}%
\end{figure}
\section{Scalar transformations on histograms}
\index{HistOOFunc@{\emph{HistOOFunc} module}}%
\index{HEPExplorer!modules!HistOOFunc@{\emph{HistOOFunc}}}%

\par
Scalar transformations on histograms are the task of the
\emph{HistOOFunc} module, whose panel is shown in Figure \ref{HEPHISTFUNC}.  In the map (Figure \ref{HEPHISTFUNC})
you can see how you connect the output port of
\emph{HistOOgramReader} module, which sends a histogram to the
input port of the \emph{HistOOFunc} module. After the needed
transformation the \emph{HistOOFunc} module sends the histogram
further to the \emph{HistOOgramPlot} module.
\index{Map}%
\index{IRIS Explorer!map}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

\par

An example of use of the \emph{HistOOFunc} module is adding a
set of constants (selected on the dial of the
\texttt{inScalar} after first pushing the \texttt{Add}
on the \emph{HistOOFunc} panel) to the same histogram (received
from the \emph{HistOOgramReader} module) and plotting the
results in \texttt{cumulate} mode onto the same figure with
the \emph{HistOOgramPlot} module, as shown in Figure \ref{HEPHISTFUNCEXA}.
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

\begin{figure}\centering

\begin{tabular}{cc}

\includegraphics[height=.3\linewidth, scale=.5]{hephistfunc}
&
\includegraphics[width=.68\linewidth, scale=.5]{hephistfuncmap}
\\

\end{tabular}
\caption{\emph{HistOOFunc} panel and 
    map structure for scalar histogram transformations\label{HEPHISTFUNC}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{hephistfuncexa}
\caption{Cumulating several histograms\label{HEPHISTFUNCEXA}}
\end{figure}
\section{Printing a histogram}
\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%

\par
Sometimes it can be interesting to actually \emph{print} a
histogram. This is made possible by the \emph{HistOOgramPrint}
module. The \emph{HistOOgramPrint} module takes his input from
the \emph{HistOOgramReader} module, as seen in the map shown in
Figure \ref{HEPPRINTHISTMAP}.  Then you will see information
(name, number of entries, bins, and parts) about the selected
histogram in the text fields of the \emph{HistOOgramReader}
panel (Figure \ref{HEPPRINTHISTPANELLOG}).  After pushing the
\texttt{Print} button in the \emph{HistOOgramPrint}
panel, the output generated by the module is written to the
\emph{Explorer Log} window (Figure \ref{HEPPRINTHISTPANELLOG}).
\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
\index{Explorer Log@{\emph{Explorer Log} window}}%
\index{IRIS Explorer!Explorer Log@{\emph{Explorer Log} window}}%
\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{Map}%
\index{IRIS Explorer!map}%
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

\begin{figure}\centering

\includegraphics[width=.9\linewidth, scale=.5]{hepprinthistmap}
\caption{HEP Explorer map to print an histogram\label{HEPPRINTHISTMAP}}
\end{figure}

\begin{figure}\centering

\begin{tabular}{cc}

\includegraphics[width=.3\linewidth, scale=.5]{hepprinthistpanel}
&
\includegraphics[width=.65\linewidth, scale=.5]{hepprinthistlog}
\\

\end{tabular}
\caption{\emph{HistOOgramPrint} panel and output\label{HEPPRINTHISTPANELLOG}}
\index{Map}%
\index{IRIS Explorer!map}%
\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
\end{figure}
\section{Turning a histogram into a lattice}
\index{HistOOgram2Lat@{\emph{HistOOgram2Lat} module}}%
\index{HEPExplorer!modules!HistOOgram2Lat@{\emph{HistOOgram2Lat}}}%

\par
To benefit fully from the many Iris Explorer modules which have
been developed in many different laboratories, research centres,
etc. worldwide, it is advantageous to provide a conversion tool to
translate the HEP-specific data types (i.e., histograms) into IRIS
Explorer generic data types (i.e., lattices).  The module
\emph{HistOOgram2Lat} performs such a conversion.  The
corresponding \emph{HistOOgram2Lat} panel is shown in Figure
\ref{HEPHIST2LAT}.  To show how this module is used let us
have a look at the map in Figure \ref{HEPHISTLATMAP}.
\index{Map}%
\index{IRIS Explorer!map}%

\begin{figure}\centering

\includegraphics[width=.65\linewidth, scale=.5]{hephist2lat}
\caption{\emph{HistOOgram2Lat} panel\label{HEPHIST2LAT}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.85\linewidth, scale=.5]{hephistlatmap}
\caption{Map of Histogram to lattice transformation\label{HEPHISTLATMAP}}
\index{Map}%
\index{IRIS Explorer!map}%
\end{figure}

\par

We see that the \emph{HistOOgram2Lat} module takes an histogram
as input and generates a lattice as output. The latter output stream
can be fed into any of a series of standard modules which consume
lattices. In particular, in the example map shown we decided to
visualise a HTL histogram with the standard \emph{NAGgraph}
module.
\index{Map}%
\index{IRIS Explorer!map}%
\index{NAG}%
\index{naggraph@{\texttt{NAGgraph}}}%
\section{Description of the IRIS 
Explorer \emph{DataFit} Module\label{MINUIT-GenDescription}}
\index{dataFit@{\emph{DataFit} module}}%
\index{HEPExplorer!modules!DataFit@{\emph{DataFit}}}%
\index{Minuit}%
\index{Minimisation!Minuit}%

\par

This module fits a mathematical model or a given user function to
data presented at its input ports. The underlying minimisation engine
is based on Minuit. The incoming data can be one- or two-dimensional
and can be presented as a lattice (any type, any coordinate type) or a
persistent histogram characterised by its Objectivity/DB object identifier. The
module always retains the data coming from the most recently updated
port.

\par

After the data have been received, the module allows you to:

\begin{itemize}

\item give an expression for a mathematical model to use in the fit;
\item specify a filename containing a full user-defined function;
\item restrict the zone of interest of the data to fit;
\item import, export and control the parameters to be optimised;
\item launch the fit and retrieve the fitted parameters;
\item analyse the error matrix via calls to dedicated Minuit procedures.\end{itemize}
\index{Minuit}%
\index{Minimisation!Minuit}%
\subsection{Using the \emph{DataFit} module: a simple
example\label{MINUIT-Using}}

\par

The layout of the \emph{DataFit} panel is shown
in Figure \ref{HEPFITFITPANEL}.

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{hepfit_fitpanel}
\caption{Layout of the \emph{DataFit} panel\label{HEPFITFITPANEL}}
\end{figure}

\par
On the fitting module's panel you can either specify as input the
object ID of the (one- or two-dimensional) persistent HTL histogram to be
fitted.  The center of each bin will be taken as reference for the
fit. Alternatively, you can use an IRIS Explorer lattice as input,
where for each lattice point two data values should be provided, first
the data and then the error value, in order to compute an accurate
chisquare. If there is only one data value per node, then a
non-weighted least mean square will be calculated.
\par
The panel offers further various dials, sliders, input boxes, etc.,
to communicate with the fitting module. Each parameter in the fit is
identified by its name. A text input widget allows you to type in the
symbolic form of the model expression for the fit.  Available symbols
are: for one-dimensional fits: \texttt{g} or \texttt{G} for
\emph{Gaussian}, \texttt{e} or \texttt{E} for \emph{Exponential},
and \texttt{pN} or \texttt{PN} (where \texttt{N} is a number) for a
\emph{Polynomial} of degree \texttt{N}. For two-dimensional fits
only the Gaussian option (\texttt{g} or \texttt{G}) is available.
For instance one could write
\begin{verbatim}
 g+p3, g+G-e,
\end{verbatim}

\par
The module will generate the code for the function, compile it and
put it in a sharable library that will be be loaded dynamically. The
generated function will be a function of one or two variables
according to the dimension of the incoming data. If necessary, the
code for the function can be edited before compilation, or, more
generally, you can use your own function for fitting. This latter
possibility is facilitated by using the \texttt{UserFunction}
pull-down menu, which can generate a skeleton to ease editing. Once
are finished, and want want to fit with your own source code, you can
try to compile it. The module will then link it as a sharable library
and load it dynamically to update the function to minimize. Although
it can take some time, it is straightforward and does not request any
special intervention from the user, except, of course, if the
compilation fails.
\par
For the fit itself there is the \texttt{Fit} menu, which
lets you launch fits with Minuit's \texttt{MIGRAD},
\texttt{MINIMIZE}, \texttt{SIMPLEX}, and
\texttt{IMPROVE} procedures (see the Minuit documentation for
details). The covariance matrix of the fit is available via the
\texttt{Show} menu, while a more detailed
\texttt{HESSE} and \texttt{MINOS} error analysis can
is initiated via the \texttt{Errors} menu.
\index{datafit@{\emph{DataFit} module}!menus!fit@{\texttt{Fit}}}%
\index{datafit@{\emph{DataFit} module}!menus!show@{\texttt{Show}}}%
\index{datafit@{\emph{DataFit} module}!menus!errors@{\texttt{Errors}}}%
\index{Minuit}%
\index{Minimisation!Minuit}%
\subsection{Setting the right parameters\label{MINUIT-parametersetting}}

\par
Sometimes there is a lack of coherency between the model you try
to fit and the current set of parameters. as the module does not erase
the previous set of parameters each time you change the model, you
must be careful to specify sensible starting values yourself.  If you
are using a combination of the \emph{standard} functions, you
can set a default starting value by using the \texttt{Set Default from
Model} command from the \texttt{Parameters} menu. This
will parse the model expression and generate a set of parameters with
appropriate names, default values and behaviours. Alternatively, you
can use the ASCII file that describes the set of parameters and that
can be read (and written) by the module. This is especially useful if
you are using your own fit function. The format of the file is very
easy to understand. Don't forget to specify in the header the number
of parameters for the fit. As it can sometimes be rather tedious to
adjust the starting values via the user interface, even for the
standard functions, you will find very quickly that the same method
can also be advantageous in this case and that the ASCII file provides
you with an efficient and fast way to achieve a good initialisation,
whereas the GUI allows you to \emph{move around and play} to
visually investigate the effect of parameter changes.in
real-time.
\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
\subsection{Using the fitting module}

\par

In this section we shall go through the various steps needed to fit
and then plot a simple one-dimensional histogram retrieved from an
Objectivity/DB database. The modules concerned can be found on the map shown in
Figure \ref{HEPFITMAP}.
\index{Map}%
\index{IRIS Explorer!map}%

\begin{figure}\centering

\includegraphics[width=.7\linewidth, scale=.5]{hepfitmap}
\caption{The IRIS Explorer map for fitting and plotting 
histograms\label{HEPFITMAP}}
\index{Map}%
\index{IRIS Explorer!map}%
\end{figure}

\par
Most modules present in the Iris Explorer map needed to fit and
plot histograms, have already been described before.
Therefore we only turn our attention towards the 
\emph{DataFit} module itself.
\index{Map}%
\index{IRIS Explorer!map}%

\par

The \emph{DataFit} module receives a histogram from the
\emph{HistOOgramReader} and performs a fit on it. The output of
the module is a lattice that is fed into a \emph{HistOOgramPlot}
lattice input.
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

\par
When the map is ready on the \emph{Map Editor}, you can
click on histogram in the \emph{HistOOgramReader}. At that point
it is possible to adjust various attributes and the effect of these
changes will be visible immediately in the \emph{Render} window.
\index{Map editor@{\emph{Map Editor} window}}%
\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
\index{Map}%
\index{IRIS Explorer!map}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%

\par
You are now ready to start a simple fit. Indeed, while sending
the data to the \emph{HistOOgramPlot} module, they was also sent
to the \emph{DataFit} module. Suppose we want to fit the
histogram to a Gaussian distribution. In this case it is enough to
type \texttt{G} in the \texttt{ModelExpression} text
field (lower left hand corner) of the \emph{DataFit}
panel. After typing a carriage return, C++ source code corresponding
to the definition of a Gaussian parameter fit is generated, compiled
and loaded.
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

\par

To have an acceptable set of starting values for the fit, it is
possible to adjust the fitting parameters visually. First in the
\texttt{Parameters} menu select \texttt{Set default from
model}.  This fills the \texttt{Parameters list} with
\texttt{MAX1}, \texttt{Mean1} and
\texttt{StdDev1}, corresponding to the three Gaussian
parameters. By clicking on one of them you can modify its value by
using the dials on the right of the \texttt{Parameters
list}. It is also possible to adjust the fitting interval with
the slider below the same \texttt{Parameters list}. If the
\texttt{Histogram/Lattice} button of the
\texttt{HistOOgramPlot} module is toggled to
\texttt{Lattice}, you will get the curve corresponding to the
actual parameter values displayed in the \texttt{Render}
window, as shown in Figure \ref{HEPFITEXA1}.
\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

\par

When you are satisfied with the initial values for the parameters, you
can select the \texttt{Set into Minuit} option in the
\texttt{Parameters} menu and then choose the fitting method
(for example \texttt{MIGRAD}) in the \texttt{Fit} menu
to perform the fit. The result is immediately visualised as shown in
Figure \ref{HEPFITEXA2}.
\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
\index{datafit@{\emph{DataFit} module}!menus!fit@{\texttt{Fit}}}%
\index{Minuit}%
\index{Minimisation!Minuit}%

\begin{figure}\centering

\includegraphics[width=.6\linewidth, scale=.5]{hepfitexa1}
\caption{Curve the initial values before the fit\label{HEPFITEXA1}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.6\linewidth, scale=.5]{hepfitexa2}
\caption{Curve for the final values after the fit\label{HEPFITEXA2}}
\end{figure}
\subsection{A more complex example:
     using your own fit function\label{MINUIT-HowSetFitFunction}}

\par
As sometimes the predefined functions are not sufficient for your
needs, you will have to write and use your own model function. The
present section will guide you through the various steps you have to
take.
\begin{enumerate}

\item 
Specify the name of the C-file which want the module to use in the
\texttt{Source Input Filename} text widget.  If this file already
exists go to step 5 since steps 2 to 4 below explain how to create a
new file. Note, however, that the contents of an already existing file
will be overwritten with its new definition.

\item 
Specify the number of parameters your model will use in the \texttt{Nb of
parameters} text widget. This is not so important; if you do not
know exactly your number of parameters, just give an
approximation.

\item 
Choose \texttt{Generate Skeleton} from the
\texttt{UserFunction} menu. This should create the file
containing a skeleton implementation for your fit function in the
directory \texttt{$EXPLORERUSERHOME/fitting/lib}.
\index{datafit@{\emph{DataFit} module}!menus!UserFunction@{\texttt{UserFunction}}}%

\item 
Edit the file and write your function. You can always have a look at
the file \texttt{Minuit_fit_function} in the same directory.
If your model contains some of the standard functions you can try to
construct a formula using these standard functions which is close in
form to your model expression, then choose \texttt{Write model to User
File} from the \texttt{UserFunction} menu. This
replaces steps 2 and 3 and can let you gain some time. Below we show
an example of such a model function.
\index{datafit@{\emph{DataFit} module}!menus!UserFunction@{\texttt{UserFunction}}}%
\index{Minuit}%
\index{Minimisation!Minuit}%

\item 
Choose \texttt{Compile User Function} from the
\texttt{UserFunction} menu. This should replace the old model
by your new one.
\index{datafit@{\emph{DataFit} module}!menus!UserFunction@{\texttt{UserFunction}}}%

\item 
Define the parameters via the option \texttt{Open Parameters
file} in the \texttt{Parameters} menu. If the file
exist, the fields \texttt{Par Filename Input} and
\texttt{Parameter List} at the top of the \emph{DataFit}
panel will be updated. If the file does not exist you should create
it. The simplest procedure is to start from a parameter file created
form a standard model via the option \texttt{Save to Parameters
file} in the \texttt{Parameters} menu.
\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
\end{enumerate}

\par
From here on the fitting procedure proceeds as in the case of a
standard expression (as explained 
in Section \ref{MINUIT-Using})
\subsubsection{Example of a fit function}

\par
Below we show the example of a fit function which was automatically
generated by the \emph{DataFit} module (in this case a second order
polynomial characterised by three parameters, the coefficients of the
terms). This source code can be edited as needed to implement the
desired function.
\begin{verbatim}
/**********************************************************************/
/*                                                                    */
/*   Here is defined the function the user wants to fit against his   */
/*   data                                                             */
/*   The call of this function is fixed                               */
/*      Arguments :                                                   */
/*          ndim : number of arguments the function needs             */
/*          coor : the coordinate of the point where the function is  */
/*                 computed                                           */
/*          nparam : nb of parameters the fit function depends on     */
/*          param   : set of parameters values                        */
/*                                                                    */
/*   This file may be automatically generated by the module           */
/*   DataFit or edited by the user                                    */
/*                                                                    */
/**********************************************************************/

#include <values.h>
#include <math.h>

double fit_function(int ndim, float *coor, int nparam, double *param)

{
	double result;
	double X;

	X=(double)(*coor);

	result =
	(param[0] +
	(param[1]*X) + 
	(param[2]*pow(X, 2.0))) ; 

	return (result);
}

 /*  Summary of the meaning of the parameters 
	  param[0] : c, constant value of polynom #1
	  param[1] : b, coefficient #1 of polynom #1
	  param[2] : a, coefficient #2 of polynom #1
 */ 
\end{verbatim}

\par
The \emph{DataFit} module uses a parameter file, which contains
the values and other information for the parameters used in the fit.
The parameter file corresponding to the function described above is
shown below.
\begin{verbatim}
 Parameter Tables for MINUIT/EXPLORER Modules 
 Number of Defined Parameter 3 
  
 Parameter # 1 
     Name c
     Value 50000
     Old Value 1 
     Lower Limit 0 
     Upper Limit 100000 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 2 
     Name b
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 3 
     Name a
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
\end{verbatim}
\index{Minuit}%
\index{Minimisation!Minuit}%
\section{Interactive analysis in IRIS Explorer\label{HEPExplorerexplorable}}
\subsection{Introduction}

\par
HEP Interactive Analysis in IRIS Explorer is implemented by a set
of HEPExplorer Modules.  Generally speaking, the current set of
Modules allows you to extract data from an Objectivity/DB data store and
put them in a HTL histogram, using cuts on the data set expressed in C++
syntax. In particular modules implement the following 
functions (see Figure ):

\begin{itemize}

\item select an explorable collection;
\index{Explorable collection}%

\item define a set of cuts over the collection;
\item define the input streams for the HTL histograms you will produce;
\item automatically generate and compile C++ code that implements the cuts;
\item fill the histogram with data retrieved from the collection.\end{itemize}

\par
Apart from accessing the data in the tag, users can invoke C++
functions that implement common physics or access the experiment
specific event object (by traversing the association between a tag and
its related event). User-defined functions can be used whenever a C++
expression is allowed.\index{Event association}%

\par
The modules can be grouped in an IRIS Explorer map to avoid redefining
every time the user's analysis setup and such a map can be executed in
a \emph{batch} fashion using IRIS Explorer's script language.\index{Map}%
\index{IRIS Explorer!map}%
\subsubsection{The \emph{HepExplorableBrowser} module}
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%

\par
The \emph{HepExplorableBrowser} module lets you browse and
select explorable collections. In the \texttt{Explorable List}
text field you can select a tag, whose identifier will appear in the
\texttt{Selected} field. Then the \texttt{Field List}
will show you the various fields of the tag, and you can select one
and pass it on to the \emph{HepMatchAndFill} module. The
\emph{HepExplorableBrowser} panel is shown in Figure \ref{HEPEXPBROWSER}.
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
\index{Explorable collection}%
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%

\begin{figure}\centering

\includegraphics[width=.6\linewidth, scale=.5]{HepExplorableBrowser}
\caption{\emph{HepExplorableBrowser}\label{HEPEXPBROWSER}}
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
\end{figure}
\subsubsection{The \emph{HepMatchAndFill} module}
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par

This new module offers the same features as the three former modules
\emph{HepExplorableSelector}, \emph{LibMaker} and
\emph{HistOOgramFill}, and is equivalent to PAW's
\texttt{NT/PLOT}, \texttt{NT/PROJECT} commands.
Basically it:
\index{LibMaker@{\emph{LibMaker} module}}%
\index{HEPExplorer!modules!LibMaker@{\emph{LibMaker}}}%
\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
\index{PAW}%
\index{Ntuple}%
\index{Project Ntuple (PAW)}%

\begin{itemize}

\item 
	allows users to define specific cuts (\texttt{Match} field),
	values and weights for filling histograms (\texttt{X, Y} and 
	\texttt{W} fields).

\item 
	automatically generates C++ code to fill histograms according to the 
	information above, compiles this code and executes it.
\end{itemize}

\par

As for the \emph{HepLoop} module, histograms are created in a
default dump container if none is specified on the input port. When
leaving the module, users can have these histograms erased
automatically (default behavior) or left as is (just click on the
\texttt{Keep Dump} radio button); users can also erase them at
any time by clicking on the \texttt{Erase Now} button.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par
The \emph{HepMatchAndFill} panel is shown in Figure \ref{HEPMATCHANDFILL}.

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{HepMatchAndFill1}
\caption{\emph{HepMatchAndFill} panel\label{HEPMATCHANDFILL}}
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
\end{figure}
\subsubsection{The \emph{HepLoop} module}
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par

This module is equivalent to the \texttt{PAW NT/LOOP} command
and offers a framework to scan an explorable collection, apply a
certain cut/match to the collection (or to each of its items) and
execute a particular action each time this match succeeds. The action
may for instance be the filling of histograms.
\index{PAW}%
\index{Ntuple}%
\index{Loop over Ntuple (PAW)}%
\index{Explorable collection}%

\par

Most of the code (both header file and source file) is automatically
generated: users only have to provide/write the relevant part of code
for the match/cut or action to be taken for instance.  As with
\emph{HepMatchAndFill} symbolic constants are supported and may
be passed to the code without no extra compilation overhead.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par

Once the entire code meets the user's requirements,
\emph{HepLoop} makes it possible to generate files and Makefile
for a standalone version corresponding to the current customized code
and setup. The standalone application may then be executed outside of
Iris Explorer like any other applications.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par
The \emph{HepLoop} panel is shown
in Figure \ref{HEPLOOP}.

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{HepLoop1}
\caption{\emph{HepLoop} panel\label{HEPLOOP}}
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
\end{figure}
\subsection{The \emph{explorablePlot} map}
\index{explorableplot@{\emph{explorablePlot} map}}%
\index{HEPExplorer!modules!explorableplot@{\emph{explorablePlot}}}%
\index{Map}%
\index{IRIS Explorer!map}%

\par

The \emph{explorablePlot} map is an example of how to use HEP-Explorer 
modules; it produces HTL histograms out of an explorable collection.
You can think of this map as a \emph{NT/PL replacement}.
\index{Explorable collection}%
\index{PAW}%
\index{Ntuple}%
\index{Plot Ntuple (PAW)}%

\par

The map has three modules: \emph{HepExplorableBrowser},
\emph{HepMatchAndFill}, and \emph{HistOOgramPlot}.
\index{Map}%
\index{IRIS Explorer!map}%

\begin{itemize}

\item \emph{HepExplorableBrowser}'s output port
\texttt{Explorable} is connected to
\emph{HepMatchAndFill}'s input port \texttt{Explorable};
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item \emph{HepMatchAndFill}'s output port \texttt{output
Histo} is connected to \emph{HistOOgramPlot}'s input
port \texttt{inHisto};
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item \emph{HistOOgramPlot}'s output port \texttt{OutputGeometry} is
connected to \emph{Render}'s input port \texttt{Geometry}.
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
\end{itemize}

\par

The details of the \emph{explorablePlot} map can be seen
in Figure \ref{HEPEXPLORABLEMAP}).
\index{Map}%
\index{IRIS Explorer!map}%
\index{explorableplot@{\emph{explorablePlot} map}}%
\index{HEPExplorer!modules!explorableplot@{\emph{explorablePlot}}}%

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{hepexplorablemap}
\caption{The \emph{explorablePlot} map\label{HEPEXPLORABLEMAP}}
\index{explorableplot@{\emph{explorablePlot} map}}%
\index{HEPExplorer!modules!explorableplot@{\emph{explorablePlot}}}%
\index{Map}%
\index{IRIS Explorer!map}%
\end{figure}

\par
If you want to produce HTL histograms you should do the following.
\begin{enumerate}

\item Select an explorable collection using the
\emph{HepExplorableBrowser} module.  The selected item is passed
over to the \emph{HepMatchAndFill} module.
\index{Explorable collection}%
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item Define your cuts on the explorable collection by typing a C++ expression
in the \texttt{Match} field of the \emph{HepMatchAndFill} module.
\index{Explorable collection}%
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item Define what you want to put in your HTL histograms as C++ expressions
in the \texttt{X}, \texttt{Y }and \texttt{W} fields of the
\emph{HepMatchAndFill} module.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item Click on the \texttt{Execute} button of the
\emph{HepMatchAndFill} module to generate the C++ code, compile
it, if need be, and then execute it.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item 
The \emph{HistOOgramPlot} module transforms the histogram data into
a graphics scene which is displayed by the \emph{Render} module.
\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
\index{Render@{\emph{Render} module}}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
\end{enumerate}
\subsection{ Getting the most of \emph{HepMatchAndFill}}
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par
\emph{HepMatchAndFill} provides many other useful features including the
following.

\begin{itemize}

\item 
The use of symbolic constants can avoid code recompilation overhead;

\item 
a customized pre-booked histogram can be specified instead of the
default one;

\item 
users can add extra C++ source files or includes files to define more
complex cuts or histogram variables;

\item 
users can directly access event data from an explorable collection.
\index{Explorable collection}%
\end{itemize}

\par

Notice the use of the \emph{HistoryBox} module to keep a history
of the cuts expressions, for instance.
\index{HistoryBox@{\emph{HistoryBox} module}}%
\index{HEPExplorer!modules!HistoryBox@{\emph{HistoryBox}}}%
\subsubsection{ Using symbolic constants in \emph{HepMatchAndFill}}
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par

Symbolic constants can be specified in the \texttt{Match},
\texttt{X}, \texttt{Y} and \texttt{W} fields
instead of actual numerical values.  The main advantage with this
approach, apart from having simpler and clearer expressions, is that
whenever users want to modify the numerical values of these symbolic
constants to fit their needs, the C++ generated code is neither
regenerated nor recompiled: the compilation overhead is thus
eliminated.

\par
Such symbolic constants are defined in the
\texttt{Constants} field and obey the C++ numerical constants
assignment syntax: \texttt{name = value}.  For instance, the
following expression defines two symbolic constants (the last
semi-colon is optional):

\begin{verbatim}
	PART_MIN = 45500; X_OFFSET = 36.462;
\end{verbatim}

\par

Note that currently there is a limitation on the definition of
symbolic constants, namely \textbf{the order of the definitions in the
\texttt{Constants} field is significant. The order cannot be
changed unless the code is re-generated, otherwise consistency is not
assured.
}\subsubsection{Specifying a pre-booked histogram}

\par

By default \emph{HepMatchAndFill} fills a histogram booked on the fly 
in a dump container. The min and max values of the default 
histogram are sampled from the data, while the number of bins is 100 for 
1D histograms and 40 by 40 for 2D histograms.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par

If a valid histogram is connected to the optional histogram input port
(\texttt{Input Histo}), then this histogram is used instead of
the default one.  Typically users can look up a histogram (via
\emph{HistOOgramReader}) or create a new one (thanks to
\emph{HistOOgramCreate}) and pass it to
\emph{HepMatchAndFill}, when they want to fill their customized
histogram.
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\par

The panel in Figure \ref{HEPMATCHANDFILL4} shows how the
\texttt{Customized_Histo} HTL histogram (created by
\emph{HistOOgramCreate }) can be specified and connected to the
input port \texttt{Input Histo} of
\emph{HepMatchAndFill}.
\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\begin{figure}\centering

\includegraphics[width=.6\linewidth, scale=.5]{HepMatchAndFill4}
\caption{Handling histograms with the \emph{HepMatchAndFill} module\label{HEPMATCHANDFILL4}}
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
\end{figure}
\subsubsection{Invoking user defined methods and code}

\par

When a cut becomes rather long and complex, users might find it useful
to be able to call a customized function that implements the tricky
cut.  If the routine is short enough, the easiest way to proceed is to
define it in a header file and specify the filename in the
\texttt{Include Files} widget.  However, If the code of the
function becomes larger, it might be better pratice to declare the
routine in a header file and implement it in a separate source
file. In this case the header filename (\texttt{.h}) and
source filename (\texttt{.cpp}) should be specified using the
\texttt{Include Files}, and \texttt{Source Files}
widgets, respectively.

\par

You can specify extra compilation and linking options as follows:

\begin{itemize}

\item 
the \texttt{Build Options} field lets you add extra
\texttt{includes} or \texttt{define} directives;

\item 
the \texttt{Libraries} field lets you add extra libraries.
\end{itemize}

\par

The two panels of Figure \ref{HEPMATCHANDFILLCUT} show how to
use a customized cut function (\texttt{my_cut}) and the files
(\texttt{my_cut.h} and \texttt{my_cut.cpp}) that are
specified in the relevant widgets of the \emph{HepMatchAndFill}
module.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\begin{figure}\centering

\begin{tabular}{cc}

\includegraphics[height=6cm, scale=.5]{HepMatchAndFill2}
&
\includegraphics[height=6cm, scale=.5]{mycut}
\\

\end{tabular}
\index{Cut function}%
\caption{Specifying a customized cut function with
\emph{HepMatchAndFill}\label{HEPMATCHANDFILLCUT}}
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
\end{figure}
\subsubsection{Accessing event data from an Explorable collection}
\index{Explorable collection}%

\par

HEP-Explorer modules for interactive analysis allow you to easily
manipulate tag fields to define cuts, or to collect information in a
HTL histograms. As mentioned before, no knowledge of the specific
object model is required as long as you deal with attributes defined
in the tag. However, when you need to cross the association between a
tag and its related event in order to retrieve more information, the
HEP-Explorer modules have to get access to the object model.

\par

Information about the object model is communicated to
\emph{HepMatchAndFill} by specifying the following:
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\begin{itemize}

\item 
the header file (\texttt{Include Files} field) that contains the 
declaration of your tag and the related event;

\item 
the name of the concrete tag (\texttt{Concrete Tag} field) to
be used, i.e., the name of the class implementing the tag;

\item 
the shared library (\texttt{Libraries} field) which contains
the code to access tag/event methods and attributes.
\end{itemize}

\par

Figure \ref{HEPMATCHANDFILL3} shows an example using the
\texttt{AtlasProdTag} concrete tag. Its declaration is in the
header file \texttt{AtlasProd.h} and its associated library
has been specified in the \texttt{Libraries} field.

\begin{figure}\centering

\includegraphics[width=.8\linewidth, scale=.5]{HepMatchAndFill3}
\caption{Example of accessing event data  
         from an Explorable collection\label{HEPMATCHANDFILL3}}
\index{Explorable collection}%
\end{figure}

\par

The \texttt{theTag} object is then ready for use, should you
want to access the concrete tag. You may ask for a reference to an
event using the \texttt{getEvent()} method. With this
reference you can then access each of the attributes as you would do
in a normal C++ program (in the \texttt{AtlasProd} example the
attribute is named \texttt{NgTrack} and corresponds to the
number of tracks in the event).

\par

Note that your shared library should be placed in a directory included
in the shared library path (see Section \ref{TROUBLESHAREDLIBRARIES} for more details).
\subsection{ The \emph{HepLoopMap} map}
\index{heploopmap@{\emph{HepLoopMap} map}}%
\index{HEPExplorer!modulesheploopmap@{\emph{HepLoopMap}}}%

\par

This map shows an example of how to use the \emph{HepLoop}
module with other HEP-Explorer modules to perform a custom interactive
analysis.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par

The \emph{HepLoopMap} map shown in Figure \ref{HEPLOOPMAP} consist of four modules:
\index{heploopmap@{\emph{HepLoopMap} map}}%
\index{HEPExplorer!modulesheploopmap@{\emph{HepLoopMap}}}%

\begin{itemize}

\item \emph{HepExplorableBrowser}.  This module provides an explorable
collection to be looped over.
\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
\index{Explorable collection}%

\item \emph{HepLoop}.  This module scans the collection, checks for
elements that match a specific user-defined cut and performs the
relevant user-defined action.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\item \emph{ContainerBrowser}.  Most of the time users want to fill
HTL histograms. By default, such HTL histograms are created in a dump
container. However, users can also specify their own container
(obtained via \emph{ContainerBrowser} for instance) by
connecting it to the optional input port \texttt{Container}.
\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%

\item \emph{HistOOgramReader}.  The \emph{HepLoop} module
provides on its output port the container (the default one or one
specified by the user) where all histograms have been created.  It is
then possible to display these histograms conveniently by connecting
this output port (\texttt{Out Container}) to
\emph{HistOOgramReader}.
\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
\end{itemize}

\begin{figure}\centering

\includegraphics[width=1.\linewidth, scale=.5]{HepLoopMap}
\caption{The \emph{HepLoopMap} map\label{HEPLOOPMAP}}
\index{heploopmap@{\emph{HepLoopMap} map}}%
\index{HEPExplorer!modulesheploopmap@{\emph{HepLoopMap}}}%
\end{figure}
\subsection{ Getting the most of \emph{HepLoop}}

\par
\emph{HepLoop} provides various features that offer better
control over the generated and customized code.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\begin{itemize}

\item 
Using symbolic constants can avoid recompilation overhead as explained
when discussing how to get the most of \emph{HepMatchAndFill}.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

\item 
Users can specify the actual number of events to be processed when fitting
the cut expression. By default (when nothing is entered in the text field
\texttt{Number of Events}) the full collection is scanned.

\item 
As with \emph{HepMatchAndFill}, extra files or extra compilation
options can be added.
\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
\end{itemize}

\par

When clicking on the \texttt{Prototype} button,
\emph{HepLoop} generates two skeleton files: a header (extension
\texttt{.h}) and a source (extension \texttt{.cpp})
file. The basename is specified in the \texttt{Filename}
field. The header file contains the main class declaration and the
source file the implementation of its methods. Those parts of the
methods that users may want to alter by introducing customized code
are bracketed with comments, as shown below.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\begin{alltt}
// *** BEGIN USER CODE ***
   \emph{user-modifiable code }
// *** END USER CODE   ***
\end{alltt}

\par

Both header and source files contain some hints to assist the user,
e.g., on how to declare and use histograms.

\par

Figure \ref{GENERATEDCODE} shows two panels with an example
of a header (left) and part of a source file (right) that were
automatically generated.

\begin{figure}\centering

\begin{tabular}{cc}

\includegraphics[height=9cm, scale=.5]{GeneratedCodeH}
&
\includegraphics[height=9cm, scale=.5]{GeneratedCodeCPP}
\\

\end{tabular}
\caption{Example of skeleton files generated by 
\emph{{HepLoop}}\label{GENERATEDCODE}}
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
\end{figure}

\par

The principal idea behind \emph{HepLoop} and its generated
skeleton code is to scan (loop over) an explorable collection, \index{Explorable collection}%
 apply a user-defined cut while trying
to match each of its items, then, when a match is successful, execute
a given action.  Note that customized actions can also be performed
once before the start of the loop (\texttt{preExecute} method)
and once after the loop terminates (\texttt{postExecute}).
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par

The main methods users might want to customize include:

\begin{itemize}

\item \texttt{match}: define in this method the specific cut/match
that is applied to each item of the explorable
collection. \texttt{match} should return 0 when the cut was
unsuccessful, a non-zero value otherwise.
\index{Explorable collection}%

\item \texttt{action}: this method is executed whenever the
match/cut succeeds.  Typically users might want to fill histograms in
this method.

\item \texttt{preExecute}: this method is executed once before
scanning an Explorable collection. Typically, this is where you would
perform initializations or assign resources.
\index{Explorable collection}%

\item \texttt{postExecute}: this method is executed once after
scanning an Explorable collection. Typically, this is where you would
release the resources that were assigned in
\texttt{preExecute}.
\end{itemize}

\par
Figures \ref{CUSTOMIZEDGENERATEDCODE1} and \ref{CUSTOMIZEDGENERATEDCODE2} show an implementation of some of
the methods described above, while Figure \ref{CUSTOMIZEDGENERATEDCODE3} is the header file containing their
declaration.

\begin{figure}\centering

\includegraphics[width=.5\linewidth, scale=.5]{CustomizedGeneratedCode1}
\caption{Customized code: the \texttt{match} and
         \texttt{preExecute} methods\label{CUSTOMIZEDGENERATEDCODE1}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.95\linewidth, scale=.5]{CustomizedGeneratedCode2}
\caption{Customized code: the \texttt{action} method\label{CUSTOMIZEDGENERATEDCODE2}}
\end{figure}

\begin{figure}\centering

\includegraphics[width=.95\linewidth, scale=.5]{CustomizedGeneratedCode3}
\caption{Header file used with \emph{HepLoop} customized code
         examples\label{CUSTOMIZEDGENERATEDCODE3}}
\end{figure}
\subsection{The standalone version of \emph{HepLoop}}

\par

Once the code generated by \emph{HepLoop} has been modified and
customized, it is possible to build a standalone version of the code,
i.e., a version of \emph{HepLoop} that can execute the
customized code outside of Iris Explorer.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par

In order to prepare such a standalone versin, users should click on
the \texttt{Generate Makefile} button. Then
\emph{HepLoop} generates:
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\begin{itemize}

\item 
a makefile (\texttt{GNUmakefile}) that registers the current
setup of the module (compilation options, include files, source files,
etc.);

\item 
the \texttt{main_HepLoop.cpp} file that can run the customized
code, which was prepared and tested previously.
\end{itemize}

\par

Then a standalone version can be build by just typing the command:

\begin{verbatim}
      gmake
\end{verbatim}

\par

This will compile the customized code together with the file
\texttt{main_HepLoop.cpp} (and other C++ code, as needed)
using and environmental setup that was defined in
\emph{HepLoop}.  The generated application is called
\texttt{main_HepLoop}, which can be executed by typing its
name:
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\begin{verbatim}
      main_HepLoop
\end{verbatim}

\par

This has the same effect as clicking on the \texttt{Execute} button of
\emph{HepLoop} inside Iris Explorer.
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\par

The standalone version of \emph{HepLoop} accepts two optional arguments:
\index{HepLoop@{\emph{HepLoop} module}}%
\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

\begin{enumerate}

\item 
The constants to be passed to the customized code. It is a string
(inside quotes) that has the same format as the one of the
\texttt{Constants} field in \emph{HepLoop}.  e.g.,
\texttt{PART_MIN=45500; X_OFFSET 36.642;}, where the last
semi-colon is optional. Constants must be specified in the same order
as they were in the \texttt{Constants} field and their number
must also correspond; no consistency is assured when these
requirements are not fulfilled.

\item 
The number of actual events to be processed.
\end{enumerate}

\par

As an example, the following command line executes the customized code
specifying two constants and looping will process a total of 65000
event.

\begin{verbatim}
      main_HepLoop "PART_MIN=3455; X_OFFSET=24.78" 65000
\end{verbatim}
\subsection{The \emph{TagViewer} module}
\index{IRIS Explorer!troubleshooting}%
\index{Troubleshooting}%

\par

The \emph{TagViewer} module allows users to apply simple range
cuts on tags values and visualize the result of the query as a
histogram.  Cuts can be specified as sequences of C++ expressions,
that are combined in \emph{and} mode, so a cut is a valid C++
logical expression.  The BNF format of the cut is:

\begin{verbatim}
<var#1> <comp#1> <arg#1> && <var#2> <comp#2> <arg#2> ...
\end{verbatim}
\texttt{<var\#i>} is a tag attribute in the Field Lists.
\texttt{<comp\#i>} is a comparison operator from the list:

\begin{verbatim}
> , < , >= , <= , == , != 
\end{verbatim}
\texttt{<arg\#i>} represents either a tag attribute
\texttt{<var\#j>} or a numeric value. 
\texttt{\&\&} represents the \emph{and}
operator that separate elementary cuts.

\par

Examples of valid cuts are:

\begin{verbatim}
pT > 400

pt > 400 && pT < 800

px > py && E < 2.9 && deadChan == 0
\end{verbatim}

The module supports on-the-fly rebinning of the histogram and
selection of a subset of tags. Figure \ref{TAGVIEWER} shows
an example of the usage of the \emph{TagViewer} module.

\begin{figure}\centering

\includegraphics[width=.95\linewidth, scale=.5]{TagViewer}
\caption{The \emph{TagViewer} module\label{TAGVIEWER}}
\end{figure}
\section{Troubleshooting}
\index{IRIS Explorer!troubleshooting}%
\index{Troubleshooting}%
\subsection{The text in the menus of the \emph{Render} module is
difficult to read}

\par

Sometimes the text strings in the menus and subpanels of the
\emph{Render} module are difficult to read since the actual
message text is not properly initialized (strings of the type
\texttt{ivxxx} are displayed).
\index{Render@{\emph{Render} module}!menus}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%

\par

To define the relevant text strings to be displayed, the corresponding
resources must be defined. These resources allow you to customize the
menus in question. For instance, you can change the language and
disable some of the menu items.

\par

The \texttt{app-defaults/Inventor} directory contains the
default resource file for all standard viewers. System administrators
should copy this file into the directory
\texttt{/usr/lib/X11/app-defaults}.  For instance, a specific
language is chosen as follows.
\index{X11 resources}%
\index{Open Inventor!resources}%

\begin{verbatim}
  ln -s Inventor.english Inventor
\end{verbatim}

\par

One should also include the \texttt{$OIVHOME/app-defaults}
directory in the \texttt{XAPPLRESDIR} path variable.

\par

If you already have a resource file then you can also merge 
the resource file \texttt{$OIVHOME/app-defaults/Inventor.xxx}
with yours (see the manual page of \texttt{xrdb}).
\subsection{What to do if a map does not react at all?}
\index{Map}%
\index{IRIS Explorer!map}%

\par

IRIS Explorer maps obey the dataflow rule:

\begin{enumerate}

\item a module fires when one of its inputs changes;
\item the module can then change its outputs;
\item if another module's input is connected to the changed output,
then that module will fire as well (according to rule 1).\end{enumerate}

\par
You can check if a module is firing by verifying that its colour
turns yellow.  If the module does not fire then check the
following.
\begin{itemize}

\item 
All mandatory inputs are connected. For instance, if you do not
connect \emph{HistOOgramFill}'s \texttt{LibraryName}
input to the corresponding \emph{LibMaker}'s output, the module
will never activate.
\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
\index{LibMaker@{\emph{LibMaker} module}}%
\index{HEPExplorer!modules!LibMaker@{\emph{LibMaker}}}%

\item 
All mandatory fields have been properly defined: a meaningful value is
typed and the Return key is pressed on the text fields, an item is
selected on the Listboxes.

\item 
There are no Objectivity/DB locks pending (just exit from IRIS Explorer and use
the Objectivity/DB \texttt{oocleanup} utility).
\index{oocleanup@{\ttfamily oocleanup}}%

\item 
All modules are enabled (enabled modules have black titles on the
\emph{Map Editor}, while disabled modules have grey title).  Be
aware that when a module crashes, IRIS Explorer will ask you whether
you want to replace the module with another instance. If you answer
positively, the newly loaded module will be disabled by default.  In
order to enable or disable a module you should click with the right
mouse button on the module's name in the \emph{Map Editor}
window.
\index{Map editor@{\emph{Map Editor} window}}%
\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
\index{Map}%
\index{IRIS Explorer!map}%
\index{Map editor@{\emph{Map Editor}}}%
\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
\index{Map}%
\index{IRIS Explorer!map}%
\end{itemize}
\subsection{The \emph{Render} module dies when using 
Exceed\label{TROUBLEEXCEED}}
\index{Exceed}%
\index{X Window}%
\index{PC}%

\par

Exceed is the recommended X Window package on PCs at CERN.  If the
\emph{Render} module dies immediately, try modifying the
configuration of your PC to use only 256 colours (from the \texttt{Control
Panel} window, select \texttt{Display} and then
\texttt{Appearance}).
\index{Render@{\emph{Render} module}!dies}%
\index{IRIS Explorer!modules!Render@{\emph{Render}}}%

\par
Otherwise, switch to Exceed V6.1 plus GL extensions.\subsection{Shared libraries\label{TROUBLESHAREDLIBRARIES}}
\index{Shared library}%

\par

If you use HEPExplorer modules using shared libraries, e.g., to access
event data, it can happen that the module does not find a shared
library.  Although the details of shared library management differ
amongst Unix flavours, the generic approach is to define a shared
library path environment variable containing the list of directories
that have to be to searched when looking for a shared library.  You
should check that the shared library you want to use is located in one
of these directories. If it is located in a different directory you
can use a simple workaround by creating a symbolic link to your
library in the \texttt{$EXPLORERUSERHOME/fitting/lib} directory,
which is always included in the shared library path, e.g.,

\begin{verbatim}
> cd $EXPLORERUSERHOME/fitting/lib
> ln -s /afs/cern.ch/myproject/HP-UX/atlasprod/libAtlasSpy.sl libAtlasSpy.sl
\end{verbatim}

\par

Now your library has a symbolic link in one directory that is always
searched for.

\par

Note that in the example above we used the HP extension \texttt{.sl}
for shared library names; on other computer platforms a different
file extension might be required.
\subsection{Shared memory\label{TROUBLEARENA}}
\index{Shared memory}%

\par

If when running Iris Explorer you get a message saying that the disk
where the shared memory \emph{arena} resides is not large
enough, check the space available in \texttt{/usr/tmp} (the
location where IRIS Explorer by default creates its arena). If it is
too small you should enlarge it or change the directory where the
arena is created by specifying another
\emph{\texttt{tempdir}} either in the system-wide
\texttt{Explorer.config} file or in your personal
\texttt{.explorerrc} e.g., by specifying a different directory
, (see IRIS ExplorerUser's Guide,
Appendix A at the URL \url{http://www.nag.co.uk:80/visual/IE/iecbb/DOC/UG/appa.html}).
\index{Arena}%
\index{IRIS Explorer!customization!explorerrc@{\texttt{.explorerrc}}}%
\index{explorerrc@{\texttt{.explorerrc}!IRIS Explorer customization file file}}%

\begin{verbatim}
! Set the directory where the arena and pipes go
set tempdir /usr/tmp/explorer
\end{verbatim}
\subsection{Writing to \texttt{cout} on HPUX 10.20\label{TROUBLEHPUX}}

\par

On HPUX 10.20 there are problems with writing to \texttt{cout}
when the library \texttt{libcx.a} (via the option
\texttt{-lcx}) is included when building an Iris Explorer
module. It is therefore advisable to use \texttt{printf}
rather than the C++ construct \texttt{cout <<} to print
program variables to the output stream.
\subsection{Unexpected error message at Render's startup on HP machines}

\par

On HP systems when starting up the Renderer the following error
message can be printed.

\begin{verbatim}
Render: TGS hostid open failed for '/dev/seah0':Permission denied
\end{verbatim}

\par

The message is just a warning and it is due to the presence of a
non-Ethernet card on the system (typically a FDDI card).  Users can
safely ignore this message.
\index{HEPExplorer|)}%
\index{IRIS Explorer|)}%
\chapter{Short description of \emph{HEPExplorer} modules
        and maps\label{H1ModulesDescription}}

\begin{description}

\item[\emph{ContainerBrowser}]Browse the databases in the federated database.
\item[\emph{ContainerDelete}]Delete a container.
\item[\emph{DataFit}]Fit a mathematical model or a given user function to
    data presented at the input ports.
\item[\emph{explorablePlot}]A map of HEP-Explorer modules producing HistOOgrams from
  an explorable collection.
\item[\emph{HepExplorableBrowser}]Browse and select explorable collections.
\item[\emph{HepLoop}]Scan an explorable collection, apply a certain cut/match to 
the collection (or to each of its items) and execute a 
particular action if a match occurs (equivalent to PAW's \texttt{NT/LOOP}).
\item[\emph{HepLoopMap}]A map using the \emph{HepLoop} module with
other HEP-Explorer modules to perform a custom interactive analysis.
\item[\emph{HepMatchAndFill}]Define specific cuts, values and weights for filling histograms,
then automatically generate C++ code to fill those histograms
according to the specified information, compile and execute it.

\item[\emph{HistOOgram2Lat}]
Convert a HistOOgram into an Iris Explorer lattice.

\item[\emph{HistOOgramCreate}]
Create a new 1D or 2D histogram
inside an existing container.

\item[\emph{HistOOgramDelete}]Delete an individual histogram.
\item[\emph{HistOOgramFill}]Store a histogram in a container.
\item[\emph{HistOOgramFunc}]Perform scalar transformation on a histogram.
\item[\emph{HistOOgramLego}]Transform a histogram into a Lego plot.
\item[\emph{HistOOgramPlot}]Plot a histogram according to various user-defined attributes.
\item[\emph{HistOOgramPrint}]Print a histogram (as in la HBOOK).
\item[\emph{HistOOgramReader}]Select a histogram  in a container from a list.

\item[\emph{HistoryBox}]Keep the history of the cut expressions.
\item[\emph{PostScript}]Generate a vector PostScript file from an Open Inventor geometry.
\item[\emph{TagViewer}]Apply simple range cuts on tags values and
  visualize the result.

\end{description}
\chapter{Glossary\label{H1Glossary}}

\begin{description}

\item[AMS]Advanced Multi-threaded Server (Objectivity/DB).
\index{AMS}%
\index{Advanced Multi-threaded Server}%

\item[AFS]Andrew (distributed) Filesystem.
\index{AFS}%
\index{Andrew Filesystem}%

\item[CORBA]Common Object Request Broker Architecture, from the OMG.
\index{CORBA}%
\index{OMG}%
\index{Common Object Request Broker Architecture}%

\item[HPSS]High Performance Storage System. A high-end mass storage
system developed by a consortium consisting of end-user sites
and commercial companies.
\index{HPSS}%
\index{High Performance Storage System}%

\item[NFS]Network Filesystem, developed by Sun.
\index{NFS}%
\index{Network Filesystem}%

\item[Objectivity/DB]Vendor of an ODBMS. Chosen at CERN in the framework of RD45.
\index{Objectivity/DB}%

\item[ODBMS]Object Database Management System.
\index{ODBMS}%
\index{Object Database Management System}%

\item[ODL]Object Definition Language. Specification language defining the
interface to object types conforming to the ODMG Object Model.
\index{ODL}%
\index{Object Definition Language}%

\item[ODMG]Object Database Management Group. Develops standards for ODBMSes,
e.g., in the area of scalability, heterogeneity, WAN support
(distribution, replication, caching, recovery, etc.), and schema
evolution.
\index{ODMG}%
\index{Object Database Management Group}%

\item[OMG]Object Management Group.
Consortium of over 400 members from the software, hardware, and large
end-user communities, whose goal is to standardise and promote object
technology in all forms, in particular by proposing specific standards
which should increase portability of customer software across ODBMS
products.
\index{OMG}%
\index{Object Management Group}%

\item[ORB]Object Request Broker
\index{ORB}%
\index{Object Request Broker}%

\item[GEANT-4]Object-Oriented Toolkit for Simulation in HEP.
\index{GEANT 4}%

\item[RD45 Project]Research and Development project to investigate object persistency
for HEP.
\index{RD45 Project}%

\end{description}
