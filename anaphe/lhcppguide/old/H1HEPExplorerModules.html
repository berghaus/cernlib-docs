<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html xmlns:date="http://www.jclark.com/xt/java/java.util.Date">
<head>
<title>HEPExplorer Modules</title>
<STYLE TYPE="text/css">body       { background: white; color: black}
 P.CENTERP  { text-align: center}
 TD.LISTING { background: #88FFFF; color: black; white-space: pre}
 tt         { color: red }
</STYLE>
</head>
<body>
<H1>
<A NAME="H1HEPExplorerModules">6. HEPExplorer Modules</A>
</H1>




<H2>6.1. Starting IRIS Explorer</H2>

<P>
The environment variables needed to run the IRIS Explorer
components and get access to the relevant libraries and auxiliary
files have been setup on the central systems at CERN. Moreover, since
the HEP components use the Objectivity/DB database, you should have been
registered by your experiment for using that database (see the
previous chapter to find out how to handle Objectivity/DB database files).
</P>

<P>
Once your environment is set correctly, you can start up IRIS Explorer
by just typing <TT>explorer</TT>. You should then get a layout
of windows on your workstation as shown in Figure 
<a href="H1HEPExplorerModules.html#IRISEXPLORER">[IRISEXPLORER]</a>.
</P>

<P CLASS="CENTERP">
<A NAME="IRISEXPLORER"><IMG SRC="irisexplorer.gif"></A>
</P>
<P>
<B>IRIS Explorer startup screen</B>
</P>

<P>
You see three large components on your screen. First, at the left
we have the list of IRIS Explorer modules, the <EM>Librarian</EM>. 
In fact, in the figure we chose to highlight the HEP Explorer
modules, which will be described below. It should be noted that
several tens of IRIS Explorer modules come with the basic system,
and many more can be obtained from various public archives.


</P>

<P>
The larger part of the screen is occupied by the <EM>Map Editor</EM>.
This is where the user builds or modifies maps, connects modules
together, or interacts with the various modules in the map.




</P>

<P>
Finally, just below the <EM>Map Editor</EM> you have the <EM>Explorer
Log</EM> window, where messages coming from IRIS Explorer modules
are displayed.  


</P>


<H3>6.1.1.  For first time users of IRIS Explorer  </H3>
 
<P>
If this is the first time that  you are using Iris Explorer (IE), there are
several choices open to you.  You can jump straight into the examples which
follow.  Since the IE interface is intuitive, you will probably learn
your way around quite quickly.  We provide below some hints which may
nevertheless be useful for beginners.  
</P>

<P>
Either before or after your first trials, you may be interested in
some more formal Web-based guidance concerning IE.  There are two such
tutorials accessible from CERN.  One, supplied by NAG, is rather
complete and thorough, and gives you a quick tour of most
possibilities of IRIS Explorer.  It is available 
<A HREF="http://www.nag.co.uk/0/visual/IE/iecbb/Tutorial/index.html">here</A>
The other, supplied by the University of Leeds, provides more of an
overview, and might be more suitable for physicists. It can be found 

at the URL
<A HREF="http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html">here</A>.

</P>

<P> 
The following knowledge can be useful for beginners.  By default,
the <TT>Render</TT> (output) window has a black background.  If you
want to look at histogram plots, much of the (default) output will
also be black, and thus potentially invisible!  You are therefore
recommended to change the <TT>Render</TT> window background to a
colour other than black before viewing histograms. To make that
change, in the <EM>Render</EM> module you need the <TT>Viewing</TT>
menu, and <TT>Edit Background Colour</TT>, to select the background of
your choice.  The black background can also be changed permanently to
some other colour via the X11 resources described in
Section <a href="H1HEPExplorerModules.html#SECHTLPLOT">[SECHTLPLOT]</a>.
These resources should be put in the <TT>.Xdefaults</TT> file like any
other X11 resources. If you want to change the fill colour of the
histograms themselves, you can do that from the
<EM>HistOOgramPlot</EM> module.  As you complete each example, and no
longer need the the current map, you can
re-initialise your IE session via the <EM>Map Editor</EM>, by
selecting <TT>Destroy All</TT> from the <TT>Edit</TT> menu.  </P>




















<H3>6.1.2. What you should know about the IRIS Explorer user interface</H3>

<P>
In this section we give some brief comments on the general rules
which you should be aware of when using the modules described in the
later sections.
</P>

<P>
Text typed in a widget is read only if you hit <TT>Return</TT>. If
you type some text in a widget without pressing the <TT>Return</TT>
key, the widget will look modified but it keeps the previous value
instead (if this is the first time you type in a widget it is quite
likely that the previous value is the empty string).
</P>

<P>
For instance, typing a C++ cut in the <TT>Match</TT> widget of
the <EM>HepMatchAndFill</EM> module without hitting
<TT>Return</TT>, the module will not 
recognize the <TT>Match</TT>
expression and will thus select all tags.


</P>

<P>
A slider widget allows you to vary a parameter between a minimum and a
maximum value using the mouse. If you prefer to use the keyboard
instead, you can directly type into the text field displaying the
current value.  The range limits can be changed in a similar way.
</P>

<P>
When you save a map after editing its modules' widgets, the values on
the widget are retained and will be shown again the next time when you
run the map. Be aware that a listbox is usually cleaned up, so that
you will have to select the item again.


</P>

<P>
Reference documentation on Iris Explorer is available 
online as follows.
<UL>
<LI>
<EM>IRIS Explorer Users' Guide.</EM> at the URL
The basic IRIS Explorer system, scripting, and DataScribe.
<A HREF="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/UG/CONTENTS.html">here</A>.




</LI>
<LI>
<EM>IRIS Explorer Documentation.</EM>

Pointers to all of NAG's IRIS Explorer documentation. See the URL
<A HREF="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/Index.html">here</A>.

</LI>
</UL>
</P>



<H3>6.1.3. Appearance of IRIS Explorer modules</H3>

<P>On Unix systems, IRIS Explorer modules can appear in three different
ways on the Map Editor.
</P>
<UL>
<LI>
<EM>Minimized view</EM>: no user interface is visible.</LI>
<LI>
<EM>Diminutif view</EM>: a scaled-down version of the user interface is visible.</LI>
<LI>
<EM>Maximized view</EM>: the GUI is expanded to a full-size panel.</LI>
</UL>
<P>On Windows/NT the diminutif view is not available, thus modules are either minimized
or maximized.
</P>





<H2>6.2. Storing and deleting histograms</H2>

<P>HBOOK and PAW used to deal with histograms in the
``traditional'' way:</P>



<UL> 
<LI>all histograms are created in memory;</LI> 
<LI>interesting histograms are explicitly saved (explicit I/O).</LI>
</UL>

<P>An ODBMS such as Objectivity/DB works exactly the other way round:</P>


<UL>
<LI>all histograms are created in the database (implicit I/O);</LI>
<LI>uninteresting histograms are explicitly deleted.</LI>
</UL>

<P>There are different ways to manage the deletion of such histograms.</P>

<UL>
 <LI>In a C++ program the user can either:
  <UL>
   <LI>individually delete each histogram (using the <TT>delete</TT> method 
       or the <TT>ooDelete</TT> function);</LI>
   <LI>allocate ``temporary'' histograms in a well defined container and 
       at the end delete the whole container.</LI>
  </UL>
 </LI>
 <LI>In an IRIS Explorer map the user can either:


  <UL> 
   <LI>individually delete each histogram (using the
       <EM>HistOOgramDelete</EM> module);


   </LI>
   <LI>create ``temporary'' histograms in a well defined 
       container and at the end delete the whole container (using 
       the <EM>ContainerDelete</EM> module).


   </LI>
  </UL>
 </LI>
</UL>

<P>Modules such as <EM>HistOOgramFill</EM> (Ntuple-like analysis)
store their temporary histograms in a container named
<TT>HistoDump_uid</TT>, where <TT>uid</TT> stands for
the user's Unix <TT>uid</TT>. The container is created in a
database called <TT>UserDb</TT>, as seen in Figure 
<a href="H1HEPExplorerModules.html#HISTSTORE">[HISTSTORE]</a>.


</P>


<P CLASS="CENTERP">
<A NAME="HISTSTORE"><IMG SRC="histstore.gif"></A>
</P>
<P>
<B>Storing histograms in a container</B>
</P>


<P>
The cleanup of temporary histograms is managed by the <EM>HepMatchAndFill</EM>
and <EM>HepLoop</EM> modules. The user can either:




</P>
<UL>
<LI>clean up the dump container immediately;</LI>
<LI>clean it up when the module leaves;</LI>
<LI>keep the dump contents across separate IRIS Explorer sessions.</LI>
</UL>



<H2>6.3. Displaying histograms</H2>

<P>Several HEP Explorer modules have been developed to handle histograms.
In the following sections we shall explore them each in turn.</P>


<H3>6.3.1. The <EM>ContainerBrowser</EM> module</H3>



<P>The <EM>ContainerBrowser</EM> module allows you to browse the
databases in the federated database defined by the <TT>OO_FD_BOOT</TT>
environment variable.  When the module starts, the list of the data
bases available in the <TT>OO_FD_BOOT</TT> federated database appears
in the <TT>DB List</TT> scroll field. A list of all the containers
available in a given database can be obtained by click on the database
name in question the <TT>DB List</TT> field.  You can also create a
new container belonging to the chosen database by typing the new
container's name in the <TT>container</TT> text field. The output of
this module is a container which can be connected to the <EM>Histogram
Reader</EM> module. The <EM>ContainerBrowser</EM> panel is shown in 
Figure <a href="H1HEPExplorerModules.html#HEPEXCONTAINER">[HEPEXCONTAINER]</a>.


</P>

<P CLASS="CENTERP">
<A NAME="HEPEXCONTAINER"><IMG SRC="hepex_container.gif"></A>
</P>
<P>
<B><EM>ContainerBrowser</EM> panel</B>
</P>






<H3>
<A NAME="HistOOgramReader">6.3.2. The <EM>HistOOgramReader</EM> module</A>
</H3>



<P>The <EM>HistOOgramReader</EM> module receives a container from the
<EM>ContainerBrowser</EM> module and allows you to select a histogram
from that container.  The list of histograms appears in the
<TT>Histograms</TT> field. You can select the type of histogram should
be shown (1D, 2D or all) using the radio buttons on the right of the
<TT>Histogram</TT> list. By clicking on one of the histogram names in
that list, the selected histogram is send on the output port and can
be received by any module able to take an histogram as its input.
The <EM>HistOOgramReader</EM> panel is shown in 
Figure <a href="H1HEPExplorerModules.html#HEPEXREADER">[HEPEXREADER]</a>.
</P>

<P CLASS="CENTERP">
<A NAME="HEPEXREADER"><IMG SRC="hepex_reader.gif"></A>
</P>
<P>
<B><EM>HistOOgramReader</EM> panel</B>
</P>






<H3>
<A NAME="SECHTLPLOT">6.3.3. The <EM>HistOOgramPlot</EM> module</A>
</H3>



<P>This <EM>HistOOgramPlot</EM> module receives the histogram from
the <EM>HistOOgramReader</EM> module. It can also take lattices as
input as shown in the following example. It creates the geometry from
these data and sends them to the <EM>Render</EM> module, which shows
the result on screen. To save pictures as vector PostScript files, use the 
<EM>PostScript</EM> module. </P>





<P>
The <EM>HistOOgramPlot</EM> module 
shown in Figure 
assumes that the background of the
Render window is white. It is possible to change this background colour
with the <TT>Edit Background Color</TT> option in the <TT>Viewing</TT>

menu or by specifying a different colour in the X11 resources, 
as follows.</P>





<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
*SoXtExaminerViewer*BackgroundColor: white
*SoXtFlyViewer*BackgroundColor: white
*SoXtPlaneViewer*BackgroundColor: white
*SoXtWalkViewer*BackgroundColor: white
</PRE>
</TD>
</TR>
</TABLE>

<P>
Various plot attributes can be changed via radio buttons or
pull-down menus. The action of the majority of the selectors is quite
obvious by just reading their names. We shall thus only say a few
words about the less trivial case of the <TT>Plot mode</TT>
selector.</P>


<H4>6.3.3. The <TT>Plot mode</TT> selector</H4>

<P>The default value of the <TT>Plot mode</TT> selector is <TT>Start new
plot</TT>. In this state, the last histogram or lattice entered in the
picture is deleted each time a new histogram or lattice is received by
the module. Another value for this selector is <TT>Cumulate</TT>.  In
this case each new histogram or lattice received by the module will be
drawn on the same plot. Finally, by pushing the <TT>New page</TT>
button you will start a new page, deleting all the current plots.</P>


<P CLASS="CENTERP">
<A NAME="HEPEXPLOT"><IMG SRC="hepex_plot.gif"></A>
</P>
<P>
<B><EM>HistOOgramPlot</EM> panel</B>
</P>








<H3>6.3.4. How to Plot a histogram</H3>

<P>When the map is ready on the <EM>Map Editor</EM>, you should
first select a database by just clicking on its name in the
<EM>ContainerBrowser</EM> panel and then go on to select a
container name. The list of histograms is now visible in the
<EM>HistOOgramReader</EM> panel. It suffices to select a histogram
by clicking on its name for it to be displayed in the
<TT>Render</TT> window. It can be useful to set the render
window background to white via the <TT>edit background
color</TT> option in the <TT>Viewing</TT> menu of the
<EM>Render</EM> window.</P>










<P>
The map and the PostScript output for a simple one-dimensional
histogram are shown in Figures <a href="H1HEPExplorerModules.html#HEPEX1MAP">[HEPEX1MAP]</a> and 
<a href="H1HEPExplorerModules.html#HEPEX1">[HEPEX1]</a>.
</P>

<P CLASS="CENTERP">
<A NAME="HEPEX1MAP"><IMG SRC="hepex1map.gif"></A>
</P>
<P>
<B>HEP Explorer histogram viewing screen</B>
</P>


<P CLASS="CENTERP">
<A NAME="HEPEX1"><IMG SRC="hepex1.gif"></A>
</P>
<P>
<B>A histogram viewed with the HEP Explorer modules</B>
</P>


<P>
It is also possible to have several zone on the same plot by assigning
a <EM>HistOOgramPlot</EM> module to each zone and varying the zone
coordinates value. The map and the PostScript output for two
one-dimensional histograms are shown in 
Figures <a href="H1HEPExplorerModules.html#HEPEX2MAP">[HEPEX2MAP]</a> and <a href="H1HEPExplorerModules.html#HEPEX2">[HEPEX2]</a>.  
</P>

<P CLASS="CENTERP">
<A NAME="HEPEX2MAP"><IMG SRC="hepex2map.gif"></A>
</P>
<P>
<B>Map used to produce a ``2 zones'' plot</B>
</P>
 

<P CLASS="CENTERP">
<A NAME="HEPEX2"><IMG SRC="hepex2.gif"></A>
</P>
<P>
<B>Two histograms viewed with the HEP Explorer modules</B>
</P>
 



<H3>6.3.5. The <EM>PostScript</EM> module</H3>

<P>
The <EM>PostScript</EM> module allows to generate vector PostScript
files from any Open Inventor geometry. This module is based on the
PlotMaster tools provided by Master Suite. With 3D geometries the
PostScript output generated by PlotMaster may be wrong therefore it is
preferable to restrict the usage of this module to 2D geometries.
</P>


<P CLASS="CENTERP">
<A NAME="HEPEXPOSTSCRIPT"><IMG SRC="hepex_postscript.gif"></A>
</P>
<P>
<B><EM>PostScript</EM> panel</B>
</P>






<H3>6.3.6. Displaying a histogram as a Lego plot</H3>


<P>
Lauch the <TT>histogramPlot3D</TT> map, which consists of three components:
</P>
<UL>
<LI>the <TT>SelectHisto</TT> group, containing
the <EM>ContainerBrowser</EM> and <EM>HistOOgramReader</EM> modules;




</LI>
<LI>the <EM>HistOOgramLego</EM> module;


</LI>
<LI>the <EM>Render</EM> module.


</LI>
</UL>
<P>
By clicking on the <TT>SelectHisto</TT> widgets you can select
a 1D or 2D histogram that will be transformed in a Lego plot by the
<EM>HistOOgramLego</EM> module and finally displayed by the
<EM>Render</EM>. Whenever you change to another histogram, click
on the <TT>View All</TT> decoration (the small eye-shaped icon
on the right side of the <EM>Render</EM> window, sixth one from
the top) of the <EM>Render</EM> module to reset the camera
position.  An example is shown in Figure <a href="H1HEPExplorerModules.html#HISTOGRAMPLOT3D">[HISTOGRAMPLOT3D]</a>.
 

</P>

<P CLASS="CENTERP">
<A NAME="HISTOGRAMPLOT3D"><IMG SRC="lego.gif"></A>
</P>
<P>
<B>HEP Explorer map to display a Lego plot</B>
</P>







<H2>6.4. Deleting a histogram from a container</H2>

<P>If you want to delete a histogram from a container you should
construct the map shown in Figure <a href="H1HEPExplorerModules.html#HEPDELHISTMAP">[HEPDELHISTMAP]</a>.


</P>

<P CLASS="CENTERP">
<A NAME="HEPDELHISTMAP"><IMG SRC="hepdelhistmap.gif"></A>
</P>
<P>
<B>HEP Explorer map to delete a histogram from a
container</B>
</P>


<P>
The various steps to connect the modules in the map are first to
connect the <EM>HistOOgramDelete</EM> module to the output port of
the <EM>HistOOgramReader</EM> module. Then, you can select a
histogram by clicking on its name in the <EM>HistOOgramReader</EM>
panel's list.  The database identifier and name of the chosen
histogram will appear in the name fields of the
<EM>HistOOgramDelete</EM> modules. If you are sure you want to
drop the histogram from the selected container in the Objectivity/DB database,
confirm your choice by clicking the <TT>Delete</TT>
button. The situation after the deletion of the histogram selected in
the previous figure is shown in Figure <a href="H1HEPExplorerModules.html#HEPDELHISTMAP1">[HEPDELHISTMAP1]</a>.






</P>


<P CLASS="CENTERP">
<A NAME="HEPDELHISTMAP1"><IMG SRC="hepdelhistmap1.gif"></A>
</P>
<P>
<B>The <EM>HistOOgramReader</EM> after the
histogram deletion</B>
</P>






<H2>6.5. Creating a new histogram</H2>



<P>
When you want to create a new histogram you can use the module
<EM>HistOOgramCreate</EM>, whose panels for the one- and two
dimensional cases are shown in Figure <a href="H1HEPExplorerModules.html#HEPHISTCREATE">[HEPHISTCREATE]</a>.
</P>

<TABLE>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPHISTCREATE"><IMG SRC="hephistcreate1.gif"></A>
</P>
</TD>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPHISTCREATE"><IMG SRC="hephistcreate2.gif"></A>
</P>
</TD>
</TR>
</TABLE>
<P>
<B><EM>HistOOgramCreate</EM> panels (1D and 2D)</B>
</P>




<P>
The <EM>HistOOgramCreate</EM> module lets you create a new
histogram inside an existing container: the input port of this module
takes a container parameter. Therefore, it has to be connected to the
output port of the <EM>ContainerBrowser</EM> module.  The two maps
in Figure <a href="H1HEPExplorerModules.html#HEPHISTCREATEMAP">[HEPHISTCREATEMAP]</a> correspond to the situation
before and after the creation of a new one-dimensional histogram.  The
name chosen for the histogram is <TT>New Histogram</TT>, as
you can clearly see in the <EM>HistOOgramReader</EM> panel of the
map after the histogram creation.  (bottom part of Figure <a href="H1HEPExplorerModules.html#HEPHISTCREATEMAP">[HEPHISTCREATEMAP]</a>).








</P>

<TABLE>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPHISTCREATEMAP"><IMG SRC="hephistcreatemap.gif"></A>
</P>
</TD>
</TR>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPHISTCREATEMAP"><IMG SRC="hephistcreatemap1.gif"></A>
</P>
</TD>
</TR>
</TABLE>
<P>
<B>Map before (top) and after (bottom) creating a new histogram</B>
</P>






<H2>6.6. Scalar transformations on histograms</H2>



<P>Scalar transformations on histograms are the task of the
<EM>HistOOFunc</EM> module, whose panel is shown in Figure <a href="H1HEPExplorerModules.html#HEPHISTFUNC">[HEPHISTFUNC]</a>.  In the map (Figure <a href="H1HEPExplorerModules.html#HEPHISTFUNC">[HEPHISTFUNC]</a>)
you can see how you connect the output port of
<EM>HistOOgramReader</EM> module, which sends a histogram to the
input port of the <EM>HistOOFunc</EM> module. After the needed
transformation the <EM>HistOOFunc</EM> module sends the histogram
further to the <EM>HistOOgramPlot</EM> module.






</P>
<P>
An example of use of the <EM>HistOOFunc</EM> module is adding a
set of constants (selected on the dial of the
<TT>inScalar</TT> after first pushing the <TT>Add</TT>
on the <EM>HistOOFunc</EM> panel) to the same histogram (received
from the <EM>HistOOgramReader</EM> module) and plotting the
results in <TT>cumulate</TT> mode onto the same figure with
the <EM>HistOOgramPlot</EM> module, as shown in Figure <a href="H1HEPExplorerModules.html#HEPHISTFUNCEXA">[HEPHISTFUNCEXA]</a>.




</P>

<TABLE>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPHISTFUNC"><IMG SRC="hephistfunc.gif"></A>
</P>
</TD>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPHISTFUNC"><IMG SRC="hephistfuncmap.gif"></A>
</P>
</TD>
</TR>
</TABLE>
<P>
<B><EM>HistOOFunc</EM> panel and 
    map structure for scalar histogram transformations</B>
</P>


<P CLASS="CENTERP">
<A NAME="HEPHISTFUNCEXA"><IMG SRC="hephistfuncexa.gif"></A>
</P>
<P>
<B>Cumulating several histograms</B>
</P>




<H2>6.7. Printing a histogram</H2>



<P>Sometimes it can be interesting to actually <EM>print</EM> a
histogram. This is made possible by the <EM>HistOOgramPrint</EM>
module. The <EM>HistOOgramPrint</EM> module takes his input from
the <EM>HistOOgramReader</EM> module, as seen in the map shown in
Figure <a href="H1HEPExplorerModules.html#HEPPRINTHISTMAP">[HEPPRINTHISTMAP]</a>.  Then you will see information
(name, number of entries, bins, and parts) about the selected
histogram in the text fields of the <EM>HistOOgramReader</EM>
panel (Figure <a href="H1HEPExplorerModules.html#HEPPRINTHISTPANELLOG">[HEPPRINTHISTPANELLOG]</a>).  After pushing the
<TT>Print</TT> button in the <EM>HistOOgramPrint</EM>
panel, the output generated by the module is written to the
<EM>Explorer Log</EM> window (Figure <a href="H1HEPExplorerModules.html#HEPPRINTHISTPANELLOG">[HEPPRINTHISTPANELLOG]</a>).












</P>

<P CLASS="CENTERP">
<A NAME="HEPPRINTHISTMAP"><IMG SRC="hepprinthistmap.gif"></A>
</P>
<P>
<B>HEP Explorer map to print an histogram</B>
</P>


<TABLE>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPPRINTHISTPANELLOG"><IMG SRC="hepprinthistpanel.gif"></A>
</P>
</TD>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPPRINTHISTPANELLOG"><IMG SRC="hepprinthistlog.gif"></A>
</P>
</TD>
</TR>
</TABLE>
<P>
<B><EM>HistOOgramPrint</EM> panel and output</B>
</P>










<H2>6.8. Turning a histogram into a lattice</H2>



<P>To benefit fully from the many Iris Explorer modules which have
been developed in many different laboratories, research centres,
etc. worldwide, it is advantageous to provide a conversion tool to
translate the HEP-specific data types (i.e., histograms) into IRIS
Explorer generic data types (i.e., lattices).  The module
<EM>HistOOgram2Lat</EM> performs such a conversion.  The
corresponding <EM>HistOOgram2Lat</EM> panel is shown in Figure
<a href="H1HEPExplorerModules.html#HEPHIST2LAT">[HEPHIST2LAT]</a>.  To show how this module is used let us
have a look at the map in Figure <a href="H1HEPExplorerModules.html#HEPHISTLATMAP">[HEPHISTLATMAP]</a>.


</P>

<P CLASS="CENTERP">
<A NAME="HEPHIST2LAT"><IMG SRC="hephist2lat.gif"></A>
</P>
<P>
<B><EM>HistOOgram2Lat</EM> panel</B>
</P>


<P CLASS="CENTERP">
<A NAME="HEPHISTLATMAP"><IMG SRC="hephistlatmap.gif"></A>
</P>
<P>
<B>Map of Histogram to lattice transformation</B>
</P>



<P>
We see that the <EM>HistOOgram2Lat</EM> module takes an histogram
as input and generates a lattice as output. The latter output stream
can be fed into any of a series of standard modules which consume
lattices. In particular, in the example map shown we decided to
visualise a HTL histogram with the standard <EM>NAGgraph</EM>
module.




</P>



<H2>
<A NAME="MINUIT-GenDescription">6.9. Description of the IRIS 
Explorer <EM>DataFit</EM> Module</A>
</H2>





<P>
This module fits a mathematical model or a given user function to
data presented at its input ports. The underlying minimisation engine
is based on Minuit. The incoming data can be one- or two-dimensional
and can be presented as a lattice (any type, any coordinate type) or a
persistent histogram characterised by its Objectivity/DB object identifier. The
module always retains the data coming from the most recently updated
port.
</P>

<P>
After the data have been received, the module allows you to:
</P>

<UL>
<LI>give an expression for a mathematical model to use in the fit;</LI>
<LI>specify a filename containing a full user-defined function;</LI>
<LI>restrict the zone of interest of the data to fit;</LI>
<LI>import, export and control the parameters to be optimised;</LI>
<LI>launch the fit and retrieve the fitted parameters;</LI>
<LI>analyse the error matrix via calls to dedicated Minuit procedures.</LI>
</UL>




<H3>
<A NAME="MINUIT-Using">6.9.1. Using the <EM>DataFit</EM> module: a simple
example</A>
</H3>

<P>
The layout of the <EM>DataFit</EM> panel is shown
in Figure <a href="H1HEPExplorerModules.html#HEPFITFITPANEL">[HEPFITFITPANEL]</a>.
</P>

<P CLASS="CENTERP">
<A NAME="HEPFITFITPANEL"><IMG SRC="hepfit_fitpanel.gif"></A>
</P>
<P>
<B>Layout of the <EM>DataFit</EM> panel</B>
</P>


<P>On the fitting module's panel you can either specify as input the
object ID of the (one- or two-dimensional) persistent HTL histogram to be
fitted.  The center of each bin will be taken as reference for the
fit. Alternatively, you can use an IRIS Explorer lattice as input,
where for each lattice point two data values should be provided, first
the data and then the error value, in order to compute an accurate
chisquare. If there is only one data value per node, then a
non-weighted least mean square will be calculated.</P>

<P>The panel offers further various dials, sliders, input boxes, etc.,
to communicate with the fitting module. Each parameter in the fit is
identified by its name. A text input widget allows you to type in the
symbolic form of the model expression for the fit.  Available symbols
are: for one-dimensional fits: <TT>g</TT> or <TT>G</TT> for
<EM>Gaussian</EM>, <TT>e</TT> or <TT>E</TT> for <EM>Exponential</EM>,
and <TT>pN</TT> or <TT>PN</TT> (where <TT>N</TT> is a number) for a
<EM>Polynomial</EM> of degree <TT>N</TT>. For two-dimensional fits
only the Gaussian option (<TT>g</TT> or <TT>G</TT>) is available.
For instance one could write</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
 g+p3, g+G-e,
</PRE>
</TD>
</TR>
</TABLE>

<P>The module will generate the code for the function, compile it and
put it in a sharable library that will be be loaded dynamically. The
generated function will be a function of one or two variables
according to the dimension of the incoming data. If necessary, the
code for the function can be edited before compilation, or, more
generally, you can use your own function for fitting. This latter
possibility is facilitated by using the <TT>UserFunction</TT>
pull-down menu, which can generate a skeleton to ease editing. Once
are finished, and want want to fit with your own source code, you can
try to compile it. The module will then link it as a sharable library
and load it dynamically to update the function to minimize. Although
it can take some time, it is straightforward and does not request any
special intervention from the user, except, of course, if the
compilation fails.</P>

<P>For the fit itself there is the <TT>Fit</TT> menu, which
lets you launch fits with Minuit's <TT>MIGRAD</TT>,
<TT>MINIMIZE</TT>, <TT>SIMPLEX</TT>, and
<TT>IMPROVE</TT> procedures (see the Minuit documentation for
details). The covariance matrix of the fit is available via the
<TT>Show</TT> menu, while a more detailed
<TT>HESSE</TT> and <TT>MINOS</TT> error analysis can
is initiated via the <TT>Errors</TT> menu.





</P>



<H3>
<A NAME="MINUIT-parametersetting">6.9.2. Setting the right parameters</A>
</H3>

<P>Sometimes there is a lack of coherency between the model you try
to fit and the current set of parameters. as the module does not erase
the previous set of parameters each time you change the model, you
must be careful to specify sensible starting values yourself.  If you
are using a combination of the <EM>standard</EM> functions, you
can set a default starting value by using the <TT>Set Default from
Model</TT> command from the <TT>Parameters</TT> menu. This
will parse the model expression and generate a set of parameters with
appropriate names, default values and behaviours. Alternatively, you
can use the ASCII file that describes the set of parameters and that
can be read (and written) by the module. This is especially useful if
you are using your own fit function. The format of the file is very
easy to understand. Don't forget to specify in the header the number
of parameters for the fit. As it can sometimes be rather tedious to
adjust the starting values via the user interface, even for the
standard functions, you will find very quickly that the same method
can also be advantageous in this case and that the ASCII file provides
you with an efficient and fast way to achieve a good initialisation,
whereas the GUI allows you to <EM>move around and play</EM> to
visually investigate the effect of parameter changes.in
real-time.

</P>




<H3>6.9.3. Using the fitting module</H3>

<P>
In this section we shall go through the various steps needed to fit
and then plot a simple one-dimensional histogram retrieved from an
Objectivity/DB database. The modules concerned can be found on the map shown in
Figure <a href="H1HEPExplorerModules.html#HEPFITMAP">[HEPFITMAP]</a>.


</P>

<P CLASS="CENTERP">
<A NAME="HEPFITMAP"><IMG SRC="hepfitmap.gif"></A>
</P>
<P>
<B>The IRIS Explorer map for fitting and plotting 
histograms</B>
</P>




<P>Most modules present in the Iris Explorer map needed to fit and
plot histograms, have already been described before.
Therefore we only turn our attention towards the 
<EM>DataFit</EM> module itself.


</P>

<P>
The <EM>DataFit</EM> module receives a histogram from the
<EM>HistOOgramReader</EM> and performs a fit on it. The output of
the module is a lattice that is fed into a <EM>HistOOgramPlot</EM>
lattice input.




</P>

<P>When the map is ready on the <EM>Map Editor</EM>, you can
click on histogram in the <EM>HistOOgramReader</EM>. At that point
it is possible to adjust various attributes and the effect of these
changes will be visible immediately in the <EM>Render</EM> window.






</P>

<P>You are now ready to start a simple fit. Indeed, while sending
the data to the <EM>HistOOgramPlot</EM> module, they was also sent
to the <EM>DataFit</EM> module. Suppose we want to fit the
histogram to a Gaussian distribution. In this case it is enough to
type <TT>G</TT> in the <TT>ModelExpression</TT> text
field (lower left hand corner) of the <EM>DataFit</EM>
panel. After typing a carriage return, C++ source code corresponding
to the definition of a Gaussian parameter fit is generated, compiled
and loaded.


</P>

<P>
To have an acceptable set of starting values for the fit, it is
possible to adjust the fitting parameters visually. First in the
<TT>Parameters</TT> menu select <TT>Set default from
model</TT>.  This fills the <TT>Parameters list</TT> with
<TT>MAX1</TT>, <TT>Mean1</TT> and
<TT>StdDev1</TT>, corresponding to the three Gaussian
parameters. By clicking on one of them you can modify its value by
using the dials on the right of the <TT>Parameters
list</TT>. It is also possible to adjust the fitting interval with
the slider below the same <TT>Parameters list</TT>. If the
<TT>Histogram/Lattice</TT> button of the
<TT>HistOOgramPlot</TT> module is toggled to
<TT>Lattice</TT>, you will get the curve corresponding to the
actual parameter values displayed in the <TT>Render</TT>
window, as shown in Figure <a href="H1HEPExplorerModules.html#HEPFITEXA1">[HEPFITEXA1]</a>.





</P>

<P>
When you are satisfied with the initial values for the parameters, you
can select the <TT>Set into Minuit</TT> option in the
<TT>Parameters</TT> menu and then choose the fitting method
(for example <TT>MIGRAD</TT>) in the <TT>Fit</TT> menu
to perform the fit. The result is immediately visualised as shown in
Figure <a href="H1HEPExplorerModules.html#HEPFITEXA2">[HEPFITEXA2]</a>.


</P>



<P CLASS="CENTERP">
<A NAME="HEPFITEXA1"><IMG SRC="hepfitexa1.gif"></A>
</P>
<P>
<B>Curve the initial values before the fit</B>
</P>


<P CLASS="CENTERP">
<A NAME="HEPFITEXA2"><IMG SRC="hepfitexa2.gif"></A>
</P>
<P>
<B>Curve for the final values after the fit</B>
</P>




<H3>
<A NAME="MINUIT-HowSetFitFunction">6.9.4. A more complex example:
     using your own fit function</A>
</H3>

<P>As sometimes the predefined functions are not sufficient for your
needs, you will have to write and use your own model function. The
present section will guide you through the various steps you have to
take.</P>

<OL>
<LI>
Specify the name of the C-file which want the module to use in the
<TT>Source Input Filename</TT> text widget.  If this file already
exists go to step 5 since steps 2 to 4 below explain how to create a
new file. Note, however, that the contents of an already existing file
will be overwritten with its new definition.
</LI>
<LI>
Specify the number of parameters your model will use in the <TT>Nb of
parameters</TT> text widget. This is not so important; if you do not
know exactly your number of parameters, just give an
approximation.
</LI>
<LI>
Choose <TT>Generate Skeleton</TT> from the
<TT>UserFunction</TT> menu. This should create the file
containing a skeleton implementation for your fit function in the
directory <TT>$EXPLORERUSERHOME/fitting/lib</TT>.

</LI>
<LI>
Edit the file and write your function. You can always have a look at
the file <TT>Minuit_fit_function</TT> in the same directory.
If your model contains some of the standard functions you can try to
construct a formula using these standard functions which is close in
form to your model expression, then choose <TT>Write model to User
File</TT> from the <TT>UserFunction</TT> menu. This
replaces steps 2 and 3 and can let you gain some time. Below we show
an example of such a model function.



</LI>
<LI>
Choose <TT>Compile User Function</TT> from the
<TT>UserFunction</TT> menu. This should replace the old model
by your new one.

</LI>
<LI>
Define the parameters via the option <TT>Open Parameters
file</TT> in the <TT>Parameters</TT> menu. If the file
exist, the fields <TT>Par Filename Input</TT> and
<TT>Parameter List</TT> at the top of the <EM>DataFit</EM>
panel will be updated. If the file does not exist you should create
it. The simplest procedure is to start from a parameter file created
form a standard model via the option <TT>Save to Parameters
file</TT> in the <TT>Parameters</TT> menu.


</LI>
</OL>

<P>From here on the fitting procedure proceeds as in the case of a
standard expression (as explained 
in Section <a href="H1HEPExplorerModules.html#MINUIT-Using">[MINUIT-Using]</a>)
</P>


<H4>6.9.4. Example of a fit function</H4>

<P>Below we show the example of a fit function which was automatically
generated by the <EM>DataFit</EM> module (in this case a second order
polynomial characterised by three parameters, the coefficients of the
terms). This source code can be edited as needed to implement the
desired function.</P>

<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
/**********************************************************************/
/*                                                                    */
/*   Here is defined the function the user wants to fit against his   */
/*   data                                                             */
/*   The call of this function is fixed                               */
/*      Arguments :                                                   */
/*          ndim : number of arguments the function needs             */
/*          coor : the coordinate of the point where the function is  */
/*                 computed                                           */
/*          nparam : nb of parameters the fit function depends on     */
/*          param   : set of parameters values                        */
/*                                                                    */
/*   This file may be automatically generated by the module           */
/*   DataFit or edited by the user                                    */
/*                                                                    */
/**********************************************************************/

#include &lt;values.h&gt;
#include &lt;math.h&gt;

double fit_function(int ndim, float *coor, int nparam, double *param)

{
	double result;
	double X;

	X=(double)(*coor);

	result =
	(param[0] +
	(param[1]*X) + 
	(param[2]*pow(X, 2.0))) ; 

	return (result);
}

 /*  Summary of the meaning of the parameters 
	  param[0] : c, constant value of polynom #1
	  param[1] : b, coefficient #1 of polynom #1
	  param[2] : a, coefficient #2 of polynom #1
 */ 
</PRE>
</TD>
</TR>
</TABLE>

<P>The <EM>DataFit</EM> module uses a parameter file, which contains
the values and other information for the parameters used in the fit.
The parameter file corresponding to the function described above is
shown below.</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
 Parameter Tables for MINUIT/EXPLORER Modules 
 Number of Defined Parameter 3 
  
 Parameter # 1 
     Name c
     Value 50000
     Old Value 1 
     Lower Limit 0 
     Upper Limit 100000 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 2 
     Name b
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 3 
     Name a
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
</PRE>
</TD>
</TR>
</TABLE>







<H2>
<A NAME="HEPExplorerexplorable">6.10. Interactive analysis in IRIS Explorer</A>
</H2>


<H3>6.10.1. Introduction</H3>


<P>HEP Interactive Analysis in IRIS Explorer is implemented by a set
of HEPExplorer Modules.  Generally speaking, the current set of
Modules allows you to extract data from an Objectivity/DB data store and
put them in a HTL histogram, using cuts on the data set expressed in C++
syntax. In particular modules implement the following 
functions (see Figure ):
</P>

<UL>
<LI>select an explorable collection;

</LI>
<LI>define a set of cuts over the collection;</LI>
<LI>define the input streams for the HTL histograms you will produce;</LI>
<LI>automatically generate and compile C++ code that implements the cuts;</LI>
<LI>fill the histogram with data retrieved from the collection.</LI>
</UL>

<P>Apart from accessing the data in the tag, users can invoke C++
functions that implement common physics or access the experiment
specific event object (by traversing the association between a tag and
its related event). User-defined functions can be used whenever a C++
expression is allowed.</P>


<P>The modules can be grouped in an IRIS Explorer map to avoid redefining
every time the user's analysis setup and such a map can be executed in
a <EM>batch</EM> fashion using IRIS Explorer's script language.</P>




<H4>6.10.1. The <EM>HepExplorableBrowser</EM> module</H4>



<P>The <EM>HepExplorableBrowser</EM> module lets you browse and
select explorable collections. In the <TT>Explorable List</TT>
text field you can select a tag, whose identifier will appear in the
<TT>Selected</TT> field. Then the <TT>Field List</TT>
will show you the various fields of the tag, and you can select one
and pass it on to the <EM>HepMatchAndFill</EM> module. The
<EM>HepExplorableBrowser</EM> panel is shown in Figure <a href="H1HEPExplorerModules.html#HEPEXPBROWSER">[HEPEXPBROWSER]</a>.







</P>

<P CLASS="CENTERP">
<A NAME="HEPEXPBROWSER"><IMG SRC="HepExplorableBrowser.gif"></A>
</P>
<P>
<B><EM>HepExplorableBrowser</EM></B>
</P>






<H4>6.10.1. The <EM>HepMatchAndFill</EM> module</H4>



<P>
This new module offers the same features as the three former modules
<EM>HepExplorableSelector</EM>, <EM>LibMaker</EM> and
<EM>HistOOgramFill</EM>, and is equivalent to PAW's
<TT>NT/PLOT</TT>, <TT>NT/PROJECT</TT> commands.
Basically it:







</P>
<UL>
<LI>
	allows users to define specific cuts (<TT>Match</TT> field),
	values and weights for filling histograms (<TT>X, Y</TT> and 
	<TT>W</TT> fields).
</LI>
<LI>
	automatically generates C++ code to fill histograms according to the 
	information above, compiles this code and executes it.
</LI>
</UL>
<P>
As for the <EM>HepLoop</EM> module, histograms are created in a
default dump container if none is specified on the input port. When
leaving the module, users can have these histograms erased
automatically (default behavior) or left as is (just click on the
<TT>Keep Dump</TT> radio button); users can also erase them at
any time by clicking on the <TT>Erase Now</TT> button.


</P>
<P>The <EM>HepMatchAndFill</EM> panel is shown in Figure <a href="H1HEPExplorerModules.html#HEPMATCHANDFILL">[HEPMATCHANDFILL]</a>.
</P>

<P CLASS="CENTERP">
<A NAME="HEPMATCHANDFILL"><IMG SRC="HepMatchAndFill1.gif"></A>
</P>
<P>
<B><EM>HepMatchAndFill</EM> panel</B>
</P>






<H4>6.10.1. The <EM>HepLoop</EM> module</H4>



<P>
This module is equivalent to the <TT>PAW NT/LOOP</TT> command
and offers a framework to scan an explorable collection, apply a
certain cut/match to the collection (or to each of its items) and
execute a particular action each time this match succeeds. The action
may for instance be the filling of histograms.




</P>
<P>
Most of the code (both header file and source file) is automatically
generated: users only have to provide/write the relevant part of code
for the match/cut or action to be taken for instance.  As with
<EM>HepMatchAndFill</EM> symbolic constants are supported and may
be passed to the code without no extra compilation overhead.


</P>
<P>
Once the entire code meets the user's requirements,
<EM>HepLoop</EM> makes it possible to generate files and Makefile
for a standalone version corresponding to the current customized code
and setup. The standalone application may then be executed outside of
Iris Explorer like any other applications.


</P>
<P>The <EM>HepLoop</EM> panel is shown
in Figure <a href="H1HEPExplorerModules.html#HEPLOOP">[HEPLOOP]</a>.
</P>

<P CLASS="CENTERP">
<A NAME="HEPLOOP"><IMG SRC="HepLoop1.gif"></A>
</P>
<P>
<B><EM>HepLoop</EM> panel</B>
</P>







<H3>6.10.2. The <EM>explorablePlot</EM> map</H3>





<P>
The <EM>explorablePlot</EM> map is an example of how to use HEP-Explorer 
modules; it produces HTL histograms out of an explorable collection.
You can think of this map as a <EM>NT/PL replacement</EM>.




</P>
<P>
The map has three modules: <EM>HepExplorableBrowser</EM>,
<EM>HepMatchAndFill</EM>, and <EM>HistOOgramPlot</EM>.


</P>

<UL>
<LI>
<EM>HepExplorableBrowser</EM>'s output port
<TT>Explorable</TT> is connected to
<EM>HepMatchAndFill</EM>'s input port <TT>Explorable</TT>;




</LI>

<LI>
<EM>HepMatchAndFill</EM>'s output port <TT>output
Histo</TT> is connected to <EM>HistOOgramPlot</EM>'s input
port <TT>inHisto</TT>;


</LI>

<LI>
<EM>HistOOgramPlot</EM>'s output port <TT>OutputGeometry</TT> is
connected to <EM>Render</EM>'s input port <TT>Geometry</TT>.




</LI>
</UL>

<P>
The details of the <EM>explorablePlot</EM> map can be seen
in Figure <a href="H1HEPExplorerModules.html#HEPEXPLORABLEMAP">[HEPEXPLORABLEMAP]</a>).




</P>

<P CLASS="CENTERP">
<A NAME="HEPEXPLORABLEMAP"><IMG SRC="hepexplorablemap.gif"></A>
</P>
<P>
<B>The <EM>explorablePlot</EM> map</B>
</P>






<P>If you want to produce HTL histograms you should do the following.</P>

<OL>
<LI>Select an explorable collection using the
<EM>HepExplorableBrowser</EM> module.  The selected item is passed
over to the <EM>HepMatchAndFill</EM> module.





</LI>
<LI>Define your cuts on the explorable collection by typing a C++ expression
in the <TT>Match</TT> field of the <EM>HepMatchAndFill</EM> module.



</LI>
<LI>Define what you want to put in your HTL histograms as C++ expressions
in the <TT>X</TT>, <TT>Y </TT>and <TT>W</TT> fields of the
<EM>HepMatchAndFill</EM> module.


</LI>
<LI>Click on the <TT>Execute</TT> button of the
<EM>HepMatchAndFill</EM> module to generate the C++ code, compile
it, if need be, and then execute it.


</LI>
<LI>
The <EM>HistOOgramPlot</EM> module transforms the histogram data into
a graphics scene which is displayed by the <EM>Render</EM> module.




</LI>
</OL>



<H3>6.10.3.  Getting the most of <EM>HepMatchAndFill</EM>
</H3>



<P>
<EM>HepMatchAndFill</EM> provides many other useful features including the
following.
</P>
<UL>
<LI>
The use of symbolic constants can avoid code recompilation overhead;
</LI>
<LI>
a customized pre-booked histogram can be specified instead of the
default one;
</LI>
<LI>
users can add extra C++ source files or includes files to define more
complex cuts or histogram variables;
</LI>
<LI>
users can directly access event data from an explorable collection.

</LI>
</UL>
<P>
Notice the use of the <EM>HistoryBox</EM> module to keep a history
of the cuts expressions, for instance.


</P>


<H4>6.10.3.  Using symbolic constants in <EM>HepMatchAndFill</EM>
</H4>



<P>
Symbolic constants can be specified in the <TT>Match</TT>,
<TT>X</TT>, <TT>Y</TT> and <TT>W</TT> fields
instead of actual numerical values.  The main advantage with this
approach, apart from having simpler and clearer expressions, is that
whenever users want to modify the numerical values of these symbolic
constants to fit their needs, the C++ generated code is neither
regenerated nor recompiled: the compilation overhead is thus
eliminated.
</P>

<P>Such symbolic constants are defined in the
<TT>Constants</TT> field and obey the C++ numerical constants
assignment syntax: <TT>name = value</TT>.  For instance, the
following expression defines two symbolic constants (the last
semi-colon is optional):
</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
	PART_MIN = 45500; X_OFFSET = 36.462;
</PRE>
</TD>
</TR>
</TABLE>
<P>
Note that currently there is a limitation on the definition of
symbolic constants, namely <B>the order of the definitions in the
<TT>Constants</TT> field is significant. The order cannot be
changed unless the code is re-generated, otherwise consistency is not
assured.
</B>
</P>



<H4>6.10.3. Specifying a pre-booked histogram</H4>
<P>
By default <EM>HepMatchAndFill</EM> fills a histogram booked on the fly 
in a dump container. The min and max values of the default 
histogram are sampled from the data, while the number of bins is 100 for 
1D histograms and 40 by 40 for 2D histograms.


</P>
<P>
If a valid histogram is connected to the optional histogram input port
(<TT>Input Histo</TT>), then this histogram is used instead of
the default one.  Typically users can look up a histogram (via
<EM>HistOOgramReader</EM>) or create a new one (thanks to
<EM>HistOOgramCreate</EM>) and pass it to
<EM>HepMatchAndFill</EM>, when they want to fill their customized
histogram.






</P>
<P>
The panel in Figure <a href="H1HEPExplorerModules.html#HEPMATCHANDFILL4">[HEPMATCHANDFILL4]</a> shows how the
<TT>Customized_Histo</TT> HTL histogram (created by
<EM>HistOOgramCreate </EM>) can be specified and connected to the
input port <TT>Input Histo</TT> of
<EM>HepMatchAndFill</EM>.




</P>

<P CLASS="CENTERP">
<A NAME="HEPMATCHANDFILL4"><IMG SRC="HepMatchAndFill4.gif"></A>
</P>
<P>
<B>Handling histograms with the <EM>HepMatchAndFill</EM> module</B>
</P>






<H4>6.10.3. Invoking user defined methods and code</H4>

<P>
When a cut becomes rather long and complex, users might find it useful
to be able to call a customized function that implements the tricky
cut.  If the routine is short enough, the easiest way to proceed is to
define it in a header file and specify the filename in the
<TT>Include Files</TT> widget.  However, If the code of the
function becomes larger, it might be better pratice to declare the
routine in a header file and implement it in a separate source
file. In this case the header filename (<TT>.h</TT>) and
source filename (<TT>.cpp</TT>) should be specified using the
<TT>Include Files</TT>, and <TT>Source Files</TT>
widgets, respectively.
</P>
<P>
You can specify extra compilation and linking options as follows:
</P>
<UL>
<LI>
the <TT>Build Options</TT> field lets you add extra
<TT>includes</TT> or <TT>define</TT> directives;
</LI>
<LI>
the <TT>Libraries</TT> field lets you add extra libraries.
</LI>
</UL>
<P>
The two panels of Figure <a href="H1HEPExplorerModules.html#HEPMATCHANDFILLCUT">[HEPMATCHANDFILLCUT]</a> show how to
use a customized cut function (<TT>my_cut</TT>) and the files
(<TT>my_cut.h</TT> and <TT>my_cut.cpp</TT>) that are
specified in the relevant widgets of the <EM>HepMatchAndFill</EM>
module.


</P>

<TABLE>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPMATCHANDFILLCUT"><IMG SRC="HepMatchAndFill2.gif"></A>
</P>
</TD>
<TD>
<P CLASS="CENTERP">
<A NAME="HEPMATCHANDFILLCUT"><IMG SRC="mycut.gif"></A>
</P>
</TD>
</TR>
</TABLE>

<P>
<B>Specifying a customized cut function with
<EM>HepMatchAndFill</EM></B>
</P>






<H4>6.10.3. Accessing event data from an Explorable collection</H4>


<P>
HEP-Explorer modules for interactive analysis allow you to easily
manipulate tag fields to define cuts, or to collect information in a
HTL histograms. As mentioned before, no knowledge of the specific
object model is required as long as you deal with attributes defined
in the tag. However, when you need to cross the association between a
tag and its related event in order to retrieve more information, the
HEP-Explorer modules have to get access to the object model.
</P>

<P>
Information about the object model is communicated to
<EM>HepMatchAndFill</EM> by specifying the following:


</P>

<UL>
<LI>
the header file (<TT>Include Files</TT> field) that contains the 
declaration of your tag and the related event;
</LI>
<LI>
the name of the concrete tag (<TT>Concrete Tag</TT> field) to
be used, i.e., the name of the class implementing the tag;
</LI>
<LI>
the shared library (<TT>Libraries</TT> field) which contains
the code to access tag/event methods and attributes.
</LI>
</UL>

<P>
Figure <a href="H1HEPExplorerModules.html#HEPMATCHANDFILL3">[HEPMATCHANDFILL3]</a> shows an example using the
<TT>AtlasProdTag</TT> concrete tag. Its declaration is in the
header file <TT>AtlasProd.h</TT> and its associated library
has been specified in the <TT>Libraries</TT> field.
</P>

<P CLASS="CENTERP">
<A NAME="HEPMATCHANDFILL3"><IMG SRC="HepMatchAndFill3.gif"></A>
</P> 
<P>
<B>Example of accessing event data  
         from an Explorable collection</B>
</P>



<P>
The <TT>theTag</TT> object is then ready for use, should you
want to access the concrete tag. You may ask for a reference to an
event using the <TT>getEvent()</TT> method. With this
reference you can then access each of the attributes as you would do
in a normal C++ program (in the <TT>AtlasProd</TT> example the
attribute is named <TT>NgTrack</TT> and corresponds to the
number of tracks in the event).
</P>

<P>
Note that your shared library should be placed in a directory included
in the shared library path (see Section <a href="H1HEPExplorerModules.html#TROUBLESHAREDLIBRARIES">[TROUBLESHAREDLIBRARIES]</a> for more details).
</P>





<H3>6.10.4.  The <EM>HepLoopMap</EM> map</H3>



<P>
This map shows an example of how to use the <EM>HepLoop</EM>
module with other HEP-Explorer modules to perform a custom interactive
analysis.


</P>

<P>
The <EM>HepLoopMap</EM> map shown in Figure <a href="H1HEPExplorerModules.html#HEPLOOPMAP">[HEPLOOPMAP]</a> consist of four modules:


</P>
<UL>
<LI>
<EM>HepExplorableBrowser</EM>.  This module provides an explorable
collection to be looped over.



</LI>
<LI>
<EM>HepLoop</EM>.  This module scans the collection, checks for
elements that match a specific user-defined cut and performs the
relevant user-defined action.


</LI>
<LI>
<EM>ContainerBrowser</EM>.  Most of the time users want to fill
HTL histograms. By default, such HTL histograms are created in a dump
container. However, users can also specify their own container
(obtained via <EM>ContainerBrowser</EM> for instance) by
connecting it to the optional input port <TT>Container</TT>.


</LI>
<LI>
<EM>HistOOgramReader</EM>.  The <EM>HepLoop</EM> module
provides on its output port the container (the default one or one
specified by the user) where all histograms have been created.  It is
then possible to display these histograms conveniently by connecting
this output port (<TT>Out Container</TT>) to
<EM>HistOOgramReader</EM>.




</LI>
</UL>


<P CLASS="CENTERP">
<A NAME="HEPLOOPMAP"><IMG SRC="HepLoopMap.gif"></A>
</P> 
<P>
<B>The <EM>HepLoopMap</EM> map</B>
</P>






<H3>6.10.5.  Getting the most of <EM>HepLoop</EM>
</H3>

<P>
<EM>HepLoop</EM> provides various features that offer better
control over the generated and customized code.


</P>
<UL>
<LI>
Using symbolic constants can avoid recompilation overhead as explained
when discussing how to get the most of <EM>HepMatchAndFill</EM>.


</LI>
<LI>
Users can specify the actual number of events to be processed when fitting
the cut expression. By default (when nothing is entered in the text field
<TT>Number of Events</TT>) the full collection is scanned.
</LI>
<LI>
As with <EM>HepMatchAndFill</EM>, extra files or extra compilation
options can be added.


</LI>
</UL>

<P>
When clicking on the <TT>Prototype</TT> button,
<EM>HepLoop</EM> generates two skeleton files: a header (extension
<TT>.h</TT>) and a source (extension <TT>.cpp</TT>)
file. The basename is specified in the <TT>Filename</TT>
field. The header file contains the main class declaration and the
source file the implementation of its methods. Those parts of the
methods that users may want to alter by introducing customized code
are bracketed with comments, as shown below.


</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
// *** BEGIN USER CODE ***
   <EM>user-modifiable code </EM>
// *** END USER CODE   ***
</PRE>
</TD>
</TR>
</TABLE>
<P>
Both header and source files contain some hints to assist the user,
e.g., on how to declare and use histograms.
</P>

<P>
Figure <a href="H1HEPExplorerModules.html#GENERATEDCODE">[GENERATEDCODE]</a> shows two panels with an example
of a header (left) and part of a source file (right) that were
automatically generated.
</P>

<TABLE>
<TR>
<TD>
<P CLASS="CENTERP">
<A NAME="GENERATEDCODE"><IMG SRC="GeneratedCodeH.gif"></A>
</P>
</TD>
<TD>
<P CLASS="CENTERP">
<A NAME="GENERATEDCODE"><IMG SRC="GeneratedCodeCPP.gif"></A>
</P>
</TD>
</TR>
</TABLE>
<P>
<B>Example of skeleton files generated by 
<EM>{HepLoop}</EM></B>
</P>



<P>
The principal idea behind <EM>HepLoop</EM> and its generated
skeleton code is to scan (loop over) an explorable collection,  apply a user-defined cut while trying
to match each of its items, then, when a match is successful, execute
a given action.  Note that customized actions can also be performed
once before the start of the loop (<TT>preExecute</TT> method)
and once after the loop terminates (<TT>postExecute</TT>).


</P>

<P>
The main methods users might want to customize include:
</P>
<UL>
<LI>
<TT>match</TT>: define in this method the specific cut/match
that is applied to each item of the explorable
collection. <TT>match</TT> should return 0 when the cut was
unsuccessful, a non-zero value otherwise.

</LI>
<LI>
<TT>action</TT>: this method is executed whenever the
match/cut succeeds.  Typically users might want to fill histograms in
this method.
</LI>
<LI>
<TT>preExecute</TT>: this method is executed once before
scanning an Explorable collection. Typically, this is where you would
perform initializations or assign resources.

</LI>
<LI>
<TT>postExecute</TT>: this method is executed once after
scanning an Explorable collection. Typically, this is where you would
release the resources that were assigned in
<TT>preExecute</TT>.
</LI>
</UL>
<P>Figures <a href="H1HEPExplorerModules.html#CUSTOMIZEDGENERATEDCODE1">[CUSTOMIZEDGENERATEDCODE1]</a> and <a href="H1HEPExplorerModules.html#CUSTOMIZEDGENERATEDCODE2">[CUSTOMIZEDGENERATEDCODE2]</a> show an implementation of some of
the methods described above, while Figure <a href="H1HEPExplorerModules.html#CUSTOMIZEDGENERATEDCODE3">[CUSTOMIZEDGENERATEDCODE3]</a> is the header file containing their
declaration.
</P>

<P CLASS="CENTERP">
<A NAME="CUSTOMIZEDGENERATEDCODE1"><IMG SRC="CustomizedGeneratedCode1.gif"></A>
</P>
<P>
<B>Customized code: the <TT>match</TT> and
         <TT>preExecute</TT> methods</B>
</P>


<P CLASS="CENTERP">
<A NAME="CUSTOMIZEDGENERATEDCODE2"><IMG SRC="CustomizedGeneratedCode2.gif"></A>
</P>
<P>
<B>Customized code: the <TT>action</TT> method</B>
</P>


<P CLASS="CENTERP">
<A NAME="CUSTOMIZEDGENERATEDCODE3"><IMG SRC="CustomizedGeneratedCode3.gif"></A>
</P>
<P>
<B>Header file used with <EM>HepLoop</EM> customized code
         examples</B>
</P>




<H3>6.10.6. The standalone version of <EM>HepLoop</EM>
</H3>

<P>
Once the code generated by <EM>HepLoop</EM> has been modified and
customized, it is possible to build a standalone version of the code,
i.e., a version of <EM>HepLoop</EM> that can execute the
customized code outside of Iris Explorer.


</P>
<P>
In order to prepare such a standalone versin, users should click on
the <TT>Generate Makefile</TT> button. Then
<EM>HepLoop</EM> generates:


</P>
<UL>
<LI>
a makefile (<TT>GNUmakefile</TT>) that registers the current
setup of the module (compilation options, include files, source files,
etc.);
</LI>
<LI>
the <TT>main_HepLoop.cpp</TT> file that can run the customized
code, which was prepared and tested previously.
</LI>
</UL>
<P>
Then a standalone version can be build by just typing the command:
</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
      gmake
</PRE>
</TD>
</TR>
</TABLE>
<P>
This will compile the customized code together with the file
<TT>main_HepLoop.cpp</TT> (and other C++ code, as needed)
using and environmental setup that was defined in
<EM>HepLoop</EM>.  The generated application is called
<TT>main_HepLoop</TT>, which can be executed by typing its
name:


</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
      main_HepLoop
</PRE>
</TD>
</TR>
</TABLE>
<P>
This has the same effect as clicking on the <TT>Execute</TT> button of
<EM>HepLoop</EM> inside Iris Explorer.


</P>

<P>
The standalone version of <EM>HepLoop</EM> accepts two optional arguments:


</P>
<OL>
<LI>
The constants to be passed to the customized code. It is a string
(inside quotes) that has the same format as the one of the
<TT>Constants</TT> field in <EM>HepLoop</EM>.  e.g.,
<TT>PART_MIN=45500; X_OFFSET 36.642;</TT>, where the last
semi-colon is optional. Constants must be specified in the same order
as they were in the <TT>Constants</TT> field and their number
must also correspond; no consistency is assured when these
requirements are not fulfilled.
</LI>
<LI>
The number of actual events to be processed.
</LI>
</OL>
<P>
As an example, the following command line executes the customized code
specifying two constants and looping will process a total of 65000
event.
</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
      main_HepLoop "PART_MIN=3455; X_OFFSET=24.78" 65000
</PRE>
</TD>
</TR>
</TABLE>




<H3>6.10.7. The <EM>TagViewer</EM> module</H3>



<P>
The <EM>TagViewer</EM> module allows users to apply simple range
cuts on tags value and visualize the result of the query as a
histogram.  Cuts can be specified as sequences of C++ expressions,
that are combined in <EM>and</EM> mode, so a cut is a valid C++
logical expression.  The BNF format of the cut is:
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
&lt;var#1&gt; &lt;comp#1&gt; &lt;arg#1&gt; &amp;&amp; &lt;var#2&gt; &lt;comp#2&gt; &lt;arg#2&gt; ...
</PRE>
</TD>
</TR>
</TABLE>
<TT>&lt;var#i&gt;</TT> is a tag attribute in the Field Lists.
<TT>&lt;comp#i&gt;</TT> is a comparison operator from the list:
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
&gt; , &lt; , &gt;= , &lt;= , == , != 
</PRE>
</TD>
</TR>
</TABLE>
<TT>&lt;arg#i&gt;</TT> represents either a tag attribute
<TT>&lt;var#j&gt;</TT> or a numeric value. 
<TT>&amp;&amp;</TT> represents the <EM>and</EM>
operator that separate elementary cuts.
</P>

<P>
Examples of valid cuts are:
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
pT &gt; 400

pt &gt; 400 &amp;&amp; pT &lt; 800

px &gt; py &amp;&amp; E &lt; 2.9 &amp;&amp; deadChan == 0
</PRE>
</TD>
</TR>
</TABLE>
The module supports on-the-fly rebinning of the histogram and
selection of a subset of tags. Figure <a href="H1HEPExplorerModules.html#TAGVIEWER">[TAGVIEWER]</a> shows
an example of the usage of the <EM>TagViewer</EM> module.
</P>


<P CLASS="CENTERP">
<A NAME="TAGVIEWER"><IMG SRC="TagViewer.gif"></A>
</P>
<P>
<B>The <EM>TagViewer</EM> module</B>
</P>






<H2>6.11. Troubleshooting</H2>




<H3>6.11.1. The text in the menus of the <EM>Render</EM> module is
difficult to read</H3>

<P>
Sometimes the text strings in the menus and subpanels of the
<EM>Render</EM> module are difficult to read since the actual
message text is not properly initialized (strings of the type
<TT>ivxxx</TT> are displayed).


</P>

<P>
To define the relevant text strings to be displayed, the corresponding
resources must be defined. These resources allow you to customize the
menus in question. For instance, you can change the language and
disable some of the menu items.
</P>

<P>
The <TT>app-defaults/Inventor</TT> directory contains the
default resource file for all standard viewers. System administrators
should copy this file into the directory
<TT>/usr/lib/X11/app-defaults</TT>.  For instance, a specific
language is chosen as follows.


</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
  ln -s Inventor.english Inventor
</PRE>
</TD>
</TR>
</TABLE>
<P>
One should also include the <TT>$OIVHOME/app-defaults</TT>
directory in the <TT>XAPPLRESDIR</TT> path variable.
</P>
<P>
If you already have a resource file then you can also merge 
the resource file <TT>$OIVHOME/app-defaults/Inventor.xxx</TT>
with yours (see the manual page of <TT>xrdb</TT>).
</P>



<H3>6.11.2. What to do if a map does not react at all?</H3>



<P>
IRIS Explorer maps obey the dataflow rule:
</P>

<OL>
<LI>a module fires when one of its inputs changes;</LI>
<LI>the module can then change its outputs;</LI>
<LI>if another module's input is connected to the changed output,
then that module will fire as well (according to rule 1).</LI>
</OL>

<P>You can check if a module is firing by verifying that its colour
turns yellow.  If the module does not fire then check the
following.</P>

<UL>
<LI>
All mandatory inputs are connected. For instance, if you do not
connect <EM>HistOOgramFill</EM>'s <TT>LibraryName</TT>
input to the corresponding <EM>LibMaker</EM>'s output, the module
will never activate.




</LI>
<LI>
All mandatory fields have been properly defined: a meaningful value is
typed and the Return key is pressed on the text fields, an item is
selected on the Listboxes.
</LI>
<LI>
There are no Objectivity/DB locks pending (just exit from IRIS Explorer and use
the Objectivity/DB <TT>oocleanup</TT> utility).

</LI>
<LI>
All modules are enabled (enabled modules have black titles on the
<EM>Map Editor</EM>, while disabled modules have grey title).  Be
aware that when a module crashes, IRIS Explorer will ask you whether
you want to replace the module with another instance. If you answer
positively, the newly loaded module will be disabled by default.  In
order to enable or disable a module you should click with the right
mouse button on the module's name in the <EM>Map Editor</EM>
window.








</LI>
</UL>



<H3>
<A NAME="TROUBLEEXCEED">6.11.3. The <EM>Render</EM> module dies when using 
Exceed</A>
</H3>




<P>
Exceed is the recommended X Window package on PCs at CERN.  If the
<EM>Render</EM> module dies immediately, try modifying the
configuration of your PC to use only 256 colours (from the <TT>Control
Panel</TT> window, select <TT>Display</TT> and then
<TT>Appearance</TT>).


</P>

<P>Otherwise, switch to Exceed V6.1 plus GL extensions.</P>


<H3>
<A NAME="TROUBLESHAREDLIBRARIES">6.11.4. Shared libraries</A>
</H3>


<P>
If you use HEPExplorer modules using shared libraries, e.g., to access
event data, it can happen that the module does not find a shared
library.  Although the details of shared library management differ
amongst Unix flavours, the generic approach is to define a shared
library path environment variable containing the list of directories
that have to be to searched when looking for a shared library.  You
should check that the shared library you want to use is located in one
of these directories. If it is located in a different directory you
can use a simple workaround by creating a symbolic link to your
library in the <TT>$EXPLORERUSERHOME/fitting/lib</TT> directory,
which is always included in the shared library path, e.g.,
</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
&gt; cd $EXPLORERUSERHOME/fitting/lib
&gt; ln -s /afs/cern.ch/myproject/HP-UX/atlasprod/libAtlasSpy.sl libAtlasSpy.sl
</PRE>
</TD>
</TR>
</TABLE>
<P>
Now your library has a symbolic link in one directory that is always
searched for.
</P>
<P>
Note that in the example above we used the HP extension <TT>.sl</TT>
for shared library names; on other computer platforms a different
file extension might be required.
</P>



<H3>
<A NAME="TROUBLEARENA">6.11.5. Shared memory</A>
</H3>


<P>
If when running Iris Explorer you get a message saying that the disk
where the shared memory <EM>arena</EM> resides is not large
enough, check the space available in <TT>/usr/tmp</TT> (the
location where IRIS Explorer by default creates its arena). If it is
too small you should enlarge it or change the directory where the
arena is created by specifying another
<EM><TT>tempdir</TT></EM> either in the system-wide
<TT>Explorer.config</TT> file or in your personal
<TT>.explorerrc</TT> e.g., by specifying a different directory
, (see IRIS ExplorerUser's Guide,
Appendix A at the URL <A HREF="http://www.nag.co.uk:80/visual/IE/iecbb/DOC/UG/appa.html">here</A>).
 


</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
! Set the directory where the arena and pipes go
set tempdir /usr/tmp/explorer
</PRE>
</TD>
</TR>
</TABLE>



<H3>
<A NAME="TROUBLEHPUX">6.11.6. Writing to <TT>cout</TT> on HPUX 10.20</A>
</H3>

<P>
On HPUX 10.20 there are problems with writing to <TT>cout</TT>
when the library <TT>libcx.a</TT> (via the option
<TT>-lcx</TT>) is included when building an Iris Explorer
module. It is therefore advisable to use <TT>printf</TT>
rather than the C++ construct <TT>cout &lt;&lt;</TT> to print
program variables to the output stream.
</P>



<H3>6.11.7. Unexpected error message at Render's startup on HP machines</H3>

<P>
On HP systems when starting up the Renderer the following error
message can be printed.
</P>
<TABLE>
<TR>
<TD CLASS="PRE">
<PRE>
Render: TGS hostid open failed for '/dev/seah0':Permission denied
</PRE>
</TD>
</TR>
</TABLE>
<P>
The message is just a warning and it is due to the presence of a
non-Ethernet card on the system (typically a FDDI card).  Users can
safely ignore this message.


</P>


<hr>
<address>
 Last updated: mg Mon Sep 06 12:06:49 GMT+03:30 1999<br>
</address>
</body>
</html>
