<?xml version="1.0" encoding='ISO-8859-1'?> 
<!-- Changed by: Michel Goossens, 3-Apr-1999 -->
<!-- 	$Id: htl.xml,v 1.4 1999/04/15 11:31:51 goossens Exp goossens $	 -->
<!DOCTYPE document SYSTEM "minilatex.dtd"[
<!ENTITY quot "&#34;">
<!ENTITY percent "!PERCENT!">
<!ENTITY uuml "ü">
<!ENTITY CERNLIB "CERNLIB">
<!ENTITY Excel "Excel">
<!ENTITY GNU  "GNU">
<!ENTITY HBOOK "HBOOK">
<!ENTITY HEP  "HEP">
<!ENTITY HepODBMS "HepODBMS">
<!ENTITY HTL  "HTL">
<!ENTITY LHCPP  "LHC++">
<!ENTITY NICE "Nice">
<!ENTITY OBJ  "Objectivity/DB">
<!ENTITY ODBMS "ODBMS">
<!ENTITY ODMG "ODMG">
<!ENTITY PAW  "PAW">
<!ENTITY SWIG "SWIG">
<!ENTITY UNIX "Unix">
<!ENTITY WNT  "Windows/NT">
<!ENTITY XML  "XML">
<!ENTITY ZEBRA "ZEBRA">
<!ENTITY % misc.new "|minipage">
<!ELEMENT minipage (#PCDATA|includegraphics|caption)*>
<!ENTITY % likepara.new "|texonly|small|footnote">
<!ELEMENT texonly (#PCDATA|par|figure|ref)*>
<!ELEMENT small (#PCDATA|par|emph)*>
<!ELEMENT footnote (#PCDATA|par|emph)*>
<!ENTITY % preformat.new "|alltt|listing|lprout">
<!ELEMENT alltt (#PCDATA|emph|ucom)*>
<!ELEMENT listing (#PCDATA)*>
<!ELEMENT lprout (#PCDATA)*>
<!ENTITY % xref.new "|vref">
<!ELEMENT vref     EMPTY>
<!ATTLIST vref     refid IDREF #REQUIRED>
<!ENTITY % inline.new "|ucom|code|sq">
<!ELEMENT code (#PCDATA)>
<!ELEMENT ucom (#PCDATA)>
<!ELEMENT sq (#PCDATA|code)*>
<!ENTITY % list.new "|descriptiona">
<!ELEMENT descriptiona ((term*,item*)+)>
<!ATTLIST descriptiona width CDATA #REQUIRED>
<!ENTITY nbsp " ">
<!-- External entity files -->
<!ENTITY Histo1Din         SYSTEM "/home/htl/HTLDOC/create_Histo1D.in">
<!ENTITY Histo1Dout        SYSTEM "/home/htl/HTLDOC/create_Histo1D.out">
<!ENTITY Histo1DVarin      SYSTEM "/home/htl/HTLDOC/create_Histo1DVar.in">
<!ENTITY Histo1DVarout     SYSTEM "/home/htl/HTLDOC/create_Histo1DVar.out">
<!ENTITY Histo2Din         SYSTEM "/home/htl/HTLDOC/create_Histo2D.in">   
<!ENTITY Histo2Dout        SYSTEM "/home/htl/HTLDOC/create_Histo2D.out">
<!ENTITY Histo2DVarin      SYSTEM "/home/htl/HTLDOC/create_Histo2DVar.in">   
<!ENTITY Histo2DVarout     SYSTEM "/home/htl/HTLDOC/create_Histo2DVar.out">
<!ENTITY HistoProfilein    SYSTEM "/home/htl/HTLDOC/create_profile.in">
<!ENTITY HistoProfileout   SYSTEM "/home/htl/HTLDOC/create_profile.out">
<!ENTITY HistoTablesin     SYSTEM "/home/htl/HTLDOC/histo_tables.in">
<!ENTITY HistoTablestxt    SYSTEM "/home/htl/HTLDOC/histo.txt">
<!ENTITY HistoTableskumac1 SYSTEM "/home/htl/HTLDOC/histotable.kumac">
<!ENTITY HistoTableskumac2 SYSTEM "/home/htl/HTLDOC/htl2hb.kumac">
<!ENTITY HistoRandomin     SYSTEM "/home/htl/HTLDOC/histo_random.in">
<!ENTITY HistoRandomout    SYSTEM "/home/htl/HTLDOC/histo_random.out">
<!ENTITY NameHistosin      SYSTEM "/home/htl/HTLDOC/name_histos.in">
<!ENTITY NameHistosout     SYSTEM "/home/htl/HTLDOC/name_histos.out">
<!ENTITY Operationsin      SYSTEM "/home/htl/HTLDOC/basic_operations.in">
<!ENTITY Operationsout     SYSTEM "/home/htl/HTLDOC/basic_operations.out">
<!ENTITY ReadHistoin       SYSTEM "/home/htl/HTLDOC/read_histo.in">
<!ENTITY ReadHistoout      SYSTEM "/home/htl/HTLDOC/read_histo.out">
<!ENTITY THistosin         SYSTEM "/home/htl/HTLDOC/create_transient.in">
<!ENTITY THistosout        SYSTEM "/home/htl/HTLDOC/create_transient.out">
<!ENTITY TSliceProjin      SYSTEM "/home/htl/HTLDOC/slice_proj.in">
<!ENTITY TSliceProjout     SYSTEM "/home/htl/HTLDOC/slice_proj.out">
]>
<document class="hepodbms">
<frontmatter>
<title>HepODBMS User Manual</title>
<author><name>Eva Arderiu, Dirk D&uuml;llmann, Romuald Knap, Jamie Shiers</name><inst>CERN IT/ASD</inst>

<thanks>
</thanks>
</author>
</frontmatter>
<bodymatter>

<!--1-->
<chapter id="H1Introduction">
<stitle>Introduction</stitle>

<section>
<stitle>What is HepODBMS?</stitle>
<index item="CERNLIB"/>

<par>
&HepODBMS; is a C++ class library that provides a simplified and consistent
interface to underlying &ODMG;-compliant Object Databases (&ODBMS;).
It provides high-level clustering and locking strategies, simplifies database
session and transaction control and offers features important to HEP applications,
such as highly scalable event collections and event tags (<sq>Ntuple</sq> replacement).
</par>

<par>
The current implementation of &HepODBMS; is based upon &OBJ;. A basic
knowledge of &OBJ; concepts and terminology is therefore
assumed. Further details regarding &OBJ; can be found
<url name="http://wwwinfo.cern.ch/asd/lhc++/Objectivity/index.html"/>.
</par>

<par>
The goals of &HepODBMS; can be summarised as follows:
</par>

<itemize>
<item>Provide an insulation layer to minimize dependencies on a given
database vendor or release.</item>
<item>Provide high level base classes that encapsulate features such
as clustering and locking strategies, database session and transaction
control, event collections, selection predicates, tagDB access and
calibration.</item>
<item>Achieve the above whilst not introducing any significant
performance or storage overhead.</item>

</itemize>

<par>
&HepODBMS; is composed of a number of packages. These are as follows:
</par>

<descriptiona width="Persistent Helper classes">
<term>Insulation Layer</term>
<item>A set of header files providing a release-independent interface
to the most commonly-used subset of the &OBJ; API.</item>
<term>Transient Helper classes</term>
<item>A high-level, simplified interface to the database.</item>
<term>Persistent Helper classes</term>
<item>Object clustering and naming and other utility classes.</item>
<term>Tags and Collections</term>
<item>Tag, event collections and selection classes.</item>
<term>Miscellaneous</term>
<item>Timers, statistics, TCL application class and so forth.</item>
<term>Conditions DB</term>
<item>A <sq>calibration</sq> or <sq>conditions</sq> DB subpackage.</item>
</descriptiona>

<par>
Before we describe these sub-packages in more detail, we first introduce a number of basic concepts.
</par>

</section>

<section>
<stitle>Basic Concepts</stitle>

<par>
In this section, we introduce a few essential concepts that need to be understood
in order to work with an &ODBMS; such as &OBJ;. A more detailed discussion of
&OBJ; can be found in the Objectivity Technical Overview, available via
<url name="http://wwwinfo.cern.ch/asd/lhc++/Objectivity/TechOver/index.htm"/>.
</par>

<par>
An &OBJ; <emph>federated database</emph> consists of:
</par>

<itemize>
<item>A <emph>bootfile</emph></item>
<item>A database catalogue (the <emph>federation</emph>)</item>
<item>One of more database files</item>
</itemize>

<par>
A <emph>bootfile</emph> is simply a small configuration file that points
to the real location of the federation and contains a number of other
parameters, explained later.</par>

<par>
The database catalogue contains the names and locations of all
of the databases making up that particular federated database. 
Each database is specified by the full pathname and filename and hostname on which
it resides. In addition, the catalogue contains the class definition, or <emph>schema</emph>,
of all objects that reside in the database. Before an object can be stored in the database,
the corresponding class definition must be defined in a step called <emph>schema processing</emph>.
</par>

<par>
In fact, each database also has internal structure, but this we defer until later.
</par>

<par>
In order to work with a federated database, an application must first
initialise a <emph>database session</emph>. For &CERNLIB; users, this
can be considered equivalent to a call to the &HBOOK; or &ZEBRA;
initialisation rountines, <code>HLIMIT</code> or <code>MZEBRA</code>
respectively.
</par>

<par>
Databases process data in units of work called <emph>transactions</emph>. Transactions
are a fundamental technique for providing consistency. Either all of the changes that
form part of a transaction are made - if the transaction successfully <emph>commits</emph>,
or none are - if it <emph>aborts</emph>. This is true for both reading and writing - a
transaction must be started before a single object is read from the database. This
allows the database to ensure that the application sees a consistent state, regardless
of changes being made concurrently by other users.
</par>

<par>
Thus, the simplest database application would perform the following steps:
</par>

<itemize>
<item>Initialise.</item>
<item>Start a transaction (in read or update mode).</item>
<item>Read or write one or more objects.</item>
<item>Commit the transaction and terminate.</item>
</itemize>

<par>
These steps are shown in the following code fragment.</par>

<verbatim>
<![CDATA[#include "HepODBMS/clustering/HepDbApplication.h"
    HepDbApplication myApp("MY_FDB"); 
    // initialize db connection 
    myApp.Init();        // initialise the db session 
    // start an update transaction if you are going to write to a database 
    myApp.startUpdate(); // start an update transaction 
    ---- work with the objects in a database ------------ 

    // commit all changes made during this transaction 
    myApp.commit(); 
]]>
</verbatim>

</section>

<section>
<stitle>The Storage Hierarchy of &OBJ;</stitle>

<par>
As described above, &OBJ; supports a so-called <emph>federated
database</emph>, which is a single, logical database composed of up to
65536 <emph>physical databases</emph>.  Each physical database is
simply a file, stored on a specified host. The physical databases - or
files - consist of <emph>database pages</emph> in which the persistent
objects are stored. The size of each database page is constant within
a given federation and can vary between 512 bytes and 64KB. Typical
values are 1KB - 8KB.
</par>

<par><includegraphics file="fdb_structure" width=".7\linewidth"/></par>

<par>
Between the database and page there is an additional layer, called a
<emph>container</emph>.  Containers are sets of contiguous database
pages within a given file. As the unit of I/O in &OBJ; is always a
multiple of database pages, it is useful - for performance reasons -
to <emph>cluster</emph> objects that are likely to be accessed
together on the same - or adajacent - pages. The concept of a
container provides a mechanism for performing such clustering at a
finer level than would be possible using simply files.
</par>
</section>

<section>
<stitle>Persistent versus Transient Objects</stitle>

<par>
In a <sq>normal</sq> - i.e. <emph>transient</emph> - C++ application,
objects are defined in C++ header files, created using the <code>new</code>
operator and then accessed using C++ pointers.
</par>

<par>
In a persistent application - that is, one that uses <sq>database objects</sq>,
one works with <emph>schema</emph>, an enhanced (<emph>overloaded</emph>) <code>new</code>
operator and <sq>smart pointers</sq>, or <sq>references</sq>. These are all
used in essentially the same way as in the transient case, as is shown in the following example.
</par>

<verbatim>

// Transient example

// Persistent example

</verbatim>

<par>
In addition to these small changes, it must be stressed that access to persistent
objects <emph>must</emph> take place within a <emph>transaction</emph>,
which in turn must be within an active database session.</par>

<par>
Thus, before creating new persistent objects, or accessing existing ones, an application
must first initialise a database session and start a read or update transaction, as 
appropriate.</par>

<par>
In order for any changes to be made persistent, the corresponding transaction must 
<code>commit</code>. Simply terminating the process will result in an abort of any
outstanding transactions and the changes will <code>not</code> be made to the database.
</par>

</section>
</chapter>

<chapter id="H1GettingStarted">
<stitle>Getting Started</stitle>

<section>
<stitle>Introduction</stitle>

<par>
In this section, we describe the basic building blocks of a persistent application.
These are:
</par>

<itemize>
<item>The &HepODBMS; insulation layer</item>
<item>The &HepODBMS; database interface</item>
<item>Schema processing</item>
</itemize>

<par>
These three components will allow you to create an application that manipulates 
objects that you have defined.
</par>

</section>

<section>
<stitle>The &HepODBMS; Insulation Layer</stitle>

<par>
As different releases of &OBJ; have small variations in the API, and in order
to provide the possibility of migration between underlying database systems -
an extremely important issue when dealing with timescales of the order of the LHC - 
it is <code>strongly</code> recommended that applications using the &HepODBMS;
insulation layer, rather than make direct calls to the &OBJ; API.
</par>

<par>
The &HepODBMS; insulation layer consists of two parts:
</par>

<itemize>
<item>A set of fixed-length types, as defined by the &ODMG;</item>
<item>High-level interface classes to the database itself, and for
working with persistent objects.</item>
</itemize>

<par>
Fixed-length types are required to support <emph>platform heterogeneity</emph> - that is,
the possibility of storing objects on a machine of one architecture, such as
a Sun, and reading them back on another - perhaps a Digital Unix system.
As the native language types - <code>int, float</code> etc. - do not have
strict definitions, the &ODMG; introduces fixed length types, as shown
in the table below. These types should <code>always</code> be used as
data members of persistent objects, rather than the native types.
</par>

<table id="tab-odmg" loc="h">
<caption>&ODMG; types and their meaning</caption>
<par>
<tabular preamble="ll">
<row><cell><emph>&ODMG; type</emph></cell>
     <cell><emph>Definition</emph></cell></row>
<row><cell><code>d_Short</code></cell><cell>16bit signed integer</cell></row>
<row><cell><code>d_Long</code></cell><cell>32bit signed integer</cell></row>
<row><cell><code>d_Short</code></cell><cell>16bit unsigned integer</cell></row>
<row><cell><code>d_UShort</code></cell><cell>32bit unsigned integer</cell></row>
<row><cell><code>d_ULong</code></cell><cell>32bit IEEE float</cell></row>
<row><cell><code>d_Float</code></cell><cell>64bit IEEE float</cell></row>
<row><cell><code>d_Double</code></cell><cell>16bit signed integer</cell></row>
<row><cell><code>d_Char</code></cell><cell>8bit ASCII character</cell></row>
<row><cell><code>d_Octet</code></cell><cell>8bit - no interpretation</cell></row>
<row><cell><code>d_Boolean</code></cell><cell>0 or 1</cell></row>
</tabular>
</par>
</table>

<par>An example of the use of these fixed length types is shown below.</par>

<verbatim>
<![CDATA[#ifndef Track_ddl 
     #define Track_ddl 
     #include "HepODBMS/odbms/HepODBMS.h" 
     class Track : public HepPersObj { 
     protected: 
       d_ULong   noOfHits; // value range of these fields 
       d_Double  theta;    // will be the same on all machines 
       d_Double  phi;      // 
     public: 
       Track() 
           :noOfHits(0),theta(0),phi(0) 
         { 
           // constructor does nothing yet... 
         } 
       d_Long    getNoOfHits { return noOfHits; } 
       d_Double  getTheta { return theta; } 
       d_Double  getPhi { return phi; } 
       static HepContainerHint clustering; 
     }; 
     #endif
]]>
</verbatim>

<par>
Note that these types should only be used in connection with 
persistent objects. As is shown in the following example,
switching globally to these types is likely to cause problems on 
certain systems and should thus be avoided.</par>

<verbatim>
<![CDATA[  const d_Long size = 10000; // the buffer size 
  char *buffer = malloc(size);
 // Error if d_Long is not the same as size_t!
]]>
</verbatim>

</section>

<section>
<stitle>Working with Persistent Objects</stitle>

<par>
In order to work with persistent objects, classes to handle the database session and
transactions are needed, as well as classes to deal with databases, containers
and persistent objects themselves.
</par>

<par>
The following classes are provided:</par>

<descriptiona width="HepContainerRef">
<term>HepRef</term>
<item>Equivalent to &OBJ;'s <code>ooHandle</code> - objects are pinned 
in memory as long as the reference is being used.</item>
<term>HepDatabaseRef</term>
<item>A reference to a database.</item>
<term>HepContainerRef</term>
<item>A reference to a container.</item>
</descriptiona>

<par>
There usage is shown in the following set of code fragments.</par>

<verbatim>
<![CDATA[
// start an update transaction 
  startUpdate(); 

  // create a db named "TrackData" or switch to it if it exists already 
  HepDatabaseRef mydb = db("TrackData"); 

  // create a container "TrackTables". If it exists already, just return the handle 
  HepContainerRef cont = container("TrackTables"); 

  // create 10 persistent track tables 
  for (int i=0; i<10; i++) 
  { 
    // create the persistent object (TrackTable) 
    HepRef(SimpleTrackTable) ttab = new(cont) SimpleTrackTable(i); 
  } 
]]>
</verbatim>

<par>
In addition. two arrays are provided:
</par>

<descriptiona width="HepRefVector(T)">
<term>HepVector(T)</term>
<item>A wrapper to <code>ooVArray(T)</code></item>
<term>HepRefVector(T)</term>
<item>A vector of references</item>
</descriptiona>
  
<verbatim>
//DDL files 
class Hit : public HepPersObject { 
public: 
d_Double q; //charge
}; 
class Track : public HepPersObj { 
public: 
d_ULong noOfHits; 
HepRef(Vertex) vtx; 
HepRefVector(Hit) hit;
}; 
</verbatim>
 
<verbatim> 
<![CDATA[
//main example2.cpp file 
#include "HepODBMS/tagdb/HepTagDbApplication.h" 
#include "HepODBMS/tagdb/HepEvent.h" 
main() 
{ 

//start a session 
HepDbApplication dbApp; 
// define which federation to use 
dbApp.fdBootName("MyBase"); 
// open federation 
dbApp.Init(); 
// start in read mode 
dbApp.StartUpdate(); 
// switch to database "analysis" 
dbApp.db("analysis"); 
//creating objects and clustering them together by class 
HepRef(Track) aTrack = new Track; 
// dereferencing 
aTrack->noOfHits = 0; 
//double deref 
cout "vtx.x" << aTrack->vtx()->x << endl; 
// vector access 
cout "hit[0].q" << aTrack->hit[0].q << endl; 
// Commit all changed objects 
dbApp.Commit();
}
]]>
</verbatim>

</section>

<section>
<stitle>Schema Processing</stitle>

<par>
Before an object can be stored in a database, its <emph>schema</emph> or class definition
must be known. This is done using an Object or Data Definition Language (ODL or DDL).
The class definition is used by the database to <sq>reassemble</sq> 
an object when it is read back from the database - converting it from its persistent representation
to something understandable to the C++ run-time system. This includes not only converting
the data - as and when required by the system in question - but also rebuilding 
the table of methods associated with the object, so that they may be invoked just as
in the transient case.</par>

<par>
To a large extent, the schema of a given class is the same as the corresponding C++ header file.
The main differences are as follows:</par>

<itemize>
<item>Persistent-capable objects must <code>inherit</code> from a special persistent base class.
The class provided by &HepODBMS; for this purpose is <code>HepPersObj</code>.</item>
<item>The use of C++ pointers and references must be replaced by &ODMG; <sq>smart pointers</sq>.</item>
<item>The &OBJ; implementation
does not permit persistent-capable objects to be embedded in other persistent-capable
objects.</item>
</itemize>

<par>
Schema processing in &OBJ; is shown in the following diagram.</par>

<par><includegraphics file="schema" width=".7\linewidth"/></par>

<par>
The example below shows the definition of several persistent capable
objects: <code>Event</code>, <code>Tracker</code> and <code>Calo</code>.
All of these objects inherit directly from <code>HepPersObj</code>.
In addition, two transient objects, <code>Track</code> and <code>Cluster</code>
are made persistent <emph>by containment</emph>. That is, they are embedded
in an object which is persistent capable and these embedded instances are
thus made persistent in their own right.
</par>

<par>
Additional constructs with respect to pure C++ are also
possible. These include variable length arrays -
<code><![CDATA[d_Varray<T>]]></code> - and associations. Associations
may be single or bi-directional, 1-N or N-M.
</par>

<descriptiona width="d_Ref&lt;Tracker> itsTracker &lt;-> itsEvent;">
<term>d_Varray&lt;Track> tracks</term>
<item>A variable length array (of tracks).</item>
<term>d_Ref&lt;Tracker> itsTracker &lt;-> itsEvent;</term>
<item>A bi-directional association.</item>
<term>d_Ref&lt;Event> itsEvents[];</term>
<item>1-to-N or N-to-M associations.</item>
</descriptiona>

<verbatim>
<![CDATA[// File: /HepODBMS/examples/populateDb/Event.ddl 

#ifndef __EVENT_DDL 
#define __EVENT_DDL 

#include "HepODBMS/clustering/HepClusteringHint.h" 
#include "HepODBMS/clustering/HepContainerHint.h" 

// a simple track -  *not* peristent by itself but by 
// embedding it in the persistent tracker object 
  

class Track { 
public: 
  // default constructor: init members to 0 
  Track(): 
      phi(0),theta(0),pt(0) 
    {} 

  // constructor just assigns the datamembers 
  Track(double _phi, double _theta, double _pt): 
      phi(_phi),theta(_theta),pt(_pt) 
    { } 

  double getPhi()   { return phi;} 
  double getTheta() { return theta;} 
  double getPt()    { return pt;} 

private: 
  double phi; 
  double theta; 
  double pt; 
}; 
  

/// persistent Tracker class, contains a variable size array of Track objects 
class Tracker : public HepPersObj { 
public: 
  /// create a new Tracker object with an track list for 
  /// noOfTracks Tracks. 

  Tracker (long noOfTracks): // pass the size to the varray contructor 
      tracks(noOfTracks) 
    { /* nothing else needed */ } 

  long getNoOfTracks() { return tracks.size(); } 

  d_VArray<Track> tracks; 

  static HepContainerHint clustering; 
private: 
}; 
  

class Cluster { 
public: 

  Cluster() : energy(0), theta(0), phi(0) 
    { /* nothing else needed */ } 

  Cluster(double _phi, double _theta, double _energy): 
      phi(_phi), theta(_theta), energy(_energy) 
    { /* nothing else needed */ } 
  

  double getPhi()    { return phi; } 
  double getTheta()  { return theta; } 
  double getEnergy() { return energy; } 

private: 
  double phi; 
  double theta; 
  double energy; 
}; 

/// persistent Calo class, contains a variable size array of Cluster objects 
class Calo : public HepPersObj { 
public: 
  Calo(int noOfClusters): 
      clusters(noOfClusters) 
    { /* nothing else needed */} 

  int getNoOfClusters() 
    { return clusters.size(); } 

  d_VArray<Cluster> clusters; 

  static HepContainerHint clustering; 
}; 

/// persistent Event class 
class Event : public HepPersObj { 
public: 
  Event(int no): 
    evtNo(no) 
    { /* nothing else needed */} 

  int getEventNo() { return evtNo;} 

private: 
  int evtNo; 

public: 
  d_Ref<Tracker> tracker; 
  d_Ref<Calo>    calo; 

  static HepContainerHint clustering; 
  
}; 

#endif /* __EVENT_DDL */ 
]]>
</verbatim>

</section>
</chapter>

<chapter id="H1ClusteringNaming">
<stitle>Clustering and Naming</stitle>

<section>
<stitle>Object Clustering</stitle>

<par>
The &ODMG; standard states that a <sq>clustering hint</sq> may be specified
(as an argument to the <code>new</code> operator), when persistent objects
are created. This is done by passing a reference to another object - 
such as the previous object of this type that was created. The new
object is then created at a physical location that is <sq>close</sq>
to the previous one. This might be on the same database page - if there
is sufficient room - or the next free one.</par>

<par>
In &OBJ;, clustering works at the level of <emph>containers</emph>. As this is
also the level at which locking works in &OBJ;, there are two issues that we need
to consider:</par>

<itemize>
<item>A way to minimise lock contention when multiple processes are
reading or writing to the same federation.</item>
<item>The possibility of providing logical clustering that is not limited
by the physical capacity of an individual container (64K logical pages).</item>
</itemize>

<par>Both of these issues are addressed in &HepODBMS;.</par> 

<par>A typical clustering strategy might be to store all objects of a given class in the same <sq>logical</sq>
container. In the case of a class such as a <code>Track</code>, a single container would clearly
be inadequate for this purpose. The &HepODBMS; clustering classes permit such <sq>class-based</sq> clustering,
automatically creating new containers as required. This is shown in the following example.
</par>

<verbatim>
<![CDATA[  // define a reference to a container 
 HepContainerRef trackContainer; 
 // initialise the container ref 
 // ... 
 // create 100 tracks clustered together 
 // in the container "trackContainer" 
 for (i=0; i<100; i++) 
 // specify the track container as clustering hint for the new track 
 HepRef(Track) aTrack = new(trackContainer) Track;
]]>
</verbatim>
  
<par>
The simplest concrete class provided by the library is the <code>HepContainerHint</code>. 
Objects of this class simply return as a hint the reference to a container that has been set e.g. at program startup. 
This is shown in the following code fragment.</par>
  
<verbatim>
<![CDATA[// create and init the hint at prg startup 
HepContainerHint trackClustering = dbApp.container("Tracks")
    // any track creation looks like this 
    HepRef(Track) aTrack = new (trackClustering::getHint()) Track; 
]]>
</verbatim>

<par>
If all the objects of a given class share the same hint, one convenient way to define 
the clustering hint is to put it as a static member in the class definition. 
(Static members are instantiated only once, are accessible from all objects of the class and are not stored in the database). 
This is shown below.</par>
  
<verbatim>
<![CDATA[ /// persistent Event class 
class Event : public HepPersObj { 
public: 
  Event(int no): 
    evtNo(no) 
    { /* nothing else needed */} 
  int getEventNo() { return evtNo;} 

private: 
  int evtNo; 

public: 
  d_Ref<Tracker> tracker; 
  d_Ref<Calo>    calo; 

  static HepContainerHint clustering; 

};]]>
</verbatim>

<par> 
The static member clustering has to be allocated (e.g. in a .cpp file) using a statement like:
</par>

<verbatim>
    // allocate static variables 
    HepContainerHint Event::clustering; 
</verbatim>
  
<par>This variable must
be initialised before it is first used e.g. using:</par>

<verbatim>
     db("Events"); 
     Event::clustering = container("EventsCont"); 
</verbatim>

<par>
New <code>Event</code> objects are now created using:</par>
  
<verbatim>
HepRef(Event) evt = new( Event::clustering() ) Event(i);
</verbatim>

<par>Note the use of the operator() shortcut for the getHint() method.</par>

<par>
For convenience a <code>HepNew</code> macro is provided. This performs
the same function as the above, but hides the additional argument for the new operator.</par>
  
<verbatim>
HepRef(Event) eventRef = HepNew(Event);
</verbatim>
  
<par>
The following example demonstrates the usage of class-based clustering.
Although the creation of new objects of type <code>Track</code> may be
spread throughout the entire code, the definition of the clustering
hints is performed in a single place, and can thus be much more easily controlled.
</par>

<verbatim>
<![CDATA[//
// Class Based Clustering
//
// class definition in Track.ddl 
class Track : public HepPersObject 
{ 
d_Double phi; 
d_Double theta; 
d_ULong noOfHits; // more stuff 
public: 
static HepContainerHint clustering;
}; 
... 

// clustering definition at startup 
Track::clustering = dbApp.container("tracks"); 
// clustering use spread all over the source code 
HepRef(Track) aTrack = new (Track::clustering()) Track;
]]>
</verbatim>

<par>
(Note the use of the scope resolution operator <code>::</code> to access the class member).
This other examples shows you how to make persistent Clustering in Parallel Writers: </par>
  
<verbatim>
<![CDATA[//
// Example of parallel writing
//
// class definition in Track.ddl 
class Track : public HepPersObject { 
d_Double phi; 
d_Double theta; 
d_ULong noOfHits; // more stuff 
public: 
static HepClusteringHint clustering;
}; 
// read or create persistent clustering definition at startup 
if (!Track::clustering.find("tracks")) 
Track::clustering.create("tracks")); 
Track::clustering.setParallelWriterMode(noOfProcs,myID); 
// clustering use spread all over the source code 
HepRef(Track) aTrack = new (Track::clustering()) Track; 
]]>
</verbatim>

</section>

<section>
<stitle>Object Naming</stitle>

<par>
Any persistent object that is stored in the database may be given a <emph>name</emph>.
A name is simply a text-string that is associated with an object. Of course, it is 
not intended that <emph>every</emph> object in the database is named - this would not be 
efficient and would have a significant overhead. Naming is most useful for defining
<sq>entry points</sq> into the database. For example, a collection of events could be
given a name - such as <sq>Higgs candidates</sq>. As a flat naming scheme is often inadequate
- and would clearly not be useful in a multi-user system, &HepODBMS; provides a hierarchical
naming scheme, similar to that of a Unix filesystem.
</par>

<par>The <code>HepNamingTree</code> class provides the following Unix-like methods:
</par>

		  <itemize>
		  <item>makeDirectory(path), </item>
		  <item>changeDirectory(path), </item>
		  <item>removeDirectory(path), </item>
		  <item>nameObject(objRef,path), </item>
		  <item>findObject(path), </item>
		  <item>removeName(path), </item>
		  <item>removeObject(path), </item>
		  <item>startItr(), </item>
		  <item>nextItr() </item>
		  </itemize>

<par>
The usage of these methods is shown in the following example. The
<code>HepDBApplication</code> class automatically places the application
in the <sq>directory</sq> corresponding to the current username, to
avoid possible conflicts between the naming trees of different users.
Naturally, it is possible to navigate to any point in the naming tree.
</par>

<verbatim>
<![CDATA[typedef h_seq<Event> EventCol; 

// initialize DB session 
HepDbApplication app; 
app.init("fdBootName"); // implicit cd /usr/$USER/ 
// move to test-beam 
app.naming.changeDirectory("test-beam"); 
evtCol = EventCol::findByName("inputEvents"); 
EventCol::iterator it; 
for (it = evtCol.begin(); it != evtCol.end(); it++) 
{ 
    -- do something-- 
}]]>
</verbatim>

</section>
</chapter>

<chapter id="H1CollectionsTags">
<stitle>Collections and Tags</stitle>

<section>
<stitle>STL Collections</stitle>

<par>
The C++ standard includes the definition of a set of collections based upon the work
of Alex Stepanov and Meng Lee. These collections are frequently referred to as
the <sq>Standard Template Library</sq> or STL, although the more correct
term is simply the Standard Library.
</par>

<par>
The <sq>STL</sq> includes the following:</par>

<descriptiona width="Allocators">
<term>Containers</term>
<item>Generalized classes used to hold a collection of typed data.</item>
<term>Iterators</term>
<item>Generalized pointers used to traverse the elements of a container.</item>
<term>Algorithms</term>
<item>Procedures that can be applied on all or part of a container.</item>
<term>Function Objects</term>
<item>Behaviors used as a parameter by a container or algorithm.</item>
<term>Allocators</term>
<item>Objects responsible for allocating storage.</item>
</descriptiona>
  
<par>
More information on the STL can be found via the following URL:
<url name="http://wwwinfo.cern.ch/asd/lhc++/ObjectSpace/doc/2.1/index.html"/>
</par>

<par>
The following example shows the use of STL collections.</par>

<verbatim>
<![CDATA[#include <iostream> 
#include <vector> 
int array[] = { 1, 42, 3 }; // Regular "C" array. 
vector < int > v; // STL transient vector of integers 

int main() 
  { 
  // Initialize the STL Vector 
  v.push_back( 1 ); 
  v.push_back( 42 ); 
  v.push_back( 3 ); 

  // Use pointer to traverse "C" array. 
  int* p1; 
  for ( p1 = array; p1 != array + 3; ++p1 ) 
    cout << "array has " << *p1 << "\n"; 

  // Use iterator to traverse STL vector. 
  int_vector::iterator p2; 
  for ( p2 = v.begin(); p2 != v.end(); ++p2 ) 
    cout << "vector has " << *p2 << "\n"; 
  } 
    return 0; 
 } 
]]> 
</verbatim> 

<par>
The &ODMG; standard includes STL-compliant collection classes. For
the main STL collections, a persistent equivalent exists, designated
by a leading <code>d_</code>.
</par>

<par>
&OBJ; provides persistent STL collections classes based upon the 
ObjectSpace implementation - also available in transient form
via &LHCPP;.</par>

<par>
The following example demonstrates the use of persistent STL collections.</par>

<verbatim>

// Example of persistent STL

</verbatim>
</section>

<section>
<stitle>HepODBMS Collections</stitle>

<par>
In addition to the persistent STL collections described above,
&HepODBMS; provides highly scalable collections - capable of handling
very large numbers of entries. They were designed to handle up to
1000 million objects, which would not be possible using the
standard persistent STL classes offered with &OBJ;.
</par>

<par> &HepODBMS; defines following templated collection that is usable for any kind of persistent objects:</par>

<par><code>typedef h_seq&lt;Event> EventCollection;</code></par>

<par>
The interface of this collection offers the following: </par>

<itemize>
<item>STL interface independent of implementation.</item>
<item>Single User visible collection class : <code>h_seq&lt;T></code></item>
<item>Single STL like iterator: <code>h_seq&lt;T>::iterator</code></item>
<item>Uses hybrid of templated classes and delegation.</item> 
<item>User extensible through strategy objects.</item>
</itemize>

<par>
For example, we may wish to access an existing event collection
by name. We first define the collection, as follows:</par>

<par><code>EventCollection evtCol("/usr/dirkd/collections/myEvents");</code></par>

<par>We then need to define an <emph>iterator</emph> for this collection (STL-like):</par>

<par><code>EventCollection::const_iterator it;</code></par>

<par>We can now iterate through the collection and read individual
event objects:</par>

<verbatim>
<![CDATA[it = evtCol.begin(); 
while( it !=  evtCol.end() ) 
    { 
 cout << "Event: " << (*it)->getEventNo() << endl; 
     ++it; 
    } 
// support for (some) STL algorithms 
 int cnt=0; 
 count(evtCol.begin(),evtCol.end(),1,cnt);
]]>
</verbatim>

<par>Writing to the collection - e.g. adding new events - is shown below.</par>

<verbatim>
<![CDATA[HepRef(Event) evt; 
for (int i=0; i<500000; i++) 
    { 
    // create a new event using the clustering hint of the sequence 
    evt = new(evtCol.clustering()) Event; 
  
    // store the new object ref in the sequence (only needed for ref collections) 
    evtCol.push_back(evt); 

    // fill the event 
    evt->setEventNo(i); 
  }]]>
</verbatim> 

<par>
The following example shows how the &HepODBMS; collection
class may be used to store events. It is available
via  /afs/cern.ch/sw/lhcxx/share/HepODBMS/examples/createCollection/createCollection.cpp 
</par>

<verbatim>
<![CDATA[#include "HepODBMS/clustering/HepDbApplication.h" 

#include "EventSeq.h" 

d_Ref<ooObj> VStore<Event>::store_clustering; 

void print_evt(d_Ref<Event> evt) 
{ 
  cout << "Event Nr=" << evt->getEventNo() << endl; 
} 
  

int main(int argc, char *argv[]) 
{ 
  // 
  // Persistent event collection tests. 
  // 
  HepDbApplication app; 
  
  app.init(); 
  
  app.startUpdate(); 

  ooHandle(ooDBObj) db_h = app.db("Sequences"); 
  ooHandle(ooContObj) ooc_h; 
  
  ooHandle(ooContObj) eventCont = app.container("Events"); 
  ooc_h= app.container("Stores"); 

  ooDelete(eventCont); 
  ooDelete(ooc_h); 

  VStore<Event>::store_clustering = app.container("Stores",1); 
  eventCont = app.container("Events"); 
  app.commit(); 

  cout << "created db and container" << endl; 

  app.startUpdate(); 
  
  h_seq<Event> seq("dirks","vector"); 

  app.commit(); 
  cout << "created store object" << endl; 
  app.startUpdate(); 

  HepRef(Event) evt; 

  for (int i=0; i<5000; i++) 
  { 
    // create a new event, use the clustering hint of the sequence 
    evt = new(seq.clustering()) Event(i); 
  
    // store the new object ref in the sequence (only needed for ref collections) 
    seq.push_back(evt); 

  } 

  app.commit(); 

  return 0; 
}]]>
</verbatim>

</section>

<section>
<stitle>Event Tags</stitle>

<par>An <emph>event tag</emph> (or rather a collection of such tags)
can be thought of as something similar to an Ntuple or an event directory.
Just as event directories are used to speedup event selection, tags
are introduced to speed up analysis - or indeed and other process
in which events are first selected. A tag may contain only information
relevent to the selection process itself - the data that is then used in the
analysis being obtained from other objects <sq>connected</sq> to the tag
via associations, or both the data used for selection and subsequent analysis (Ntuple-style).
</par>

<par>Two types of tags are provided, sharing a common interface. These are
as follows:</par>

<descriptiona width="Concrete tags">
<term>Generic tags</term>
<item>No schema definition is required.</item>
<term>Concrete tags</term>
<item>Schema processing necessary.</item>
</descriptiona>

<par>Generic tags are aimed at <sq>not too large</sq> collections, typically owned by individual users. 
They provide a simple user interface for creation of tag quantities and eliminate the 
inconvenience for the end user to formally define a new persistent class when the set of user quantities changes. 
Generic tags may contain attributes of type float, double, short, long, char. 
Additional attributes may be added after the initial definition. 
This flexibility makes the generic tag particularly useful during the first development 
phase of an analysis, when the set of quantities used in the analysis tends to change more frequently. 
Although they carry a slight performance penalty with respect to concrete tags, 
they are more convenient for end users and avoid any schema handling issues.
</par>

<par>As the interface to both generic and concrete tags is identical, the examples
below concentrate on the generic tags.</par>

<par>
A new tag collection is defined as follows:</par>

<par><code>GenericTag highPt("high pt events"); </code></par>

<par>Tag attributes can now be defined and filled just like other C++ variables: </par>

<verbatim>
<![CDATA[
TagAttribute<long>   evtNo(highPt,"eventNo"); 
TagAttribute<double> ptPlus(highPt,"ptPlus"); 
TagAttribute<long>   nTracks(highPt,"nTracks"); 
if (highPtTracks > 2) 
{ 
 // create a new tag and store the event reference 
 highPt.newTag(evt); 

 // define its tag attributes 
 evtNo   = evt->eventNo; 
 ptPlus  = evt->tracker.tracks[plusTrack].pt; 
 nTracks = evt->tracker.tracks.size();
]]>
</verbatim>

<par>
The following example shows the creation and filling of a tag collection.</par>

<verbatim>
<![CDATA[
// File: HepODBMS/examples/createTag/createTag.cpp 

#include "HepODBMS/tagdb/HepAnalysis.h" 

#include "Event.h" // generated with ooddlx from Event.ddl 

class createTagsApp : public HepTagDbApplication { 
  // inherits session control from HepTagDbApplication 
  
public: 
  // this application implements just one method: 
  int run() 
  { 

    const char *tagName="high pt events"; 
    cout << "*** creating a tag collection" << endl; 

    startUpdate(); // start an update transaction 

    HepExplorable *cd = HepExplorable::findExplorable(tagName); 
    if (cd) { 
      cout << "removing old tag:" << tagName << endl; 
      cd->removeDescription(); 
      delete cd; 
    } 
  

    HepExplorableGenericTags highPt; // create a tag collection 
    db("Tags"); 

    if (!highPt.createDescription(tagName)) // start creating a new field description 
      fatal("could not create new tag");  // print the message and stop the application 

    // define fields all fields that belong to genTag 
    TagAttribute<long>  eventNo (highPt,"eventNo"); 
  
    /* track 1*/ 
    TagAttribute<double> ptPlus (highPt,"ptPlus"); 
    TagAttribute<double> phiPlus(highPt,"phiPlus"); 
  
    /* track 2*/ 
    TagAttribute<double> ptMinus (highPt,"ptMinus"); 
    TagAttribute<double> phiMinus(highPt,"phiMinus"); 
  

    cout << endl; 

    db("Events"); 
    ooItr(Event) eventItr; 
    eventItr.scan(container("Events")); 

    HepRef(Event) evt; 
    // now fill some tags 
    while( eventItr.next()) 
    { 
      // check for opposite signed pt > 5 
      HepRef(Tracker) aTracker = eventItr->tracker; 

      // keep index to current largest pt for each sign 
      int maxTrack = 0; 
      int minTrack = 0; 

      for (int track=0; track < aTracker->getNoOfTracks(); track++) 
      { 
        if (aTracker->tracks[track].getPt() 
            > aTracker->tracks[maxTrack].getPt() ) 
          maxTrack = track; 

        if (aTracker->tracks[track].getPt() 
            < aTracker->tracks[minTrack].getPt() ) 
          minTrack = track; 
      } 
  
      highPt.newTag();      // create a new tag (all fields have default values) 
      eventNo  = eventItr->getEventNo(); 
  
      ptPlus   = aTracker->tracks[maxTrack].getPt(); 
      phiPlus  = aTracker->tracks[maxTrack].getPhi(); 

      ptMinus  = aTracker->tracks[minTrack].getPt(); 
      phiMinus = aTracker->tracks[minTrack].getPhi(); 
  
    } 
    // commit this transaction 
    commit(); 
    return 0; 
  } 
}; 

int main() 
{ 
  createTagsApp myApp;  // create an application object 
  myApp.init();        // initialise the db session 
  return myApp.run();   // run it 
} ]]>
</verbatim>

</section>

</chapter>

<chapter id="H1ConditionsDatabase">
<stitle>Conditions Database</stitle>

<section>
<stitle>Introduction</stitle>
<par>This section describes a <sq>conditions</sq> or <sq>calibration</sq>
database application library, built on top of &OBJ;. It is based upon the
conditions database application, built by Jim Onhemus for the BaBar experiment.
The user guide for the BaBar library can be found 
<url name="http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/user-guide/docs/ConditionsDBapi.ps"/>.
</par>

<par>
The basic purpose of this library is to store detector-related information
with an associated <sq>validity period</sq> and allow retrieval based upon a
validity instant. A typical example is the storage and retrieval of detector
calibration information. As such, the application must support multiple entries
for the same or overlapping validity period and provide flexible mechanisms for
retrieving the desired data.
</par>
</section>

<section>
<stitle>Storing and Retrieving Information</stitle>

<par>
The interface to the conditions database is built on a small number of classes. These are as 
follows:</par>

<descriptiona width="HepCalibApplication">
<term>HepCalibApplication</term>
<item>Handles database sessions and transactions</item>
<term>HepCalibDatabase</term>
<item>Used to create new calibration databases</item>
<term>calibInterval</term>
<item>Used to store calibration information and associated validity period</item>
</descriptiona>

<par>
The use of these classes is illustrated in the following code fragments.
The first demonstrates the use of the <code>HepCalibApplication</code> class.</par>

<verbatim>
// initialize the federated database 
  calibApp = new HepCalibApplication(fdBootName); 
  
  // start transaction for update 
  calibApp->startUpdate(); 
   --- work with the calibration database ---- 

     // save changes on disk 
   calibApp->startUpdate();
</verbatim>

<par>
The use of <code>HepCalibDatabase</code> is shown below.</par>

<verbatim>
theDatabase = new HepCalibDatabase ( calibApp, "cal", dbPathName); // create calibration database group system 

theDatabase->open (); // open the database
</verbatim>

<par>
The above code fragment will create a directory <code>cal</code> under the directory
specified by <code>dbPathName</code>. When such a directory is created, two database
files are automatically generated. These are <code>cal00000.DB</code> and <code>IndexCal.DB</code>.
The first file contains the calibration constants themselves. The calibration database system
will automatically create new files (cal00001.DB, cal00002.DB, ...) as required. The file
<code>IndexCal.DB</code> contains the validity instants for all inserted calibrations.
The calibrations themselves can be any persistent C++ object.
</par>

<verbatim>
// Define a time interval ( theBeginTime, theEndTime ) 
HepTime theBeginTime = HepTime( 1996, 1, 1, 0, 0,  10 ); 
HepTime theEndTime =  HepTime( 1996, 1, 1, 0, 0, 15 ); 
// Create a calibration constant 
HepRef(PedestalCal) thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(1); 

// Store the calibration interval in the calIndex.DB database and stablish the link between the interval 
// and the calibration constant previously created. 
theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
</verbatim>

<par>
The <code>store</code> method of the <code>HepCalibDatabase</code> class is responsible
for storing the calibrations, handling their versioning and updating the appropriate index
structures.</par>

<par>
Retrieval of calibration information is performed using the <code>calibInterval</code> class.
This class supports the following:</par>

<itemize>

<item>Locate the calibration information valid at a given interval of
time or point in time.  The default calibration is the most recent
entry that is valid for the specified instant.</item>

<item>Provide navigation to all previous versions of a calibration</item>

<item>Read all calibrations taken for a given constant</item> 

<item>given a value of the constant at a certain interval of time,
lets say with version <sq>V10</sq>, we can look for an specific version for
example <sq>v2</sq>. </item>
</itemize>

<par>
The following example shows calibrations being entered for four validity periods.</par>

<verbatim>
<![CDATA[
//File:/HepODBMS/examples/readCalibration/readCalibration.cpp 

#ifndef HepCalib_HH 
#include "HepODBMS/calibration/HepCalib.h" 
#endif 
#include "HepODBMS/calibration/HepTime.h" 
#include "HepODBMS/calibration/HepCalibApplication.h" 
#include "HepODBMS/calibration/HepCalibDatabase.h" 
#include "HepODBMS/odbms/HepODBMS.h" 
#include "PedestalCal.h" 

int 
main( int argc, char* argv[] ) 
{ 
  
  HepCalibApplication*  calibApp; 
  HepRef(PedestalCal) thePedestalCalData; 
  HepCalibDatabase * theDatabase; 

  //get the boot file variable ... fdbootname 
  // get the path name for the database .... dbname 
  

  // initialize the federated database 
  calibApp = new HepCalibApplication(fdBootName); 
    #ifdef STANDALONE 
        ooNoLock(); // ATTENTION: this must be used only on private databases and when you compiled in standalone mode 
    #endif 
  // start transaction for update 
  calibApp->startUpdate(); 
  // creates a BdbDatabase object which is used to open and close the 
  // conditions database. 
  theDatabase = new HepCalibDatabase ( calibApp, "cal", dbPathName); 
  // 1st transaction 
  // open the cal DB 
  theDatabase->open (); 

  HepTime theBeginTime; 
  HepTime theEndTime;   
  // FIRST INTERVAL 
  // creates a PedestalCal object in the conditions database 
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(1); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  // Set my time to  year, month, day, `hour` (0-23), `minute` (0-59), 
  // `second` (0-59), a  `microsecond` (0-999999). 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  10 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 15 ); 
  // we create the interval object, we create/update the index and we set the reference 
  // to the calibration constant object 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  
  // SECOND INTERVAL 
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(2); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  20 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 25 ); 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  
  // THIRD INTERVAL 
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(3); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  30 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 35 ); 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  
  // LAST INTERVAL 
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(4); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  40 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 45 ); 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  theDatabase->close( ); 
  calibApp->commit( ); 
]]>
</verbatim>

<par>
After the above example has been run, the database structure is as
follows:</par>

<par><includegraphics file="trans1" width=".7\linewidth"/></par>

<par>
We now add a new calibration, valid for the period covered
by the first two entries created above, as well as the period between them.
</par>

<verbatim>
<![CDATA[// 2nd run, version the first two intervals 
  calibApp->startUpdate(); 
  theDatabase = new HepCalibDatabase ( calibApp, "cal", dbPathName); 
  theDatabase->open (); 
  
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(5); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  10 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 25 ); 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  theDatabase->close( ); 
  calibApp->commit( ); ]]>
</verbatim>

<par>
The database now has the following structure:</par>

<par><includegraphics file="trans2" width=".7\linewidth"/></par>

<par>
We now add a new calibration, valid for the period of the third calibration
created in the first step.</par>

<verbatim>
<![CDATA[// 3rd run, version the third interval 
  calibApp->startUpdate(); 
  theDatabase = new HepCalibDatabase ( calibApp, "cal", dbPathName); 
  theDatabase->open (); 
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(6); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  30 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 35 ); 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  theDatabase->close( ); 
  calibApp->commit( ); ]]>
</verbatim>

<par>
The database structure now looks as follows:</par>

<par><includegraphics file="trans3" width=".7\linewidth"/></par>

<par>
We now add yet further calibrations, demonstrating how an existing validity period can
be subdivided.</par>

<verbatim>
<![CDATA[// 4th run, split the value of one interval 
  calibApp->startUpdate(); 
  theDatabase = new HepCalibDatabase ( calibApp, "cal", dbPathName); 
  theDatabase->open (); 
  thePedestalCalData = new ( theDatabase->hint() ) PedestalCal(7); 
  cout << "the object created is " << thePedestalCalData->i <<endl; 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  42 ); 
  theEndTime =  HepTime( 1996, 1, 1, 0, 0, 43 ); 
  theDatabase->store ( thePedestalCalData, "PedestalCalCont", theBeginTime,theEndTime, 0 ); 
  theDatabase->close( ); 
  calibApp->commit( ); ]]>
</verbatim>

<par>
The database structure now looks like:</par>

<par><includegraphics file="trans3" width=".7\linewidth"/></par>

<par>
The following example shows retrieval by validity instant and handling of versions.
</par>

<verbatim>
<![CDATA[//File:/HepODBMS/examples/readCalibration/readCalibration.cpp 
  
calibApp->startRead (); 
theDatabase = new HepCalibDatabase ( calibApp, "cal", dbPathName);

  
  // open the cal DB 
  theDatabase->open (); 
  // define the interval you look for 
  theBeginTime = HepTime( 1996, 1, 1, 0, 0,  20 ); 
  
  // Find the interval corresponding to theTime 
  // findInterval( BdbIntervalH, theContainerName, anyTime, atag ) 
  HepRef(calibInterval) theInterval; 
  int res = theDatabase->findInterval( theInterval, "PedestalCalCont", theBeginTime ); 
  if (res) 
  { 
    cout << "the interval was found" << endl; 
    HepRef( PedestalCal ) thePedestalCalDataFound =(HepRef(PedestalCal)) theInterval->getObject( ); 
    if (thePedestalCalDataFound != 0 ) { 
      HepTime theVersionTime = theInterval -> getVersionTime( ); 
      cout << "the object found had a pedestal of: " << thePedestalCalDataFound->i <<endl; 
    } 
  } 
  else 
 cout << "the interval was not found" << endl; 

  // get version name of this interval 
  char * version; 
  version = new char [3]; 
  version = theInterval->getVersionNumber(); 
  cout << "Version number of the interval found : " << version << endl; 
  
  
  // get V1 from this interval 
  HepRef( calibInterval ) intervalFoundH; 
  intervalFoundH = theInterval->getCalibInterval( "v1" ); 
  if ( intervalFoundH != 0 ) 
  { 
    cout << "the interval with version V1 was found" << endl; 
    HepRef( PedestalCal ) thePedestalCalDataFound =(HepRef(PedestalCal)) intervalFoundH->getObject( ); 
    if (thePedestalCalDataFound != 0 ) { 
      HepTime theVersionTime = intervalFoundH -> getVersionTime( ); 
      cout << "the object found had a pedestal of: " << thePedestalCalDataFound->i <<endl; 
    } 
  } 
  else 
 cout << "the interval with version v1 does not exist" << endl; 
  

  // read previous values (versions) of the interval found 
  cout << "reading all version values of this interval " << endl; 
  HepRef( calibInterval ) prevH,intervalH; 
  if ( ( theInterval->hasVersion() ) && ( theInterval !=0 ) ) 
    { 
      theInterval->prevVers( prevH ); 
      intervalH = prevH; 
      while ( intervalH != 0 ) 
 { 
   HepRef( PedestalCal ) thePedestalCalDataFound =(HepRef(PedestalCal)) intervalH->getObject( ); 
   if ( thePedestalCalDataFound != 0 ) 
     cout << "previous version value: " << thePedestalCalDataFound->i <<endl; 
   intervalH->prevVers ( prevH ); 
   intervalH = prevH; 
 } 
    } 
  else 
    cout << "has no versions. " << endl; 

  // read the default version from minus infinite to infinite 
  cout << " reading the current default version for Pedestal ... " << endl; 
  theDatabase->firstInterval( intervalH, "PedestalCalCont" ); 
  while ( (intervalH = intervalH->next( )) != 0 ) 
  { 
     cout << intervalH << endl; 
     HepRef(PedestalCal) thePedestalCalDataFound = (HepRef(PedestalCal))intervalH->getObject( ); 
     if (thePedestalCalDataFound != 0 ) 
   cout << "- Pedestal value: " << thePedestalCalDataFound->i <<endl; 
     else 
       cout << "- Pedestal value: EMPTY" << endl; 
  
  } 
  theDatabase->close( ); ]]>
</verbatim> 

<par>
The following example shows the definition of a trivial
(non-realistic) calibration class.  The class is made persistent by
inheritence (from <code>HepPersObjy</code>. The <code>HepTime</code>
class is made persistent by containment.</par>


<verbatim>
<![CDATA[//File:/HepODBMS/examples/readCalibration/PedestalCal.ddl

#ifndef pedestalcal.ddl 
#define pedestalcal.ddl 
#include "HepODBMS/odbms/HepODBMS.h" 
class HepTime; 
  
class PedestalCal : public HepPersObj { 
public: 
  
  int i; 
  // constructors 
  PedestalCal() {i=0;}; 
  PedestalCal(int a) {i = a;} ; 

  // set and get function 
  void set_PedestalCal(int a) {i=a;}; 
  int get_PedestalCal( ) {return i;}; 
  
}; ]]>
</verbatim>

</section>

<section>
<stitle>Conditions DB Examples</stitle>

<par>
In order to run the calibration database examples, follow the instructions for running
&HepODBMS; examples for Unix or NT as appropriate. For example, the <code>readCalibration</code>
example contains:</par>

<descriptiona width="readCalibration.cpp">
<term>Pedestal.ddl</term>
<item>The calibration type definition for pedestal</item>
<term>readCalibration.cpp</term>
<item>The main function. It will start six transactions to store and read the calibrations.</item>
<term>GNUmakefile</term>
<item>The makefile to copy the federeated database and schema from HepODBMS, compile and link readCalibration.</item>
<term>example_setup</term>
<item>Script to set the environment variables to run the program</item>
</descriptiona>

<par>
Having built the example, set the boot file and location of the calibration
database files as appropriate:</par>

<alltt>
setenv OO_FD_BOOT <emph>your local directory</emph>/readCalibration/db/calibration 
setenv OO_DB_PATH <emph>your local directory</emph>/readCalibration/db 
 <emph>your local directory</emph>/readCalibration/readCalibration 
</alltt>

<par>
The following output will be produced.</par>

<verbatim>
%source example_setup ( should set OO_FD_BOOT,  OO_DB_PATH and LD_LIBRARY_PATH(in UNIX)or PATH (in NT) ) 
%readCalibration: 
WARNING: HepDbApplication: Could not find naming root directory: Naming will be disabled. 
the object created is 1 
the object created is 2 
the object created is 3 
the object created is 4 
the object created is 5 
the object created is 6 
the object created is 7 
the interval was found 
the object found had a pedestal of: 5 
Version number of the interval found : V1 
the interval with version V1 was found 
the object found had a pedestal of: 5 
reading all version values of this interval 
previous version value: 2 
 reading the current default version for Pedestal ... 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:10:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:15:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:48:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 5 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:15:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:20:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:49:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 5 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:20:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:25:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:49:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 5 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:25:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:30:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:48:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: EMPTY 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:30:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:35:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:50:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 6 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:35:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:40:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:48:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: EMPTY 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:40:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:42:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:51:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 4 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:42:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:43:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:51:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 7 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:43:000000GMT, nanoseconds: 0 
- endTime: 01/01/96 01:00:45:000000GMT, nanoseconds: 0 
- version time: 04/23/99 19:18:51:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: 4 
* Calibration Interval: 
- beginTime: 01/01/96 01:00:45:000000GMT, nanoseconds: 0 
- endTime: +Infinity 
- version time: 04/23/99 19:18:48:000000GMT, nanoseconds: 0 
- tag: 0 
- Pedestal value: EMPTY 
</verbatim>

<par>
The datbase contents may be viewed using:</par>

<itemize>
<item>oobrowse ./db/Calibration (in NT ) </item>
<item>ootoolmgr  ./db/Calibration  (in UNIX ) </item>
</itemize>

</section>
</chapter>

<chapter id="H1Examples">
<stitle>Examples</stitle>

<section>
<stitle>Running the Examples on Unix</stitle>

<par>
In this section, we describe how you may run the &HepODBMS; example programs.
We describe the procedure for the <code>populateDB</code> example. Exactly
the same procedure may be used for all other examples, simply by using the 
appropriate example name.
</par>

<par>
Before running the examples, make sure that your environment is correctly configured.
Instructions for running &OBJ; either from <code>AFS</code> or for installing locally
are available <url name="http://wwwinfo.cern.ch/asd/lhc++/Objectivity/index.html"/>.
</par>

<par>
In particular, you should check that the following two environment variables
are correctly set.</par>

<itemize>
<item>OBJY_DIR</item>
<item>LD_LIBRARY_PATH(or equivalent)</item>
</itemize>

<par>
It is also recommended that you run the examples in <code>standalone</code> mode. As shown in
the following diagram, this means that neither data server (AMS) nor lockserver are required.</par>

<par><includegraphics file="sa-vs-ls" width=".7\linewidth"/></par>

<par><code>Do not run in standalone mode against a production federation</code> (or indeed
any other federation that is shared).</par>

<par>
To run in standalone mode, set the <code>STANDALONE</code>environment variable as follows:</par>

<verbatim>
# C shell
setenv STANDALONE 1
</verbatim>

<verbatim>
# Bourne Shell: 
STANDALONE=1 
export STANDALONE 
</verbatim>

<par>
Add the following code to your application just before you call the
database initialization function, i.e. before calling the constructor 
of <code>HepDbApplication</code> or <code>HepCalibApplication</code>:</par> 
  
<verbatim>
#ifdef nolockserver 
  ooNoLock(); 
#endif
</verbatim>

<par>
You should now copy the examples to your local directory, as follows:</par>

<alltt>
cp -r /afs/cern.ch/sw/lhcxx/share/HepODBMS/new/examples/populateDb <emph>your local directory</emph>
</alltt>

<par>
You will now have the following files:</par>

<descriptiona width="SimpleTrackTable.ddl">
<term>Event.ddl</term>
<item>DDL file to define the persistent Event type</item>
<term>GNUmakefile</term>
<item>The makefile for the example</item>
<term>SimpleTrackTable.ddl</term>
<item>DDL file to define persistent the Track Table</item>
<term>example_setup</term>
<item>Script to perform the setup of the environment variables</item>
<term>populateDb.cpp</term>
<item>The main program</item>
<term>randomSource.cpp</term>
<item>Source file and...</item>
<term>randomSource.h</term>
<item>header file to generate random tracks and clusters</item>
</descriptiona>

<par>
The <code>example_setup</code> file is as follows:</par>

<verbatim>
HEP_ODBMS_DIR=/afs/cern.ch/sw/lhcxx/specific/$OS/HepODBMS/new 
export HEP_ODBMS_DIR 
#STANDALONE=1   TAKE THE COMMENT OUT IF YOU WORK IN STANDALONE MODE 
#export STANDALONE 
OO_FD_BOOT=`pwd`/db/EXAMPLE_FD 
export OO_FD_BOOT 
LD_LIBRARY_PATH=/afs/cern.ch/sw/lhcxx/specific/$OS/HepODBMS/new/lib:$LD_LIBRARY_PATH 
</verbatim>

<par>
Edit this file as appropriate.</par>

<par>
Once correctly configured, <emph>source</emph> the file.</par>

<verbatim>
<![CDATA[source example_setup # C shell

%  vi GNUmakefile EDIT GNUmakefile and add schema in path 
"$(HEP_ODBMS_DIR)"/etc/getdb $(HEP_ODBMS_DIR)/schema/HEP_BASE $(BOOT) ${FDID}
%  gmake VERBOSE=1 ]]>
</verbatim>

<par>
This makefile does automatically all steps needed to create the federated database, load the schema and make the executable: 
</par>

<itemize>
<item>creates a platform specific directory where the object files
will be located: LINUX, Solaris.. </item>
<item>copies the <code>HEP-BASE</code> federated database from
&HepODBMS; and installs it in your local subdirectory
<code>~HepODBMS/examples/populatedb/db</code> with the name
<code>EXAMPLE_FD</code>. If you are in <code>STANDALONE</code> mode
you should <emph>only</emph> access your private federated
database</item>

<item>runs the <code>ooddlx</code> preprocessor on all schema files
(<code>*.ddl</code>) and generates <code>.h</code>,
<code>_ref.h</code>, and <code>_ddl.cpp</code> files.</item>

<item>compiles and links the <code>populateDb</code> application with
the schema files and produces the executable.</item>

</itemize>

<par>
The example may now be run as shown below.</par>
  
<verbatim>
[pc30] ~/examples/populateDb % populateDb 10 # Generate 10 events
*** starting execution of populateDb 
*** about to initialise the database session 
WARNING: HepDbApplication: Could not find naming root directory: Naming will be disabled. 
*** creating 10 Events ... done. 
*** generated 100 tracks and 100 clusters in total. 
[pc30] ~/examples/populateDb %
</verbatim>
  
<par><code>N.B.</code>If you run your application in <code>STANDALONE</code>
mode you should use the <code>-standalone</code> when using any of the &OBJ; tools.
For example, to view the objects using the <code>ootoolmgr</code> tool, use:
</par>
  
<verbatim>
% examples/populateDb > ootoolmgr [-standalone] ./db/EXAMPLE_FD 
</verbatim>

<par><includegraphics file="ootoolmgr" width=".7\linewidth"/></par>

<par>
Alternatively, you may
simply run the <code>oodump</code> tool, which will dump the database in raw text format
as follows: 
</par>
  
<verbatim>
 % examples/populateDb > oodump [-standalone] -db TrackData ./db/EXAMPLE_FD 
</verbatim>
 
<par>
You can check also the database catalog of the <code>EXAMPLE_FD</code> federated database as follows:</par>

<verbatim>
% examples/populateDb > oodumpcatalog [-standalone] ./db/EXAMPLE_FD 
</verbatim>

<par>
In standalone mode, this would produce something like the following.</par>

<verbatim>
/populateDb/db % oodumpcatalog -standalone EXAMPLE_FD 
Objectivity/DB (TM) List Database Files Utility, Version 5.1.0 
Copyright (c) Objectivity, Inc 1990, 1998. All rights reserved. 

FD Name   = EXAMPLE_FD 
FD ID     = 1 
FD File   = pc30::/populateDb/db/EXAMPLE_FD.FDDB 
Boot File = pc30::/populateDb/db/EXAMPLE_FD 
Jnl Dir   = pc30::/populateDb/db 
Lock Host = GHOST (lockserver is set to GHOST automatically if you run in standalone mode) 

DB Name   = System 
DB ID     = 2 
DB Image  = pc30::/populateDb/db/System.EXAMPLE_FD.DB 

DB Name   = Events 
DB ID     = 3 
DB Image  = pc30::/populateDb/db/Events.EXAMPLE_FD.DB 

DB Name   = Tracker 
DB ID     = 4 
DB Image  = pc30::/populateDb/db/Tracker.EXAMPLE_FD.DB 

DB Name   = Calo 
DB ID     = 5 
DB Image  = pc30::/populateDb/db/Calo.EXAMPLE_FD.DB 

/populateDb/db

</verbatim>

</section>

<section>
<stitle>Running the Examples on NT</stitle>

<par>
Before running the examples, ensure that both &OBJ; and ObjectSpace are installed.
Instructions on installing &OBJ; locally can be found via the following URL:
<url name="http://wwwinfo.cern.ch/asd/lhc++/Objectivity/index.html"/>.
</par>

<par>
You then need to install the GNU tools (CYGWIN-B20.1), available via
the following URL: <url
name="http://sourceware.cygnus.com/cygwin/"/>. These tools are ports
of the popular GNU development tools and utilities for Windows 95, 98,
and NT.  Using the GNU tools you will start a bash shell and proceed
as in UNIX, the only difference being the settings for the
<code>HEP_ODBMS_DIR</code> and <code>OBJY_DIR</code> environment
variables.
</par>

<alltt>
ALL STEPS YOU HAVE TO DO TO RUN WITH GNU TOOLS: 
  
bash-2.02$ <ucom>cp -r z:/P32/lhcxx/share/HepODBMS/new/HepODBMS/examples/populateDb . </ucom>
bash-2.02$ <ucom>cd populateDb</ucom>
bash-2.02$ <ucom>vi GNUmakefile</ucom> (Edit GNUmakefile) 
   getdb $(HEP_ODBMS_DIR)/schema/HEP_BASE $(BOOT) ${FDID} 
bash-2.02$ <ucom>vi example_setup</ucom> (edit example_setup as it follows) 
#!/bin/sh 
HEP_ODBMS_DIR=z:/P32/lhcxx/specific/Windows_NT/HepODBMS/new 
export HEP_ODBMS_DIR 
OBJY_DIR=d:/objy51 (set your local path!) 
export OBJY_DIR 
#STANDALONE=1 (TAKE COMMENT ONLY IF YOU RUN IN STANDALONE MODE) 
#export STANDALONE 
OO_FD_BOOT=`pwd`/db/EXAMPLE_FD 
export OO_FD_BOOT 
PATH=z:/P32/lhcxx/specific/Windows_NT/HepODBMS/new/lib:$PATH 
export PATH
bash-2.02$ <ucom>source example_setup</ucom>
bash-2.02$ <ucom>gmake</ucom> ( you can use VERBOSE=1 ) 
WARNING: LHCXXTOP is not defined! [z:/p32/lhcxx will be used] 
WARNING: PLATF is not defined! [ Windows_NT will be used] 
"z:/p32/lhcxx/specific/windows_NT/HepODBMS/new"/etc/getdb z:/p32/lhcxx/specific/ 
windows_NT/HepODBMS/new/schema/HEP_BASE db/EXAMPLE_FD 1 
ATTENTION:getdb in STANDALONE MODE 
Schema import from HEP_BASE to EXAMPLE_FD 
Updating Name Service values... 
Now updating System Name Space (catalog) values... 
Now updating Database File locations... 

Federated Database Installation complete. 
generating schema for Event 

compiling Event_ddl 
Event_ddl.cpp 
compiling populateDb 
populateDb.cpp 
compiling randomSource 
randomSource.cpp 
Linking ...

bash-2.02$ <ucom>populateDb 10</ucom> 
*** starting execution of populateDb 
*** about to initialise the database session 
WARNING: HepDbApplication: Could not find naming root directory: Naming will be 
disabled. 
*** creating 10 Events ... done. 
*** generated 100 tracks and 100 clusters in total. 
note: if you run in standalone mode remember to have following code in 
your populateDb.cpp, if not it will not run: 

      #ifdef nolockserver 
              ooNoLock(); 
      #endif 
      app.init("db/EXAMPLE_FD"); 
</alltt>

<par>
We can now generate a catalog of the database content as follows.
</par>
<alltt>
bash-2.02$ <ucom>oodumpcatalog -standalone db/EXAMPLE_FD</ucom>
</alltt>

<verbatim>
<![CDATA[Objectivity/DB (TM) List Database Files Utility, Version 5.1.0 
Copyright (c) Objectivity, Inc 1990, 1998. All rights reserved. 
FD Name   = EXAMPLE_FD 
FD ID     = 1 
FD File   = pc20::D:\populateDb\db\EXAMPLE_FD.FDDB 
Boot File = pc20::D:\populateDb\db\EXAMPLE_FD 
Jnl Dir   = pc20::D:\populateDb\db 
Lock Host = GHOST 

DB Name   = System 
DB ID     = 2 
DB Image  = pc20::D:\populateDb\db\System.EXAMPLE_FD.DB 

DB Name   = Events 
DB ID     = 3 
DB Image  = pc20::D:\populateDb\db\Events.EXAMPLE_FD.DB 

DB Name   = Tracker 
DB ID     = 4 
DB Image  = pc20::D:\populateDb\db\Tracker.EXAMPLE_FD.DB 

DB Name   = Calo 
DB ID     = 5 
DB Image  = pc20::D:\populateDb\db\Calo.EXAMPLE_FD.DB 
]]>
</verbatim>

<par>
The database browser allows you to obtain a pictural
representation as follows.</par>
<alltt>
bash-2.02$ <ucom>oobrowse -standalone db/EXAMPLE_FD</ucom>
</alltt>
<par><includegraphics file="oobrowse" width=".7\linewidth"/></par>

</section>
</chapter>

<appendix>
</appendix>

</bodymatter>
</document>
