head	1.9;
access;
symbols;
locks
	goossens:1.9; strict;
comment	@# @;


1.9
date	99.05.05.10.44.57;	author goossens;	state Exp;
branches;
next	1.8;

1.8
date	99.04.22.07.58.12;	author goossens;	state Exp;
branches;
next	1.7;

1.7
date	99.04.22.07.36.38;	author goossens;	state Exp;
branches;
next	1.6;

1.6
date	99.04.22.07.21.34;	author goossens;	state Exp;
branches;
next	1.5;

1.5
date	99.04.21.12.24.50;	author goossens;	state Exp;
branches;
next	1.4;

1.4
date	99.04.15.11.31.51;	author goossens;	state Exp;
branches;
next	1.3;

1.3
date	99.04.15.11.27.33;	author goossens;	state Exp;
branches;
next	1.2;

1.2
date	99.04.15.10.54.43;	author goossens;	state Exp;
branches;
next	1.1;

1.1
date	99.04.15.10.54.03;	author goossens;	state Exp;
branches;
next	;


desc
@@


1.9
log
@a few changes by Dino
@
text
@<?xml version="1.0" encoding='ISO-8859-1'?> 
<!-- Changed by: Michel Goossens, 3-Apr-1999 -->
<!-- 	$Id: htl.xml,v 1.8 1999/04/22 07:58:12 goossens Exp goossens $	 -->
<!DOCTYPE document SYSTEM "minilatex.dtd"[
<!ENTITY quot "&#34;">
<!ENTITY percent "!PERCENT!">
<!ENTITY uuml "ü">
<!ENTITY Excel "Excel">
<!ENTITY GNU  "GNU">
<!ENTITY HBOOK "HBOOK">
<!ENTITY HEP  "HEP">
<!ENTITY HTL  "HTL">
<!ENTITY LHCPP  "LHC++">
<!ENTITY NICE "Nice">
<!ENTITY OBJ  "Objectivity/DB">
<!ENTITY ODBMS "ODBMS">
<!ENTITY ODMG "ODMG">
<!ENTITY PAW  "PAW">
<!ENTITY SWIG "SWIG">
<!ENTITY UNIX "Unix">
<!ENTITY WNT  "Windows/NT">
<!ENTITY XML  "XML">
<!ENTITY % misc.new "|minipage">
<!ELEMENT minipage (#PCDATA|includegraphics|caption)*>
<!ENTITY % likepara.new "|texonly|small|footnote">
<!ELEMENT texonly (#PCDATA|par|figure|ref)*>
<!ELEMENT small (#PCDATA|par|emph)*>
<!ELEMENT footnote (#PCDATA|par|emph)*>
<!ENTITY % preformat.new "|alltt|listing|lprout">
<!ELEMENT alltt (#PCDATA|emph|ucom)*>
<!ELEMENT listing (#PCDATA)*>
<!ELEMENT lprout (#PCDATA)*>
<!ENTITY % xref.new "|vref">
<!ELEMENT vref     EMPTY>
<!ATTLIST vref     refid IDREF #REQUIRED>
<!ENTITY % inline.new "|ucom|code|sq">
<!ELEMENT code (#PCDATA)>
<!ELEMENT ucom (#PCDATA)>
<!ELEMENT sq (#PCDATA|code)*>
<!ENTITY % list.new "|descriptiona">
<!ELEMENT descriptiona ((term*,item*)+)>
<!ATTLIST descriptiona width CDATA #REQUIRED>
<!ENTITY nbsp " ">
<!-- External entity files -->
<!ENTITY Histo1Din         SYSTEM "/home/htl/HTLDOC/create_Histo1D.in">
<!ENTITY Histo1Dout        SYSTEM "/home/htl/HTLDOC/create_Histo1D.out">
<!ENTITY Histo1DVarin      SYSTEM "/home/htl/HTLDOC/create_Histo1DVar.in">
<!ENTITY Histo1DVarout     SYSTEM "/home/htl/HTLDOC/create_Histo1DVar.out">
<!ENTITY Histo2Din         SYSTEM "/home/htl/HTLDOC/create_Histo2D.in">   
<!ENTITY Histo2Dout        SYSTEM "/home/htl/HTLDOC/create_Histo2D.out">
<!ENTITY Histo2DVarin      SYSTEM "/home/htl/HTLDOC/create_Histo2DVar.in">   
<!ENTITY Histo2DVarout     SYSTEM "/home/htl/HTLDOC/create_Histo2DVar.out">
<!ENTITY HistoProfilein    SYSTEM "/home/htl/HTLDOC/create_profile.in">
<!ENTITY HistoProfileout   SYSTEM "/home/htl/HTLDOC/create_profile.out">
<!ENTITY HistoTablesin     SYSTEM "/home/htl/HTLDOC/histo_tables.in">
<!ENTITY HistoTablestxt    SYSTEM "/home/htl/HTLDOC/histo.txt">
<!ENTITY HistoTableskumac1 SYSTEM "/home/htl/HTLDOC/histotable.kumac">
<!ENTITY HistoTableskumac2 SYSTEM "/home/htl/HTLDOC/htl2hb.kumac">
<!ENTITY HistoRandomin     SYSTEM "/home/htl/HTLDOC/histo_random.in">
<!ENTITY HistoRandomout    SYSTEM "/home/htl/HTLDOC/histo_random.out">
<!ENTITY NameHistosin      SYSTEM "/home/htl/HTLDOC/name_histos.in">
<!ENTITY NameHistosout     SYSTEM "/home/htl/HTLDOC/name_histos.out">
<!ENTITY Operationsin      SYSTEM "/home/htl/HTLDOC/basic_operations.in">
<!ENTITY Operationsout     SYSTEM "/home/htl/HTLDOC/basic_operations.out">
<!ENTITY ReadHistoin       SYSTEM "/home/htl/HTLDOC/read_histo.in">
<!ENTITY ReadHistoout      SYSTEM "/home/htl/HTLDOC/read_histo.out">
<!ENTITY THistosin         SYSTEM "/home/htl/HTLDOC/create_transient.in">
<!ENTITY THistosout        SYSTEM "/home/htl/HTLDOC/create_transient.out">
<!ENTITY TSliceProjin      SYSTEM "/home/htl/HTLDOC/slice_proj.in">
<!ENTITY TSliceProjout     SYSTEM "/home/htl/HTLDOC/slice_proj.out">
]>
<document class="htl">
<frontmatter>
<title>HTL User Manual</title>
<author><name>Dino Ferrero Merlino</name><inst>CERN IT/ASD</inst>
<name>Savrak Sar</name>

<!--
This manual has been marked up using <emph>&XML;</emph> - the
eXtensible Markup Language.  (Is anything else relevent? Perhaps:

Pending the wide-spread availability of XML-capable browsers and
WYSIWYG editors, HTML and PostScript versions of this document have
been produced using ...
-->

<thanks>
HTL has benefited from the suggestions,
advice and help of many individuals. In particular,
Yemi Adesanya
and Jacub Moscicki are acknowledged for the development of the
existing HistOOgrams package and the templated prototype;
Dirk D&uuml;llman and
Marcin Nowak for help concerning &OBJ;;
Vincenzo Innocente for his version of templated histograms;
Olivier Couet and Michel Goossens for their general support.
</thanks>
</author>
</frontmatter>
<bodymatter>
<part>
<stitle>Getting started</stitle>

<!--1-->
<chapter id="H1Overview">
<stitle>Overview</stitle>

<section>
<stitle>What is HTL?</stitle>
<index item="CERNLIB"/>

<par>
The Histogram Template Library (&HTL;) is a C++ class library
that provides powerful histogramming functionality. As the name
suggests, it exploits the <emph>template</emph> facility of C++ and is
designed to be compact, extensible, modular and performant. As such it
only deals with histograms - i.e. binned data - and not unbinned or
<sq>Ntuple</sq> data. Furthermore, although simple file-based I/O and
<sq>lineprinter</sq> output are supported, it is decoupled from more advanced
I/O and visualisation techniques. In the context of &LHCPP;, such
capabilities are provided by other components that fully interoperate
with &HTL;. 
</par>

<par>
In the High Energy Physics (&HEP;) community, the &HBOOK; package has
been the <emph>de-facto</emph> standard for histogramming for many
years. This manual is written assuming a basic familiarity with 
&HBOOK; (see Table <ref refid="tab-hbook"/>).
</par>

<table id="tab-hbook" loc="h">
<caption>HBOOK routines and their HTL equivalent</caption>
<par>
<tabular preamble="ll">
<row><cell><emph>HBOOK name</emph></cell>
     <cell><emph>&HTL; equivalent</emph></cell></row>
<row><cell>HBOOK1    </cell><cell><code>Histo1D</code>     </cell></row>
<row><cell>HBOOK2    </cell><cell><code>Histo2D</code>     </cell></row>
<row><cell>HFILL     </cell><cell><code>fill</code> method </cell></row>
<row><cell>HPRINT    </cell><cell><code>print</code> method</cell></row>
</tabular>
</par>
</table>

<par>
&HTL; itself offers the histogramming features of
&HBOOK; as well as a number of useful extensions, with an
object-oriented (O-O) approach. These features include the following:
</par>

<itemize>
<item>booking and filling of 1D, 2D and profile histograms;</item>
<item>computation of statistics such as the mean or rms of a histogram;</item>
<item>support for operations between histograms;</item>
<item>browsing of and access to characteristics of individual histograms.</item>
</itemize>

<par>
This package replaces the histOOgrams package - an earlier C++
class library for histograms. The major functional innovation over the
previous package are the support for different kinds of bins, the
support of both persistent and transient (i.e. in-memory) histograms
at runtime and the definition of an abstract histogram interface.
</par>

<par>As a result, it is now possible to work with transient
histograms and subsequently save some or all of them in a database as
persistent histograms in a very simple and natural way (thus
simulating so called explicit I/O). This clearly has significant performance advantages,
particularly in the area of filling operations.
</par>

<par>
It is also possible to work with transient histograms only. These
may be printed or stored in files - the latter using a simple ASCII table
format that can be readily used by widely available tools,
including &PAW; or &Excel;.
</par>

<par>
The definition of an abstract histogram interface allows functionality
that is provided by external packages, such as plotting or fitting, to be decoupled from the actual
implementation of the histogram. This feature paves the way for co-existence of different histogram packages
that conform to the abstract interface.
</par>
</section>
	<section>
	  <stitle>Use of templates</stitle>

<par>
Although &HTL; uses templates internally, a small set of 
`user-classes' are provided. These have a very familiar (i.e. &HBOOK;-like)
look-and-feel and eliminate the need for users to be exposed to templates.
</par>

<par>
Nevertheless, the package still requires adequate template support at the C++ compiler level.
More details are given in Appendix A.
</par>
</section>
<section>
<stitle>Motivation</stitle>

<par>
When the existing HistOOgram package was implemented, compilers that provided
adequate support for templates were not widely available. Templates and other modern
C++ features can offer significant advantages.
In the case of &HTL;, these can be summarised as:
</par>
<itemize>
<item>increased performance;</item>
<item>greater flexibility and maintainability;</item>
<item>the support of both persistent and transient histograms at runtime.
Both provide similar features and are generated from the same
source files;</item>
<item>a more O-O approach, which in turn results in better encapsulation and more decoupling.</item>
</itemize>
<par>
These issues, especially the maintainability and high degree of decoupling, are of
particular importance to very long-term projects, such as those at the LHC, where
change and migration must be assumed and planned for.
</par>
</section>
</chapter>

<!--2-->
<chapter id="H1HTLglance">
<stitle>HTL at a glance</stitle>

<par>
This chapter provides an overview of &HTL; features.  Example code is
based on the use of the non-templated classes that are recommended for
use in typical analysis jobs.  The &HTL; package itself includes a
complete set of working examples that can be used as a basis for
building more complex applications.  A description of these examples
can be found in Appendix <ref refid="H1APPrunexamples"/>.
</par>

<section>
<stitle>Booking and filling persistent histograms</stitle>

<par>
The basic operations of creating (booking) and filling histograms are
shown below.  As the code fragments illustrate, these operations are
performed using methods that have the same basic signature as the
equivalent &HBOOK; subroutines. The primary difference is that the
&HBOOK; histogram identifier (ID) is replaced by <sq>smart pointers</sq>.
These pointers indicate both the type of the histogram to which they
refer (e.g. 1D, 2D) and whether they are transient or not.
</par>

<par>
As will be familiar to all &HBOOK; users, the following information is
specified at booking time:
</par>

<itemize>
<item>A character string or <emph>title</emph>, normally 
printed when the histogram is displayed.</item>
<item>The number of bins.</item>
<item>The lower bound of the histogram axis.</item>
<item>The upper bound of the histogram axis.</item>
</itemize>

<par>
For histograms of more than one dimension, the last three
arguments are then repeated for each dimension.
</par>

<par>
The following example shows the booking and filling of a 1D histogram
of 20 bins and a 2D histogram of 50 bins in both X and Y axes.
</par>

<verbatim>
#include "HTL/PHistograms.h" // Persistent histograms.
...
// Booking a 20 bin 1D histogram
 HepRef(PHisto1D) histo1 = 
  new (db_) PHisto1D("A 1D histogram",20,0.,40.);
// Booking a 50X50 bins 2D histogram
 HepRef(PHisto2D) histo2 = 
  new (db_) PHisto2D("A 2D histogram",50,5.,15.,50,5.,15.);

// Filling
 double x, w = 0.5;
 for( long i=0; i&lt;50000; i++ ) {
  x = -i*sin(float(i));
  histo-&gt;fill(x,w);
  histo2-&gt;fill(x,x,w);
 }
</verbatim>

<par>
The current implementation of &HTL; uses an Object Database (ODBMS) to
provide powerful and scalable persistence capabilities that go beyond
what is possible with simple files.  <footnote>Simple file-based
persistence is also provided - see chapter 2 for a description of the
<emph>write</emph> method.</footnote>
</par>

<par>
In the following, it
is assumed that the reader is familiar with the basic concepts 
of using an &ODBMS;. For example, any operations on persistent objects
must be performed in the context of a <emph>transaction</emph> and
a database session must have been established. The necessary code to perform
such operations has been omitted in the interests of clarity.</par>

<par>Although the basic histogram operations that are performed in the
above example will be clear to &HBOOK; users, the use of
<sq>smart-pointers</sq> differs from the traditional use of histogram
IDs and needs further explanation. Consider the following code fragment:
</par>

<verbatim>
HepRef(PHisto1D) histo1 = new ...
</verbatim>
<par>rather than</par>
<verbatim>
PHisto1D *histo1 = new ...
</verbatim>

<par>
In this piece of code,
<code>HepRef</code> is a smart pointer to a persistent histogram. As the previous
example shows, a smart pointer can be used as a
standard C++ pointer: that is, you can dereference it in the normal C++ manner:
</par>

<verbatim>
histo1-&gt;fill(...)
</verbatim>

<par>
In addition to the use of smart pointers, the <code>new()</code>
operator should be studied. It is followed by a so-called
<emph>clustering hint</emph>. A clustering hint is used to indicate
where the persistent objects - histograms in this case - should be
physically located on persistent storage. The database attempts to
place new objects <sq>close</sq> to those referenced by the hint. In
general, the efficient use of clustering allows performance to be
maximised, as objects are transferred to and from disk and across the
network in database pages.  Effective clustering minimises unnecessary
I/O and improves cache efficiency.
</par>

<par>
Finally, we note that the histograms created with <code>new()</code>
are not deleted with a corresponding <code>delete()</code>
operator. This would not only delete the histogram in the running
application <emph>but also</emph> from persistent storage, which is
presumably not the intention.
</par>
</section>

<section>
<stitle>Booking and filling transient histograms</stitle>

<par>The previous example is now repeated for the case of transient histograms.
Once again, two histograms are created and filled. Largely speaking, the code 
required is identical to the persistent case. The differences between the two
are discussed in futher detail below.</par>

<verbatim>
#include "HTL/Histograms.h" // Transient histograms.
...
// Booking a 20 bin 1D histogram
 Histo1D *histo1 = new Histo1D("A 1D histogram",20,0.,40.);
// Booking a 50X50 bins 2D histogram
 Histo2D *histo2 = new Histo2D("A 2D histogram",50,5.,15.,50,5.,15.);

// Filling
 double x, w = 0.5;
 for( long i=0; i&lt;50000; i++ ) {
  x = -i*sin(float(i));
  histo-&gt;fill(x,w);
  histo2-&gt;fill(x,x,w);
...
delete histo1;
delete histo2;
</verbatim>

<par>
Transient histograms are normal, in-memory C++ objects so
standard C++ pointers are used. 

</par>

<par>We note that the <code>new()</code> operator is now the standard C++
one. In this case, it is necessary to also handle explicit deletion of the
histogram to avoid memory leaks.</par>

<par>In summary, the differences between transient and
persistent &HTL; usage requires only the selection of the
corresponding class names (<code>Histo</code> versus <code>PHisto</code>)
and the use of smart pointer in the persistent case.
</par>

</section>
<section>
<stitle>Making a transient histogram persistent</stitle>

<par>
As already mentioned, &HTL; makes it possible to use both
persistent and transient histograms at runtime in the same program.
</par>

<par>
Since operations on transient histograms are significantly faster than those on persistent
ones, a typical procedure would be as follows:
</par>
<enumerate>
<item>perform all of the desired operations on transient histograms (filling
in particular)</item>
<item>make persistent copies of these transient histograms.
</item>
</enumerate>
<par>This offers the <sq>best of both worlds</sq> - the performance of
the transient implementation plus the added value of
persistence.</par>
<par>
To make a transient histogram <code>ph</code> persistent:
</par>
<enumerate>
<item>declare a persistent histogram
<code>ph</code> analogous to the transient counterpart,</item>
<item>use the <code>new</code> operator
as for the booking and then</item>
<item>pass the histo interface of <code>ph</code> to
the constructor of <code>ph</code>.
</item>
</enumerate>

<par>A persistent copy of the transient histogram now exists. These steps are
shown in the following code fragment.</par>

<verbatim>
#include "HTL/Histograms.h" // Transient histograms.
#include "HTL/PHistograms.h" // Persistent histograms.

// Declare and define `th': 
 Histo1D  *th = new Histo1D( "Mass",20,0.,4000.);

// Process `th', perform operations: 

// Copy `th' to the database, i.e. make `th' persistent: 
// 
HepRef( PHisto1D ) ph = new (dbH ) PHisto1D( *th ); 
// This create a persistent histo that is a clone (with data) of transient histo `th'. 
</verbatim>

<par>
We note that it is possible to create a persistent histogram out of
<emph>any</emph> histogram interface, be the source histogram transient or 
persistent itself.
</par>
</section>

<section>
<stitle>&HTL; histogram classes</stitle>

<par>
As described above, &HTL; is based on template classes which
allow very different types of histogram to be supported using the
smallest amount of code.
</par>

<par>
Nevertheless, the emphasis on usability has been maintained and hence
a small set of simple, easy-to-use simple &HBOOK;-like
classes are provided. It is expected that these classes will cover
most cases. The list of available classes is given below.
</par>

<par>Note that all of these classes are used in the same way.
For example, to book a histogram of a given type one uses:</par>

<verbatim>

// Use HepRef to refer to persistent classes, C++ pointers for transient ones

 HepRef(PHistyyy) histo1 =   new (dbH) PHistoyyy( ...
 Histyyy *histo1 =   new  Histoyyy( ...

// Use Histo1D for 1D Histogram, Histo2D for 2D Histogram,
// Histo2DVar for 2D histogram with variable binning etc.

</verbatim>

<par>e.g., to repeat the initial example:</par>

<verbatim>
Histo1D *histo1 = new Histo1D("A 1D transient histogram",20,0.,40.);
</verbatim>

<subsection>
<stitle>Persistent classes</stitle>

<descriptiona width="PProfileHistoVar">
<term><code>PHisto1D</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and fixed binning;</item>
<term><code>PHisto1DVar</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and variable
binning;</item>
<term><code>PProfileHisto</code></term>
<item>1D histogram with <code>Profile_Bin</code> and fixed binning;</item>
<term><code>PProfileHistoVar</code></term>
<item>1D histogram with <code>Profile_Bin</code> and variable
binning;</item>
<term><code>PHisto2D</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and fixed binning;</item>
<term><code>PHisto2DF</code></term>
<item>2D histogram with <code>Float_Weighted_Bin</code> and fixed binning;</item>
<term><code>PHisto2DVar</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and variable binning.</item>
</descriptiona>

<par>
All classes store bin values and errors as <emph>doubles</emph>, except
<code>PHisto2DF</code>, which stores them as <emph>floats</emph> (thereby
minimising the storage requirements for very large 2D histograms).
</par>

<par>
Weighted bins are equivalent to &HBOOK; bins, Gravity bins store the
position of the bin center-of-mass, so that the position of the bin
center is more accurate when the bin count is low or the binning is
not optimal (at least in some cases).
More details on bin types will be given later.
</par>

<par>
Notice that profile histograms and 2D histograms with variable
binning were not available in &HBOOK;.
</par>
</subsection>
<subsection>
<stitle>Transient classes</stitle>

<descriptiona width="ProfileHistoVar">
<term><code>Histo1D</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and fixed binning;</item>
<term><code>Histo1DVar</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and variable
binning;</item>
<term><code>ProfileHisto</code></term>
<item>1D histogram with <code>Profile_Bin</code> and fixed binning;</item>
<term><code>ProfileHistoVar</code></term>
<item>1D histogram with <code>Profile_Bin</code> and variable
binning;</item>
<term><code>Histo2D</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and fixed binning;</item>
<term><code>Histo2DF</code></term>
<item>2D histogram with <code>Float_Weighted_Bin</code> and fixed binning;</item>
<term><code>Histo2DVar</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and variable binning.</item>
</descriptiona>

<par>
All notes relating to persistent classes are also valid for
transient classes.
</par>
</subsection>
</section>
<section>
<stitle>Accessing bin content, bin error, bin center</stitle>

<par>
A histogram stores its bins and allows to access their content,
error and center.
</par>

<descriptiona width="h1D-&gt;bin(i).error();">
<term><code>h1D-&gt;bin(i).value();</code></term>
<item>Value of the bin indexed by <sq><code>i</code></sq>.</item>
<term><code>h1D-&gt;bin(i).error();</code></term>
<item>Error of the bin indexed by <sq><code>i</code></sq>.</item>
<term><code>h1D-&gt;bin_center(i);</code></term>
<item>center of bin index by <sq><code>i</code></sq>.</item>
</descriptiona>

<par>
Notice that the bin object can retrieve its content/error but
not its center; bins are simple containers, only the histogram
knows where they are mapped in the binning space.
</par>

</section>
<section>
<stitle>Line-printer and ASCII table output</stitle>

<par>
Printing a histogram in text mode is required in a number of
cases. For example, it can be useful for 
long batch jobs, where the user is mainly interested in checking
the quality of data.
</par>

<par>
&HTL; provides a text print helper for this purpose, that is largely
reused from the previous HistOOgrams packages.</par>

<par>The following example shows how the <code>print</code> method can
be invoked to generate a simple line-printer style representation of a histogram.</par>

<verbatim>
#include "HTL/Histograms.h" // Transient histograms.

Histo1D *histot = new Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
HepRef(PHisto2D) histop = 
  new PHisto2D("Persistent Histo_2D", 20, 0.0, 20.0, 20, 0.0, 20.0 ); 
... 
HPrinter hp( cout ); 
hp.print( *histop ); 
hp.print( *histot ); 
delete histot; 
</verbatim>

<par>
The above example demonstrates the use of the abstract histogram
interface: the same helper object can print any histogram that conforms to
the interface, regardless of whether it is transient, persistent, 1D, 2D and so
forth.
</par>

<par>
Particularly when working with transient &HTL;, it can be convenient to dump
a histogram in a simple ASCII table that can then be read by standard
tools (PAW, Excel, IRIS Explorer...) to plot or fit it.
</par>

<verbatim>
#include "HTL/Histograms.h" // Transient histograms.

T_Histo1D *histo = new Histo1D("Histo_1D", 20, 0.0, 20.0 ); 
... 
HistoTable1D ht1 ("histo.txt"); 
ht1.write(*histo); 
delete histo; 
</verbatim>
</section>
</chapter>

<!--3-->
<chapter id="H1PartitionsBins">
<stitle>Partitions and Bins</stitle>

<section>
<stitle>Partitions</stitle>

<par>
The concept of a 
<sq>Partition</sq> was first introduced in the HistOOgrams package. 
A partition describes how one dimension of the
problem space is divided into intervals. Consider the case of a 50
bin histogram in the range <inlinemath>[0,50]</inlinemath>, a
partition object containing the number of bins and the interval limits
will describe completely how we divide such interval: a set of 50
sub-intervals of equal width. This is termed a <sq>Fixed</sq>
or <sq>Even</sq> partition.
</par>

<par>
It may be required to book an histogram over the same range as the example
above, but with bins of variable widths. In this case,
a partition containing the number
of bins, the lower limit of each sub-interval and the upper limit
of the last sub-interval will describe completely 
<inlinemath>[0,50]</inlinemath> interval is divided. Such a partition is termed a
<sq>variable</sq> or <sq>Uneven</sq> partition.
</par>

<par>
An <emph>n-dimensional</emph> &HTL; histogram thus contains <emph>n</emph> partitions, one for
each axis. The only concern of a partition is to associate any ordered
1D space with a discreet numbered space. Thus it associates an
interval to a positive integer. Hence, a partition knows about the
width of the intervals and their lower point/bound or upper point/bound.
</par>

<par>
In the &HTL; package, a histogram delegates to
its partitions the task of locating a bin. In other words,
information about the lower and upper bounds of a bin or the width
of a given bin are obtained from the corresponding partition. This is shown in 
the following code fragment, which demonstrates how the lower and upper bound and width
of a given bin can be obtained.
</par>

<verbatim>
Histo1D *histo = new Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
... 
histo->partition().lower_point(i) // Obtain the lower bound of bin i
histo->partition().bin_width(i)   // and its width
histo->partition().upper_point(i) // and upper bound
</verbatim>
</section>
<section>
<stitle>Bins</stitle>

<par>
Bins themselves contain information about the content, the error and
possibly the center of the bin. Bin information is always accessed
through interface methods. &HTL; provides the following types of bin:
</par>

<descriptiona width="Gravity_bin_1D">
<term><code>Weighted_Bin</code></term> 
<item>class representing bins with weighted data points. 
By default the gravity center of these bins are the middle or center 
of the bin.</item>
<term><code>Gravity_Bin_1D</code></term>
<item>class representing bins with weighted data
points and that know how to determine the gravity center of the
bins. This new bin class allows us to have filling time statistics
as in the existing histogram package, but without having to compute
separate quantities at filling time. The other advantage is that in
case of bins with low counting, the information of the bin center
is more accurate that the middle of the bin.
<par>
Also, <code>Gravity_Bins</code> could provide more accurate
information in some cases of non-optimal binning. For instance, 
if you sample an integer variable in the range
<inlinemath>[0,20]</inlinemath> with a 20 bin histogram over the same
interval, the bin center is properly computed at the integer values,
while in a traditional histograms they would correspond to the closest
half integer.
</par></item>
<term><code>Profile_Bin</code></term>
<item>class representing bins that can average
another quantity.</item>
</descriptiona>

<par>
Note that bins only know about their contents. They do <emph>not</emph>
know where they are 
are located in the histogram to which they belong, nor about
their widths or bounds - this information is stored in the
partition to which they belong, which also defines the bin layout within
a histogram.
</par>
</section>
</chapter>

<!--4-->
<chapter id="H1VariablePartitionsandProfile">
<stitle>Histograms with variable partitions and Profile
histograms</stitle>

<section>
<stitle>Variable partition histograms</stitle>

<par>
HTL supports 1D and 2D histograms with variable partitions. The
partitions are specified as a vector of real numbers.
</par>

<subsection>
<stitle>Persistent case</stitle>

<verbatim>
P_Points_Vector points_on_X(10); // Vector of 10 real numbers 
points_on_X[0] = 0.0; points_on_X[1] = 1.0; 
points_on_X[2] = 3.5; points_on_X [3] = 4.0; 
points_on_X[4] = 5.5; points_on_X[5] = 9.0; 
points_on_X[6] = 10.; points_on_X[7] = 15.; 
points_on_X[8] = 19.; points_on_X[9] = 20.; 

HepRef(PHisto1DVar) histo = 
  new (db_) PHisto1DVar( "Histo1DVar", points_on_X ); 

P_Points_Vector points_on_Y(10); 
points_on_Y[0] = 0.0; points_on_Y[1] = 1.0; 
points_on_Y[2] = 2.5; points_on_Y[3] = 4.0; 
points_on_Y[4] = 6.0; points_on_Y[5] = 9.0; 
points_on_Y[6] = 12.; points_on_Y[7] = 14.; 
points_on_Y[8] = 18.; points_on_Y[9] = 20.; 

HepRef(PHisto2DVar) histo = 
  new (db_) PHisto2DVar( "Histo2DVar", points_on_X, points_on_Y ); 
</verbatim>
</subsection>

<subsection>
<stitle>Transient case</stitle>

<verbatim>
T_Points_Vector points_on_X(10); // Vector of 10 real numbers 
points_on_X[0] = 0.0; points_on_X[1] = 1.0; 
points_on_X[2] = 3.5; points_on_X[3] = 4.0; 
points_on_X[4] = 5.5; points_on_X[5] = 9.0; 
points_on_X[6] = 10.; points_on_X[7] = 15.; 
points_on_X[8] = 19.; points_on_X[9] = 20.; 

Histo1DVar *histo = new Histo1DVar( "Histo1DVar", points_on_X ); 

T_Points_Vector points_on_Y(10); 
points_on_Y[0] = 0.0; points_on_Y[1] = 1.0; 
points_on_Y[2] = 2.5; points_on_Y[3] = 4.0; 
points_on_Y[4] = 6.0; points_on_Y[5] = 9.0; 
points_on_Y[6] = 12.; points_on_Y[7] = 14.; 
points_on_Y[8] = 18.; points_on_Y[9] = 20.; 

Histo2DVar *histo2 = new Histo2DVar( "Histo2DVar", points_on_X, points_on_Y ); 
</verbatim>

<par>
Both the class names and type of vector used depends on whether transient or persistent
histograms are involved.
</par>
</subsection>
</section>

<section>
<stitle>Profile Histograms</stitle>

<par>
Profile histograms are implemented both with fixed and variable
partitions. The bin errors are computed as in &HBOOK;, but only the
<code>' '</code> and <code>'S'</code> options are supported (see the &HBOOK; manual
for a definition of these options and the associated error calculation).
However,
unlike in &HBOOK; these are not a booking time options; you can ask
each bin to compute either the Spread or the Spread/sqrt(N) error at
run-time.
</par>

<verbatim>
HepRef(PProfileHisto) histo = new (db_) PProfileHisto("Profile",20,0.,1.); 
long i; 
double x; 
for( i=0; i&lt;50000; i++ ) { 
  x = drand48(); 
  histo->fill(x,x,1.); 
} 

for( i=0; i&lt;histo-&gt;bin_count(); i++ ) { 
  cout &lt;&lt; endl &lt;&lt; ". " &lt;&lt; setw(2) &lt;&lt; i &lt;&lt; ": " 
&lt;&lt; setw(9) &lt;&lt; histo->i_bin(i).value() &lt;&lt; " Error " 
&lt;&lt; setw(4) &lt;&lt; histo->i_bin(i).error(0) &lt;&lt; " Spread Error " 
&lt;&lt; setw(4) &lt;&lt; histo->i_bin(i).error(1); 
} 
</verbatim>

<par>
As you can see the <code>error()</code> method on the bin interface
allows to access a set of errors: in this case the
<code>Profile_Bin</code> class accepts either the 0 or 1 index, which
map respectively to Spread/sqrt(N) and Spread errors.
</par>

<par>
Profile histograms can be filled with weights, but use of negative
weights yield meaningless results. With weights different from 1. the
errors are calculated properly only for bins with non-zero spread, and
set to 0. for bins with zero spread (&HBOOK;-like).
</par>
</section>
</chapter>

<!--5-->
<chapter id="H1OperationsHistograms">
<stitle>Operations on histograms</stitle>

<section>
<stitle>What do histogram operations apply to?</stitle>

<par>
In the &HBOOK; package, operations on histograms result in the
creation of a new histogram, rather than working directly on
the target histogram. This is not an approach which fits naturally
in the Object Oriented world of C++, where responsibility for object 
deletion and creation should normally go together.
</par>

<par>
In &HTL;, one first creates a copy of the target histogram and then
applies the operation on the newly created copy. The responsibility
for the creation and deletion of the new histogram are thus delegated
to the target application and unnoticed memory leaks potentially avoided.
</par>

</section>
<section>
<stitle>Cloning a histogram</stitle>

<par>
HTL allows you to produce a new copy of an existing histogram using
the <code>clone</code> method of the <code>I_Histogram</code>
interface.  The first argument, if given, specifies where the histogram
should be cloned, that is the clustering hint. By default the
clustering hint is the container that contains the source histogram in the
persistent case and empty in the transient case. The last argument, if
any, specifies how the histogram should be cloned:
</par>

<itemize>
<item>Specifying a value of 0 will result in a clone of just the structure;</item>
<item>A non-zero argument, which is also the default, will cause the data to be copied in addition.</item>
</itemize>

<par>An example of cloning in the persistent and transient case follows.</par>

<verbatim>
* Persistent case */ 

HepRef(PHisto1D) h1D = 
  new(db_)  PHisto1D( "Histo1: parabolic function", 20,0.,20.); 
... 
// The persistent histogram will be cloned close to the original
// object (default behaviour) 
HepRef(PHisto1D) clone_1D = h1D->clone();   // Clone 'h1D' structure and data
  
/* Transient case */ 

Histo1D *h1D = new Histo1D( "Histo1: parabolic function", 20,0.,20.); 
... 
Histo1D *clone_1D = h1D->clone();   // Clone 'h1D' structure and data
</verbatim>

</section>
<section>
<stitle>Operations on histograms</stitle>

<par>Below is a list of methods implementing operations on
histograms.</par>

<subsection>
<stitle>Operations with scalars</stitle>

<description>
<term><code>void add( double x )</code></term>
<item>Add <sq><code>x</code></sq> to current histo.</item>
<term><code>void sub( double x )</code></term>
<item>Substract <sq><code>x</code></sq> from current histo.</item>
<term><code>void mul( double x )</code></term>
<item>Multiply <sq><code>x</code></sq> with current histo.</item>
<term><code>void div( double x )</code></term>
<item>Divide current histo by <sq><code>x</code></sq>.</item>
</description>

</subsection>
<subsection>
<stitle>Operations with another histogram</stitle>

<description>
<term><code>Ref_Like_Current add( const Ref_Like_Current &amp;other )</code></term>
<item>Add <sq><code>other</code></sq> histo to current histo.</item>
<term><code>void add( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current sub( const Ref_Like_Current &amp;other )</code></term>
<item>Subtract <sq><code>other</code></sq> histo from current histo.</item>
<term><code>void sub( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current mul( const Ref_Like_Current &amp;other )</code></term>
<item>Multiply <sq><code>other</code></sq> histo with current histo.</item>
<term><code>void mul( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current div( const Ref_Like_Current &amp;other )</code></term>
<item>Divide current histogram by <sq><code>other</code></sq> histo.</item>
<term><code>void div( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current binomial_div( const Ref_Like_Current &amp;other
)</code></term>
<item>Divide current histo by <sq><code>other</code></sq> histo using <sq>binomial error</sq></item>
<term><code>void binomial_div( const I_Histo &amp;other )</code></term>
</description>

<par>Notice that operations with another histogram exists with two
signatures, the first one allowing to directly assign the result of
an operation.</par>

<par>This is an example of code to add two histograms:</par>

<verbatim>
HepRef(PHisto1D) histo1 = 
  new(db_)  PHisto1D( "Histo1: parabolic function", 20,0.,20.); 
  ... 
  for (int i = 0; i &lt; 50000; i++) 
    histo1->fill(x,w); 

  // Now create a clone of histo1 
  HepRef(Histo1D) histo2 = histo1->clone(); 
  // Add histo1 to histo2 and change histogram name 
  histo2->add( *histo1 ); 
  histo2->set_name( "Histo2 =  Histo2+Histo1 = 2*Histo1" ); 

  //
  // It is also possible to clone and perform an operation on single
  // statement:
  // 	histo2 = histo1->clone()->add( histo1 );
  //

</verbatim>

<par>As discussed in the first paragraph, it's important to first
make a clone of the original histogram. Another way to clone a
histogram is using a copy constructor, as described in Chapter 
<ref refid="H1Constructors"/>.
</par>
</subsection>
</section>
</chapter>
</part>

<part>
<stitle>Advanced HTL</stitle>

<!--6-->
<chapter id="H1UsingHistogramFactories">
<stitle>Histogram Factories and Naming Trees</stitle>

<par>
This section describes a number of techniques for handling the naming
and location of persistent histograms in the database. As such, 
this section only applies to persistent &HTL; histograms
as they 
</par>

<section>
<stitle>Histogram factories</stitle>

<par>
The Object Database Management Group (&ODMG;) standard for Object Databases 
specifies that persistent objects are created using a <code>new()</code> operator
with a <emph>clustering hint</emph> argument. This parameter provides
a mechanism whereby the user or application code can specify where
each individual object is physically stored. This is demonstrated by
the the following code fragment, where the <code>histo1</code> object
is created in the database referred to by the database handle
<code>db_</code>.
</par>

<verbatim>
HepRef(PHisto1D) histo1 = 
  new (db_) PHisto1D("A 1D histogram",20,0.,40.);
</verbatim>

<par>
Not only is this syntax somewhat unusual to novice users, but also
it poses problems when attempting to use tools 
such as the &SWIG; interface generator for scripting languages.
<footnote>The &SWIG; interface generator provides a generic mechanism for
integrating a wide variety of scripting languages, including Tcl, Perl, Python
and even Java.</footnote>
</par>

<par>
The <code>HFactory</code> class overcomes this problem by letting the
user specify by name the database or container in which histograms
should be created and provides a factory method for the actual creation of the
histograms.</par>

<par>
The following code fragment demonstrates the usage of a Histogram Factory.
It first initialises the factory, specifying the target database and container
by name. Histograms are then created and filled and are automatically 
stored in the appropriate container.
</par>

<verbatim>
#include "HTL/H_Factory.h" 
... 
  HFactory myFactory; 
  // Create histograms in DataBase "gepo", Container "sbaffini" 
  if (myFactory.init(this,"gepo","sbaffini")) { 
    // Create a histogram using the factory 
    HepRef(PHisto1D) h1 = myFactory.Histo1D("Histo-1",noBins,0.0,20.0); 
   ... 
   h1->fill(x, 1.); 
</verbatim>

<par>
The <code>HFactory</code> class provides a method to generate all
useful types of histograms. The factory methods are named according to
the histogram type and take parameters according to the corresponding
constructor.
</par>

<verbatim>
int init (HepDbApplication *sess, char *dbname,  char *contname = 0); 
HepRef(PHisto1D) Histo1D (const char *a_title, Size n, double x1, 
              double x2, End_Point_Convention epc = RIGHT_OPEN);
HepRef(PHisto1DVar) Histo1DVar(const char *,P_Points_Vector &amp;,
              End_Point_Convention epc = RIGHT_OPEN );  
HepRef(PProfileHisto) ProfileHisto1D (const char *a_title, Size n,
              double x1, double x2, End_Point_Convention  epc =
              RIGHT_OPEN ); 
HepRef(PProfileHistoVar) ProfileHisto1DVar(const char *,
              P_Points_Vector &amp;, End_Point_Convention epc = RIGHT_OPEN );  
HepRef(PHisto2D) Histo2D (const char *, Size , double  , double ,
              Size , double  , double , End_Point_Convention  epc1 =
              RIGHT_OPEN , End_Point_Convention  epc2 = RIGHT_OPEN );  
HepRef(PHisto2DVar) Histo2DVar( const char *, P_Points_Vector &amp;,
              P_Points_Vector &amp;, End_Point_Convention  epc1 =
              RIGHT_OPEN, End_Point_Convention   epc2 = RIGHT_OPEN );  
</verbatim>
</section>

<section>
<stitle>Naming histograms</stitle>

<par>
The HepODBMS package of &LHCPP; provides a logical naming scheme on top of
the physical structure of the underlying database. Note that these two structures
are independent - naming does not imply physical location and vice-versa. 
The naming package creates
and maintains a naming tree similar to file-system trees, with
directories and <sq>final objects</sq> (equivalent to files in a
file-system).
</par>

<par>
The HepODBMS naming package assumes each user is given a personal
naming tree which starts in a <sq>home directory</sq> like
structure. Each user is assigned a home directory that maps directly
to their user name 
under the common directory <code>/usr</code>. Thus, the home directory
in the naming tree for a user named <code>dinofm</code> is <code>/usr/dinofm</code>.
</par>

<par>
An exampe of the use of the naming tree that will be familiar to &HBOOK; 
users would be to name &HTL; histograms using an identifier much like the 
&HBOOK; <code>ID</code> and store them in appropriate named directories
in the database. This provides a naming scheme similiar to that used
by &HBOOK;, with the exception that the naming is case sensitive.
</par>

<par>
Although users can use the HepODBMS classes directly to name &HTL;
histograms, a simple <code>Factory</code> class which
extends the basic <code>HFactory</code> with naming
capabilities has also been provided. Using this extended factory class, users can choose
where to store histograms (physical location) and name them according to their favourite
scheme (logical location).
</par>

<par>
The following code fragment shows how &HTL; histograms
can be named. Two histograms are created and stored in the same database
and container as before. However, they are also given names in the
<code>/usr/dinofm/Histograms/MC</code> directory - one using an &HBOOK;-like
identifier and the other using a short text string.
</par>

<verbatim>
#include "HTL/HNaming.h" 
... 
  HNamingFactory myFactory(HNamingFactory::Override); 
  // Create histograms in DB "gepo", Container "sbaffini" and name
  // them in /usr/dinofm/Histograms/MC (dinofm is my user name) 
  if (myFactory.init(this,"Histograms/MC","gepo","sbaffini")) { 
    // Create two histograms. They're named 10 and "pt" in the name tree 
    HepRef(PHisto1D) h1 = myFactory.Histo1D(10,"Histo-1",noBins,0.0,20.0); 
    HepRef(PHisto1D) h2 = myFactory.Histo1D("pt","Histo-2",noBins,0.0,20.0); 
    ... 
    h1->fill(x, 1.); 
    h2->fill(x, 2.); 
</verbatim>

<par>
Named histograms, such as those created above, can then be retrieved as follows:
</par>

<verbatim>
/usr/dinofm/Histograms/MC/10
/usr/dinofm/Histograms/MC/pt
</verbatim>

<par>
It should be remembered that - unlike &HBOOK; - the naming scheme is case sensitive.
Histograms can be named with a character string such as
<sq><code>pt</code></sq> or with an integer code like 10 (similar to
&HBOOK;'s histogram identifier <code>ID</code>).
</par>

<par>
If the histogram you create already exists, <code>HNamingFactory</code>
can either override the previous histogram or refuse to create the
new one, depending on the strategy specified when the factory was
declared.
</par>

<par>
To instruct the factory to override existing histograms, use a construct like:
</par>

<verbatim>
 HNamingFactory myFactory(HNamingFactory::Override);
</verbatim>
<par>
To avoid accidental overwriting of existing histograms,
use something like:
</par>

<verbatim>
 HNamingFactory myFactory(HNamingFactory::Keep);
</verbatim>

<par>
The Override directive can be useful for cases such as batch jobs 
or debugging: old histograms are simply replaced by new
ones. The <code>Keep</code> mode allows one to protect against
the accidental deletion of useful data. Other strategies, such as
cycles or versions, are not presently implemented.
</par>

</section>

<section>
<stitle>Retrieving named histograms</stitle>

<par>
Once the histograms have been saved and named in an Objectivity
data store, a mechanism for retrieving them is clearly required.
The <code>HLocator</code>
class allows the retrieval of a histogram by name, as follows:
</par>

<verbatim>
#include "HTL/HNaming.h" 
... 
  // Locate Histograms pt and 10 
  HLocator myLocator; 
  HPrintert hp(cout); 
  myLocator.init(this); 
  HepRef(PHisto1D) h = myLocator.Histo1D("pt"); 
  if (h != 0) 
    hp.print(*h); 
  h = myLocator.Histo1D(10); 
  if (h != 0) 
    hp.print(*h); 
</verbatim>

<par>
Notice that the <code>HLocator</code> class provides methods to
retrieve different kinds of histograms (so users should know what
they are retrieving). Type checking is thus guaranteed and if the
expected histogram type does not match the real one, an error message
is printed and the return value is zero.
</par>
</section>
</chapter>

<!--7-->
<chapter id="H1UsingInterfaces">
<stitle>Using interfaces</stitle>

<par>
Interfaces are a powerful OO concept which allows designers to
decouple what an object does from its actual implementation. This
reduces the impact on <sq>external</sq> software using such object(s) and
makes software reuse more realistic.
</par>

<par>
In the C++ world, interfaces are usually implemented by abstract
classes with virtual methods. In this context the only drawback of
interfaces might be a performance penalty due to the extra
indirection required by virtual functions, but we should not
neglect the usefulness of interfaces just because of that.
</par>

<section>
<stitle>Interfaces in HTL</stitle>

<par>
HTL defines and implements abstract interfaces for most of its
functionalities. The only method which is not available on purpose at
the interface level is the <code>fill()</code> method, which must be
implemented as an non-virtual inline method to provide the highest
performance (see Appendix <ref refid="H1APPerformance"/> for details).
</par>

<par>
HTL interfaces are used by other packages such as fitting (HEPFitting)
and visualisation (HEPInventor) that are thus independent from the
actual HTL implementation of histograms. Interfaces are what allows
external packages to deal with transient and persistent HTL histograms
at the same time. Using such interfaces we might even implement an
HTL-like package based on other technologies, for instance an HTL
interface to &HBOOK;, although this is not envisaged at present.
</par>

<subsection>
<stitle>The <code>I_Histo</code> interface</stitle>

<par>
<code>I_Histo</code> is the high-level interface to histograms. The following
is a list of supported methods.
</par>

<description>
<term><code>virtual const char* name()</code></term>
<item>Title attached to current histogram.</item>
<term><code>virtual I_Bin&amp; i_bin( I_Bin_Location &amp;a_location )</code></term>
<item>In-range bin associated with location <code>a_location</code>.</item>
<term><code>virtual I_Bin&amp; i_extra_bin( I_Extra_Bin_Location
&amp;a_location )</code></term>
<item>Extra bin associated with extra location <code>a_location</code>.</item>
<term><code>virtual Size bin_count()</code></term>
<item>Number of in-range bins.</item>
<term><code>virtual Size extra_bin_count()</code></term>
<item>Number of extra bins.</item>
<term><code>virtual Size dim()</code></term>
<item>Dimension of the histo, i.e., of the problem space.</item>
<term><code>virtual I_Partition&amp; i_partition( Index p = 0 )</code></term>
<item>Partition interface associated with this histo. 
For the first partition one has <code>a_dim_index = 0</code>.</item>
<term><code>virtual I_Bin&amp; i_bin( Index i )</code></term>
<item>Any bin (in-range or extra) with index <sq><code>i</code></sq>
(note that this is a linear access).</item>
</description>

<par>
The <code>I_Histo</code> interface can retrieve the number of bins
that are in-range or out-range, for instance, overflow or underflow,
as well as the number of partitions (i.e. the dimensionality of the
histogram). It also allows you to access other interfaces such as
<code>I_Partition</code> and <code>I_Bin</code>. 
</par>

<par>
On the other hand, the <code>I_Histo</code> interface does not try to
provide all information in a single interface: details about binning
and bin content are delegated, respectively, to the <code>I_Partition</code>
and <code>I_Bin</code> interfaces, as explained later.
</par>
</subsection>
<subsection>
<stitle>The <code>I_Partition</code> interface</stitle>

<par>
The <code>I_partition</code> interface deals with binning details,
such as, which interval of the problem space a bin is mapped to, that
is where does it start and end, and what are the limits of the range
spanned by the partition.  The following is a list of supported
methods.
</par>

<description>
<term><code>End_Point_Convention end_point_convention()</code></term>
<item>End point convention for all bins; can be either 
<code>RIGHT_OPEN</code> or <code>LEFT_OPEN</code>.</item>
<term><code>virtual double i_bin_width( Index i )</code></term>
<item>Width of in-range bin <sq><code>i</code></sq>.</item>
<term><code>virtual double i_lower_point()</code></term>
<item>Leftmost point of the partition.</item>
<term><code>virtual double i_lower_point( Index i )</code></term>
<item>Leftmost point of bin indexed by <sq><code>i</code></sq>.</item>
<term><code>virtual double i_upper_point()</code></term>
<item>Rightmost point of the partition.</item>
<term><code>virtual double i_upper_point( Index i )</code></term>
<item>R`ightmost point of bin indexed by <sq><code>i</code></sq>.</item>
</description>
</subsection>

<subsection>
<stitle>The <code>I_Bin</code> interface</stitle>

<par>
The <code>I_Bin</code> interface allows you to set or get the content of
a bin, its count information, and its error.
The available methods are listed below.</par>

<description>
<term><code>virtual double value( Index i = 0)</code></term>
<item>Value associated with this bin.</item>
<term><code>virtual double error( Index i = 0)</code></term>
<item>Error associated with this bin.</item>
<term><code>virtual Size count()</code></term>
<item>Count associated with this bin. = Number of entries.</item>
<term><code>virtual void set_value( double other, Index i = 0 )</code></term>
<item>Set the value associated with this bin to <sq><code>other</code></sq>.</item>
<term><code>virtual void set_error( double other, Index i = 0 )</code></term>
<item>Change/set the error of the bin to <sq><code>other</code></sq>.</item>
<term><code>virtual void set_count( Size other )</code></term>
<item>Change/set the count of the bin to <sq><code>other</code></sq>.</item>
<term><code>virtual double center( Index i = 0)</code></term>
<item>Absolute or relative center of this bin on axis <sq><code>i</code></sq>.</item>
<term><code>virtual int offset( Index i = 0)</code></term>
<item>Relative or absolute position for the center of the bin.</item>
</description>
</subsection>
</section>

<section>
<stitle>Example using Interface classes</stitle>

<par>
The following example is derived from the HEPInventor visualisation package -
only a subset of the complete code is used.  The method receives
an <code>I_Histo</code> reference which is then used, for instance, to
find out whether this is a 1D or 2D histogram. Via the same
<code>I_Histo</code> reference, the code retrieves an interface to the
underlying partition, which gives information about the beginning and
end of each bin. At the end, the <code>I_Bin</code> interface of each
bin allows us to retrieve the content and the error associated to each
bin.
</par>

<verbatim>
HIData::HIData(I_Histo &amp;histo) { 
  int i,j,k=0; 
  switch (histo.dim()) { // Is it 1D or 2D? 
  case 1: 
    // Copy the histogram content in a local data structure 
    nptx       = histo.bin_count(); 
    // Use underlying histo.i_partition() interface 
    Xval[0]    = histo.i_partition(0).i_lower_point(0); 
    Yval[0]    = histo.i_bin(0).value(); 
    // Had to patch this... no asymmetric errors yet... 
    EXval[0]   = (histo.i_partition(0).i_lower_point(1)-Xval[0])/2.; 
    EYval[0]   = histo.i_bin(0).error(); 
    for ( i=1; i &lt; nptx; i++) { 
      Xval[i]  = histo.i_partition(0).i_lower_point(i); 
      // Use I_Bin interface to retriev value/error 
      Yval[i]  = histo.i_bin(i).value();  
      EYval[i] = histo.i_bin(i).error(); 
    } 
  } 
} 
</verbatim>

<par>
As you can see there is no reference whatsoever to the real C++
type of the histogram, to its dimensionality, etc. The same code
works with all HTL histograms!
</par>

</section>
</chapter>

<!--8-->
<chapter id="H1Constructors">
<stitle>Constructors</stitle>

<section>
<stitle>Types of constructors</stitle>

<par>
HTL provides more constructors than the current package and allows us
to define and create new histograms out of transient or persistent
ones in a nice and natural way.
</par>

<par>
Three kinds of constructor are defined for any histogram
class.
</par>

<par>
The first kind of constructor is the classic one used for the booking.
Arguments reflect the type of the histogram, for instance, 1D or 2D,
fixed or variable bin size, etc. An example is the following:
</par>

<verbatim>
Histo1D( const char *a_title, Size nBins, double lowX, double
           highX, End_Point_Convention epc = RIGHT_OPEN )
</verbatim>

<par>
The second kind of constructor is a copy constructor. The first
argument must be a histo of the same type. The optional second
argument specifies whether we want to copy the structure only (the
argument must equal 0) or the structure as well as the data also.
(This is the default - argument non 0).
</par>

<verbatim>
Histo1D( Like_Current &amp;a_histo, int copy_data = 1 )
</verbatim>

<par>
<code>Like_Current</code> is a typedef and designates the real type of
the current histogram class with all its template arguments.
</par>

<par>
The third kind of constructor is a variant of a copy constructor. It
makes it possible to create a new histogram out of a histo interface. It
is particularly useful to create persistent histograms from
transient ones. The optional second argument for data copying is also
available.
</par>

<verbatim>
Histo1D( const I_Histo &amp;a_histo, int copy_data = 1 )
</verbatim>

</section>
</chapter>

<!--9-->
<chapter id="H1RetrievingStatistics">
<stitle>Retrieving statistics and entries information</stitle>

<section>
<stitle>Shortcuts</stitle>

<par>
1D histograms implement shortcut methods to retrieve mean and
RMS of a histogram, as follows:
</par>

<verbatim>
Histo1D *h1D = new Histo1D("Histo1: parabolic function",20,0.,20.);
...
cout &lt;&lt; "Mean " &lt;&lt; h1D-&gt;mean() &lt;&lt; " RMS " &lt;&lt; h1D-&gt;rms() &lt;&lt; endl;
</verbatim>
</section>
<section>
<stitle>General method</stitle>

<par>
HTL implements retrieval of statistics and entries information via
separate helper classes. The helper class is called
<code>HStat</code> and it allows us to decouple computation
of statistics and entries information from the implementation
of the histogram.
</par>

<verbatim>
#include "HTL/Histograms.h"  

Histo1D *h1D = new Histo1D("Histo1: parabolic function",20,0.,20.); 

... // filling 

// Now display some statistics: 
// 
long in_entries = HStat::in_range_entries_count(*histo); 
long extra_entries = HStat::extra_entries_count(*histo); 
cout &lt;&lt; "Entries count: " &lt;&lt; (in_entries + extra_entries) 
 &lt;&lt; " with IN_RANGE: " &lt;&lt; in_entries 
 &lt;&lt; " EXTRA: " &lt;&lt; extra_entries &lt;&lt; endl; 

double mean = HStat::mean( *histo ); 
cout &lt;&lt; "MEAN (B.C.): " &lt;&lt; mean &lt;&lt; endl; 
cout &lt;&lt; "RMS  (B.C.): " &lt;&lt; HStat::rms(*histo, mean) 
 &lt;&lt; endl &lt;&lt; endl; 
</verbatim>
</section>
</chapter>
</part>

<appendix>

<!--A-->
<chapter id="H1APSupportedCompilers">
<stitle>Supported compilers</stitle>

<par>
The list of supported compilers on a given platform follows
</par>

<description>
<term>Solaris</term><item>CC 4.2</item>
<term>HP-UX</term><item>aCC A.01.15</item>
<term>Linux</term><item>egcs 1.1.1 with patch for 
  persistent templates specialization</item>
<term>Digital Unix</term><item> cxx V6.1-027</item>
<term>AIX </term><item>xlC 3.1.?</item>
<term>&WNT;</term><item>VC++ 5.0 SP3</item>
</description>
</chapter>

<!--B-->
<chapter id="H1APStatisticsErrorPropagation">
<stitle>Statistics and error propagation</stitle>

<section>
<stitle>Histogram statistics</stitle>

<par>
HTL implements histogram statistics as bin content statistics
only.
</par>

<verbatim>
Mean = SUM[ bin center * bin value ] / SUM[ bin value ]
RMS = SUM[ (bin center - mean)^2 * bin value ] / SUM[ bin value ]
</verbatim>

<par>
Since the <code>Gravity_Bin</code> used in 1D HTL histograms keeps the
weighted center of the bin, those quantities are equal to so-called
<sq>filling time statistics</sq> computed by &HBOOK; and HistOOgrams.
</par>
</section>

<section>
<stitle>Bin errors</stitle>

<par>
Bin errors are always computed taking weights into account.
</par>

<verbatim>
error = sqrt( SUM[ weight*weight ])
</verbatim>

<subsection>
<stitle>Bin error <sq>propagation</sq> for histogram operations</stitle>

<par>
Depending on histogram operations, bin errors are combined in
the error of the resulting bin. Formulas should be equivalent to
the ones used in &HBOOK;.
</par>
</subsection>

<subsection>
<stitle>Synopsis</stitle>

<description>
<term><code>error_</code></term>
<item>error of the first bin, <code>other.error()</code> 
is the error of the second bin;</item>
<term><code>value_</code></term>
<item>value of the first bin, <code>other.value()</code> is the error of
the second bin.</item>
</description>

<verbatim>
 void add( const Like_Parent &amp;other ) 
  error_ =  other.error()*other.error() + error_ ; 

void sub( const Like_Parent &amp;other ) 
  error_ = other.error() * other.error() + error_ ; 

void mul( const Like_Parent &amp;other ) 
  error_ = error_ * other.value()*other.value() +  
           other.error()*other.error() * value_*value_ ; 

void div( const Like_Parent &amp;other ) 
  e = pow(other.error(),4) ;
  error_ = error_ * other.value()*other.value() +  
           other.error()*other.error() * value_*value_ ; 
  if( e != 0 ) 
    error_ = ( error_/e ); 

void binomial_div( const Like_Parent &amp;other ) 
  e = other.error()*other.error() ;
  error_ = sqrt( error_ / e ); 
  error_ = error_ * (1-error_); 
  error_ = error_ * error_; 
  error_ = ( error_ / e ); 
</verbatim>
</subsection>
</section>
</chapter>

<!--C-->
<chapter id="H1APPerformance">
<stitle>Performance</stitle>

<section>
<stitle>Introduction</stitle>

<par>
Most of the time the performance of an histogramming package is not
critical. For example, in the typical case of long running
batch jobs, the time spent in histogram operations is not that important.
On the other hand there are applications, such as online monitoring,
where excellent performance is fundamental.
</par>

<par>
The HistOOgram package, which &HTL; replaces, was not optimised for 
performance, but rather was designed 
for maximum flexibility. In addition, early benchmarks of this package
were performed on a pre-release and should be considered unrepresentative.
</par>

<par>
Experience shows that there is always a tradeoff between higher performance
and maximum flexibility. Fortunately, a reasonable compromise
can usually be found, since performance is normally required only in well
defined areas of the code.
</par>

<par>
A often-heard rule of thumb states that in most cases an application
spends 80&percent; of its time in 20&percent; of the code. Hence an 
efficient approach is to estimate where the critical sections of the code lie,
identify the most appropriate algorithms (which are more difficult to
change than code), and finally measure the performance with a proper
tool, such as a code profiler. 
Code portability and maintainability should not be abandoned in the pursuit of
performance - all are important issues that need to be addressed when
producing a package.
</par>

<par>
The procedure described above was that used in the case of &HTL;. In other words,
the critical portions of
code were first identified, which unsurprisingly turned out to be the filling
methods, that can be called millions of times. A
technique to speed up filling by using templated classes was then identified (see for
instance the Blitz++ libraries for a discussion about templates and
C++ performance). Finally, once the package was working,
the performance was measured and tuned using a simple code profiler.
</par>

<par>
The results of a simple comparison with &HBOOK; are presented below. These
are not intended as a complete test but rather as a benchmark
reference. The source code used for the benchmark
is available on request.
</par>
</section>

<section>
<stitle>Comparison between &HBOOK;, HistOOgrams, and HTL</stitle>

<subsection>
<stitle>Description of the benchmark</stitle>

<par>
A set of 10 histograms with fixed binning is filled with 50000 points
each.  The benchmark is focused on filling performance. 

The I/O part is more difficult to compare directly and is not included
in these comparisons. &OBJ;, used by persistent &HTL;, ensures that all data
is written to disk as part of a transaction. In the case of &HBOOK; 
buffers are not flushed and so a comparison of the two is not meaningful.
In the &HBOOK; case, timing is measured with the CERNLIB routine
<code>TIMED</code>. The C++ benchmark reports real time as measured by
RD45's <code>Timer</code> class.  HTL histograms are based on gravity
bins, so they harvest more information than their &HBOOK; counterpart,
and thus use CPU.
</par>
</subsection>

<subsection>
<stitle>Results of the benchmark</stitle>

<par>
The target machine used for the test was a Sparc Ultra:
</par>

<verbatim>
SunOS sunasd1 5.5.1 Generic_103640-12 sun4u sparc SUNW,Ultra-30
</verbatim>

<par>
The compilers used were the following: <code>C++ V 4.1</code> for
HistOO, <code>C++ V4.2</code> for HTL, and <code>f77 4.2</code> for
&HBOOK;.
</par>

<par>
The results are summarised in the table below.
</par>

<par>
<tabular preamble="@@{}ll@@{}">
<row><cell>&HBOOK;</cell><cell>860 ms</cell></row>
<row><cell>Transient HTL</cell><cell>790 ms</cell></row>
<row><cell>HistOO</cell><cell>3600 ms</cell></row>
<row><cell>Persistent HTL</cell><cell>2700 ms</cell></row>
<row><cell>Persistent HTL(fast-filling)</cell><cell>1150 ms</cell></row>
</tabular>
</par>

<par>
The timing on the second line of the persistent &HTL; case is for a
version optimised by using a fast filling method.
</par>

<par>
It should also be stressed that the &HTL; package allows you to create a
persistent Histogram out of a transient one so that it is possible
to work in a mixed mode: first histograms can be created
and filled as transient, and only at the end saved as persistent.
Thus one combines the advantages of a fastest possible filling 
with the those of profiting of object persistency.
</par>
</subsection>
</section>

<section>
<stitle>Conclusion</stitle>

<par>
&HTL; transient histograms are slightly faster than comparable &HBOOK;
ones, even though they provide the user with more accurate information
about bin centers.
</par>

<par>
&HTL; persistent histograms are somewhat slower than their transient counterparts. 
It would be possible, using
more advanced &OBJ; techniques such as
fast-filling methods and pinning in memory, to make them
almost as fast as transient ones. However, a more practical approach
in most cases is the use of transient histograms for repetitive operations such as
filling, combined with persistent copies of the filled histogram for storage.
</par>

<par>
When raw performance is absolutely crucial, faster &HTL; histograms 
are also available. However, they do not provide filling time statistics.
</par>

<par>
Since &HTL; allows you to mix persistent and transient histograms, the
optimal strategy when performance is an issue is to book and fill
transient histogram and save them at the end of the run using the
persistent histogram <code>copy</code> constructors (as explained in
chapter <ref refid="H1HTLglance"/>).
</par>

</section>
</chapter>

<!--D-->
<chapter id="H1APPrunexamples">
<stitle>Running the examples</stitle>

<section>
<stitle>List of available examples</stitle>

<par>
A set of HTL examples can be found in the directory 
<url name="file:/afs/cern.ch/sw/lhcxx/share/HTL/dev/HTL/examples"/>.
</par>

<descriptiona width="HistoProfile">
<term><code>Histo1D</code></term>
<item>create persistent 1D histogram with fixed binning;</item>
<term><code>Histo2D</code></term>
<item>create persistent 2D histogram with fixed binning;</item>
<term><code>HistoProfile</code></term>
<item>create persistent 1D profile histogram with fixed binning;</item>
<term><code>HistoTables</code></term>
<item>produce ASCII tables to export HTL histograms to, e.g., PAW;</item>
<term><code>Operations</code></term>
<item>histogram cloning and histogram operations;</item>
<term><code>THistos</code></term>
<item>create transient 1D/2D histograms with fixed binning;</item>
<term><code>Histo1DVar</code></term>
<item>create persistent 1D histogram with variable binning;</item>
<term><code>Histo2DVar</code></term>
<item>create persistent 2D histogram with variable binning;</item>
<term><code>HistoRandom</code></term>
<item>use of CLHEP random generators;</item>
<term><code>NameHistos</code></term>
<item>naming persistent histograms;</item>
<term><code>ReadHisto</code></term>
<item>reading back histograms from Objectivity/DB datastore;</item>
<term><code>TSliceProj</code></term>
<item>slice/projections of a 2D histogram.</item>
</descriptiona>
</section>

<section>
<stitle>Setting up for using the examples</stitle>

<subsection>
<stitle>Defining your environment</stitle>

<par>
When you are running in an environment created by the &LHCPP; setup
procedure (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/lhcppguide/SetUpUserEnvironment.html"/>) 
all environment variables needed by HTL will be already in place.
</par>

<par>
If you are not running in such an environment, you will have to set 
the HTL environment variables up yourself, since the GNUmakefiles for
running the examples assume that the following environment
variables are defined correctly:
</par>

<itemize>
<item><code>LHCXXTOP</code></item>
<item><code>PLATF</code></item>
<item><code>HEP_ODBMS_DIR</code></item>
<item><code>HISTOODIR</code></item>
</itemize>

<par>
If they are not defined run the following script which is likely to
work at CERN (replace <emph>pro</emph> by <emph>new</emph> or
<emph>dev</emph> to get the new or development versions as required):
</par>

<verbatim>
source /afs/cern.ch/sw/lhcxx/share/HTL/pro/HTL.csh
</verbatim>

<par>
The above syntax is for C-shell flavours, while on Bourne shell
flavours you should use:
<verbatim>
. /afs/cern.ch/sw/lhcxx/share/HTL/pro/HTL.ksh
</verbatim>

For non-CERN installations you will have to replace the path:
<verbatim>
/afs/cern.ch/sw/lhcxx
</verbatim>
with the location of your &LHCPP; tree.
</par>

<par>
Finally, a similar script is provided on &WNT; as a batch file:

<verbatim>
Z:\P32\lhcxx\share\HTL\pro\HTL.bat
</verbatim>

If you are using persistent HTL your &OBJ; environment should be
properly defined as well.
</par>
</subsection>

<subsection>
<stitle>Building the examples</stitle>

<par>
Make a local copy of the examples directory and run
<code>gmake</code>, as follows:
</par>

<alltt>
<ucom>cp -r /afs/cern.ch/sw/lhcxx/HTL/dev/HTL/examples .</ucom>
<ucom>cd examples</ucom>
<ucom>gmake</ucom>
</alltt>

<par>
These commands will build all examples in one go. You can build
examples separately by running <code>gmake</code> in each
subdirectory.
</par>

</subsection>

<subsection>
<stitle>Running the examples</stitle>

<par>
HTL is provided as shared libraries on most platforms. This means HTL
libraries and any other shared library used by HTL, such as HepODBMS
and &OBJ; for persistent HTL, should be visible in your shared library
path.
</par>

<par>
Provided that your environment is already configured for &LHCPP;, no furher
setup is required. If not, as a mininum your shared library path must
include the directory where the &HTL; library (and also &OBJ;, for
the persistent version) is located.
The scripts mentioned in the previous sections will update your library
path as well.
</par>

<par>
The examples executables are created in a <code>$(OS)</code>
subdirectory in each example directory.
</par>
</subsection>
</section>

<section>
<stitle>Structure of each example</stitle>

<par>
Each example directory contains two files: a GNUmakefile
to build the example and a source file containing the C++ code.
The source file typically defines an <sq>Application</sq> class
and a main program which instantiates that class and calls one or more
methods.
</par>

<verbatim>
class Histo_App :
...
int main( int argc, char **argv )
{
 Histo_App app;
 app.init();
 app.run();
 app.commit();
}
</verbatim>

<par>
The <sq>Application</sq> class may inherit from
<code>HepODBMS::HepDBApplication</code> when working with the
persistent HTL examples. This allows the class to manage transactions
and so on. Apart from transaction issues, most examples based on
persistent HTL can be translated to transient HTL by changing all
occurrences of <code>PHisto</code> to <code>Histo</code>
</par>
</section>

<section>
<stitle>One dimensional histograms</stitle>
<par>
The following example shows the creation, filling and line-printer
output of a 1D histogram and some of its attributes. The histogram
itself has weighted bins and an even partition. The histogram
is persistent - that is, it is stored in the database and remains
there after the job has completed.
</par>

<subsection>
<stitle>Input program</stitle>

<listing>
&Histo1Din;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>

<lprout>
&Histo1Dout;
</lprout>
</subsection>
</section>

<section>
<stitle>One dimensional variable histograms</stitle>
<par>
The following example shows the use of a variable partition, but is otherwise similar
to the previous case.
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&Histo1DVarin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&Histo1DVarout;
</lprout>
</subsection>
</section>

<section>
<stitle>Two dimensional histograms</stitle>
<par>
The following example shows the use of a 2D histogram
with fixed partitions.
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&Histo2Din;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&Histo2Dout;
</lprout>
</subsection>
</section>

<section>
<stitle>Two dimensional variable histograms</stitle>
<par>
The following example shows the use of a 2D histogram
with variable partitions.
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&Histo2DVarin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&Histo2DVarout;
</lprout>
</subsection>
</section>

<section>
<stitle>Profile histograms</stitle>
<par>
The following example shows the use of profile historams.</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&HistoProfilein;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&HistoProfileout;
</lprout>
</subsection>
</section>

<section>
<stitle>Filling histograms with random numbers</stitle>
<par>
The following example shows cloning of and operations on histograms.</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&HistoRandomin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&HistoRandomout;
</lprout>
</subsection>
</section>

<section>
<stitle>Saving histogram as text table</stitle>
<par>
The following example shows how a histogram can be saved in a simple
text file that can subsequently be read by PAW, Excel or other common tool.
An example of a suitable PAW macro is also provided.
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&HistoTablesin;
</listing>
</subsection>

<subsection>
<stitle>PAW kumac for reading table</stitle>
<listing>
&HistoTableskumac1;
</listing>
</subsection>

<subsection>
<stitle>PAW Macro to produce 1D HBOOK histogram from HTL ASCII table</stitle>
<listing>
&HistoTableskumac2;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&HistoTablestxt;
</lprout>
</subsection>
</section>

<section>
<stitle>Histogram naming</stitle>
<par>
The following example demonstrates the usage of histogram naming.
Histograms are first created and filled using a histogram factory and then located
by name and printed.
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&NameHistosin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&NameHistosout;
</lprout>
</subsection>
</section>

<section>
<stitle>Basic histogram operations</stitle>
<par>
The following example shows a number of basic histogram operations,
such as subtraction, multiplication etc.</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&Operationsin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&Operationsout;
</lprout>
</subsection>
</section>

<section>
<stitle>Read histograms</stitle>
<par>
The following example shows the creation of 3 persistent histograms
and the location of a particle histogram using a database scan.
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&ReadHistoin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&ReadHistoout;
</lprout>
</subsection>
</section>

<section>
<stitle>Create transient histograms</stitle>
<par>
The following example shows the use of transient histograms. 
</par>
<subsection>
<stitle>Input program</stitle>
<listing>
&THistosin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
&THistosout;
</lprout>
</subsection>
</section>

<section>
<stitle>Create sliced projections</stitle>
<subsection>
<stitle>Input program</stitle>

<listing>
&TSliceProjin;
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>

<lprout>
&TSliceProjout;
</lprout>
</subsection>
</section>
</chapter>
</appendix>
</bodymatter>
</document>
@


1.8
log
@more mods by Jamie
@
text
@d3 1
a3 1
<!-- 	$Id: htl.xml,v 1.7 1999/04/22 07:36:38 goossens Exp goossens $	 -->
d1564 1
a1564 1
<term>Windows/NT</term><item>VC++ 5.0 SP3</item>
d1865 1
a1865 1
When you are running in an environment created by the LHC++ setup
d1886 1
a1886 1
If they are not defined the following settings are likely to
d1892 1
a1892 4
setenv LHCXXTOP /afs/cern.ch/sw/lhcxx
setenv PLATF @@sys
setenv HEP_ODBMS_DIR $LHCXXTOP/specific/$PLATF/HepODBMS/pro
setenv HISTOODIR $LHCXXTOP/specific/$PLATF/HTL/pro
d1898 9
d1909 3
d1913 1
a1913 3
LHCXXTOP=/afs/cern.ch/sw/lhcxx
export LHCXXTOP
...
a1915 1
<par>
d1958 2
@


1.7
log
@Dino's changes
@
text
@d3 1
a3 1
<!-- 	$Id: htl.xml,v 1.4 1999/04/15 11:31:51 goossens Exp goossens $	 -->
d128 2
a129 2
years. This manual is written assuming a basic familiarity with the
&HBOOK; package (see Table <ref refid="tab-hbook"/>).
a205 1

d219 5
d232 6
a237 6
This chapter provides an overview of &HTL; features.  Example code
is based on the use of the non-templated classes that should be used in
typical analysis jobs.
The &HTL; package itself includes a complete set of working examples that 
can be used as a basis for building more complex applications. 
A description of these examples can be found in chapter <ref refid="H1Examples"/>.
d254 3
a256 2
As will be familiar to all &HBOOK; users, the following information is specified
at booking time:</par>
d259 2
a260 2
<item>A character string or <emph>title</emph>, normally printed when the histogram
is displayed.</item>
d266 4
a269 2
<par>For histograms of more than one dimension, the last three arguments are then repeated
for each dimension.</par>
d271 4
a274 2
<par>The following example shows the booking and filling of a 1D histogram of 20 bins
and a 2D histogram of 50 bins in both X and Y axes.</par>
d309 1
a309 1
such operations has been omitted in the interests of clarify.</par>
d314 1
a314 1
IDs and is worthy of note. Consider the following code fragment:
d345 1
a345 1
network in database pages.  Effective clustering minimises unecessary
d393 1
a393 1
histogram to avoid memory leakages.</par>
d495 1
a495 1
 T_Histo1D *histo1 = new Histo1D("A 1D transient histogram",20,0.,40.);
d810 1
a810 1
Both the class names and type of vector used depends on whether transient or persisten
d892 1
a892 1
interface.  The first argument, if any, specifies where the histo
d894 1
a894 1
clustering hint is the container that contains the source histo in the
d896 1
a896 1
any, specifies how the histo should be cloned:
d900 2
a901 2
<item>if it equals 0 then only the structure is cloned;</item>
<item>otherwise the data is also copied (default).</item>
d904 1
a904 1
<par>Example of cloning in the persistent and transient case follow.</par>
d918 1
a918 1
T_Histo1D *h1D = new Histo1D( "Histo1: parabolic function", 20,0.,20.); 
d920 1
a920 1
T_Histo1D *clone_1D = h1D->clone();   // Clone 'h1D' structure and data
d967 3
a969 7
<par>
<code>Ref_Like_Current</code> designates a reference to the real type of
the current histogram class with all its template arguments.</par>
<par>
Notice that operations with another histogram exists with two
signatures, the first one (Ref_Like_Current) allowing to directly assign the 
result of an operation.</par>
d1012 4
a1015 1
The techniques described in this section only apply to persistent &HTL; histograms.
d1022 2
a1023 2
The Object Database Management Group (&ODMG;) standard specifies that
persistent objects are created using a <code>new()</code> operator
d1084 1
a1084 1
HepRef(PProfileHisto) ProfileHisto (const char *a_title, Size n,
d1087 1
a1087 1
HepRef(PProfileHistoVar) ProfileHistoVar(const char *,
d1353 1
a1353 3
<item>Rightmost point of bin indexed by <sq><code>i</code></sq>.</item>
<term><code>virtual void map_point( double a_point, Index &amp;an_index, Extra_Index &amp;an_extra_index )</code></term>
<item>Bin mapped to point <sq><code>a_point</code></sq>.</item>
a1544 177

<!--10-->
<chapter id="H1Examples">
<stitle>Examples</stitle>

<section>
<stitle>List of available examples</stitle>

<par>
A set of HTL examples can be found in the directory 
<url name="file:/afs/cern.ch/sw/lhcxx/share/HTL/dev/HTL/examples"/>.
</par>

<description>
<term><code>Histo1D</code></term>
<item>create persistent 1D histogram with fixed binning;</item>
<term><code>Histo2D</code></term>
<item>create persistent 2D histogram with fixed binning;</item>
<term><code>HistoProfile</code></term>
<item>create persistent 1D profile histogram with fixed binning;</item>
<term><code>HistoTables</code></term>
<item>produce ASCII tables to export HTL histograms to, e.g., PAW;</item>
<term><code>Operations</code></term>
<item>histogram cloning and histogram operations;</item>
<term><code>THistos</code></term>
<item>create transient 1D/2D histograms with fixed binning;</item>
<term><code>Histo1DVar</code></term>
<item>create persistent 1D histogram with variable binning;</item>
<term><code>Histo2DVar</code></term>
<item>create persistent 2D histogram with variable binning;</item>
<term><code>HistoRandom</code></term>
<item>use of CLHEP random generators;</item>
<term><code>NameHistos</code></term>
<item>naming persistent histograms;</item>
<term><code>ReadHisto</code></term>
<item>reading back histograms from Objectivity/DB datastore;</item>
<term><code>TSliceProj</code></term>
<item>slice/projections of a 2D histogram.</item>
</description>
</section>

<section>
<stitle>Setting up for using the examples</stitle>

<subsection>
<stitle>Defining your environment</stitle>

<par>
When you are running in an environment created by the LHC++ setup
procedure (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/lhcppguide/SetUpUserEnvironment.html"/>) 
all environment variables needed by HTL will be already in place.
</par>

<par>
If you are not running in such an environment, you will have to set 
the HTL environment variables up yourself, since the GNUmakefiles for
running the examples assume that the following environment
variables are defined correctly:
</par>

<itemize>
<item><code>LHCXXTOP</code></item>
<item><code>PLATF</code></item>
<item><code>HEP_ODBMS_DIR</code></item>
<item><code>HISTOODIR</code></item>
</itemize>

<par>
If they are not defined the following settings are likely to
work at CERN:
</par>

<verbatim>
setenv LHCXXTOP /afs/cern.ch/sw/lhcxx
setenv PLATF @@sys
setenv HEP_ODBMS_DIR $LHCXXTOP/specific/$PLATF/HepODBMS/dev51
setenv HISTOODIR $LHCXXTOP/specific/$PLATF/HTL/dev
</verbatim>

<par>
The above syntax is for C-shell flavours, while on Bourne shell
flavours you should use:
</par>

<verbatim>
LHCXXTOP=/afs/cern.ch/sw/lhcxx
export LHCXXTOP
...
</verbatim>

<par>
If you are using persistent HTL your &OBJ; environment should be
properly defined as well.
</par>
</subsection>

<subsection>
<stitle>Building the examples</stitle>

<par>
Make a local copy of the examples directory and run
<code>gmake</code>, as follows:
</par>

<alltt>
<ucom>cp -r /afs/cern.ch/sw/lhcxx/HTL/dev/HTL/examples .</ucom>
<ucom>cd examples</ucom>
<ucom>gmake</ucom>
</alltt>

<par>
These commands will build all examples in one go. You can build
examples separately by running <code>gmake</code> in each
subdirectory.
</par>

</subsection>

<subsection>
<stitle>Running the examples</stitle>

<par>
HTL is provided as shared libraries on most platforms. This means HTL
libraries and any other shared library used by HTL, such as HepODBMS
and &OBJ; for persistent HTL, should be visible in your shared library
path.
</par>

<par>
Let us emphasise one more that if you are running in an environment
created by the LHC++ setup procedure then there is nothing to do,
otherwise you must modify your shared library path to make sure that
such libraries are visible.
</par>

<par>
The examples executables are created in a <code>$(OS)</code>
subdirectory in each example directory.
</par>
</subsection>
</section>

<section>
<stitle>Structure of each example</stitle>

<par>
Each example directory contains two files: a GNUmakefile
to build the example and a source file containing the C++ code.
The source file typically defines an <sq>Application</sq> class
and a main program which instantiates that class and calls one or more
methods.
</par>

<verbatim>
class Histo_App :
...
int main( int argc, char **argv )
{
 Histo_App app;
 app.init();
 app.run();
 app.commit();
}
</verbatim>

<par>
The <sq>Application</sq> class may inherit from
<code>HepODBMS::HepDBApplication</code> when working with the
persistent HTL examples. This allows the class to manage transactions
and so on. Apart from transaction issues, most examples based on
persistent HTL can be translated to transient HTL by changing all
occurrences of <code>PHisto</code> to <code>Histo</code> and all occurences of
<code>HepRef</code> to normal C++ pointers.
</par>
</section>
</chapter>
d1680 1
a1680 1
defined areas of code.
d1686 1
a1686 1
efficient approach is to estimate what the critical part of the code is,
d1696 1
a1696 1
The procedure described above was that use in the case of &HTL;. In other words,
d1699 1
a1699 1
methods, which can be called millions of times. A
d1703 1
a1703 1
the performance was measured and tuned it using a simple code profiler.
d1710 1
a1710 1
can be provided if required.
d1722 6
a1727 4
each.  The benchmark is focused on filling performance. The I/O part
is neglected since histograms are pretty small objects. It would be
anyway difficult to assess the I/O overhead, since &OBJ; transactions
ensure that buffers are synced on disk, while &HBOOK; I/O does not.
d1732 1
a1732 1
and thus use more CPU.
d1821 173
@


1.6
log
@mods by Jamie
@
text
@d132 1
a132 1
<table id="tab-hbook">
d135 1
a135 1
<tabular preamble="ll" loc="h">
d958 7
a964 3
<par>Notice that operations with another histogram exists with two
signatures, the first one allowing to directly assign the result of
an operation.</par>
d1076 1
a1076 1
HepRef(PProfileHisto) ProfileHisto1D (const char *a_title, Size n,
d1079 1
a1079 1
HepRef(PProfileHistoVar) ProfileHisto1DVar(const char *,
d1346 2
d1711 2
a1712 1
occurrences of <code>PHisto</code> to <code>Histo</code>
d1842 1
a1842 1
performance, but rather was designed for speed but
d1901 1
a1901 1
and thus use CPU.
@


1.5
log
@Before more mods by Jamie
@
text
@d16 2
d19 1
d25 1
a25 1
<!ENTITY % likepara.new "|texonly|small">
d28 1
d133 1
a133 1
<caption>blaba</caption>
d135 7
a141 5
<tabular preamble="ll">
<row><cell>HBOOK name</cell><cell>&HTL; equivalent</cell></row>
<row><cell>HBOOK1    </cell><cell>Histo1D         </cell></row>
<row><cell>HBOOK name</cell><cell>&HTL; equivalent</cell></row>
<row><cell>HBOOK name</cell><cell>&HTL; equivalent</cell></row>
d154 1
a154 1
<item>computation of statistics like the mean or rms;</item>
a263 2
<par>Shouldn't the methods be listed somewhere (here?) as in e.g. HBOOK????</par>

d287 9
a295 1
As the current implementation uses &OBJ; to provide persistence, it
d297 1
a297 1
of using an ODBMS. For example, any operations on persistent objects
d354 1
a354 1
required is identical to the persistent cases. The differences between the two
d428 1
a428 1
shown in the followng code fragment.</par>
d512 3
a514 3
All classes store bin values/errors as doubles, except
<code>PHisto2DF</code>, which stores them as floats (this class minimizes the
memory size when using very large 2D histograms).
d533 1
a533 1
<description>
d550 1
a550 1
</description>
d566 1
a566 1
<description>
d573 1
a573 1
</description>
d615 1
a615 1
the interface, regardless of whether it is transient, persistent, 1D, 2D or so
d620 3
a622 3
In particular when working with transient &HTL;, it can be convenient to dump
a histogram in a simple ASCII table that can then be read by more or less
any tool (PAW, Excel, IRIS Explorer...) to plot or fit it.
d648 1
a648 1
problem space is divided into intervals. If we're going to book a 50
d652 1
a652 1
sub-intervals of equal width.  This is what we call a <sq>Fixed</sq>
d657 6
a662 5
I we book an histogram over the same range but we want to have for
instance 10 bins of variable widths, a partition containing the number
of bins, the lowest limit of each sub-interval and the highest limit
of the last sub-interval will describe completely how we divided the
<inlinemath>[0,50]</inlinemath> interval. This is what we call a
d670 2
a671 2
interval to a positive integer. A partition hence knows about the
width of the intervals, their lower point/bound or upper point/bound.
d675 6
a680 2
It is important to note that an &HTL; histogram delegates to
its partitions the task of locating a bin, for example:
d686 3
a688 3
histo->partition().lower_point() 
histo->partition().bin_width(i) 
histo->partition().upper_point(i) 
d695 1
a695 1
Bins mainly contain information about the content, the error and
d697 1
a697 1
through interface methods. &HTL; provides the following bins:
d700 1
a700 1
<description>
d717 1
a717 1
<inlinemath>[0,[20</inlinemath> with a 20 bin histogram over the same
d725 1
a725 1
</description>
d728 6
a733 5
Note that bins only know about their contents. They couldn't
care less about where they are located in the histogram or about
their widths or bounds. They are just containees that happen to be
in a histogram container. Their layout within the histogram is
defined by the partition objects.
d748 1
a748 1
partition(s) are specified as a vector of real numbers.
d801 2
a802 2
Apart from the class names you will notice that the type of the vector
depends on the transient/persistent choice as well.
d813 3
a815 1
<code>' '</code> and <code>'S'</code> options are supported.  However,
d862 5
a866 3
When performing an operation on a histogram, a package can
either create a new histogram or apply the operation directly on
the original one.
d870 4
a873 8
The first approach is used, for instance, by &HBOOK;. It preserves the
original histogram and creates a new entity on behalf of the user. HTL
takes the second approach: creating new objects on behalf of users is
a risky policy in C+ + (although quite common), since it could lead to
unnoticed memory leakages and it's even more difficult to manage when
an ODBMS is used to provide persistency. Thus histogram operations
always apply to an existing histogram object and it's up to the user
to make a copy of the original histogram first.
d1000 5
a1004 1
<stitle>Using histogram factories and naming trees (persistent HTL only)</stitle>
d1010 8
a1017 6
According to ODMG rules persistent objects are created using a
<code>new()</code> operator with a clustering hint that specifies in which
database/container the object should be physically stored, for instance,
in the following example <code>histo1</code>
will be created in the database specified by the 
database handle <code>db_</code>.
d1026 6
a1031 3
This syntax may look a bit unusual to novice users and is
difficult to understand by other preprocessors such as the SWIG
interface generator for scripting languages.
d1036 9
a1044 4
user specify by name the database/container histogram in which it will
be generated and then use a factory method to actually create the
histograms. The following bit of code shows an example of Histogram Factory
usage.
d1090 4
a1093 2
The HepODBMS package provides a logical naming structure on top of
Objectivity's physical structure. The HepODBMS naming package creates
d1102 4
a1105 2
structure. In practice each user is given a home directory named after
his user name under the common directory <code>/usr</code>.
d1109 5
a1113 3
A typical application of HepODBMS would be to name HTL histograms with
a symbolic <code>ID</code> and store them in separate directories
(much like the current &HBOOK; tree structure).
d1117 2
a1118 2
Although users can rely on the HepODBMS classes to name HTL
histograms, we provided a simple <code>Factory</code> class which
d1120 3
a1122 3
capabilities. Using this extended factory class, users can choose
where to store histograms and name them according to their favourite
scheme.
d1126 5
a1130 2
The following bit of code shows how to name HTL histograms
in a naming tree.
d1149 1
a1149 1
Histograms can then be retrieved as follows.
d1158 2
a1159 2
Notice that the naming tree is case sensitive (like &UNIX; and unlike
&HBOOK;!). Histograms can be named with a character string such as
d1167 1
a1167 1
new one depending on the strategy specified when the factory was
d1172 1
a1172 1
If you want the factory to override existing histograms, you should write:
d1179 2
a1180 2
whereas, when factory has to keep existing histograms, the new histogram is
not allocated, and you write something like the following:
d1188 2
a1189 2
The Override directive is useful, for instance when running in batch
or when debugging your program: old histograms are replaced by new
d1191 2
a1192 2
destroying useful data. No more sophisticated strategies, such as
cycles or versions, are implemented at present.
d1202 3
a1204 2
data store users will want to retrieve them. The <code>HLocator</code>
class allows you to retrieve an histogram by name, as follows:
d1378 2
a1379 2
This example is taken from the HEPInventor visualisation package
(although it's actually a subset of working code). The method receives
d1827 4
a1830 4
important: if your batch job takes 4 hours of CPU you should not
really care if histogram filling takes 10 seconds or 100 seconds.
On the other hand there are applications where users really expect a
good performance (such as online monitoring).
d1841 3
a1843 3
Experience shows exists always a tradeoff between higher performance
and maximum flexibility, but most of the time a reasonable compromise
can be found, since performance is usually required only in well
d1849 2
a1850 2
spends 80&percent; of its time in 20&percent; of the code. Hence the
right approach is to estimate what the critical part of the code is,
d1853 4
a1856 2
tool, such as a code profiler. To write ugly and unmaintainable code
just because it is thought to be faster is not an effective approach.
d1860 5
a1864 4
That procedure was followed for HTL. We first identified the critical
code, and obviously it turned out to correspond to the filling
methods, which can be called millions of times. We then identified a
technique to speed up filling by using templated classes (see for
d1866 2
a1867 2
C++ performance). Finally, once the package was working, we measured
the performance and tuned it using a simple code profiler.
d1871 4
a1874 5
Below we present the results of a comparison with &HBOOK;, which is
not intended as a complete test but rather is used as a benchmark
reference. Anyone interested in measuring the performance of HTL down
to the millisecond level can be provided with the source code used for
the benchmark tests.
d1955 2
a1956 1
&HTL; persistent histograms are slower. It would be possible, using
d1985 8
a1995 4
<par>
This is a description of the first example.
</par>

d2012 4
d2033 4
d2054 4
d2075 2
d2094 2
d2113 5
d2149 5
d2171 3
d2191 4
d2212 3
@


1.4
log
@insert RCS version info
@
text
@d3 1
a3 1
<!-- 	$Id$	 -->
d8 1
d16 1
d25 1
a25 1
<!ENTITY % preformat.new "|alltt|listing">
d27 2
a28 1
<!ELEMENT listing (#PCDATA|emph)*>
d36 3
d40 27
d74 8
a81 7

This manual has been marked up using <emph>&XML;</emph> - the eXtensible Markup Language.
(Is anything else relevent? Perhaps:

Pending the wide-spread availability of XML-capable browsers and WYSIWYG editors, HTML and PostScript 
versions of this document have been produced using ...

d92 2
a93 1
Olivier Couet and Michel Goossens for their general support.</thanks>
d114 2
a115 2
"Ntuple" data. Furthermore, although simple file-based I/O and
"lineprinter" output are supported, it is decoupled from more advanced
d118 1
a118 1
with &HTL;. However, it is intended that &HTL;.
d125 17
a141 1
&HBOOK; package. &HTL; itself offers the histogramming features of
d143 1
a143 1
object-oriented (O-O) approach. These features:
d153 6
a158 5
<par>This package replaces the histOOgrams package - an earlier C++ class library for
histograms. The major functional innovation over the previous package are
the support for different kinds of bins, the support of both
persistent and transient (i.e. in-memory) histograms at runtime and
the definition of an abstract histogram interface.
d172 1
a172 1
including PAW or Excel.
d177 1
a177 1
that is provided by external packages, such as plotting or fitting, from the actual
d207 1
a207 1
<item>increased performance.</item>
d212 1
a212 1
<item>a more O-O approach, which in turn results in better encapsulation and more decoupling;</item>
d222 1
a222 1
This chapter provides and overview of HTL features.  Example code
d225 2
a226 2
The &HTL;  package itself includes a complete set of working examples that 
can be used as a basis for building more complex examples. 
d234 7
a240 6
The basic operations of creating (booking) and filling histograms are shown below.
As the code fragments illustrate, these operations are performed using methods
that have the same basic signature as the equivalent &HBOOK; subroutines. The primary difference
is that the &HBOOK; histogram identifier (ID) is replaced by "smart pointers". 
These pointers indicate both the type of the histogram to which they refer (e.g. 1D, 2D)
and whether they are transient or not.
d243 15
d260 3
d264 1
a264 2
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
#include "HTL/P_Histograms_2D.h" // Persistent histograms.
d267 2
a268 2
 H_P_REF(P_Histo1D) histo1 = 
  new (db_) P_Histo1D("A 1D histogram",20,0.,40.);
d270 2
a271 2
 H_P_REF(P_Histo2D) histo2 = 
  new (db_) P_Histo2D("A 2D histogram",50,5.,15.,50,5.,15.);
d283 11
a293 4
Persistent histograms are based on &OBJ;, thus I will
assume the reader knows the basics of using an ODBMS (such as the
fact this code must be executed inside a transaction).The first
point worth a note is the use of so-called 'smart-pointers':
d297 1
a297 1
H_P_REF(P_HISTO1D) histo1 = new ...
d301 1
a301 1
P_HISTO1D *histo1 = new ...
d305 4
a308 3
<code>H_P_REF</code> is a smart pointer to a persistent histogram: as
you can see in the filling code, the smart pointer can be used as a
standard C++ pointer, e.g. you can dereference it:
d316 18
a333 6
If you're familiar with &OBJ; you will recognise the use of a
<code>new()</code> operator which takes an Objectivity clustering
hint.  Finally notice that the histogram created with
<code>new()</code> is not deleted: unlike standard C++ object the
histogram exists in the database and not deleting it will
not cause a memory leakage.
d340 5
d346 1
a346 2
#include "HTL/T_Histograms_1D.h" // Transient histograms.
#include "HTL/T_Histograms_2D.h" // Transient histograms.
d349 1
a349 2
 H_T_REF(T_Histo1D) histo1 = 
  new T_Histo1D("A 1D histogram",20,0.,40.);
d351 1
a351 2
 H_T_REF(T_Histo2D) histo2 = 
  new T_Histo2D("A 2D histogram",50,5.,15.,50,5.,15.);
d360 2
a361 2
delete (T_Histo1D *)histo1;
delete (T_Histo2D *)histo2;
d365 3
a367 2
Transient histograms are in-memory C++ objects. The first point
worth a note is that we still use so-called 'smart-pointers':
d370 3
a372 3
<verbatim>
H_T_REF(T_HISTO1D) histo1 = new ...
</verbatim>
d374 4
a377 14
<par>rather than</par>

<verbatim>
T_HISTO1D *histo1 = new ...
</verbatim>

<par>
<code>H_T_REF</code> is a smart pointer to a transient histogram: we
prefer to use it to enforce the symmetry with its persistent
counterpart. The <code>new()</code> operator is now the standard C++
one, thus you should not forget to delete the histogram to avoid
memory leakages. As you can see the differences between transient and
persistent HTL boils down to class names and smart pointer names
(<code>H_T</code> versus <code>H_P</code>).
d385 1
a385 1
As already mentioned, HTL makes it possible to use both
d390 2
a391 3
Since
operations on transient histos are faster than those on persistent
histos, one might find it convenient to proceed like this:
d394 3
a396 2
<item>perform all of the desired operations on transient histos and then</item>
<item>make these transient histos persistent.
d399 3
d403 1
a403 2
The last step can be performed in very natural and nice way. To
make a transient histogram <code>ph</code> persistent:
d406 1
a406 1
<item>declare a persistent histo
d411 1
a411 1
the constructor of <code>ph</code> and that's it.
d415 3
d419 2
a420 4
#include "HTL/T_Histograms_1D.h" // Transient histograms. 
#include "HTL/T_Histograms_2D.h" // Transient histograms. 
#include "HTL/P_Histograms_1D.h" // Persistent histograms. 
#include "HTL/P_Histograms_2D.h" // Persistent histograms. 
d423 1
a423 1
 H_T_REF( T_Histo1D ) th = ... 
d429 1
a429 1
H_P_REF( P_Histo1D ) ph = new (dbH ) P_Histo1D( *th ); 
d434 3
a436 2
Notice that it is possible to create a persistent histo out of
any histo interface, be the source histo transient or persistent.
d441 1
a441 1
<stitle>HTL histogram classes</stitle>
d444 2
a445 2
As mentioned before, HTL is based on template classes which
allow to support very different types of histogram using the
d450 4
a453 4
Since most end users want to produce physics result rather than
evaluate how nice the design is, we provided very simple &HBOOK;-like
classes which should cover most of the needs. This is a list of the
available classes:
d456 21
d480 2
a481 2
<description>
<term><code>P_Histo1D</code></term>
d483 1
a483 1
<term><code>P_Histo1DVar</code></term>
d486 1
a486 1
<term><code>P_ProfileHisto1D</code></term>
d488 1
a488 1
<term><code>P_ProfileHisto1DVar</code></term>
d491 1
a491 1
<term><code>P_Histo2D</code></term>
d493 1
a493 1
<term><code>P_Histo2DF</code></term>
d495 1
a495 1
<term><code>P_Histo2DVar</code></term>
d497 1
a497 1
</description>
d500 2
a501 2
All classes store bin values/errors as double, except
<code>P_Histo2DF</code>, which stores them as floats (this class minimizes the
d522 1
a522 1
<term><code>T_Histo1D</code></term>
d524 1
a524 1
<term><code>T_Histo1DVar</code></term>
d527 1
a527 1
<term><code>T_ProfileHisto1D</code></term>
d529 1
a529 1
<term><code>T_ProfileHisto1DVar</code></term>
d532 1
a532 1
<term><code>T_Histo2D</code></term>
d534 1
a534 1
<term><code>T_Histo2DF</code></term>
d536 1
a536 1
<term><code>T_Histo2DVar</code></term>
d560 1
a560 1
<item>Center of bin index by <sq><code>i</code></sq>.</item>
d571 1
a571 1
<stitle>Line-printing and ASCII table output</stitle>
d574 4
a577 3
Printing an histogram in text mode is a nice feature for, e.g.,
long batch jobs where the user is mainly interested in checking
that quality of data.
d581 5
a585 3
HTL provides a text print helper for this purpose (which is mostly
recycled from the previous package).
</par>
d588 1
a588 1
#include "HTL/H_Printout.h"  // Printing. 
d590 3
a592 4
H_T_REF(T_Histo1D) histot = 
  new T_Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
H_P_REF(P_Histo2D) histop = 
  new P_Histo1D("Persistent Histo_2D", 20, 0.0, 20.0 ); 
d594 1
a594 1
H_Printout hp( cout ); 
d597 1
a597 1
delete (T_Histo1D *) histot; 
d601 4
a604 4
This example shows one nice feature of the abstract histogram
interface: the same helper object can print any histogram obeying to
the interface, it doesn't matter if it's transient or persistent, 1D
or 2D.
d608 3
a610 3
In particular when working with transient HTL, it's convenient to dump
the histogram in a simple ASCII table which can then be read by your
favourite tool (PAW, Excel, IRIS Explorer...) to plot or fit it.
d614 1
a614 1
#include "HTL/H_HistoTable.h" 
d616 1
a616 1
H_T_REF(T_Histo1D) histo = new T_Histo1D("Histo_1D", 20, 0.0, 20.0 ); 
d620 1
a620 1
delete (T_Histo1D *)histo; 
d633 3
a635 2
The HistOOgram package introduced first the concept of
<sq>Partition</sq>. A partition describes how one dimension of the
d637 1
a637 1
bin histogram in the range <inlinemath>[0,50[</inlinemath>, a
d649 1
a649 1
<inlinemath>[0,50[</inlinemath> interval. This is what we call a
d654 1
a654 1
An n-dimensional HTL histogram thus contains n partitions, one for
d662 1
a662 1
The important point here is that an HTL histogram delegates to
d667 1
a667 2
H_T_REF(T_Histo1D) histo = 
  new T_Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
d680 1
a680 1
trough interface methods. HTL provides the following bins:
d737 16
a752 16
P_Points_Vector my_points_on_X(10); // Vector of 10 real numbers 
my_points[0] = 0.0; my_points[1] = 1.0; 
my_points[2] = 3.5; my_points[3] = 4.0; 
my_points[4] = 5.5; my_points[5] = 9.0; 
my_points[6] = 10.; my_points[7] = 15.; 
my_points[8] = 19.; my_points[9] = 20.; 

H_P_REF(P_Histo1DVar) histo = 
  new (db_)  P_Histo1DVar( "Histo1DVar", my_points_on_X ); 

P_Points_Vector my_points_on_Y(10); 
my_points_on_Y[0] = 0.0; my_points_on_Y[1] = 1.0; 
my_points_on_Y[2] = 2.5; my_points_on_Y[3] = 4.0; 
my_points_on_Y[4] = 6.0; my_points_on_Y[5] = 9.0; 
my_points_on_Y[6] = 12.; my_points_on_Y[7] = 14.; 
my_points_on_Y[8] = 18.; my_points_on_Y[9] = 20.; 
d754 2
a755 2
H_P_REF(P_Histo2DVar) histo = 
  new (db_) P_Histo2DVar( "Histo2DVar", my_points_on_X, my_points_on_Y ); 
d763 15
a777 16
T_Points_Vector my_points_on_X(10); // Vector of 10 real numbers 
my_points[0] = 0.0; my_points[1] = 1.0; 
my_points[2] = 3.5; my_points[3] = 4.0; 
my_points[4] = 5.5; my_points[5] = 9.0; 
my_points[6] = 10.; my_points[7] = 15.; 
my_points[8] = 19.; my_points[9] = 20.; 

H_T_REF(T_Histo1DVar) histo = 
  new (db_)  T_Histo1DVar( "Histo1DVar", my_points_on_X ); 

T_Points_Vector my_points_on_Y(10); 
my_points_on_Y[0] = 0.0; my_points_on_Y[1] = 1.0; 
my_points_on_Y[2] = 2.5; my_points_on_Y[3] = 4.0; 
my_points_on_Y[4] = 6.0; my_points_on_Y[5] = 9.0; 
my_points_on_Y[6] = 12.; my_points_on_Y[7] = 14.; 
my_points_on_Y[8] = 18.; my_points_on_Y[9] = 20.; 
d779 1
a779 2
H_T_REF(T_Histo2DVar) histo = 
  new (db_) T_Histo2DVar( "Histo2DVar", my_points_on_X, my_points_on_Y ); 
d802 1
a802 2
H_P_REF(P_ProfileHisto1D) histo = 
  new (db_) P_ProfileHisto1D("Profile",20,0.,1.); 
d882 2
a883 2
H_P_REF(P_Histo1D) h1D = 
  new(db_)  P_Histo1D( "Histo1: parabolic function", 20,0.,20.); 
d887 1
a887 1
H_P_REF(P_Histo1D) clone_1D = h1D->clone();   // Clone 'h1D' structure and data
d891 1
a891 2
H_T_REF(T_Histo1D) h1D = 
  new T_Histo1D( "Histo1: parabolic function", 20,0.,20.); 
d893 1
a893 1
H_T_REF(T_Histo1D) clone_1D = h1D->clone();   // Clone 'h1D' structure and data
d947 2
a948 2
H_P_REF(P_Histo1D) histo1 = 
  new(db_)  P_Histo1D( "Histo1: parabolic function", 20,0.,20.); 
d954 1
a954 1
  H_P_REF(P_Histo1D) histo2 = histo1->clone(); 
d958 7
d997 2
a998 2
H_P_REF(P_Histo1D) histo1 = 
  new (db_) P_Histo1D("A 1D histogram",20,0.,40.);
d1008 1
a1008 1
The <code>H_Factory</code> class overcomes this problem by letting the
d1018 1
a1018 1
  H_Factory myFactory; 
d1022 1
a1022 1
    H_P_REF(P_Histo1D) h1 = myFactory.Histo1D("Histo-1",noBins,0.0,20.0); 
d1028 1
a1028 1
The <code>H_Factory</code> class provides a method to generate all
d1036 1
a1036 1
H_P_REF(P_Histo1D) Histo1D (const char *a_title, Size n, double x1, 
d1038 1
a1038 1
H_P_REF(P_Histo1DVar) Histo1DVar(const char *,P_Points_Vector &amp;,
d1040 1
a1040 1
H_P_REF(P_ProfileHisto1D) ProfileHisto1D (const char *a_title, Size n,
d1043 1
a1043 1
H_P_REF(P_ProfileHisto1DVar) ProfileHisto1DVar(const char *,
d1045 1
a1045 1
H_P_REF(P_Histo2D) Histo2D (const char *, Size , double  , double ,
d1048 1
a1048 1
H_P_REF(P_Histo2DVar) Histo2DVar( const char *, P_Points_Vector &amp;,
d1060 1
a1060 1
and maintain a naming tree similar to file-system trees, with
d1081 1
a1081 1
extends the basic <code>H_Factory</code> with naming
d1093 1
a1093 1
#include "HTL/H_Naming_Factory.h" 
d1095 1
a1095 1
  H_Naming_Factory myFactory(H_Naming_Factory::Override); 
d1100 2
a1101 2
    H_P_REF(P_Histo1D) h1 = myFactory.Histo1D(10,"Histo-1",noBins,0.0,20.0); 
    H_P_REF(P_Histo1D) h2 = myFactory.Histo1D("pt","Histo-2",noBins,0.0,20.0); 
d1124 1
a1124 1
If the histogram you create already exists, <code>H_Naming_Factory</code>
d1135 1
a1135 1
 H_Naming_Factory myFactory(H_Naming_Factory::Override);
d1143 1
a1143 1
 H_Naming_Factory myFactory(H_Naming_Factory::Keep);
d1161 1
a1161 1
data store users will want to retrieve them. The <code>H_Locator</code>
d1166 1
a1166 1
#include "HTL/H_Locator.h" 
d1169 2
a1170 2
  H_Locator myLocator; 
  H_Printout hp(cout); 
d1172 1
a1172 1
  H_P_REF(P_Histo1D) h = myLocator.Histo1D("pt"); 
d1181 1
a1181 1
Notice that the <code>H_Locator</code> class provides methods to
d1404 1
a1404 1
T_Histo1D( const char *a_title, Size nBins, double lowX, double
d1417 1
a1417 1
T_Histo1D( Like_Current &amp;a_histo, int copy_data = 1 )
d1434 1
a1434 1
P_Histo1D( const I_Histo &amp;a_histo, int copy_data = 1 )
d1453 1
a1453 2
H_T_REF(T_Histo1D) h1D = 
  new T_Histo1D("Histo1: parabolic function",20,0.,20.);
d1464 1
a1464 1
<code>H_Statistics</code> and it allows us to decouple computation
d1470 1
a1470 1
#include "HTL/H_Statistics.h"  // Computing statistics. 
d1472 1
a1472 2
H_T_REF(T_Histo1D) h1D = 
  new T_Histo1D("Histo1: parabolic function",20,0.,20.); 
d1478 2
a1479 2
long in_entries = H_Statistics::in_range_entries_count(*histo); 
long extra_entries = H_Statistics::extra_entries_count(*histo); 
d1484 1
a1484 1
double mean = H_Statistics::mean( *histo ); 
d1486 1
a1486 1
cout &lt;&lt; "RMS  (B.C.): " &lt;&lt; H_Statistics::rms(*histo, mean) 
d1663 1
a1663 1
occurrences of <code>H_T</code> to <code>H_P</code>
d1792 4
a1795 6
The HistOOgram package, which HTL is supposed to replace, suffered of
a bad reputation in this respect. Part of this bad reputation was
actually justified, since HistOOgrams were not designed for speed but
for maximum flexibility. Moreover, the bad reputation was also due for
a large part to the fact that tests were performed using an unreleased
version.
d1886 1
a1886 1
The timing on the second line of the persistent HTL case is for a
d1891 1
a1891 1
It should also be stressed that the HTL package allows you to create a
d1905 1
a1905 1
HTL transient histograms are slightly faster than comparable &HBOOK;
d1907 1
a1907 1
about bin centres.
d1911 6
a1916 3
HTL persistent histograms are slower, but an Objectivity expert could
easily apply fast-filling methods and pinning in memory to make them
almost as fast as transient ones.
d1920 2
a1921 3
There are faster HTL histograms which can be used when raw performance
is crucial. The drawback in this case is that filling time statistics
are no longer available.
d1925 1
a1925 1
Since HTL allows you to mix persistent and transient histograms, the
a1933 3
</appendix>
  </bodymatter>
</document>
d1935 219
d2155 2
d2158 9
@


1.3
log
@first mods js
@
text
@d3 1
a3 1
<!-- $ Id: $ -->
@


1.2
log
@initial entry
@
text
@d1 1
a1 2
<!-- $ id: $ -->
<?xml version="1.0" ?> 
d3 1
d7 1
d10 3
d17 1
d40 9
d51 1
a51 2
advice and help of many individuals. In particular I would like to
acknowledge 
d53 4
a56 4
and Jacub Moscicki for the existing HistOOgrams package and the
templated prototype;
Dirk Duellman and
Marcin Nowak for all of the help about Objectivity;
d73 21
a93 4
<par>The Histogram Template Library (HTL) is yet another package
which provides the basic histogramming features of &HBOOK; with an
object-oriented (O-O) approach. These features include as
usual:</par>
d97 3
a99 4
<item>computing of statistics like the mean or rms;</item>
<item>support of operations between histograms;</item>
<item>browsing of, and access to, the histogram's
characteristics.</item>
d102 3
a104 2
<par>The major functional innovation over the existing package are
the support of different kinds of bins, the support of both
d106 1
a106 1
finally the definition of an abstract histogram interface.
d109 2
a110 2
<par>As a consequence it is now possible to first produce transient
histograms, then save some or all of them in the database as
d112 2
a113 1
simulating so called explicit I/O).
d117 4
a120 5
It is of course possible to work with transient histograms only: in
this case you can still keep track of their content by printing
them in the familiar line-printer output format or by saving the
content in a ASCII table which can then be read by e.g. PAW or
Excel.
d124 4
a127 4
The definition of an abstract histogram interface allows to decouple
external functionalities, such as plotting or fitting, from the actual
implementation of the histogram. This feature could allow, in the
future, co-existence of different histogram packages.
d134 3
a136 4
HTL is based on templates, but you don't need to know about
templates to use it. End users just see a small set of so called
'user-classes' which have a very familiar (i.e. &HBOOK;-like)
look-and-feel.
d140 2
a141 2
Of course, you still need a compiler with decent template support
(see Appendix A for more information).
d145 3
a147 1
<stitle>Why yet another histogram package?</stitle>
d149 4
a152 5
<par>The existing HistOOgram package works, so why do we need a new
package anyway? It turns out that, with a better use of O-O and the
support of templates, both performance and design can be improved
along with flexibility and maintainability. HTL offers manifold
advantages over the existing HistOOgrams package:
d155 2
a156 2
<item>a more O-O approach, better encapsulation, more decoupling;
</item>
d160 1
a160 2
<item>more flexibility and maintainability;</item>
<item>better performance.</item>
d170 6
a175 4
This chapter gives a sketch of HTL features.  Example code
concentrates on the non-templated classes which should be used by most
physicists. The package includes a set of working examples which you
can start from and they will be described in chapter <ref refid="H1Examples"/>.
d181 11
d1824 1
a1824 1
</bodymatter>
@


1.1
log
@Initial revision
@
text
@d1 1
@
