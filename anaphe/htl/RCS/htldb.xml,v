head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2000.04.19.15.13.08;	author goossens;	state Exp;
branches;
next	;


desc
@initial checkin
@


1.1
log
@Initial revision
@
text
@<?xml version="1.0" encoding='ISO-8859-1'?> 
<!-- 	$Id: htl.xml,v 1.9 1999/05/05 10:44:57 goossens Exp goossens $	 -->
<!DOCTYPE book PUBLIC "-//Norman Walsh//DTD DocBk XML V3.1.4//EN"
          "/usr/local/share/docbookxml/3.17/docbookx.dtd" [
<!ENTITY percent "!PERCENT!">
<!ENTITY Excel "Excel">
<!ENTITY GNU  "GNU">
<!ENTITY HBOOK "HBOOK">
<!ENTITY HEP  "HEP">
<!ENTITY HTL  "HTL">
<!ENTITY LHCPP  "LHC++">
<!ENTITY nbsp " ">
<!ENTITY NICE "Nice">
<!ENTITY OBJ  "Objectivity/DB">
<!ENTITY ODBMS "ODBMS">
<!ENTITY ODMG "ODMG">
<!ENTITY PAW  "PAW">
<!ENTITY SWIG "SWIG">
<!ENTITY uuml "ü">
<!ENTITY UNIX "Unix">
<!ENTITY WNT  "Windows/NT">
<!ENTITY XML  "XML">
<!ENTITY % local.programlisting.attrib '
    font        CDATA           #IMPLIED '>
<!ENTITY % bodyatt              '
    loc         CDATA           #IMPLIED
    preamble    CDATA           #IMPLIED '>
<!-- External entity files -->
<!ENTITY Histo1Din         SYSTEM "/home/htl/HTLDOC/createHisto1D.in">
<!ENTITY Histo1Dout        SYSTEM "/home/htl/HTLDOC/createHisto1D.out">
<!ENTITY Histo1DVarin      SYSTEM "/home/htl/HTLDOC/createHisto1DVar.in">
<!ENTITY Histo1DVarout     SYSTEM "/home/htl/HTLDOC/createHisto1DVar.out">
<!ENTITY Histo2Din         SYSTEM "/home/htl/HTLDOC/createHisto2D.in">   
<!ENTITY Histo2Dout        SYSTEM "/home/htl/HTLDOC/createHisto2D.out">
<!ENTITY Histo2DVarin      SYSTEM "/home/htl/HTLDOC/createHisto2DVar.in">   
<!ENTITY Histo2DVarout     SYSTEM "/home/htl/HTLDOC/createHisto2DVar.out">
<!ENTITY HistoProfilein    SYSTEM "/home/htl/HTLDOC/createprofile.in">
<!ENTITY HistoProfileout   SYSTEM "/home/htl/HTLDOC/createprofile.out">
<!ENTITY HistoTablesin     SYSTEM "/home/htl/HTLDOC/histotables.in">
<!ENTITY HistoTablestxt    SYSTEM "/home/htl/HTLDOC/histo.txt">
<!ENTITY HistoTableskumac1 SYSTEM "/home/htl/HTLDOC/histotable.kumac">
<!ENTITY HistoTableskumac2 SYSTEM "/home/htl/HTLDOC/htl2hb.kumac">
<!ENTITY HistoRandomin     SYSTEM "/home/htl/HTLDOC/historandom.in">
<!ENTITY HistoRandomout    SYSTEM "/home/htl/HTLDOC/historandom.out">
<!ENTITY NameHistosin      SYSTEM "/home/htl/HTLDOC/namehistos.in">
<!ENTITY NameHistosout     SYSTEM "/home/htl/HTLDOC/namehistos.out">
<!ENTITY Operationsin      SYSTEM "/home/htl/HTLDOC/basicoperations.in">
<!ENTITY Operationsout     SYSTEM "/home/htl/HTLDOC/basicoperations.out">
<!ENTITY ReadHistoin       SYSTEM "/home/htl/HTLDOC/readhisto.in">
<!ENTITY ReadHistoout      SYSTEM "/home/htl/HTLDOC/readhisto.out">
<!ENTITY THistosin         SYSTEM "/home/htl/HTLDOC/createtransient.in">
<!ENTITY THistosout        SYSTEM "/home/htl/HTLDOC/createtransient.out">
<!ENTITY TSliceProjin      SYSTEM "/home/htl/HTLDOC/sliceproj.in">
<!ENTITY TSliceProjout     SYSTEM "/home/htl/HTLDOC/sliceproj.out">
]>
<book>
<bookinfo>
<title>HTL User Manual</title>
<authorgroup>
<author>
<firstname>Dino</firstname>
<surname>Ferrero Merlino</surname>
<affiliation>
<orgname>CERN IT/API</orgname>
</affiliation>
</author>
<author>
<firstname>Savrak</firstname>
<surname>Sar</surname>
</author>
</authorgroup>
<pubdate>May 2000</pubdate>

<!--
This manual has been marked up using <emphasis>&XML;</emphasis> - the
eXtensible Markup Language.  (Is anything else relevent? Perhaps:

Pending the wide-spread availability of XML-capable browsers and
WYSIWYG editors, HTML and PostScript versions of this document have
been produced using ...
-->
<contrib>
HTL has benefited from the suggestions,
advice and help of many individuals. In particular,
Yemi Adesanya
and Jacub Moscicki are acknowledged for the development of the
existing HistOOgrams package and the templated prototype;
Dirk D&uuml;llman and
Marcin Nowak for help concerning &OBJ;;
Vincenzo Innocente for his version of templated histograms;
Olivier Couet and Michel Goossens for their general support.
</contrib>
</bookinfo>
<!--<part>
<title>Getting started</title>
-->
<!--1-->
<chapter id="H1Overview">
<title>Overview</title>

<sect1>
<title>What is HTL?</title>
<indexterm><primary>CERNLIB</primary></indexterm>

<para>
The Histogram Template Library (&HTL;) is a C++ class library that
provides powerful histogramming functionality. As the name suggests,
it exploits the <emphasis>template</emphasis> facility of C++ and is designed
to be compact, extensible, modular and performant. As such it only
deals with histograms - i.e. binned data - and not unbinned or
<quote>Ntuple</quote> data. Furthermore, although simple file-based
I/O and <quote>lineprinter</quote> output are supported, it is
decoupled from more advanced I/O and visualisation techniques. In the
context of &LHCPP;, such capabilities are provided by other components
that fully interoperate with &HTL;.
</para>

<para>
In the High Energy Physics (&HEP;) community, the &HBOOK; package has
been the <emphasis>de-facto</emphasis> standard for histogramming for many
years. This manual is written assuming a basic familiarity with 
&HBOOK; (see Table <xref linkend="tab-hbook"/>).
</para>

<para>
<table id="tab-hbook" loc="h" preamble="ll">
<title>&HBOOK; routines and their HTL equivalent</title>
<tgroup cols="2">
<tbody>
<row><entry><emphasis>HBOOK name</emphasis></entry>
     <entry><emphasis>&HTL; equivalent</emphasis></entry>
</row>
<row><entry>HBOOK1</entry>
     <entry><classname>Histo1D</classname>     </entry>
</row>
<row><entry>HBOOK2</entry>
     <entry><classname>Histo2D</classname>     </entry>
</row>
<row><entry>HFILL </entry>
     <entry><classname>fill</classname> method </entry>
</row>
<row><entry>HPRINT</entry>
     <entry><classname>print</classname> method</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
&HTL; itself offers the histogramming features of
&HBOOK; as well as a number of useful extensions, with an
object-oriented (O-O) approach. These features include the following:
</para>

<itemizedlist>
<listitem><simpara>booking and filling of 1D, 2D and profile histograms;</simpara></listitem>
<listitem><simpara>computation of statistics such as the mean or rms of a histogram;</simpara></listitem>
<listitem><simpara>support for operations between histograms;</simpara></listitem>
<listitem><simpara>browsing of and access to characteristics of individual histograms.</simpara></listitem>
</itemizedlist>

<para>
This package replaces the histOOgrams package - an earlier C++
class library for histograms. The major functional innovation over the
previous package are the support for different kinds of bins, the
support of both persistent and transient (i.e. in-memory) histograms
at runtime and the definition of an abstract histogram interface.
</para>

<para>As a result, it is now possible to work with transient
histograms and subsequently save some or all of them in a database as
persistent histograms in a very simple and natural way (thus
simulating so called explicit I/O). This clearly has significant performance advantages,
particularly in the area of filling operations.
</para>

<para>
It is also possible to work with transient histograms only. These
may be printed or stored in files - the latter using a simple ASCII table
format that can be readily used by widely available tools,
including &PAW; or &Excel;.
</para>

<para>
The definition of an abstract histogram interface allows functionality
that is provided by external packages, such as plotting or fitting, to be decoupled from the actual
implementation of the histogram. This feature paves the way for co-existence of different histogram packages
that conform to the abstract interface.
</para>
</sect1>
	<sect1>
	  <title>Use of templates</title>

<para>
Although &HTL; uses templates internally, a small set of 
`user-classes' are provided. These have a very familiar (i.e. &HBOOK;-like)
look-and-feel and eliminate the need for users to be exposed to templates.
</para>

<para>
Nevertheless, the package still requires adequate template support at the C++ compiler level.
More details are given in Appendix A.
</para>
</sect1>
<sect1>
<title>Motivation</title>

<para>
When the existing HistOOgram package was implemented, compilers that provided
adequate support for templates were not widely available. Templates and other modern
C++ features can offer significant advantages.
In the case of &HTL;, these can be summarised as:
</para>
<itemizedlist>
<listitem><simpara>increased performance;</simpara></listitem>
<listitem><simpara>greater flexibility and maintainability;</simpara></listitem>
<listitem><simpara>the support of both persistent and transient histograms at runtime.
Both provide similar features and are generated from the same
source files;</simpara></listitem>
<listitem><simpara>a more O-O approach, which in turn results in better encapsulation and more decoupling.</simpara></listitem>
</itemizedlist>
<para>
These issues, especially the maintainability and high degree of decoupling, are of
particular importance to very long-term projects, such as those at the LHC, where
change and migration must be assumed and planned for.
</para>
</sect1>
</chapter>

<!--2-->
<chapter id="H1HTLglance">
<title>HTL at a glance</title>

<para>
This chapter provides an overview of &HTL; features.  Example code is
based on the use of the non-templated classes that are recommended for
use in typical analysis jobs.  The &HTL; package itself includes a
complete set of working examples that can be used as a basis for
building more complex applications.  A description of these examples
can be found in Appendix <xref linkend="H1APPrunexamples"/>.
</para>

<sect1>
<title>Booking and filling persistent histograms</title>

<para>
The basic operations of creating (booking) and filling histograms are
shown below.  As the code fragments illustrate, these operations are
performed using methods that have the same basic signature as the
equivalent &HBOOK; subroutines. The primary difference is that the
&HBOOK; histogram identifier (ID) is replaced by <quote>smart
pointers</quote>.  These pointers indicate both the type of the
histogram to which they refer (e.g. 1D, 2D) and whether they are
transient or not.
</para>

<para>
As will be familiar to all &HBOOK; users, the following information is
specified at booking time:
</para>

<itemizedlist>
<listitem><simpara>A character string or <emphasis>title</emphasis>, normally 
printed when the histogram is displayed.</simpara></listitem>
<listitem><simpara>The number of bins.</simpara></listitem>
<listitem><simpara>The lower bound of the histogram axis.</simpara></listitem>
<listitem><simpara>The upper bound of the histogram axis.</simpara></listitem>
</itemizedlist>

<para>
For histograms of more than one dimension, the last three
arguments are then repeated for each dimension.
</para>

<para>
The following example shows the booking and filling of a 1D histogram
of 20 bins and a 2D histogram of 50 bins in both X and Y axes.
</para>

<programlisting font="footnotesize">
<![CDATA[#include "HTL/PHistograms.h" // Persistent histograms.
...
// Booking a 20 bin 1D histogram
 HepRef(PHisto1D) histo1 = 
  new (db_) PHisto1D("A 1D histogram",20,0.,40.);
// Booking a 50X50 bins 2D histogram
 HepRef(PHisto2D) histo2 = 
  new (db_) PHisto2D("A 2D histogram",50,5.,15.,50,5.,15.);

// Filling
 double x, w = 0.5;
 for( long i=0; i<50000; i++ ) {
  x = -i*sin(float(i));
  histo->fill(x,w);
  histo2->fill(x,x,w);
 }]]></programlisting>

<para>
The current implementation of &HTL; uses an Object Database (ODBMS) to
provide powerful and scalable persistence capabilities that go beyond
what is possible with simple files.  <footnote><simpara>Simple file-based
persistence is also provided - see chapter 2 for a description of the
<emphasis>write</emphasis> method.</simpara></footnote>
</para>

<para>
In the following, it
is assumed that the reader is familiar with the basic concepts 
of using an &ODBMS;. For example, any operations on persistent objects
must be performed in the context of a <emphasis>transaction</emphasis> and
a database session must have been established. The necessary code to perform
such operations has been omitted in the interests of clarity.</para>

<para>Although the basic histogram operations that are performed in
the above example will be clear to &HBOOK; users, the use of
<quote>smart-pointers</quote> differs from the traditional use of
histogram IDs and needs further explanation. Consider the following
code fragment:
</para>

<programlisting>
HepRef(PHisto1D) histo1 = new ...
</programlisting>
<para>rather than</para>
<programlisting>
PHisto1D *histo1 = new ...
</programlisting>

<para>
In this piece of code, <literal>HepRef</literal> is a smart pointer to
a persistent histogram. As the previous example shows, a smart pointer
can be used as a standard C++ pointer: that is, you can dereference it
in the normal C++ manner:
</para>

<programlisting>
histo1-&gt;fill(...)
</programlisting>

<para>
In addition to the use of smart pointers, the
<function>new()</function> operator should be studied. It is followed
by a so-called <emphasis>clustering hint</emphasis>. A clustering hint is used
to indicate where the persistent objects - histograms in this case -
should be physically located on persistent storage. The database
attempts to place new objects <quote>close</quote> to those referenced
by the hint. In general, the efficient use of clustering allows
performance to be maximised, as objects are transferred to and from
disk and across the network in database pages.  Effective clustering
minimises unnecessary I/O and improves cache efficiency.
</para>

<para>
Finally, we note that the histograms created with
<function>new()</function> are not deleted with a corresponding
<function>delete()</function> operator. This would not only delete the
histogram in the running application <emphasis>but also</emphasis> from
persistent storage, which is presumably not the intention.
</para>
</sect1>

<sect1>
<title>Booking and filling transient histograms</title>

<para>The previous example is now repeated for the case of transient
histograms.  Once again, two histograms are created and
filled. Largely speaking, the code required is identical to the
persistent case. The differences between the two are discussed in
futher detail below.</para>

<programlisting font="footnotesize">
<![CDATA[#include "HTL/Histograms.h" // Transient histograms.
...
// Booking a 20 bin 1D histogram
 Histo1D *histo1 = new Histo1D("A 1D histogram",20,0.,40.);
// Booking a 50X50 bins 2D histogram
 Histo2D *histo2 = new Histo2D("A 2D histogram",50,5.,15.,50,5.,15.);

// Filling
 double x, w = 0.5;
 for( long i=0; i<50000; i++ ) {
  x = -i*sin(float(i));
  histo->fill(x,w);
  histo2->fill(x,x,w);
...
delete histo1;
delete histo2;]]></programlisting>

<para>
Transient histograms are normal, in-memory C++ objects so
standard C++ pointers are used. 

</para>

<para>
We note that the <function>new()</function> operator is now the standard
C++ one. In this case, it is necessary to also handle explicit
deletion of the histogram to avoid memory leaks.
</para>

<para>In summary, the differences between transient and persistent
&HTL; usage requires only the selection of the corresponding class
names (<classname>Histo</classname> versus
<classname>PHisto</classname>) and the use of smart pointer in the
persistent case.
</para>

</sect1>
<sect1>
<title>Making a transient histogram persistent</title>

<para>
As already mentioned, &HTL; makes it possible to use both
persistent and transient histograms at runtime in the same program.
</para>

<para>
Since operations on transient histograms are significantly faster than those on persistent
ones, a typical procedure would be as follows:
</para>
<orderedlist>
<listitem><simpara>perform all of the desired operations on transient histograms (filling
in particular)</simpara></listitem>
<listitem><simpara>make persistent copies of these transient histograms.
</simpara></listitem>
</orderedlist>
<para>This offers the <quote>best of both worlds</quote> - the
performance of the transient implementation plus the added value of
persistence.</para>
<para>
To make a transient histogram <literal>ph</literal> persistent:
</para>
<orderedlist>
<listitem><simpara>declare a persistent histogram <literal>ph</literal> analogous
to the transient counterpart,
</simpara></listitem>
<listitem><simpara>use the <function>new</function> operator as for the booking and
then
</simpara></listitem>
<listitem><simpara>pass the histo interface of <literal>ph</literal> to the
constructor of <literal>ph</literal>.
</simpara></listitem>
</orderedlist>

<para>
A persistent copy of the transient histogram now exists. These steps
are shown in the following code fragment.
</para>

<programlisting font="footnotesize">
#include "HTL/Histograms.h"  // Transient histograms.
#include "HTL/PHistograms.h" // Persistent histograms.

// Declare and define `th': 
 Histo1D  *th = new Histo1D( "Mass",20,0.,4000.);

// Process `th', perform operations: 

// Copy `th' to the database, i.e. make `th' persistent: 
// 
HepRef( PHisto1D ) ph = new (dbH ) PHisto1D( *th ); 
// This create a persistent histo that is a clone (with data) of transient histo `th'. 
</programlisting>

<para>
We note that it is possible to create a persistent histogram out of
<emphasis>any</emphasis> histogram interface, be the source histogram transient or 
persistent itself.
</para>
</sect1>

<sect1>
<title>&HTL; histogram classes</title>

<para>
As described above, &HTL; is based on template classes which
allow very different types of histogram to be supported using the
smallest amount of code.
</para>

<para>
Nevertheless, the emphasis on usability has been maintained and hence
a small set of simple, easy-to-use simple &HBOOK;-like
classes are provided. It is expected that these classes will cover
most cases. The list of available classes is given below.
</para>

<para>Note that all of these classes are used in the same way.
For example, to book a histogram of a given type one uses:</para>

<programlisting font="footnotesize">

// Use HepRef to refer to persistent classes, C++ pointers for transient ones

 HepRef(PHistyyy) histo1 =   new (dbH) PHistoyyy( ...
 Histyyy *histo1 =   new  Histoyyy( ...

// Use Histo1D for 1D Histogram, Histo2D for 2D Histogram,
// Histo2DVar for 2D histogram with variable binning etc.

</programlisting>

<para>e.g., to repeat the initial example:</para>

<programlisting font="footnotesize">
Histo1D *histo1 = new Histo1D("A 1D transient histogram",20,0.,40.);
</programlisting>

<sect2>
<title>Persistent classes</title>

<variablelist termlength="PProfileHistoVar">
<varlistentry>
<term><classname>PHisto1D</classname></term>
<listitem><simpara>1D histogram with <classname>Gravity_Bin_1D</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>PHisto1DVar</classname></term>
<listitem><simpara>1D histogram with <classname>Gravity_Bin_1D</classname> and variable
binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>PProfileHisto</classname></term>
<listitem><simpara>1D histogram with <classname>Profile_Bin</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>PProfileHistoVar</classname></term>
<listitem><simpara>1D histogram with <classname>Profile_Bin</classname> and variable
binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>PHisto2D</classname></term>
<listitem><simpara>2D histogram with <classname>Weighted_Bin</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>PHisto2DF</classname></term>
<listitem><simpara>2D histogram with <classname>Float_Weighted_Bin</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>PHisto2DVar</classname></term>
<listitem><simpara>2D histogram with <classname>Weighted_Bin</classname> and variable binning.</simpara></listitem>
</varlistentry>
</variablelist>

<para>
All classes store bin values and errors as <emphasis>doubles</emphasis>, except
<classname>PHisto2DF</classname>, which stores them as <emphasis>floats</emphasis> (thereby
minimising the storage requirements for very large 2D histograms).
</para>

<para>
Weighted bins are equivalent to &HBOOK; bins, Gravity bins store the
position of the bin center-of-mass, so that the position of the bin
center is more accurate when the bin count is low or the binning is
not optimal (at least in some cases).
More details on bin types will be given later.
</para>

<para>
Notice that profile histograms and 2D histograms with variable
binning were not available in &HBOOK;.
</para>
</sect2>
<sect2>
<title>Transient classes</title>

<variablelist termlength="ProfileHistoVar">
<varlistentry>
<term><classname>Histo1D</classname></term>
<listitem><simpara>1D histogram with <classname>Gravity_Bin_1D</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>Histo1DVar</classname></term>
<listitem><simpara>1D histogram with <classname>Gravity_Bin_1D</classname> and variable
binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>ProfileHisto</classname></term>
<listitem><simpara>1D histogram with <classname>Profile_Bin</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>ProfileHistoVar</classname></term>
<listitem><simpara>1D histogram with <classname>Profile_Bin</classname> and variable
binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>Histo2D</classname></term>
<listitem><simpara>2D histogram with <classname>Weighted_Bin</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>Histo2DF</classname></term>
<listitem><simpara>2D histogram with <classname>Float_Weighted_Bin</classname> and fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry><term><classname>Histo2DVar</classname></term>
<listitem><simpara>2D histogram with <classname>Weighted_Bin</classname> and variable binning.</simpara></listitem>
</varlistentry>
</variablelist>

<para>
All notes relating to persistent classes are also valid for
transient classes.
</para>
</sect2>
</sect1>
<sect1>
<title>Accessing bin content, bin error, bin center</title>

<para>
A histogram stores its bins and allows to access their content,
error and center.
</para>

<variablelist termlength="h1D-&gt;bin(i).error();">
<varlistentry>
<term><function>h1D-&gt;bin(i).value();</function></term>
<listitem><simpara>Value of the bin indexed by <quote><literal>i</literal></quote>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>h1D-&gt;bin(i).error();</function></term>
<listitem><simpara>Error of the bin indexed by <quote><literal>i</literal></quote>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>h1D-&gt;bin_center(i);</function></term>
<listitem><simpara>center of bin index by <quote><literal>i</literal></quote>.
</simpara></listitem>
</varlistentry>
</variablelist>

<para>
Notice that the bin object can retrieve its content/error but
not its center; bins are simple containers, only the histogram
knows where they are mapped in the binning space.
</para>

</sect1>
<sect1>
<title>Line-printer and ASCII table output</title>

<para>
Printing a histogram in text mode is required in a number of
cases. For example, it can be useful for 
long batch jobs, where the user is mainly interested in checking
the quality of data.
</para>

<para>
&HTL; provides a text print helper for this purpose, that is largely
reused from the previous HistOOgrams packages.
</para>

<para>
The following example shows how the <function>print</function>
method can be invoked to generate a simple line-printer style
representation of a histogram.
</para>

<programlisting font="footnotesize">
#include "HTL/Histograms.h" // Transient histograms.

Histo1D *histot = new Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
HepRef(PHisto2D) histop = 
  new PHisto2D("Persistent Histo_2D", 20, 0.0, 20.0, 20, 0.0, 20.0 ); 
... 
HPrinter hp( cout ); 
hp.print( *histop ); 
hp.print( *histot ); 
delete histot; 
</programlisting>

<para>
The above example demonstrates the use of the abstract histogram
interface: the same helper object can print any histogram that conforms to
the interface, regardless of whether it is transient, persistent, 1D, 2D and so
forth.
</para>

<para>
Particularly when working with transient &HTL;, it can be convenient to dump
a histogram in a simple ASCII table that can then be read by standard
tools (PAW, Excel, IRIS Explorer...) to plot or fit it.
</para>

<programlisting font="footnotesize">
#include "HTL/Histograms.h" // Transient histograms.

T_Histo1D *histo = new Histo1D("Histo_1D", 20, 0.0, 20.0 ); 
... 
HistoTable1D ht1 ("histo.txt"); 
ht1.write(*histo); 
delete histo; 
</programlisting>
</sect1>
</chapter>

<!--3-->
<chapter id="H1PartitionsBins">
<title>Partitions and Bins</title>

<sect1>
<title>Partitions</title>

<para>
The concept of <quote>partition</quote> was first introduced in the
HistOOgrams package.  A partition describes how one dimension of the
problem space is divided into intervals. Consider the case of a 50 bin
histogram in the range <literal>[0,50]</literal>, a
partition object containing the number of bins and the interval limits
will describe completely how we divide such interval: a set of 50
sub-intervals of equal width. This is termed a <quote>Fixed</quote> or
<quote>Even</quote> partition.
</para>

<para>
It may be required to book an histogram over the same range as the
example above, but with bins of variable widths. In this case, a
partition containing the number of bins, the lower limit of each
sub-interval and the upper limit of the last sub-interval will
describe completely <literal>[0,50]</literal> interval
is divided. Such a partition is termed a <quote>variable</quote> or
<quote>Uneven</quote> partition.
</para>

<para>
An <emphasis>n-dimensional</emphasis> &HTL; histogram thus contains <emphasis>n</emphasis> partitions, one for
each axis. The only concern of a partition is to associate any ordered
1D space with a discreet numbered space. Thus it associates an
interval to a positive integer. Hence, a partition knows about the
width of the intervals and their lower point/bound or upper point/bound.
</para>

<para>
In the &HTL; package, a histogram delegates to its partitions the task
of locating a bin. In other words, information about the lower and
upper bounds of a bin or the width of a given bin are obtained from
the corresponding partition. This is shown in the following code
fragment, which demonstrates how the lower and upper bound and width
of a given bin can be obtained.
</para>

<programlisting font="footnotesize">
Histo1D *histo = new Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
... 
histo->partition().lower_point(i) // Obtain the lower bound of bin i
histo->partition().bin_width(i)   // and its width
histo->partition().upper_point(i) // and upper bound
</programlisting>
</sect1>
<sect1>
<title>Bins</title>

<para>
Bins themselves contain information about the content, the error and
possibly the center of the bin. Bin information is always accessed
through interface methods. &HTL; provides the following types of bin:
</para>

<variablelist termlength="Gravity_bin_1D">
<varlistentry>
<term><classname>Weighted_Bin</classname></term> 
<listitem><simpara>class representing bins with weighted data points. 
By default the gravity center of these bins are the middle or center 
of the bin.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><classname>Gravity_Bin_1D</classname></term>
<listitem>
<para>
class representing bins with weighted data
points and that know how to determine the gravity center of the
bins. This new bin class allows us to have filling time statistics
as in the existing histogram package, but without having to compute
separate quantities at filling time. The other advantage is that in
case of bins with low counting, the information of the bin center
is more accurate that the middle of the bin.
</para>
<para>
Also, <classname>Gravity_Bins</classname> could provide more accurate
information in some cases of non-optimal binning. For instance, if you
sample an integer variable in the range
<literal>[0,20]</literal> with a 20 bin histogram over
the same interval, the bin center is properly computed at the integer
values, while in a traditional histograms they would correspond to the
closest half integer.  
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><classname>Profile_Bin</classname></term>
<listitem>
<simpara>
class representing bins that can average another quantity.
</simpara>
</listitem>
</varlistentry>
</variablelist>

<para>
Note that bins only know about their contents. They do <emphasis>not</emphasis>
know where they are 
are located in the histogram to which they belong, nor about
their widths or bounds - this information is stored in the
partition to which they belong, which also defines the bin layout within
a histogram.
</para>
</sect1>
</chapter>

<!--4-->
<chapter id="H1VariablePartitionsandProfile">
<title>Histograms with variable partitions and Profile
histograms</title>

<sect1>
<title>Variable partition histograms</title>

<para>
HTL supports 1D and 2D histograms with variable partitions. The
partitions are specified as a vector of real numbers.
</para>

<sect2>
<title>Persistent case</title>

<programlisting font="footnotesize">
P_Points_Vector points_on_X(10); // Vector of 10 real numbers 
points_on_X[0] = 0.0; points_on_X[1] = 1.0; 
points_on_X[2] = 3.5; points_on_X [3] = 4.0; 
points_on_X[4] = 5.5; points_on_X[5] = 9.0; 
points_on_X[6] = 10.; points_on_X[7] = 15.; 
points_on_X[8] = 19.; points_on_X[9] = 20.; 

HepRef(PHisto1DVar) histo = 
  new (db_) PHisto1DVar( "Histo1DVar", points_on_X ); 

P_Points_Vector points_on_Y(10); 
points_on_Y[0] = 0.0; points_on_Y[1] = 1.0; 
points_on_Y[2] = 2.5; points_on_Y[3] = 4.0; 
points_on_Y[4] = 6.0; points_on_Y[5] = 9.0; 
points_on_Y[6] = 12.; points_on_Y[7] = 14.; 
points_on_Y[8] = 18.; points_on_Y[9] = 20.; 

HepRef(PHisto2DVar) histo = 
  new (db_) PHisto2DVar( "Histo2DVar", points_on_X, points_on_Y ); 
</programlisting>
</sect2>

<sect2>
<title>Transient case</title>

<programlisting font="footnotesize">
T_Points_Vector points_on_X(10); // Vector of 10 real numbers 
points_on_X[0] = 0.0; points_on_X[1] = 1.0; 
points_on_X[2] = 3.5; points_on_X[3] = 4.0; 
points_on_X[4] = 5.5; points_on_X[5] = 9.0; 
points_on_X[6] = 10.; points_on_X[7] = 15.; 
points_on_X[8] = 19.; points_on_X[9] = 20.; 

Histo1DVar *histo = new Histo1DVar( "Histo1DVar", points_on_X ); 

T_Points_Vector points_on_Y(10); 
points_on_Y[0] = 0.0; points_on_Y[1] = 1.0; 
points_on_Y[2] = 2.5; points_on_Y[3] = 4.0; 
points_on_Y[4] = 6.0; points_on_Y[5] = 9.0; 
points_on_Y[6] = 12.; points_on_Y[7] = 14.; 
points_on_Y[8] = 18.; points_on_Y[9] = 20.; 

Histo2DVar *histo2 = new Histo2DVar( "Histo2DVar", points_on_X, points_on_Y ); 
</programlisting>

<para>
Both the class names and type of vector used depends on whether transient or persistent
histograms are involved.
</para>
</sect2>
</sect1>

<sect1>
<title>Profile Histograms</title>

<para>
Profile histograms are implemented both with fixed and variable
partitions. The bin errors are computed as in &HBOOK;, but only the
<literal>' '</literal> and <literal>'S'</literal> options are
supported (see the &HBOOK; manual for a definition of these options
and the associated error calculation).  However, unlike in &HBOOK;
these are not a booking time options; you can ask each bin to compute
either the <literal>Spread</literal> or the
<literal>Spread/sqrt(N)</literal> error at run-time.
</para>

<programlisting font="footnotesize">
HepRef(PProfileHisto) histo = new (db_) PProfileHisto("Profile",20,0.,1.); 
long i; 
double x; 
for( i=0; i&lt;50000; i++ ) { 
  x = drand48(); 
  histo->fill(x,x,1.); 
} 

for( i=0; i&lt;histo-&gt;bin_count(); i++ ) { 
  cout &lt;&lt; endl &lt;&lt; ". " &lt;&lt; setw(2) &lt;&lt; i &lt;&lt; ": " 
&lt;&lt; setw(9) &lt;&lt; histo->i_bin(i).value() &lt;&lt; " Error " 
&lt;&lt; setw(4) &lt;&lt; histo->i_bin(i).error(0) &lt;&lt; " Spread Error " 
&lt;&lt; setw(4) &lt;&lt; histo->i_bin(i).error(1); 
} 
</programlisting>

<para>
As you can see the <function>error()</function> method on the bin
interface allows to access a set of errors: in this case the
<classname>Profile_Bin</classname> class accepts either the 0 or 1
index, which map respectively to <literal>Spread/sqrt(N)</literal> and
<literal>Spread</literal> errors.
</para>

<para>
Profile histograms can be filled with weights, but use of negative
weights yield meaningless results. With weights different from 1. the
errors are calculated properly only for bins with non-zero spread, and
set to 0. for bins with zero spread (&HBOOK;-like).
</para>
</sect1>
</chapter>

<!--5-->
<chapter id="H1OperationsHistograms">
<title>Operations on histograms</title>

<sect1>
<title>What do histogram operations apply to?</title>

<para>
In the &HBOOK; package, operations on histograms result in the
creation of a new histogram, rather than working directly on
the target histogram. This is not an approach which fits naturally
in the Object Oriented world of C++, where responsibility for object 
deletion and creation should normally go together.
</para>

<para>
In &HTL;, one first creates a copy of the target histogram and then
applies the operation on the newly created copy. The responsibility
for the creation and deletion of the new histogram are thus delegated
to the target application and unnoticed memory leaks potentially avoided.
</para>

</sect1>
<sect1>
<title>Cloning a histogram</title>

<para>
HTL allows you to produce a new copy of an existing histogram using
the <function>clone</function> method of the
<interface>I_Histogram</interface> interface.  The first argument, if
given, specifies where the histogram should be cloned, that is the
clustering hint. By default the clustering hint is the container that
contains the source histogram in the persistent case and empty in the
transient case. The last argument, if any, specifies how the histogram
should be cloned:
</para>

<itemizedlist>
<listitem><simpara>Specifying a value of 0 will result in a clone of just the structure;</simpara></listitem>
<listitem><simpara>A non-zero argument, which is also the default, will cause the data to be copied in addition.</simpara></listitem>
</itemizedlist>

<para>An example of cloning in the persistent and transient case follows.</para>

<programlisting font="footnotesize">
* Persistent case */ 

HepRef(PHisto1D) h1D = 
  new(db_)  PHisto1D( "Histo1: parabolic function", 20,0.,20.); 
... 
// The persistent histogram will be cloned close to the original
// object (default behaviour) 
HepRef(PHisto1D) clone_1D = h1D->clone();   // Clone 'h1D' structure and data
  
/* Transient case */ 

Histo1D *h1D = new Histo1D( "Histo1: parabolic function", 20,0.,20.); 
... 
Histo1D *clone_1D = h1D->clone();   // Clone 'h1D' structure and data
</programlisting>

</sect1>
<sect1>
<title>Operations on histograms</title>

<para>Below is a list of methods implementing operations on
histograms.</para>

<sect2>
<title>Operations with scalars</title>


<variablelist>
<varlistentry>
<term><function>void add( double x )</function></term>
<listitem>
<simpara>
Add <quote><literal>x</literal></quote> to current histo.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><function>void sub( double x )</function></term>
<listitem><simpara>Substract <quote><literal>x</literal></quote> from current histo.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>void mul( double x )</function></term>
<listitem><simpara>Multiply <quote><literal>x</literal></quote> with current histo.</simpara></listitem>
</varlistentry>
<varlistentry><term><function>void div( double x )</function></term>
<listitem><simpara>Divide current histo by <quote><literal>x</literal></quote>.</simpara></listitem>
</varlistentry>
</variablelist>

</sect2>
<sect2>
<title>Operations with another histogram</title>

<variablelist>
<varlistentry>
<term>
<function>Ref_Like_Current add( const Ref_Like_Current &amp;other )</function>
</term>
<listitem>
<simpara>
Add <quote><literal>other</literal></quote> histo to current histo.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<function>void add( const I_Histo &amp;other )</function>
</term>
<term>
<function>Ref_Like_Current sub( const Ref_Like_Current &amp;other )</function>
</term>
<listitem>
<simpara>
Subtract <quote><literal>other</literal></quote> histo from current histo.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<function>void sub( const I_Histo &amp;other )</function>
</term>
<term>
<function>Ref_Like_Current mul( const Ref_Like_Current &amp;other )</function>
</term>
<listitem>
<simpara>
Multiply <quote><literal>other</literal></quote> histo with current histo.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<function>void mul( const I_Histo &amp;other )</function>
</term>
<term>
<function>Ref_Like_Current div( const Ref_Like_Current &amp;other )</function>
</term>
<listitem>
<simpara>
Divide current histogram by <quote><literal>other</literal></quote> histo.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<function>void div( const I_Histo &amp;other )</function>
</term>
<term>
<function>Ref_Like_Current binomial_div( const Ref_Like_Current &amp;other )</function>
</term>
<listitem>
<simpara>
Divide current histo by <quote><literal>other</literal></quote> histo
using <quote>binomial error</quote>
</simpara>
</listitem>
</varlistentry>
<varlistentry><term>
<function>void binomial_div( const I_Histo &amp;other )</function>
</term>
<listitem><simpara></simpara></listitem>
</varlistentry>
</variablelist>

<para>
Notice that operations with another histogram exists with two
signatures, the first one allowing to directly assign the result of
an operation.
</para>

<para>This is an example of code to add two histograms:</para>

<programlisting font="footnotesize">
HepRef(PHisto1D) histo1 = 
  new(db_)  PHisto1D( "Histo1: parabolic function", 20,0.,20.); 
  ... 
  for (int i = 0; i &lt; 50000; i++) 
    histo1->fill(x,w); 

  // Now create a clone of histo1 
  HepRef(Histo1D) histo2 = histo1->clone(); 
  // Add histo1 to histo2 and change histogram name 
  histo2->add( *histo1 ); 
  histo2->set_name( "Histo2 =  Histo2+Histo1 = 2*Histo1" ); 

  //
  // It is also possible to clone and perform an operation on single
  // statement:
  // 	histo2 = histo1->clone()->add( histo1 );
  //

</programlisting>

<para>As discussed in the first paragraph, it's important to first
make a clone of the original histogram. Another way to clone a
histogram is using a copy constructor, as described in Chapter 
<xref linkend="H1Constructors"/>.
</para>
</sect2>
</sect1>
</chapter>
<!--</part>

<part>
<title>Advanced HTL</title>
-->
<!--6-->
<chapter id="H1UsingHistogramFactories">
<title>Histogram Factories and Naming Trees</title>

<para>
This section describes a number of techniques for handling the naming
and location of persistent histograms in the database. As such, 
this section only applies to persistent &HTL; histograms
as they 
</para>

<sect1>
<title>Histogram factories</title>

<para>
The Object Database Management Group (&ODMG;) standard for Object
Databases specifies that persistent objects are created using a
<function>new()</function> operator with a <emphasis>clustering hint</emphasis>
argument. This parameter provides a mechanism whereby the user or
application code can specify where each individual object is
physically stored. This is demonstrated by the the following code
fragment, where the <literal>histo1</literal> object is created in the
database referred to by the database handle <literal>db_</literal>.
</para>

<programlisting font="footnotesize">
HepRef(PHisto1D) histo1 = 
  new (db_) PHisto1D("A 1D histogram",20,0.,40.);
</programlisting>

<para>
Not only is this syntax somewhat unusual to novice users, but also it
poses problems when attempting to use tools such as the &SWIG;
interface generator for scripting languages.<footnote><simpara>The
&SWIG; interface generator provides a generic mechanism for
integrating a wide variety of scripting languages, including Tcl,
Perl, Python and even Java.</simpara></footnote>
</para>

<para>
The <classname>HFactory</classname> class overcomes this problem by
letting the user specify by name the database or container in which
histograms should be created and provides a factory method for the
actual creation of the histograms.
</para>

<para>
The following code fragment demonstrates the usage of a Histogram Factory.
It first initialises the factory, specifying the target database and container
by name. Histograms are then created and filled and are automatically 
stored in the appropriate container.
</para>

<programlisting font="footnotesize">
#include "HTL/H_Factory.h" 
... 
  HFactory myFactory; 
  // Create histograms in DataBase "gepo", Container "sbaffini" 
  if (myFactory.init(this,"gepo","sbaffini")) { 
    // Create a histogram using the factory 
    HepRef(PHisto1D) h1 = myFactory.Histo1D("Histo-1",noBins,0.0,20.0); 
   ... 
   h1->fill(x, 1.); 
</programlisting>

<para>
The <classname>HFactory</classname> class provides a method to
generate all useful types of histograms. The factory methods are named
according to the histogram type and take parameters according to the
corresponding constructor.
</para>

<programlisting font="footnotesize">
int init (HepDbApplication *sess, char *dbname,  char *contname = 0); 
HepRef(PHisto1D) Histo1D (const char *a_title, Size n, double x1, 
              double x2, End_Point_Convention epc = RIGHT_OPEN);
HepRef(PHisto1DVar) Histo1DVar(const char *,P_Points_Vector &amp;,
              End_Point_Convention epc = RIGHT_OPEN );  
HepRef(PProfileHisto) ProfileHisto1D (const char *a_title, Size n,
              double x1, double x2, End_Point_Convention  epc =
              RIGHT_OPEN ); 
HepRef(PProfileHistoVar) ProfileHisto1DVar(const char *,
              P_Points_Vector &amp;, End_Point_Convention epc = RIGHT_OPEN );  
HepRef(PHisto2D) Histo2D (const char *, Size , double  , double ,
              Size , double  , double , End_Point_Convention  epc1 =
              RIGHT_OPEN , End_Point_Convention  epc2 = RIGHT_OPEN );  
HepRef(PHisto2DVar) Histo2DVar( const char *, P_Points_Vector &amp;,
              P_Points_Vector &amp;, End_Point_Convention  epc1 =
              RIGHT_OPEN, End_Point_Convention   epc2 = RIGHT_OPEN );  
</programlisting>
</sect1>

<sect1>
<title>Naming histograms</title>

<para>
The HepODBMS package of &LHCPP; provides a logical naming scheme on top of
the physical structure of the underlying database. Note that these two structures
are independent - naming does not imply physical location and vice-versa. 
The naming package creates
and maintains a naming tree similar to file-system trees, with
directories and <quote>final objects</quote> (equivalent to files in a
file-system).
</para>

<para>
The HepODBMS naming package assumes each user is given a personal
naming tree which starts in a <quote>home directory</quote> like
structure. Each user is assigned a home directory that maps directly
to their user name under the common directory
<literal>/usr</literal>. Thus, the home directory in the naming tree
for a user named <literal>dinofm</literal> is <literal>/usr/dinofm</literal>.
</para>

<para>
An exampe of the use of the naming tree that will be familiar to
&HBOOK; users would be to name &HTL; histograms using an identifier
much like the &HBOOK; <literal>ID</literal> and store them in
appropriate named directories in the database. This provides a naming
scheme similiar to that used by &HBOOK;, with the exception that the
naming is case sensitive.
</para>

<para>
Although users can use the HepODBMS classes directly to name &HTL;
histograms, a simple <classname>Factory</classname> class which
extends the basic <classname>HFactory</classname> with naming
capabilities has also been provided. Using this extended factory
class, users can choose where to store histograms (physical location)
and name them according to their favourite scheme (logical location).
</para>

<para>
The following code fragment shows how &HTL; histograms can be
named. Two histograms are created and stored in the same database and
container as before. However, they are also given names in the
<literal>/usr/dinofm/Histograms/MC</literal> directory - one using an
&HBOOK;-like identifier and the other using a short text string.
</para>

<programlisting font="footnotesize">
#include "HTL/HNaming.h" 
... 
  HNamingFactory myFactory(HNamingFactory::Override); 
  // Create histograms in DB "gepo", Container "sbaffini" and name
  // them in /usr/dinofm/Histograms/MC (dinofm is my user name) 
  if (myFactory.init(this,"Histograms/MC","gepo","sbaffini")) { 
    // Create two histograms. They're named 10 and "pt" in the name tree 
    HepRef(PHisto1D) h1 = myFactory.Histo1D(10,"Histo-1",noBins,0.0,20.0); 
    HepRef(PHisto1D) h2 = myFactory.Histo1D("pt","Histo-2",noBins,0.0,20.0); 
    ... 
    h1->fill(x, 1.); 
    h2->fill(x, 2.); 
</programlisting>

<para>
Named histograms, such as those created above, can then be retrieved as follows:
</para>

<programlisting>
/usr/dinofm/Histograms/MC/10
/usr/dinofm/Histograms/MC/pt
</programlisting>

<para>
It should be remembered that - unlike &HBOOK; - the naming scheme is
case sensitive.  Histograms can be named with a character string such
as <quote><literal>pt</literal></quote> or with an integer code like
10 (similar to &HBOOK;'s histogram identifier <literal>ID</literal>).
</para>

<para>
If the histogram you create already exists,
<classname>HNamingFactory</classname> can either override the previous
histogram or refuse to create the new one, depending on the strategy
specified when the factory was declared.
</para>

<para>
To instruct the factory to override existing histograms, use a construct like:
</para>

<programlisting>
 HNamingFactory myFactory(HNamingFactory::Override);
</programlisting>
<para>
To avoid accidental overwriting of existing histograms,
use something like:
</para>

<programlisting>
 HNamingFactory myFactory(HNamingFactory::Keep);
</programlisting>

<para>
The Override directive can be useful for cases such as batch jobs or
debugging: old histograms are simply replaced by new ones. The
<literal>Keep</literal> mode allows one to protect against the
accidental deletion of useful data. Other strategies, such as cycles
or versions, are not presently implemented.
</para>

</sect1>

<sect1>
<title>Retrieving named histograms</title>

<para>
Once the histograms have been saved and named in an Objectivity data
store, a mechanism for retrieving them is clearly required.  The
<classname>HLocator</classname> class allows the retrieval of a
histogram by name, as follows:
</para>

<programlisting font="footnotesize">
#include "HTL/HNaming.h" 
... 
  // Locate Histograms pt and 10 
  HLocator myLocator; 
  HPrintert hp(cout); 
  myLocator.init(this); 
  HepRef(PHisto1D) h = myLocator.Histo1D("pt"); 
  if (h != 0) 
    hp.print(*h); 
  h = myLocator.Histo1D(10); 
  if (h != 0) 
    hp.print(*h); 
</programlisting>

<para>
Notice that the <classname>HLocator</classname> class provides methods
to retrieve different kinds of histograms (so users should know what
they are retrieving). Type checking is thus guaranteed and if the
expected histogram type does not match the real one, an error message
is printed and the return value is zero.
</para>
</sect1>
</chapter>

<!--7-->
<chapter id="H1UsingInterfaces">
<title>Using interfaces</title>

<para>
Interfaces are a powerful OO concept which allows designers to
decouple what an object does from its actual implementation. This
reduces the impact on <quote>external</quote> software using such object(s) and
makes software reuse more realistic.
</para>

<para>
In the C++ world, interfaces are usually implemented by abstract
classes with virtual methods. In this context the only drawback of
interfaces might be a performance penalty due to the extra
indirection required by virtual functions, but we should not
neglect the usefulness of interfaces just because of that.
</para>

<sect1>
<title>Interfaces in HTL</title>

<para>
HTL defines and implements abstract interfaces for most of its
functionalities. The only method which is not available on purpose at
the interface level is the <function>fill()</function> method, which must be
implemented as an non-virtual inline method to provide the highest
performance (see Appendix <xref linkend="H1APPerformance"/> for details).
</para>

<para>
HTL interfaces are used by other packages such as fitting (HEPFitting)
and visualisation (HEPInventor) that are thus independent from the
actual HTL implementation of histograms. Interfaces are what allows
external packages to deal with transient and persistent HTL histograms
at the same time. Using such interfaces we might even implement an
HTL-like package based on other technologies, for instance an HTL
interface to &HBOOK;, although this is not envisaged at present.
</para>

<sect2>
<title>The <interface>I_Histo</interface> interface</title>

<para>
<interface>I_Histo</interface> is the high-level interface to
histograms. The following is a list of supported methods.
</para>

<variablelist>
<varlistentry>
<term><function>virtual const char* name()</function></term>
<listitem><simpara>Title attached to current histogram.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual I_Bin&amp; i_bin( I_Bin_Location &amp;a_location )</function></term>
<listitem><simpara>In-range bin associated with location <literal>a_location</literal>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual I_Bin&amp; i_extra_bin( I_Extra_Bin_Location
&amp;a_location )</function></term>
<listitem><simpara>Extra bin associated with extra location <literal>a_location</literal>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual Size bin_count()</function></term>
<listitem><simpara>Number of in-range bins.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual Size extra_bin_count()</function></term>
<listitem><simpara>Number of extra bins.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual Size dim()</function></term>
<listitem><simpara>Dimension of the histo, i.e., of the problem space.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual I_Partition&amp; i_partition( Index p = 0 )</function></term>
<listitem><simpara>Partition interface associated with this histo. 
For the first partition one has <literal>a_dim_index = 0</literal>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual I_Bin&amp; i_bin( Index i )</function></term>
<listitem><simpara>Any bin (in-range or extra) with index <quote><literal>i</literal></quote>
(note that this is a linear access).</simpara></listitem>
</varlistentry>
</variablelist>

<para>
The <interface>I_Histo</interface> interface can retrieve the number
of bins that are in-range or out-range, for instance, overflow or
underflow, as well as the number of partitions (i.e. the
dimensionality of the histogram). It also allows you to access other
interfaces such as <interface>I_Partition</interface> and
<interface>I_Bin</interface>.
</para>

<para>
On the other hand, the <interface>I_Histo</interface> interface does
not try to provide all information in a single interface: details
about binning and bin content are delegated, respectively, to the
<interface>I_Partition</interface> and <interface>I_Bin</interface>
interfaces, as explained later.
</para>
</sect2>
<sect2>
<title>The <interface>I_Partition</interface> interface</title>

<para>
The <interface>I_partition</interface> interface deals with binning details,
such as, which interval of the problem space a bin is mapped to, that
is where does it start and end, and what are the limits of the range
spanned by the partition.  The following is a list of supported
methods.
</para>

<variablelist>
<varlistentry>
<term><function>End_Point_Convention end_point_convention()</function></term>
<listitem><simpara>End point convention for all bins; can be either 
<literal>RIGHT_OPEN</literal> or <literal>LEFT_OPEN</literal>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual double i_bin_width( Index i )</function></term>
<listitem><simpara>Width of in-range bin <quote><literal>i</literal></quote>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual double i_lower_point()</function></term>
<listitem><simpara>Leftmost point of the partition.</simpara></listitem>
</varlistentry>
<varlistentry><term><function>virtual double i_lower_point( Index i )</function></term>
<listitem><simpara>Leftmost point of bin indexed by <quote><literal>i</literal></quote>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual double i_upper_point()</function></term>
<listitem><simpara>Rightmost point of the partition.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual double i_upper_point( Index i )</function></term>
<listitem><simpara>R`ightmost point of bin indexed by <quote><literal>i</literal></quote>.</simpara></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>The <interface>I_Bin</interface> interface</title>

<para>
The <interface>I_Bin</interface> interface allows you to set or get the content of
a bin, its count information, and its error.
The available methods are listed below.</para>

<variablelist>
<varlistentry>
<term><function>virtual double value( Index i = 0)</function></term>
<listitem><simpara>Value associated with this bin.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual double error( Index i = 0)</function></term>
<listitem><simpara>Error associated with this bin.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual Size count()</function></term>
<listitem><simpara>Count associated with this bin. = Number of entries.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual void set_value( double other, Index i = 0 )</function></term>
<listitem><simpara>Set the value associated with this bin to <quote><literal>other</literal></quote>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual void set_error( double other, Index i = 0 )</function></term>
<listitem><simpara>Change/set the error of the bin to <quote><literal>other</literal></quote>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual void set_count( Size other )</function></term>
<listitem><simpara>Change/set the count of the bin to <quote><literal>other</literal></quote>.</simpara></listitem>
</varlistentry>
<varlistentry>
<term><function>virtual double center( Index i = 0)</function></term>
<listitem><simpara>Absolute or relative center of this bin on axis <quote><literal>i</literal></quote>.</simpara></listitem>
</varlistentry>
<varlistentry><term><function>virtual int offset( Index i = 0)</function></term>
<listitem><simpara>Relative or absolute position for the center of the bin.</simpara></listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1>

<sect1>
<title>Example using Interface classes</title>

<para>
The following example is derived from the HEPInventor visualisation
package - only a subset of the complete code is used.  The method
receives an <literal>I_Histo</literal> reference which is then used,
for instance, to find out whether this is a 1D or 2D histogram. Via
the same <literal>I_Histo</literal> reference, the code retrieves an
interface to the underlying partition, which gives information about
the beginning and end of each bin. At the end, the
<interface>I_Bin</interface> interface of each bin allows us to
retrieve the content and the error associated to each bin.
</para>

<programlisting font="footnotesize">
HIData::HIData(I_Histo &amp;histo) { 
  int i,j,k=0; 
  switch (histo.dim()) { // Is it 1D or 2D? 
  case 1: 
    // Copy the histogram content in a local data structure 
    nptx       = histo.bin_count(); 
    // Use underlying histo.i_partition() interface 
    Xval[0]    = histo.i_partition(0).i_lower_point(0); 
    Yval[0]    = histo.i_bin(0).value(); 
    // Had to patch this... no asymmetric errors yet... 
    EXval[0]   = (histo.i_partition(0).i_lower_point(1)-Xval[0])/2.; 
    EYval[0]   = histo.i_bin(0).error(); 
    for ( i=1; i &lt; nptx; i++) { 
      Xval[i]  = histo.i_partition(0).i_lower_point(i); 
      // Use I_Bin interface to retriev value/error 
      Yval[i]  = histo.i_bin(i).value();  
      EYval[i] = histo.i_bin(i).error(); 
    } 
  } 
} 
</programlisting>

<para>
As you can see there is no reference whatsoever to the real C++
type of the histogram, to its dimensionality, etc. The same code
works with all HTL histograms!
</para>

</sect1>
</chapter>

<!--8-->
<chapter id="H1Constructors">
<title>Constructors</title>

<sect1>
<title>Types of constructors</title>

<para>
HTL provides more constructors than the current package and allows us
to define and create new histograms out of transient or persistent
ones in a nice and natural way.
</para>

<para>
Three kinds of constructor are defined for any histogram
class.
</para>

<para>
The first kind of constructor is the classic one used for the booking.
Arguments reflect the type of the histogram, for instance, 1D or 2D,
fixed or variable bin size, etc. An example is the following:
</para>

<programlisting font="footnotesize">
Histo1D( const char *a_title, Size nBins, double lowX, double
           highX, End_Point_Convention epc = RIGHT_OPEN )
</programlisting>

<para>
The second kind of constructor is a copy constructor. The first
argument must be a histo of the same type. The optional second
argument specifies whether we want to copy the structure only (the
argument must equal 0) or the structure as well as the data also.
(This is the default - argument non 0).
</para>

<programlisting font="footnotesize">
Histo1D( Like_Current &amp;a_histo, int copy_data = 1 )
</programlisting>

<para>
<literal>Like_Current</literal> is a typedef and designates the real
type of the current histogram class with all its template arguments.
</para>

<para>
The third kind of constructor is a variant of a copy constructor. It
makes it possible to create a new histogram out of a histo interface. It
is particularly useful to create persistent histograms from
transient ones. The optional second argument for data copying is also
available.
</para>

<programlisting font="footnotesize">
Histo1D( const I_Histo &amp;a_histo, int copy_data = 1 )
</programlisting>

</sect1>
</chapter>

<!--9-->
<chapter id="H1RetrievingStatistics">
<title>Retrieving statistics and entries information</title>

<sect1>
<title>Shortcuts</title>

<para>
1D histograms implement shortcut methods to retrieve mean and
RMS of a histogram, as follows:
</para>

<programlisting font="footnotesize">
Histo1D *h1D = new Histo1D("Histo1: parabolic function",20,0.,20.);
...
cout &lt;&lt; "Mean " &lt;&lt; h1D-&gt;mean() &lt;&lt; " RMS " &lt;&lt; h1D-&gt;rms() &lt;&lt; endl;
</programlisting>
</sect1>
<sect1>
<title>General method</title>

<para>
HTL implements retrieval of statistics and entries information via
separate helper classes. The helper class is called
<classname>HStat</classname> and it allows us to decouple computation
of statistics and entries information from the implementation
of the histogram.
</para>

<programlisting font="footnotesize">
#include "HTL/Histograms.h"  

Histo1D *h1D = new Histo1D("Histo1: parabolic function",20,0.,20.); 

... // filling 

// Now display some statistics: 
// 
long in_entries = HStat::in_range_entries_count(*histo); 
long extra_entries = HStat::extra_entries_count(*histo); 
cout &lt;&lt; "Entries count: " &lt;&lt; (in_entries + extra_entries) 
 &lt;&lt; " with IN_RANGE: " &lt;&lt; in_entries 
 &lt;&lt; " EXTRA: " &lt;&lt; extra_entries &lt;&lt; endl; 

double mean = HStat::mean( *histo ); 
cout &lt;&lt; "MEAN (B.C.): " &lt;&lt; mean &lt;&lt; endl; 
cout &lt;&lt; "RMS  (B.C.): " &lt;&lt; HStat::rms(*histo, mean) 
 &lt;&lt; endl &lt;&lt; endl; 
</programlisting>
</sect1>
</chapter>
<!--</part>
-->

<!--A-->
<appendix id="H1APSupportedCompilers">
<title>Supported compilers</title>

<para>
The list of supported compilers on a given platform follows
</para>

<variablelist>
<varlistentry>
<term>Solaris</term><listitem><simpara>CC 4.2</simpara></listitem>
</varlistentry>
<varlistentry>
<term>HP-UX</term><listitem><simpara>aCC A.01.15</simpara></listitem>
</varlistentry>
<varlistentry>
<term>Linux</term>
<listitem><simpara>egcs 1.1.1 with patch for 
  persistent templates specialization</simpara></listitem>
</varlistentry>
<varlistentry>
<term>Digital Unix</term><listitem><simpara> cxx V6.1-027</simpara></listitem>
</varlistentry>
<varlistentry>
<term>AIX </term><listitem><simpara>xlC 3.1.?</simpara></listitem>
</varlistentry>
<varlistentry>
<term>&WNT;</term><listitem><simpara>VC++ 5.0 SP3</simpara></listitem>
</varlistentry>
</variablelist>
</appendix>

<!--B-->
<appendix id="H1APStatisticsErrorPropagation">
<title>Statistics and error propagation</title>

<sect1>
<title>Histogram statistics</title>

<para>
HTL implements histogram statistics as bin content statistics
only.
</para>

<programlisting font="footnotesize">
Mean = SUM[ bin center * bin value ] / SUM[ bin value ]
RMS = SUM[ (bin center - mean)^2 * bin value ] / SUM[ bin value ]
</programlisting>

<para>
Since the <classname>Gravity_Bin</classname> used in 1D HTL histograms
keeps the weighted center of the bin, those quantities are equal to
so-called <quote>filling time statistics</quote> computed by &HBOOK;
and HistOOgrams.
</para>
</sect1>

<sect1>
<title>Bin errors</title>

<para>
Bin errors are always computed taking weights into account.
</para>

<programlisting font="footnotesize">
error = sqrt( SUM[ weight*weight ])
</programlisting>

<sect2>
<title>Bin error <quote>propagation</quote> for histogram operations</title>

<para>
Depending on histogram operations, bin errors are combined in
the error of the resulting bin. Formulas should be equivalent to
the ones used in &HBOOK;.
</para>
</sect2>

<sect2>
<title>Synopsis</title>

<variablelist>
<varlistentry>
<term><literal>error_</literal></term>
<listitem><simpara>
error of the first bin, <function>other.error()</function> 
is the error of the second bin;
</simpara></listitem>
</varlistentry>
<varlistentry><term><literal>value_</literal></term>
<listitem><simpara>
value of the first bin, <function>other.value()</function> is the error of
the second bin.
</simpara></listitem>
</varlistentry>
</variablelist>

<programlisting font="footnotesize">
 void add( const Like_Parent &amp;other ) 
  error_ =  other.error()*other.error() + error_ ; 

void sub( const Like_Parent &amp;other ) 
  error_ = other.error() * other.error() + error_ ; 

void mul( const Like_Parent &amp;other ) 
  error_ = error_ * other.value()*other.value() +  
           other.error()*other.error() * value_*value_ ; 

void div( const Like_Parent &amp;other ) 
  e = pow(other.error(),4) ;
  error_ = error_ * other.value()*other.value() +  
           other.error()*other.error() * value_*value_ ; 
  if( e != 0 ) 
    error_ = ( error_/e ); 

void binomial_div( const Like_Parent &amp;other ) 
  e = other.error()*other.error() ;
  error_ = sqrt( error_ / e ); 
  error_ = error_ * (1-error_); 
  error_ = error_ * error_; 
  error_ = ( error_ / e ); 
</programlisting>
</sect2>
</sect1>
</appendix>

<!--C-->
<appendix id="H1APPerformance">
<title>Performance</title>

<sect1>
<title>Introduction</title>

<para>
Most of the time the performance of an histogramming package is not
critical. For example, in the typical case of long running
batch jobs, the time spent in histogram operations is not that important.
On the other hand there are applications, such as online monitoring,
where excellent performance is fundamental.
</para>

<para>
The HistOOgram package, which &HTL; replaces, was not optimised for 
performance, but rather was designed 
for maximum flexibility. In addition, early benchmarks of this package
were performed on a pre-release and should be considered unrepresentative.
</para>

<para>
Experience shows that there is always a tradeoff between higher performance
and maximum flexibility. Fortunately, a reasonable compromise
can usually be found, since performance is normally required only in well
defined areas of the code.
</para>

<para>
A often-heard rule of thumb states that in most cases an application
spends 80&percent; of its time in 20&percent; of the code. Hence an 
efficient approach is to estimate where the critical sections of the code lie,
identify the most appropriate algorithms (which are more difficult to
change than code), and finally measure the performance with a proper
tool, such as a code profiler. 
Code portability and maintainability should not be abandoned in the pursuit of
performance - all are important issues that need to be addressed when
producing a package.
</para>

<para>
The procedure described above was that used in the case of &HTL;. In other words,
the critical portions of
code were first identified, which unsurprisingly turned out to be the filling
methods, that can be called millions of times. A
technique to speed up filling by using templated classes was then identified (see for
instance the Blitz++ libraries for a discussion about templates and
C++ performance). Finally, once the package was working,
the performance was measured and tuned using a simple code profiler.
</para>

<para>
The results of a simple comparison with &HBOOK; are presented below. These
are not intended as a complete test but rather as a benchmark
reference. The source code used for the benchmark
is available on request.
</para>
</sect1>

<sect1>
<title>Comparison between &HBOOK;, HistOOgrams, and HTL</title>

<sect2>
<title>Description of the benchmark</title>

<para>
A set of 10 histograms with fixed binning is filled with 50000 points
each.  The benchmark is focused on filling performance. 

The I/O part is more difficult to compare directly and is not included
in these comparisons. &OBJ;, used by persistent &HTL;, ensures that
all data is written to disk as part of a transaction. In the case of
&HBOOK; buffers are not flushed and so a comparison of the two is not
meaningful.  In the &HBOOK; case, timing is measured with the CERNLIB
routine <function>TIMED</function>. The C++ benchmark reports real
time as measured by RD45's <classname>Timer</classname> class.  HTL
histograms are based on gravity bins, so they harvest more information
than their &HBOOK; counterpart, and thus use CPU.
</para>
</sect2>

<sect2>
<title>Results of the benchmark</title>

<para>
The target machine used for the test was a Sparc Ultra:
</para>

<programlisting font="footnotesize">
SunOS sunasd1 5.5.1 Generic_103640-12 sun4u sparc SUNW,Ultra-30
</programlisting>

<para>
The compilers used were the following: <literal>C++ V 4.1</literal>
for HistOO, <literal>C++ V4.2</literal> for HTL, and <literal>f77
4.2</literal> for &HBOOK;.
</para>

<para>
The results are summarised in the table below.
</para>

<para>
<informaltable preamble="@@{}ll@@{}">
<tgroup cols="2">
<tbody>
<row><entry>&HBOOK;</entry><entry>860 ms</entry></row>
<row><entry>Transient HTL</entry><entry>790 ms</entry></row>
<row><entry>HistOO</entry><entry>3600 ms</entry></row>
<row><entry>Persistent HTL</entry><entry>2700 ms</entry></row>
<row><entry>Persistent HTL(fast-filling)</entry><entry>1150
ms</entry></row>
</tbody>
</tgroup>
</informaltable>
</para>

<para>
The timing on the second line of the persistent &HTL; case is for a
version optimised by using a fast filling method.
</para>

<para>
It should also be stressed that the &HTL; package allows you to create a
persistent Histogram out of a transient one so that it is possible
to work in a mixed mode: first histograms can be created
and filled as transient, and only at the end saved as persistent.
Thus one combines the advantages of a fastest possible filling 
with the those of profiting of object persistency.
</para>
</sect2>
</sect1>

<sect1>
<title>Conclusion</title>

<para>
&HTL; transient histograms are slightly faster than comparable &HBOOK;
ones, even though they provide the user with more accurate information
about bin centers.
</para>

<para>
&HTL; persistent histograms are somewhat slower than their transient counterparts. 
It would be possible, using
more advanced &OBJ; techniques such as
fast-filling methods and pinning in memory, to make them
almost as fast as transient ones. However, a more practical approach
in most cases is the use of transient histograms for repetitive operations such as
filling, combined with persistent copies of the filled histogram for storage.
</para>

<para>
When raw performance is absolutely crucial, faster &HTL; histograms 
are also available. However, they do not provide filling time statistics.
</para>

<para>
Since &HTL; allows you to mix persistent and transient histograms, the
optimal strategy when performance is an issue is to book and fill
transient histogram and save them at the end of the run using the
persistent histogram <function>copy</function> constructors (as explained in
chapter <xref linkend="H1HTLglance"/>).
</para>

</sect1>
</appendix>

<!--D-->
<appendix id="H1APPrunexamples">
<title>Running the examples</title>

<sect1>
<title>List of available examples</title>

<para>
A set of HTL examples can be found
<ulink url="file:/afs/cern.ch/sw/lhcxx/share/HTL/dev/HTL/examples">
here</ulink>.
</para>

<variablelist termlength="HistoProfile">
<varlistentry>
<term><command>Histo1D</command></term>
<listitem><simpara>create persistent 1D histogram with fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>Histo2D</command></term>
<listitem><simpara>create persistent 2D histogram with fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>HistoProfile</command></term>
<listitem><simpara>create persistent 1D profile histogram with fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>HistoTables</command></term>
<listitem><simpara>produce ASCII tables to export HTL histograms to, e.g., PAW;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>Operations</command></term>
<listitem><simpara>histogram cloning and histogram operations;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>THistos</command></term>
<listitem><simpara>create transient 1D/2D histograms with fixed binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>Histo1DVar</command></term>
<listitem><simpara>create persistent 1D histogram with variable binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>Histo2DVar</command></term>
<listitem><simpara>create persistent 2D histogram with variable binning;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>HistoRandom</command></term>
<listitem><simpara>use of CLHEP random generators;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>NameHistos</command></term>
<listitem><simpara>naming persistent histograms;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>ReadHisto</command></term>
<listitem><simpara>reading back histograms from Objectivity/DB datastore;</simpara></listitem>
</varlistentry>
<varlistentry>
<term><command>TSliceProj</command></term>
<listitem><simpara>slice/projections of a 2D histogram.</simpara></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1>
<title>Setting up for using the examples</title>

<sect2>
<title>Defining your environment</title>

<para>
When you are running in an environment created by the &LHCPP; setup
procedure (as explained <ulink
url="http://wwwinfo.cern.ch/asd/lhc++/lhcppguide/SetUpUserEnvironment.html">here</ulink>)
all environment variables needed by HTL will be already in place.
</para>

<para>
If you are not running in such an environment, you will have to set 
the HTL environment variables up yourself, since the GNUmakefiles for
running the examples assume that the following environment
variables are defined correctly:
</para>

<itemizedlist>
<listitem><simpara><envar>LHCXXTOP</envar></simpara></listitem>
<listitem><simpara><envar>PLATF</envar></simpara></listitem>
<listitem><simpara><envar>HEP_ODBMS_DIR</envar></simpara></listitem>
<listitem><simpara><envar>HISTOODIR</envar></simpara></listitem>
</itemizedlist>

<para>
If they are not defined run the following script which is likely to
work at CERN (replace <emphasis>pro</emphasis> by
<emphasis>new</emphasis> or <emphasis>dev</emphasis> to get the new or
development versions as required):
</para>

<programlisting font="footnotesize">
source /afs/cern.ch/sw/lhcxx/share/HTL/pro/HTL.csh
</programlisting>

<para>
The above syntax is for C-shell flavours, while on Bourne shell
flavours you should use:
<programlisting font="footnotesize">
. /afs/cern.ch/sw/lhcxx/share/HTL/pro/HTL.ksh
</programlisting>

For non-CERN installations you will have to replace the path:
<programlisting font="footnotesize">
/afs/cern.ch/sw/lhcxx
</programlisting>
with the location of your &LHCPP; tree.
</para>

<para>
Finally, a similar script is provided on &WNT; as a batch file:

<programlisting font="footnotesize">
Z:\P32\lhcxx\share\HTL\pro\HTL.bat
</programlisting>

If you are using persistent HTL your &OBJ; environment should be
properly defined as well.
</para>
</sect2>

<sect2>
<title>Building the examples</title>

<para>
Make a local copy of the examples directory and run
<application>gmake</application>, as follows:
</para>

<programlisting font="footnotesize">
<userinput>cp -r /afs/cern.ch/sw/lhcxx/HTL/dev/HTL/examples .</userinput>
<userinput>cd examples</userinput>
<userinput>gmake</userinput>
</programlisting>

<para>
These commands will build all examples in one go. You can build
examples separately by running <application>gmake</application> in each
subdirectory.
</para>

</sect2>

<sect2>
<title>Running the examples</title>

<para>
HTL is provided as shared libraries on most platforms. This means HTL
libraries and any other shared library used by HTL, such as HepODBMS
and &OBJ; for persistent HTL, should be visible in your shared library
path.
</para>

<para>
Provided that your environment is already configured for &LHCPP;, no furher
setup is required. If not, as a mininum your shared library path must
include the directory where the &HTL; library (and also &OBJ;, for
the persistent version) is located.
The scripts mentioned in the previous sections will update your library
path as well.
</para>

<para>
The examples executables are created in a <envar>$(OS)</envar>
subdirectory in each example directory.
</para>
</sect2>
</sect1>

<sect1>
<title>Structure of each example</title>

<para>
Each example directory contains two files: a GNUmakefile
to build the example and a source file containing the C++ code.
The source file typically defines an <quote>Application</quote> class
and a main program which instantiates that class and calls one or more
methods.
</para>

<programlisting font="footnotesize">
class Histo_App :
...
int main( int argc, char **argv )
{
 Histo_App app;
 app.init();
 app.run();
 app.commit();
}
</programlisting>

<para>
The <classname>Application</classname> class may inherit from
<classname>HepODBMS::HepDBApplication</classname> when working with
the persistent HTL examples. This allows the class to manage
transactions and so on. Apart from transaction issues, most examples
based on persistent HTL can be translated to transient HTL by changing
all occurrences of <literal>PHisto</literal> to
<literal>Histo</literal>
</para>
</sect1>

<sect1>
<title>One dimensional histograms</title>
<para>
The following example shows the creation, filling and line-printer
output of a 1D histogram and some of its attributes. The histogram
itself has weighted bins and an even partition. The histogram
is persistent - that is, it is stored in the database and remains
there after the job has completed.
</para>

<sect2>
<title>Input program</title>

<programlisting font="footnotesize">
&Histo1Din;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>

<informalexample>
<programlisting font="footnotesize">
&Histo1Dout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>One dimensional variable histograms</title>
<para>
The following example shows the use of a variable partition, but is
otherwise similar to the previous case.
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&Histo1DVarin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&Histo1DVarout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Two dimensional histograms</title>
<para>
The following example shows the use of a 2D histogram
with fixed partitions.
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&Histo2Din;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&Histo2Dout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Two dimensional variable histograms</title>
<para>
The following example shows the use of a 2D histogram
with variable partitions.
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&Histo2DVarin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&Histo2DVarout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Profile histograms</title>
<para>
The following example shows the use of profile historams.</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&HistoProfilein;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&HistoProfileout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Filling histograms with random numbers</title>
<para>
The following example shows cloning of and operations on histograms.</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&HistoRandomin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&HistoRandomout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Saving histogram as text table</title>
<para>
The following example shows how a histogram can be saved in a simple
text file that can subsequently be read by PAW, Excel or other common tool.
An example of a suitable PAW macro is also provided.
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&HistoTablesin;
</programlisting>
</sect2>

<sect2>
<title>PAW kumac for reading table</title>
<programlisting font="footnotesize">
&HistoTableskumac1;
</programlisting>
</sect2>

<sect2>
<title>PAW Macro to produce 1D HBOOK histogram from HTL ASCII table</title>
<programlisting font="footnotesize">
&HistoTableskumac2;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&HistoTablestxt;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Histogram naming</title>
<para>
The following example demonstrates the usage of histogram naming.
Histograms are first created and filled using a histogram factory and then located
by name and printed.
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&NameHistosin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&NameHistosout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Basic histogram operations</title>
<para>
The following example shows a number of basic histogram operations,
such as subtraction, multiplication etc.</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&Operationsin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&Operationsout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Read histograms</title>
<para>
The following example shows the creation of 3 persistent histograms
and the location of a particle histogram using a database scan.
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&ReadHistoin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&ReadHistoout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Create transient histograms</title>
<para>
The following example shows the use of transient histograms. 
</para>
<sect2>
<title>Input program</title>
<programlisting font="footnotesize">
&THistosin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>
<informalexample>
<programlisting font="footnotesize">
&THistosout;
</programlisting>
</informalexample>
</sect2>
</sect1>

<sect1>
<title>Create sliced projections</title>
<sect2>
<title>Input program</title>

<programlisting font="footnotesize">
&TSliceProjin;
</programlisting>
</sect2>

<sect2>
<title>Output Generated</title>

<informalexample>
<programlisting font="footnotesize">
&TSliceProjout;
</programlisting>
</informalexample>
</sect2>
</sect1>
</appendix>
</book>
<!-- 
*Total*	1108	14
affiliation	1	0
appendix	4	4
application	2	0
author	2	0
authorgroup	1	0
book	1	0
bookinfo	1	0
chapter	9	9
classname	52	0
command	12	0
contrib	1	0
emphasis	19	0
entry	20	0
envar	5	0
firstname	2	0
footnote	2	0
function	53	0
indexterm	1	0
informalexample	12	0
informaltable	1	0
interface	14	0
itemizedlist	5	0
listitem	95	0
literal	59	0
orderedlist	2	0
orgname	1	0
para	154	0
primary	1	0
programlisting	66	0
pubdate	1	0
quote	39	0
row	10	0
sect1	44	0
sect2	42	0
simpara	96	0
surname	2	0
table	1	1
tbody	2	0
term	76	0
tgroup	2	0
title	101	0
ulink	2	0
userinput	3	0
variablelist	12	0
varlistentry	72	0
xref	5	0
-->@
