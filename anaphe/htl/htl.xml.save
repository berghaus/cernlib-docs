<?xml version="1.0" encoding='ISO-8859-1'?> 
<!-- Changed by: Michel Goossens, 3-Apr-1999 -->
<!-- 	$Id: htl.xml,v 1.4 1999/04/15 11:31:51 goossens Exp goossens $	 -->
<!DOCTYPE document SYSTEM "minilatex.dtd"[
<!ENTITY quot "&#34;">
<!ENTITY percent "!PERCENT!">
<!ENTITY uuml "ü">
<!ENTITY Excel "Excel">
<!ENTITY GNU  "GNU">
<!ENTITY HBOOK "HBOOK">
<!ENTITY HEP  "HEP">
<!ENTITY HTL  "HTL">
<!ENTITY LHCPP  "LHC++">
<!ENTITY NICE "Nice">
<!ENTITY OBJ  "Objectivity/DB">
<!ENTITY PAW  "PAW">
<!ENTITY UNIX "Unix">
<!ENTITY WNT  "Windows/NT">
<!ENTITY XML  "XML">
<!ENTITY % misc.new "|minipage">
<!ELEMENT minipage (#PCDATA|includegraphics|caption)*>
<!ENTITY % likepara.new "|texonly|small">
<!ELEMENT texonly (#PCDATA|par|figure|ref)*>
<!ELEMENT small (#PCDATA|par|emph)*>
<!ENTITY % preformat.new "|alltt|listing|lprout">
<!ELEMENT alltt (#PCDATA|emph|ucom)*>
<!ELEMENT listing (#PCDATA)*>
<!ELEMENT lprout (#PCDATA)*>
<!ENTITY % xref.new "|vref">
<!ELEMENT vref     EMPTY>
<!ATTLIST vref     refid IDREF #REQUIRED>
<!ENTITY % inline.new "|ucom|code|sq">
<!ELEMENT code (#PCDATA)>
<!ELEMENT ucom (#PCDATA)>
<!ELEMENT sq (#PCDATA|code)*>
<!ENTITY nbsp " ">
]>
<document class="htl">
<frontmatter>
<title>HTL User Manual</title>
<author><name>Dino Ferrero Merlino</name><inst>CERN IT/ASD</inst>
<name>Savrak Sar</name>

<!--
This manual has been marked up using <emph>&XML;</emph> - the
eXtensible Markup Language.  (Is anything else relevent? Perhaps:

Pending the wide-spread availability of XML-capable browsers and
WYSIWYG editors, HTML and PostScript versions of this document have
been produced using ...
-->

<thanks>
HTL has benefited from the suggestions,
advice and help of many individuals. In particular,
Yemi Adesanya
and Jacub Moscicki are acknowledged for the development of the
existing HistOOgrams package and the templated prototype;
Dirk D&uuml;llman and
Marcin Nowak for help concerning &OBJ;;
Vincenzo Innocente for his version of templated histograms;
Olivier Couet and Michel Goossens for their general support.
</thanks>
</author>
</frontmatter>
<bodymatter>
<part>
<stitle>Getting started</stitle>

<!--1-->
<chapter id="H1Overview">
<stitle>Overview</stitle>

<section>
<stitle>What is HTL?</stitle>
<index item="CERNLIB"/>

<par>
The Histogram Template Library (&HTL;) is a C++ class library
that provides powerful histogramming functionality. As the name
suggests, it exploits the <emph>template</emph> facility of C++ and is
designed to be compact, extensible, modular and performant. As such it
only deals with histograms - i.e. binned data - and not unbinned or
"Ntuple" data. Furthermore, although simple file-based I/O and
"lineprinter" output are supported, it is decoupled from more advanced
I/O and visualisation techniques. In the context of &LHCPP;, such
capabilities are provided by other components that fully interoperate
with &HTL;. 
</par>

<par>
In the High Energy Physics (&HEP;) community, the &HBOOK; package has
been the <emph>de-facto</emph> standard for histogramming for many
years. This manual is written assuming a basic familiarity with the
&HBOOK; package. &HTL; itself offers the histogramming features of
&HBOOK; as well as a number of useful extensions, with an
object-oriented (O-O) approach. These features include the following:
</par>

<itemize>
<item>booking and filling of 1D, 2D and profile histograms;</item>
<item>computation of statistics like the mean or rms;</item>
<item>support for operations between histograms;</item>
<item>browsing of and access to characteristics of individual histograms.</item>
</itemize>

<par>This package replaces the histOOgrams package - an earlier C++ class library for
histograms. The major functional innovation over the previous package are
the support for different kinds of bins, the support of both
persistent and transient (i.e. in-memory) histograms at runtime and
the definition of an abstract histogram interface.
</par>

<par>As a result, it is now possible to work with transient
histograms and subsequently save some or all of them in a database as
persistent histograms in a very simple and natural way (thus
simulating so called explicit I/O). This clearly has significant performance advantages,
particularly in the area of filling operations.
</par>

<par>
It is also possible to work with transient histograms only. These
may be printed or stored in files - the latter using a simple ASCII table
format that can be readily used by widely available tools,
including &PAW; or &Excel;.
</par>

<par>
The definition of an abstract histogram interface allows functionality
that is provided by external packages, such as plotting or fitting, to be decoupled from the actual
implementation of the histogram. This feature paves the way for co-existence of different histogram packages
that conform to the abstract interface.
</par>
</section>
	<section>
	  <stitle>Use of templates</stitle>

<par>
Although &HTL; uses templates internally, a small set of 
`user-classes' are provided. These have a very familiar (i.e. &HBOOK;-like)
look-and-feel and eliminate the need for users to be exposed to templates.
</par>

<par>
Nevertheless, the package still requires adequate template support at the C++ compiler level.
More details are given in Appendix A.
</par>
</section>
<section>
<stitle>Motivation</stitle>

<par>

When the existing HistOOgram package was implemented, compilers that provided
adequate support for templates were not widely available. Templates and other modern
C++ features can offer significant advantages.
In the case of &HTL;, these can be summarised as:
</par>
<itemize>
<item>increased performance;</item>
<item>greater flexibility and maintainability;</item>
<item>the support of both persistent and transient histograms at runtime.
Both provide similar features and are generated from the same
source files;</item>
<item>a more O-O approach, which in turn results in better encapsulation and more decoupling.</item>
</itemize>
</section>
</chapter>

<!--2-->
<chapter id="H1HTLglance">
<stitle>HTL at a glance</stitle>

<par>
This chapter provides an overview of &HTL; features.  Example code
is based on the use of the non-templated classes that should be used in
typical analysis jobs.
The &HTL; package itself includes a complete set of working examples that 
can be used as a basis for building more complex applications. 
A description of these examples can be found in chapter <ref refid="H1Examples"/>.
</par>

<section>
<stitle>Booking and filling persistent histograms</stitle>

<par>
The basic operations of creating (booking) and filling histograms are shown below.
As the code fragments illustrate, these operations are performed using methods
that have the same basic signature as the equivalent &HBOOK; subroutines. The primary difference
is that the &HBOOK; histogram identifier (ID) is replaced by "smart pointers". 
These pointers indicate both the type of the histogram to which they refer (e.g. 1D, 2D)
and whether they are transient or not.
</par>

<par>
As will be familiar to all &HBOOK; users, the following information is specified
at booking time:</par>

<itemize>
<item>A character string or <emph>title</emph>, normally printed when the histogram
is displayed.</item>
<item>The number of bins.</item>
<item>The lower bound of the histogram axis.</item>
<item>The upper bound of the histogram axis.</item>
</itemize>

<par>For histograms of more than one dimension, the last three arguments are then repeated
for each dimension.</par>

<par>Shouldn't the methods be listed somewhere (here?) as in e.g. HBOOK????</par>

<par>The following example shows the booking and filling of a 1D histogram of 20 bins
and a 2D histogram of 50 bins in both X and Y axes.</par>

<verbatim>
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
#include "HTL/P_Histograms_2D.h" // Persistent histograms.
...
// Booking a 20 bin 1D histogram
 H_P_REF(P_Histo1D) histo1 = 
  new (db_) P_Histo1D("A 1D histogram",20,0.,40.);
// Booking a 50X50 bins 2D histogram
 H_P_REF(P_Histo2D) histo2 = 
  new (db_) P_Histo2D("A 2D histogram",50,5.,15.,50,5.,15.);

// Filling
 double x, w = 0.5;
 for( long i=0; i&lt;50000; i++ ) {
  x = -i*sin(float(i));
  histo-&gt;fill(x,w);
  histo2-&gt;fill(x,x,w);
 }
</verbatim>

<par>
As the current implementation uses &OBJ; to provide persistence, it
is assumed that the reader is familiar with the basic concepts 
of using an ODBMS. For example, any operations on persistent objects
must be performed in the context of a <emph>transaction</emph> and
a database session must have been established. The necessary code to perform
such operations has been omitted in the interests of clarify.</par>

<par>Although the basic histogram operations that are performed
in the above example will be clear to &HBOOK; users, the 
use of "smart-pointers" is differs from the traditional use of histogram IDs
and is worthy of note. Consider the following code fragment:
</par>

<verbatim>
H_P_REF(P_HISTO1D) histo1 = new ...
</verbatim>
<par>rather than</par>
<verbatim>
P_HISTO1D *histo1 = new ...
</verbatim>

<par>
In this piece of code,
<code>H_P_REF</code> is a smart pointer to a persistent histogram. As the previous
example shows, a smart pointer can be used as a
standard C++ pointer: that is, you can dereference it in the normal C++ manner:
</par>

<verbatim>
histo1-&gt;fill(...)
</verbatim>

<par>
In addition to the use of smart pointers, 
the <code>new()</code> operator should be studied. It is followed
by a so-called <emph>clustering hint</emph>. A clustering hint is
used to indicate where the persistent objects - histograms in this case -
should be physically located on persistent storage. The database attempts
to place new objects "close" to those referenced by the hint. In general,
the efficient use of clustering allows performance to be maximised, as objects
are transferred to and from disk and across the network in database pages.
Effective clustering minimises unecessary I/O and improves cache efficiency.</par>

<par>Finally, we note that the histograms created with
<code>new()</code> are not deleted with a corresponding
<code>delete()</code> operator. This would not only
delete the histogram in the running application <emph>but also</emph>
from persistent storage, which is presumably not the intention. 
</par>
</section>

<section>
<stitle>Booking and filling transient histograms</stitle>

<par>The previous example is now repeated for the case of transient histograms.
Once again, two histograms are created and filled. Largely speaking, the code 
required is identical to the persistent cases. The differences between the two
are discussed in futher detail below.</par>

<verbatim>
#include "HTL/T_Histograms_1D.h" // Transient histograms.
#include "HTL/T_Histograms_2D.h" // Transient histograms.
...
// Booking a 20 bin 1D histogram
 H_T_REF(T_Histo1D) histo1 = 
  new T_Histo1D("A 1D histogram",20,0.,40.);
// Booking a 50X50 bins 2D histogram
 H_T_REF(T_Histo2D) histo2 = 
  new T_Histo2D("A 2D histogram",50,5.,15.,50,5.,15.);

// Filling
 double x, w = 0.5;
 for( long i=0; i&lt;50000; i++ ) {
  x = -i*sin(float(i));
  histo-&gt;fill(x,w);
  histo2-&gt;fill(x,x,w);
...
delete (T_Histo1D *)histo1;
delete (T_Histo2D *)histo2;
</verbatim>

<par>
Transient histograms are normal, in-memory C++ objects. In theory,
standard C++ pointers should therefore be used. Nevertheless,
the use of smart pointers is recommended. For example, we write:
</par>

<verbatim>
H_T_REF(T_HISTO1D) histo1 = new ...
</verbatim>

<par>rather than</par>

<verbatim>
T_HISTO1D *histo1 = new ...
</verbatim>

<par>
Once again,
<code>H_T_REF</code> is a smart pointer: this time to a transient histogram. 
The use of a smart pointer is preferred as it enforces symmetry with its persistent
counterpart. This can be useful for a number of reasons, including for
simplification of the task of switching between the two modes.</par>

<par>We note that the <code>new()</code> operator is now the standard C++
one. In this case, it is necessary to also handle explicit deletion of the
histogram to avoid memory leakages.</par>

<par>In summary, the differences between transient and
persistent &HTL; usage requires only the selection of the
corresponding class and smart pointer names:
(<code>H_T</code> versus <code>H_P</code>).
</par>

</section>
<section>
<stitle>Making a transient histogram persistent</stitle>

<par>
As already mentioned, &HTL; makes it possible to use both
persistent and transient histograms at runtime in the same program.
</par>

<par>
Since operations on transient histograms are significantly faster than those on persistent
ones, a typical procedure would be as follows:
</par>
<enumerate>
<item>perform all of the desired operations on transient histograms (filling
in particular)</item>
<item>make persistent copies of these tranisent histograms.
</item>
</enumerate>
<par>This offers the "best of both worlds" - the performance of the transient
implementation plus the added value of persistence.</par>
<par>
To make a transient histogram <code>ph</code> persistent:
</par>
<enumerate>
<item>declare a persistent histogram
<code>ph</code> analogous to the transient counterpart,</item>
<item>use the <code>new</code> operator
as for the booking and then</item>
<item>pass the histo interface of <code>ph</code> to
the constructor of <code>ph</code>.
</item>
</enumerate>

<par>A persistent copy of the transient histogram now exists. These steps are
shown in the followng code fragment.</par>

<verbatim>
#include "HTL/T_Histograms_1D.h" // Transient histograms. 
#include "HTL/T_Histograms_2D.h" // Transient histograms. 
#include "HTL/P_Histograms_1D.h" // Persistent histograms. 
#include "HTL/P_Histograms_2D.h" // Persistent histograms. 

// Declare and define `th': 
 H_T_REF( T_Histo1D ) th = ... 

// Process `th', perform operations: 

// Copy `th' to the database, i.e. make `th' persistent: 
// 
H_P_REF( P_Histo1D ) ph = new (dbH ) P_Histo1D( *th ); 
// This create a persistent histo that is a clone (with data) of transient histo `th'. 
</verbatim>

<par>
We note that it is possible to create a persistent histogram out of
<emph>any</emph> histogram interface, be the source histogram transient or 
persistent itself.
</par>
</section>

<section>
<stitle>&HTL; histogram classes</stitle>

<par>
As described above, &HTL; is based on template classes which
allow very different types of histogram to be supported using the
smallest amount of code.
</par>

<par>
Nevertheless, the emphasis on usability has been maintained and hence
a small set of simple, easy-to-use simple &HBOOK;-like
classes are provided. It is expected that these classes will cover
most cases. The list of available classes is given below.
</par>

<par>Note that all of these classes are used in the same way.
For example, to book a histogram of a given type one uses:</par>

<verbatim>

// Use H_P_REF to refer to persistent classes, H_T_REF for transient ones

 H_x_REF(x_Histyyy) histo1 = 
  new x_Histoyyy( ...

// Use x_Histo1D for 1D Histogram, x_Histo2D for 2D Histogram,
// x_Histo2DVar for 2D histogram with variable binning etc.

</verbatim>

<par>e.g., to repeat the initial example:</par>

<verbatim>
 H_T_REF(T_Histo1D) histo1 = 
  new T_Histo1D("A 1D histogram",20,0.,40.);
</verbatim>

<subsection>
<stitle>Persistent classes</stitle>

<description>
<term><code>P_Histo1D</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and fixed binning;</item>
<term><code>P_Histo1DVar</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and variable
binning;</item>
<term><code>P_ProfileHisto1D</code></term>
<item>1D histogram with <code>Profile_Bin</code> and fixed binning;</item>
<term><code>P_ProfileHisto1DVar</code></term>
<item>1D histogram with <code>Profile_Bin</code> and variable
binning;</item>
<term><code>P_Histo2D</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and fixed binning;</item>
<term><code>P_Histo2DF</code></term>
<item>2D histogram with <code>Float_Weighted_Bin</code> and fixed binning;</item>
<term><code>P_Histo2DVar</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and variable binning.</item>
</description>

<par>
All classes store bin values/errors as doubles, except
<code>P_Histo2DF</code>, which stores them as floats (this class minimizes the
memory size when using very large 2D histograms).
</par>

<par>
Weighted bins are equivalent to &HBOOK; bins, Gravity bins store the
position of the bin center-of-mass, so that the position of the bin
center is more accurate when the bin count is low or the binning is
not optimal (at least in some cases).
More details on bin types will be given later.
</par>

<par>
Notice that profile histograms and 2D histograms with variable
binning were not available in &HBOOK;.
</par>
</subsection>
<subsection>
<stitle>Transient classes</stitle>

<description>
<term><code>T_Histo1D</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and fixed binning;</item>
<term><code>T_Histo1DVar</code></term>
<item>1D histogram with <code>Gravity_Bin_1D</code> and variable
binning;</item>
<term><code>T_ProfileHisto1D</code></term>
<item>1D histogram with <code>Profile_Bin</code> and fixed binning;</item>
<term><code>T_ProfileHisto1DVar</code></term>
<item>1D histogram with <code>Profile_Bin</code> and variable
binning;</item>
<term><code>T_Histo2D</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and fixed binning;</item>
<term><code>T_Histo2DF</code></term>
<item>2D histogram with <code>Float_Weighted_Bin</code> and fixed binning;</item>
<term><code>T_Histo2DVar</code></term>
<item>2D histogram with <code>Weighted_Bin</code> and variable binning.</item>
</description>

<par>
All notes relating to persistent classes are also valid for
transient classes.
</par>
</subsection>
</section>
<section>
<stitle>Accessing bin content, bin error, bin center</stitle>

<par>
A histogram stores its bins and allows to access their content,
error and center.
</par>

<description>
<term><code>h1D-&gt;bin(i).value();</code></term>
<item>Value of the bin indexed by <sq><code>i</code></sq>.</item>
<term><code>h1D-&gt;bin(i).error();</code></term>
<item>Error of the bin indexed by <sq><code>i</code></sq>.</item>
<term><code>h1D-&gt;bin_center(i);</code></term>
<item>center of bin index by <sq><code>i</code></sq>.</item>
</description>

<par>
Notice that the bin object can retrieve its content/error but
not its center; bins are simple containers, only the histogram
knows where they are mapped in the binning space.
</par>

</section>
<section>
<stitle>Line-printer and ASCII table output</stitle>

<par>
Printing a histogram in text mode is required in a number of
cases. For example, it can be useful for 
long batch jobs, where the user is mainly interested in checking
the quality of data.
</par>

<par>
&HTL; provides a text print helper for this purpose, that is largely
reused from the previous HistOOgrams packages.</par>

<par>The following example shows how the <code>print</code> method can
be invoked to generate a simple line-printer style representation of a histogram.</par>

<verbatim>
#include "HTL/H_Printout.h"  // Printing. 

H_T_REF(T_Histo1D) histot = 
  new T_Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
H_P_REF(P_Histo2D) histop = 
  new P_Histo1D("Persistent Histo_2D", 20, 0.0, 20.0 ); 
... 
H_Printout hp( cout ); 
hp.print( *histop ); 
hp.print( *histot ); 
delete (T_Histo1D *) histot; 
</verbatim>

<par>
The above example demonstrates the use of the abstract histogram
interface: the same helper object can print any histogram that conforms to
the interface, regardless of whether it is transient, persistent, 1D, 2D or so
forth.
</par>

<par>
In particular when working with transient &HTL;, it can be convenient to dump
a histogram in a simple ASCII table that can then be read by more or less
any tool (PAW, Excel, IRIS Explorer...) to plot or fit it.
</par>

<verbatim>
#include "HTL/H_HistoTable.h" 

H_T_REF(T_Histo1D) histo = new T_Histo1D("Histo_1D", 20, 0.0, 20.0 ); 
... 
HistoTable1D ht1 ("histo.txt"); 
ht1.write(*histo); 
delete (T_Histo1D *)histo; 
</verbatim>
</section>
</chapter>

<!--3-->
<chapter id="H1PartitionsBins">
<stitle>Partitions and Bins</stitle>

<section>
<stitle>Partitions</stitle>

<par>
The concept of a 
<sq>Partition</sq> was first introduced in the HistOOgrams package. 
A partition describes how one dimension of the
problem space is divided into intervals. If we're going to book a 50
bin histogram in the range <inlinemath>[0,50]</inlinemath>, a
partition object containing the number of bins and the interval limits
will describe completely how we divide such interval: a set of 50
sub-intervals of equal width.  This is what we call a <sq>Fixed</sq>
or <sq>Even</sq> partition.
</par>

<par>
I we book an histogram over the same range but we want to have for
instance 10 bins of variable widths, a partition containing the number
of bins, the lowest limit of each sub-interval and the highest limit
of the last sub-interval will describe completely how we divided the
<inlinemath>[0,50]</inlinemath> interval. This is what we call a
<sq>variable</sq> or <sq>Uneven</sq> partition.
</par>

<par>
An <emph>n-dimensional</emph> &HTL; histogram thus contains <emph>n</emph> partitions, one for
each axis. The only concern of a partition is to associate any ordered
1D space with a discreet numbered space. Thus it associates an
interval to a positive integer. A partition hence knows about the
width of the intervals, their lower point/bound or upper point/bound.
</par>

<par>
It is important to note that an &HTL; histogram delegates to
its partitions the task of locating a bin, for example:
</par>

<verbatim>
H_T_REF(T_Histo1D) histo = 
  new T_Histo1D("Transient Histo_1D", 20, 0.0, 20.0 ); 
... 
histo->partition().lower_point() 
histo->partition().bin_width(i) 
histo->partition().upper_point(i) 
</verbatim>
</section>
<section>
<stitle>Bins</stitle>

<par>
Bins mainly contain information about the content, the error and
possibly the center of the bin. Bin information is always accessed
through interface methods. &HTL; provides the following bins:
</par>

<description>
<term><code>Weighted_Bin</code></term> 
<item>class representing bins with weighted data points. 
By default the gravity center of these bins are the middle or center 
of the bin.</item>
<term><code>Gravity_Bin_1D</code></term>
<item>class representing bins with weighted data
points and that know how to determine the gravity center of the
bins. This new bin class allows us to have filling time statistics
as in the existing histogram package, but without having to compute
separate quantities at filling time. The other advantage is that in
case of bins with low counting, the information of the bin center
is more accurate that the middle of the bin.
<par>
Also, <code>Gravity_Bins</code> could provide more accurate
information in some cases of non-optimal binning. For instance, 
if you sample an integer variable in the range
<inlinemath>[0,[20</inlinemath> with a 20 bin histogram over the same
interval, the bin center is properly computed at the integer values,
while in a traditional histograms they would correspond to the closest
half integer.
</par></item>
<term><code>Profile_Bin</code></term>
<item>class representing bins that can average
another quantity.</item>
</description>

<par>
Note that bins only know about their contents. They couldn't
care less about where they are located in the histogram or about
their widths or bounds. They are just containees that happen to be
in a histogram container. Their layout within the histogram is
defined by the partition objects.
</par>
</section>
</chapter>

<!--4-->
<chapter id="H1VariablePartitionsandProfile">
<stitle>Histograms with variable partitions and Profile
histograms</stitle>

<section>
<stitle>Variable partition histograms</stitle>

<par>
HTL supports 1D and 2D histograms with variable partitions. The
partition(s) are specified as a vector of real numbers.
</par>

<subsection>
<stitle>Persistent case</stitle>

<verbatim>
P_Points_Vector my_points_on_X(10); // Vector of 10 real numbers 
my_points[0] = 0.0; my_points[1] = 1.0; 
my_points[2] = 3.5; my_points[3] = 4.0; 
my_points[4] = 5.5; my_points[5] = 9.0; 
my_points[6] = 10.; my_points[7] = 15.; 
my_points[8] = 19.; my_points[9] = 20.; 

H_P_REF(P_Histo1DVar) histo = 
  new (db_)  P_Histo1DVar( "Histo1DVar", my_points_on_X ); 

P_Points_Vector my_points_on_Y(10); 
my_points_on_Y[0] = 0.0; my_points_on_Y[1] = 1.0; 
my_points_on_Y[2] = 2.5; my_points_on_Y[3] = 4.0; 
my_points_on_Y[4] = 6.0; my_points_on_Y[5] = 9.0; 
my_points_on_Y[6] = 12.; my_points_on_Y[7] = 14.; 
my_points_on_Y[8] = 18.; my_points_on_Y[9] = 20.; 

H_P_REF(P_Histo2DVar) histo = 
  new (db_) P_Histo2DVar( "Histo2DVar", my_points_on_X, my_points_on_Y ); 
</verbatim>
</subsection>

<subsection>
<stitle>Transient case</stitle>

<verbatim>
T_Points_Vector my_points_on_X(10); // Vector of 10 real numbers 
my_points[0] = 0.0; my_points[1] = 1.0; 
my_points[2] = 3.5; my_points[3] = 4.0; 
my_points[4] = 5.5; my_points[5] = 9.0; 
my_points[6] = 10.; my_points[7] = 15.; 
my_points[8] = 19.; my_points[9] = 20.; 

H_T_REF(T_Histo1DVar) histo = 
  new (db_)  T_Histo1DVar( "Histo1DVar", my_points_on_X ); 

T_Points_Vector my_points_on_Y(10); 
my_points_on_Y[0] = 0.0; my_points_on_Y[1] = 1.0; 
my_points_on_Y[2] = 2.5; my_points_on_Y[3] = 4.0; 
my_points_on_Y[4] = 6.0; my_points_on_Y[5] = 9.0; 
my_points_on_Y[6] = 12.; my_points_on_Y[7] = 14.; 
my_points_on_Y[8] = 18.; my_points_on_Y[9] = 20.; 

H_T_REF(T_Histo2DVar) histo = 
  new (db_) T_Histo2DVar( "Histo2DVar", my_points_on_X, my_points_on_Y ); 
</verbatim>

<par>
Apart from the class names you will notice that the type of the vector
depends on the transient/persistent choice as well.
</par>
</subsection>
</section>

<section>
<stitle>Profile Histograms</stitle>

<par>
Profile histograms are implemented both with fixed and variable
partitions. The bin errors are computed as in &HBOOK;, but only the
<code>' '</code> and <code>'S'</code> options are supported.  However,
unlike in &HBOOK; these are not a booking time options; you can ask
each bin to compute either the Spread or the Spread/sqrt(N) error at
run-time.
</par>

<verbatim>
H_P_REF(P_ProfileHisto1D) histo = 
  new (db_) P_ProfileHisto1D("Profile",20,0.,1.); 
long i; 
double x; 
for( i=0; i&lt;50000; i++ ) { 
  x = drand48(); 
  histo->fill(x,x,1.); 
} 

for( i=0; i&lt;histo-&gt;bin_count(); i++ ) { 
  cout &lt;&lt; endl &lt;&lt; ". " &lt;&lt; setw(2) &lt;&lt; i &lt;&lt; ": " 
&lt;&lt; setw(9) &lt;&lt; histo->i_bin(i).value() &lt;&lt; " Error " 
&lt;&lt; setw(4) &lt;&lt; histo->i_bin(i).error(0) &lt;&lt; " Spread Error " 
&lt;&lt; setw(4) &lt;&lt; histo->i_bin(i).error(1); 
} 
</verbatim>

<par>
As you can see the <code>error()</code> method on the bin interface
allows to access a set of errors: in this case the
<code>Profile_Bin</code> class accepts either the 0 or 1 index, which
map respectively to Spread/sqrt(N) and Spread errors.
</par>

<par>
Profile histograms can be filled with weights, but use of negative
weights yield meaningless results. With weights different from 1. the
errors are calculated properly only for bins with non-zero spread, and
set to 0. for bins with zero spread (&HBOOK;-like).
</par>
</section>
</chapter>

<!--5-->
<chapter id="H1OperationsHistograms">
<stitle>Operations on histograms</stitle>

<section>
<stitle>What do histogram operations apply to?</stitle>

<par>
When performing an operation on a histogram, a package can
either create a new histogram or apply the operation directly on
the original one.
</par>

<par>
The first approach is used, for instance, by &HBOOK;. It preserves the
original histogram and creates a new entity on behalf of the user. HTL
takes the second approach: creating new objects on behalf of users is
a risky policy in C+ + (although quite common), since it could lead to
unnoticed memory leakages and it's even more difficult to manage when
an ODBMS is used to provide persistency. Thus histogram operations
always apply to an existing histogram object and it's up to the user
to make a copy of the original histogram first.
</par>

</section>
<section>
<stitle>Cloning a histogram</stitle>

<par>
HTL allows you to produce a new copy of an existing histogram using
the <code>clone</code> method of the <code>I_Histogram</code>
interface.  The first argument, if any, specifies where the histo
should be cloned, that is the clustering hint. By default the
clustering hint is the container that contains the source histo in the
persistent case and empty in the transient case. The last argument, if
any, specifies how the histo should be cloned:
</par>

<itemize>
<item>if it equals 0 then only the structure is cloned;</item>
<item>otherwise the data is also copied (default).</item>
</itemize>

<par>Example of cloning in the persistent and transient case follow.</par>

<verbatim>
* Persistent case */ 

H_P_REF(P_Histo1D) h1D = 
  new(db_)  P_Histo1D( "Histo1: parabolic function", 20,0.,20.); 
... 
// The persistent histogram will be cloned close to the original
// object (default behaviour) 
H_P_REF(P_Histo1D) clone_1D = h1D->clone();   // Clone 'h1D' structure and data
  
/* Transient case */ 

H_T_REF(T_Histo1D) h1D = 
  new T_Histo1D( "Histo1: parabolic function", 20,0.,20.); 
... 
H_T_REF(T_Histo1D) clone_1D = h1D->clone();   // Clone 'h1D' structure and data
</verbatim>

</section>
<section>
<stitle>Operations on histograms</stitle>

<par>Below is a list of methods implementing operations on
histograms.</par>

<subsection>
<stitle>Operations with scalars</stitle>

<description>
<term><code>void add( double x )</code></term>
<item>Add <sq><code>x</code></sq> to current histo.</item>
<term><code>void sub( double x )</code></term>
<item>Substract <sq><code>x</code></sq> from current histo.</item>
<term><code>void mul( double x )</code></term>
<item>Multiply <sq><code>x</code></sq> with current histo.</item>
<term><code>void div( double x )</code></term>
<item>Divide current histo by <sq><code>x</code></sq>.</item>
</description>

</subsection>
<subsection>
<stitle>Operations with another histogram</stitle>

<description>
<term><code>Ref_Like_Current add( const Ref_Like_Current &amp;other )</code></term>
<item>Add <sq><code>other</code></sq> histo to current histo.</item>
<term><code>void add( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current sub( const Ref_Like_Current &amp;other )</code></term>
<item>Subtract <sq><code>other</code></sq> histo from current histo.</item>
<term><code>void sub( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current mul( const Ref_Like_Current &amp;other )</code></term>
<item>Multiply <sq><code>other</code></sq> histo with current histo.</item>
<term><code>void mul( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current div( const Ref_Like_Current &amp;other )</code></term>
<item>Divide current histogram by <sq><code>other</code></sq> histo.</item>
<term><code>void div( const I_Histo &amp;other )</code></term>
<term><code>Ref_Like_Current binomial_div( const Ref_Like_Current &amp;other
)</code></term>
<item>Divide current histo by <sq><code>other</code></sq> histo using <sq>binomial error</sq></item>
<term><code>void binomial_div( const I_Histo &amp;other )</code></term>
</description>

<par>Notice that operations with another histogram exists with two
signatures, the first one allowing to directly assign the result of
an operation.</par>

<par>This is an example of code to add two histograms:</par>

<verbatim>
H_P_REF(P_Histo1D) histo1 = 
  new(db_)  P_Histo1D( "Histo1: parabolic function", 20,0.,20.); 
  ... 
  for (int i = 0; i &lt; 50000; i++) 
    histo1->fill(x,w); 

  // Now create a clone of histo1 
  H_P_REF(P_Histo1D) histo2 = histo1->clone(); 
  // Add histo1 to histo2 and change histogram name 
  histo2->add( *histo1 ); 
  histo2->set_name( "Histo2 =  Histo2+Histo1 = 2*Histo1" ); 
</verbatim>

<par>As discussed in the first paragraph, it's important to first
make a clone of the original histogram. Another way to clone a
histogram is using a copy constructor, as described in Chapter 
<ref refid="H1Constructors"/>.
</par>
</subsection>
</section>
</chapter>
</part>

<part>
<stitle>Advanced HTL</stitle>

<!--6-->
<chapter id="H1UsingHistogramFactories">
<stitle>Using histogram factories and naming trees (persistent HTL only)</stitle>

<section>
<stitle>Histogram factories</stitle>

<par>
According to ODMG rules persistent objects are created using a
<code>new()</code> operator with a clustering hint that specifies in which
database/container the object should be physically stored, for instance,
in the following example <code>histo1</code>
will be created in the database specified by the 
database handle <code>db_</code>.
</par>

<verbatim>
H_P_REF(P_Histo1D) histo1 = 
  new (db_) P_Histo1D("A 1D histogram",20,0.,40.);
</verbatim>

<par>
This syntax may look a bit unusual to novice users and is
difficult to understand by other preprocessors such as the SWIG
interface generator for scripting languages.
</par>

<par>
The <code>H_Factory</code> class overcomes this problem by letting the
user specify by name the database/container histogram in which it will
be generated and then use a factory method to actually create the
histograms. The following bit of code shows an example of Histogram Factory
usage.
</par>

<verbatim>
#include "HTL/H_Factory.h" 
... 
  H_Factory myFactory; 
  // Create histograms in DataBase "gepo", Container "sbaffini" 
  if (myFactory.init(this,"gepo","sbaffini")) { 
    // Create a histogram using the factory 
    H_P_REF(P_Histo1D) h1 = myFactory.Histo1D("Histo-1",noBins,0.0,20.0); 
   ... 
   h1->fill(x, 1.); 
</verbatim>

<par>
The <code>H_Factory</code> class provides a method to generate all
useful types of histograms. The factory methods are named according to
the histogram type and take parameters according to the corresponding
constructor.
</par>

<verbatim>
int init (HepDbApplication *sess, char *dbname,  char *contname = 0); 
H_P_REF(P_Histo1D) Histo1D (const char *a_title, Size n, double x1, 
              double x2, End_Point_Convention epc = RIGHT_OPEN);
H_P_REF(P_Histo1DVar) Histo1DVar(const char *,P_Points_Vector &amp;,
              End_Point_Convention epc = RIGHT_OPEN );  
H_P_REF(P_ProfileHisto1D) ProfileHisto1D (const char *a_title, Size n,
              double x1, double x2, End_Point_Convention  epc =
              RIGHT_OPEN ); 
H_P_REF(P_ProfileHisto1DVar) ProfileHisto1DVar(const char *,
              P_Points_Vector &amp;, End_Point_Convention epc = RIGHT_OPEN );  
H_P_REF(P_Histo2D) Histo2D (const char *, Size , double  , double ,
              Size , double  , double , End_Point_Convention  epc1 =
              RIGHT_OPEN , End_Point_Convention  epc2 = RIGHT_OPEN );  
H_P_REF(P_Histo2DVar) Histo2DVar( const char *, P_Points_Vector &amp;,
              P_Points_Vector &amp;, End_Point_Convention  epc1 =
              RIGHT_OPEN, End_Point_Convention   epc2 = RIGHT_OPEN );  
</verbatim>
</section>

<section>
<stitle>Naming histograms</stitle>

<par>
The HepODBMS package provides a logical naming structure on top of
Objectivity's physical structure. The HepODBMS naming package creates
and maintains a naming tree similar to file-system trees, with
directories and <sq>final objects</sq> (equivalent to files in a
file-system).
</par>

<par>
The HepODBMS naming package assumes each user is given a personal
naming tree which starts in a <sq>home directory</sq> like
structure. In practice each user is given a home directory named after
his user name under the common directory <code>/usr</code>.
</par>

<par>
A typical application of HepODBMS would be to name HTL histograms with
a symbolic <code>ID</code> and store them in separate directories
(much like the current &HBOOK; tree structure).
</par>

<par>
Although users can rely on the HepODBMS classes to name HTL
histograms, we provided a simple <code>Factory</code> class which
extends the basic <code>H_Factory</code> with naming
capabilities. Using this extended factory class, users can choose
where to store histograms and name them according to their favourite
scheme.
</par>

<par>
The following bit of code shows how to name HTL histograms
in a naming tree.
</par>

<verbatim>
#include "HTL/H_Naming_Factory.h" 
... 
  H_Naming_Factory myFactory(H_Naming_Factory::Override); 
  // Create histograms in DB "gepo", Container "sbaffini" and name
  // them in /usr/dinofm/Histograms/MC (dinofm is my user name) 
  if (myFactory.init(this,"Histograms/MC","gepo","sbaffini")) { 
    // Create two histograms. They're named 10 and "pt" in the name tree 
    H_P_REF(P_Histo1D) h1 = myFactory.Histo1D(10,"Histo-1",noBins,0.0,20.0); 
    H_P_REF(P_Histo1D) h2 = myFactory.Histo1D("pt","Histo-2",noBins,0.0,20.0); 
    ... 
    h1->fill(x, 1.); 
    h2->fill(x, 2.); 
</verbatim>

<par>
Histograms can then be retrieved as follows.
</par>

<verbatim>
/usr/dinofm/Histograms/MC/10
/usr/dinofm/Histograms/MC/pt
</verbatim>

<par>
Notice that the naming tree is case sensitive (like &UNIX; and unlike
&HBOOK;!). Histograms can be named with a character string such as
<sq><code>pt</code></sq> or with an integer code like 10 (similar to
&HBOOK;'s histogram identifier <code>ID</code>).
</par>

<par>
If the histogram you create already exists, <code>H_Naming_Factory</code>
can either override the previous histogram or refuse to create the
new one depending on the strategy specified when the factory was
declared.
</par>

<par>
If you want the factory to override existing histograms, you should write:
</par>

<verbatim>
 H_Naming_Factory myFactory(H_Naming_Factory::Override);
</verbatim>
<par>
whereas, when factory has to keep existing histograms, the new histogram is
not allocated, and you write something like the following:
</par>

<verbatim>
 H_Naming_Factory myFactory(H_Naming_Factory::Keep);
</verbatim>

<par>
The Override directive is useful, for instance when running in batch
or when debugging your program: old histograms are replaced by new
ones. The <code>Keep</code> mode allows one to protect against
destroying useful data. No more sophisticated strategies, such as
cycles or versions, are implemented at present.
</par>

</section>

<section>
<stitle>Retrieving named histograms</stitle>

<par>
Once the histograms have been saved and named in an Objectivity
data store users will want to retrieve them. The <code>H_Locator</code>
class allows you to retrieve an histogram by name, as follows:
</par>

<verbatim>
#include "HTL/H_Locator.h" 
... 
  // Locate Histograms pt and 10 
  H_Locator myLocator; 
  H_Printout hp(cout); 
  myLocator.init(this); 
  H_P_REF(P_Histo1D) h = myLocator.Histo1D("pt"); 
  if (h != 0) 
    hp.print(*h); 
  h = myLocator.Histo1D(10); 
  if (h != 0) 
    hp.print(*h); 
</verbatim>

<par>
Notice that the <code>H_Locator</code> class provides methods to
retrieve different kinds of histograms (so users should know what
they are retrieving). Type checking is thus guaranteed and if the
expected histogram type does not match the real one, an error message
is printed and the return value is zero.
</par>
</section>
</chapter>

<!--7-->
<chapter id="H1UsingInterfaces">
<stitle>Using interfaces</stitle>

<par>
Interfaces are a powerful OO concept which allows designers to
decouple what an object does from its actual implementation. This
reduces the impact on <sq>external</sq> software using such object(s) and
makes software reuse more realistic.
</par>

<par>
In the C++ world, interfaces are usually implemented by abstract
classes with virtual methods. In this context the only drawback of
interfaces might be a performance penalty due to the extra
indirection required by virtual functions, but we should not
neglect the usefulness of interfaces just because of that.
</par>

<section>
<stitle>Interfaces in HTL</stitle>

<par>
HTL defines and implements abstract interfaces for most of its
functionalities. The only method which is not available on purpose at
the interface level is the <code>fill()</code> method, which must be
implemented as an non-virtual inline method to provide the highest
performance (see Appendix <ref refid="H1APPerformance"/> for details).
</par>

<par>
HTL interfaces are used by other packages such as fitting (HEPFitting)
and visualisation (HEPInventor) that are thus independent from the
actual HTL implementation of histograms. Interfaces are what allows
external packages to deal with transient and persistent HTL histograms
at the same time. Using such interfaces we might even implement an
HTL-like package based on other technologies, for instance an HTL
interface to &HBOOK;, although this is not envisaged at present.
</par>

<subsection>
<stitle>The <code>I_Histo</code> interface</stitle>

<par>
<code>I_Histo</code> is the high-level interface to histograms. The following
is a list of supported methods.
</par>

<description>
<term><code>virtual const char* name()</code></term>
<item>Title attached to current histogram.</item>
<term><code>virtual I_Bin&amp; i_bin( I_Bin_Location &amp;a_location )</code></term>
<item>In-range bin associated with location <code>a_location</code>.</item>
<term><code>virtual I_Bin&amp; i_extra_bin( I_Extra_Bin_Location
&amp;a_location )</code></term>
<item>Extra bin associated with extra location <code>a_location</code>.</item>
<term><code>virtual Size bin_count()</code></term>
<item>Number of in-range bins.</item>
<term><code>virtual Size extra_bin_count()</code></term>
<item>Number of extra bins.</item>
<term><code>virtual Size dim()</code></term>
<item>Dimension of the histo, i.e., of the problem space.</item>
<term><code>virtual I_Partition&amp; i_partition( Index p = 0 )</code></term>
<item>Partition interface associated with this histo. 
For the first partition one has <code>a_dim_index = 0</code>.</item>
<term><code>virtual I_Bin&amp; i_bin( Index i )</code></term>
<item>Any bin (in-range or extra) with index <sq><code>i</code></sq>
(note that this is a linear access).</item>
</description>

<par>
The <code>I_Histo</code> interface can retrieve the number of bins
that are in-range or out-range, for instance, overflow or underflow,
as well as the number of partitions (i.e. the dimensionality of the
histogram). It also allows you to access other interfaces such as
<code>I_Partition</code> and <code>I_Bin</code>. 
</par>

<par>
On the other hand, the <code>I_Histo</code> interface does not try to
provide all information in a single interface: details about binning
and bin content are delegated, respectively, to the <code>I_Partition</code>
and <code>I_Bin</code> interfaces, as explained later.
</par>
</subsection>
<subsection>
<stitle>The <code>I_Partition</code> interface</stitle>

<par>
The <code>I_partition</code> interface deals with binning details,
such as, which interval of the problem space a bin is mapped to, that
is where does it start and end, and what are the limits of the range
spanned by the partition.  The following is a list of supported
methods.
</par>

<description>
<term><code>End_Point_Convention end_point_convention()</code></term>
<item>End point convention for all bins; can be either 
<code>RIGHT_OPEN</code> or <code>LEFT_OPEN</code>.</item>
<term><code>virtual double i_bin_width( Index i )</code></term>
<item>Width of in-range bin <sq><code>i</code></sq>.</item>
<term><code>virtual double i_lower_point()</code></term>
<item>Leftmost point of the partition.</item>
<term><code>virtual double i_lower_point( Index i )</code></term>
<item>Leftmost point of bin indexed by <sq><code>i</code></sq>.</item>
<term><code>virtual double i_upper_point()</code></term>
<item>Rightmost point of the partition.</item>
<term><code>virtual double i_upper_point( Index i )</code></term>
<item>Rightmost point of bin indexed by <sq><code>i</code></sq>.</item>
</description>
</subsection>

<subsection>
<stitle>The <code>I_Bin</code> interface</stitle>

<par>
The <code>I_Bin</code> interface allows you to set or get the content of
a bin, its count information, and its error.
The available methods are listed below.</par>

<description>
<term><code>virtual double value( Index i = 0)</code></term>
<item>Value associated with this bin.</item>
<term><code>virtual double error( Index i = 0)</code></term>
<item>Error associated with this bin.</item>
<term><code>virtual Size count()</code></term>
<item>Count associated with this bin. = Number of entries.</item>
<term><code>virtual void set_value( double other, Index i = 0 )</code></term>
<item>Set the value associated with this bin to <sq><code>other</code></sq>.</item>
<term><code>virtual void set_error( double other, Index i = 0 )</code></term>
<item>Change/set the error of the bin to <sq><code>other</code></sq>.</item>
<term><code>virtual void set_count( Size other )</code></term>
<item>Change/set the count of the bin to <sq><code>other</code></sq>.</item>
<term><code>virtual double center( Index i = 0)</code></term>
<item>Absolute or relative center of this bin on axis <sq><code>i</code></sq>.</item>
<term><code>virtual int offset( Index i = 0)</code></term>
<item>Relative or absolute position for the center of the bin.</item>
</description>
</subsection>
</section>

<section>
<stitle>Example using Interface classes</stitle>

<par>
This example is taken from the HEPInventor visualisation package
(although it's actually a subset of working code). The method receives
an <code>I_Histo</code> reference which is then used, for instance, to
find out whether this is a 1D or 2D histogram. Via the same
<code>I_Histo</code> reference, the code retrieves an interface to the
underlying partition, which gives information about the beginning and
end of each bin. At the end, the <code>I_Bin</code> interface of each
bin allows us to retrieve the content and the error associated to each
bin.
</par>

<verbatim>
HIData::HIData(I_Histo &amp;histo) { 
  int i,j,k=0; 
  switch (histo.dim()) { // Is it 1D or 2D? 
  case 1: 
    // Copy the histogram content in a local data structure 
    nptx       = histo.bin_count(); 
    // Use underlying histo.i_partition() interface 
    Xval[0]    = histo.i_partition(0).i_lower_point(0); 
    Yval[0]    = histo.i_bin(0).value(); 
    // Had to patch this... no asymmetric errors yet... 
    EXval[0]   = (histo.i_partition(0).i_lower_point(1)-Xval[0])/2.; 
    EYval[0]   = histo.i_bin(0).error(); 
    for ( i=1; i &lt; nptx; i++) { 
      Xval[i]  = histo.i_partition(0).i_lower_point(i); 
      // Use I_Bin interface to retriev value/error 
      Yval[i]  = histo.i_bin(i).value();  
      EYval[i] = histo.i_bin(i).error(); 
    } 
  } 
} 
</verbatim>

<par>
As you can see there is no reference whatsoever to the real C++
type of the histogram, to its dimensionality, etc. The same code
works with all HTL histograms!
</par>

</section>
</chapter>

<!--8-->
<chapter id="H1Constructors">
<stitle>Constructors</stitle>

<section>
<stitle>Types of constructors</stitle>

<par>
HTL provides more constructors than the current package and allows us
to define and create new histograms out of transient or persistent
ones in a nice and natural way.
</par>

<par>
Three kinds of constructor are defined for any histogram
class.
</par>

<par>
The first kind of constructor is the classic one used for the booking.
Arguments reflect the type of the histogram, for instance, 1D or 2D,
fixed or variable bin size, etc. An example is the following:
</par>

<verbatim>
T_Histo1D( const char *a_title, Size nBins, double lowX, double
           highX, End_Point_Convention epc = RIGHT_OPEN )
</verbatim>

<par>
The second kind of constructor is a copy constructor. The first
argument must be a histo of the same type. The optional second
argument specifies whether we want to copy the structure only (the
argument must equal 0) or the structure as well as the data also.
(This is the default - argument non 0).
</par>

<verbatim>
T_Histo1D( Like_Current &amp;a_histo, int copy_data = 1 )
</verbatim>

<par>
<code>Like_Current</code> is a typedef and designates the real type of
the current histogram class with all its template arguments.
</par>

<par>
The third kind of constructor is a variant of a copy constructor. It
makes it possible to create a new histogram out of a histo interface. It
is particularly useful to create persistent histograms from
transient ones. The optional second argument for data copying is also
available.
</par>

<verbatim>
P_Histo1D( const I_Histo &amp;a_histo, int copy_data = 1 )
</verbatim>

</section>
</chapter>

<!--9-->
<chapter id="H1RetrievingStatistics">
<stitle>Retrieving statistics and entries information</stitle>

<section>
<stitle>Shortcuts</stitle>

<par>
1D histograms implement shortcut methods to retrieve mean and
RMS of a histogram, as follows:
</par>

<verbatim>
H_T_REF(T_Histo1D) h1D = 
  new T_Histo1D("Histo1: parabolic function",20,0.,20.);
...
cout &lt;&lt; "Mean " &lt;&lt; h1D-&gt;mean() &lt;&lt; " RMS " &lt;&lt; h1D-&gt;rms() &lt;&lt; endl;
</verbatim>
</section>
<section>
<stitle>General method</stitle>

<par>
HTL implements retrieval of statistics and entries information via
separate helper classes. The helper class is called
<code>H_Statistics</code> and it allows us to decouple computation
of statistics and entries information from the implementation
of the histogram.
</par>

<verbatim>
#include "HTL/H_Statistics.h"  // Computing statistics. 

H_T_REF(T_Histo1D) h1D = 
  new T_Histo1D("Histo1: parabolic function",20,0.,20.); 

... // filling 

// Now display some statistics: 
// 
long in_entries = H_Statistics::in_range_entries_count(*histo); 
long extra_entries = H_Statistics::extra_entries_count(*histo); 
cout &lt;&lt; "Entries count: " &lt;&lt; (in_entries + extra_entries) 
 &lt;&lt; " with IN_RANGE: " &lt;&lt; in_entries 
 &lt;&lt; " EXTRA: " &lt;&lt; extra_entries &lt;&lt; endl; 

double mean = H_Statistics::mean( *histo ); 
cout &lt;&lt; "MEAN (B.C.): " &lt;&lt; mean &lt;&lt; endl; 
cout &lt;&lt; "RMS  (B.C.): " &lt;&lt; H_Statistics::rms(*histo, mean) 
 &lt;&lt; endl &lt;&lt; endl; 
</verbatim>
</section>
</chapter>

<!--10-->
<chapter id="H1Examples">
<stitle>Examples</stitle>

<section>
<stitle>List of available examples</stitle>

<par>
A set of HTL examples can be found in the directory 
<url name="file:/afs/cern.ch/sw/lhcxx/share/HTL/dev/HTL/examples"/>.
</par>

<description>
<term><code>Histo1D</code></term>
<item>create persistent 1D histogram with fixed binning;</item>
<term><code>Histo2D</code></term>
<item>create persistent 2D histogram with fixed binning;</item>
<term><code>HistoProfile</code></term>
<item>create persistent 1D profile histogram with fixed binning;</item>
<term><code>HistoTables</code></term>
<item>produce ASCII tables to export HTL histograms to, e.g., PAW;</item>
<term><code>Operations</code></term>
<item>histogram cloning and histogram operations;</item>
<term><code>THistos</code></term>
<item>create transient 1D/2D histograms with fixed binning;</item>
<term><code>Histo1DVar</code></term>
<item>create persistent 1D histogram with variable binning;</item>
<term><code>Histo2DVar</code></term>
<item>create persistent 2D histogram with variable binning;</item>
<term><code>HistoRandom</code></term>
<item>use of CLHEP random generators;</item>
<term><code>NameHistos</code></term>
<item>naming persistent histograms;</item>
<term><code>ReadHisto</code></term>
<item>reading back histograms from Objectivity/DB datastore;</item>
<term><code>TSliceProj</code></term>
<item>slice/projections of a 2D histogram.</item>
</description>
</section>

<section>
<stitle>Setting up for using the examples</stitle>

<subsection>
<stitle>Defining your environment</stitle>

<par>
When you are running in an environment created by the LHC++ setup
procedure (see
<url name="http://wwwinfo.cern.ch/asd/lhc++/lhcppguide/SetUpUserEnvironment.html"/>) 
all environment variables needed by HTL will be already in place.
</par>

<par>
If you are not running in such an environment, you will have to set 
the HTL environment variables up yourself, since the GNUmakefiles for
running the examples assume that the following environment
variables are defined correctly:
</par>

<itemize>
<item><code>LHCXXTOP</code></item>
<item><code>PLATF</code></item>
<item><code>HEP_ODBMS_DIR</code></item>
<item><code>HISTOODIR</code></item>
</itemize>

<par>
If they are not defined the following settings are likely to
work at CERN:
</par>

<verbatim>
setenv LHCXXTOP /afs/cern.ch/sw/lhcxx
setenv PLATF @sys
setenv HEP_ODBMS_DIR $LHCXXTOP/specific/$PLATF/HepODBMS/dev51
setenv HISTOODIR $LHCXXTOP/specific/$PLATF/HTL/dev
</verbatim>

<par>
The above syntax is for C-shell flavours, while on Bourne shell
flavours you should use:
</par>

<verbatim>
LHCXXTOP=/afs/cern.ch/sw/lhcxx
export LHCXXTOP
...
</verbatim>

<par>
If you are using persistent HTL your &OBJ; environment should be
properly defined as well.
</par>
</subsection>

<subsection>
<stitle>Building the examples</stitle>

<par>
Make a local copy of the examples directory and run
<code>gmake</code>, as follows:
</par>

<alltt>
<ucom>cp -r /afs/cern.ch/sw/lhcxx/HTL/dev/HTL/examples .</ucom>
<ucom>cd examples</ucom>
<ucom>gmake</ucom>
</alltt>

<par>
These commands will build all examples in one go. You can build
examples separately by running <code>gmake</code> in each
subdirectory.
</par>

</subsection>

<subsection>
<stitle>Running the examples</stitle>

<par>
HTL is provided as shared libraries on most platforms. This means HTL
libraries and any other shared library used by HTL, such as HepODBMS
and &OBJ; for persistent HTL, should be visible in your shared library
path.
</par>

<par>
Let us emphasise one more that if you are running in an environment
created by the LHC++ setup procedure then there is nothing to do,
otherwise you must modify your shared library path to make sure that
such libraries are visible.
</par>

<par>
The examples executables are created in a <code>$(OS)</code>
subdirectory in each example directory.
</par>
</subsection>
</section>

<section>
<stitle>Structure of each example</stitle>

<par>
Each example directory contains two files: a GNUmakefile
to build the example and a source file containing the C++ code.
The source file typically defines an <sq>Application</sq> class
and a main program which instantiates that class and calls one or more
methods.
</par>

<verbatim>
class Histo_App :
...
int main( int argc, char **argv )
{
 Histo_App app;
 app.init();
 app.run();
 app.commit();
}
</verbatim>

<par>
The <sq>Application</sq> class may inherit from
<code>HepODBMS::HepDBApplication</code> when working with the
persistent HTL examples. This allows the class to manage transactions
and so on. Apart from transaction issues, most examples based on
persistent HTL can be translated to transient HTL by changing all
occurrences of <code>H_T</code> to <code>H_P</code>
</par>
</section>
</chapter>
</part>

<appendix>

<!--A-->
<chapter id="H1APSupportedCompilers">
<stitle>Supported compilers</stitle>

<par>
The list of supported compilers on a given platform follows
</par>

<description>
<term>Solaris</term><item>CC 4.2</item>
<term>HP-UX</term><item>aCC A.01.15</item>
<term>Linux</term><item>egcs 1.1.1 with patch for 
  persistent templates specialization</item>
<term>Digital Unix</term><item> cxx V6.1-027</item>
<term>AIX </term><item>xlC 3.1.?</item>
<term>Windows/NT</term><item>VC++ 5.0 SP3</item>
</description>
</chapter>

<!--B-->
<chapter id="H1APStatisticsErrorPropagation">
<stitle>Statistics and error propagation</stitle>

<section>
<stitle>Histogram statistics</stitle>

<par>
HTL implements histogram statistics as bin content statistics
only.
</par>

<verbatim>
Mean = SUM[ bin center * bin value ] / SUM[ bin value ]
RMS = SUM[ (bin center - mean)^2 * bin value ] / SUM[ bin value ]
</verbatim>

<par>
Since the <code>Gravity_Bin</code> used in 1D HTL histograms keeps the
weighted center of the bin, those quantities are equal to so-called
<sq>filling time statistics</sq> computed by &HBOOK; and HistOOgrams.
</par>
</section>

<section>
<stitle>Bin errors</stitle>

<par>
Bin errors are always computed taking weights into account.
</par>

<verbatim>
error = sqrt( SUM[ weight*weight ])
</verbatim>

<subsection>
<stitle>Bin error <sq>propagation</sq> for histogram operations</stitle>

<par>
Depending on histogram operations, bin errors are combined in
the error of the resulting bin. Formulas should be equivalent to
the ones used in &HBOOK;.
</par>
</subsection>

<subsection>
<stitle>Synopsis</stitle>

<description>
<term><code>error_</code></term>
<item>error of the first bin, <code>other.error()</code> 
is the error of the second bin;</item>
<term><code>value_</code></term>
<item>value of the first bin, <code>other.value()</code> is the error of
the second bin.</item>
</description>

<verbatim>
 void add( const Like_Parent &amp;other ) 
  error_ =  other.error()*other.error() + error_ ; 

void sub( const Like_Parent &amp;other ) 
  error_ = other.error() * other.error() + error_ ; 

void mul( const Like_Parent &amp;other ) 
  error_ = error_ * other.value()*other.value() +  
           other.error()*other.error() * value_*value_ ; 

void div( const Like_Parent &amp;other ) 
  e = pow(other.error(),4) ;
  error_ = error_ * other.value()*other.value() +  
           other.error()*other.error() * value_*value_ ; 
  if( e != 0 ) 
    error_ = ( error_/e ); 

void binomial_div( const Like_Parent &amp;other ) 
  e = other.error()*other.error() ;
  error_ = sqrt( error_ / e ); 
  error_ = error_ * (1-error_); 
  error_ = error_ * error_; 
  error_ = ( error_ / e ); 
</verbatim>
</subsection>
</section>
</chapter>

<!--C-->
<chapter id="H1APPerformance">
<stitle>Performance</stitle>

<section>
<stitle>Introduction</stitle>

<par>
Most of the time the performance of an histogramming package is not
important: if your batch job takes 4 hours of CPU you should not
really care if histogram filling takes 10 seconds or 100 seconds.
On the other hand there are applications where users really expect a
good performance (such as online monitoring).
</par>

<par>
The HistOOgram package, which &HTL; replaces, was not optimised for 
performance, but rather was designed for speed but
for maximum flexibility. In addition, early benchmarks of this package
were performed on a pre-release and should be considered unrepresentative.
</par>

<par>
Experience shows exists always a tradeoff between higher performance
and maximum flexibility, but most of the time a reasonable compromise
can be found, since performance is usually required only in well
defined areas of code.
</par>

<par>
A often-heard rule of thumb states that in most cases an application
spends 80&percent; of its time in 20&percent; of the code. Hence the
right approach is to estimate what the critical part of the code is,
identify the most appropriate algorithms (which are more difficult to
change than code), and finally measure the performance with a proper
tool, such as a code profiler. To write ugly and unmaintainable code
just because it is thought to be faster is not an effective approach.
</par>

<par>
That procedure was followed for HTL. We first identified the critical
code, and obviously it turned out to correspond to the filling
methods, which can be called millions of times. We then identified a
technique to speed up filling by using templated classes (see for
instance the Blitz++ libraries for a discussion about templates and
C++ performance). Finally, once the package was working, we measured
the performance and tuned it using a simple code profiler.
</par>

<par>
Below we present the results of a comparison with &HBOOK;, which is
not intended as a complete test but rather is used as a benchmark
reference. Anyone interested in measuring the performance of HTL down
to the millisecond level can be provided with the source code used for
the benchmark tests.
</par>
</section>

<section>
<stitle>Comparison between &HBOOK;, HistOOgrams, and HTL</stitle>

<subsection>
<stitle>Description of the benchmark</stitle>

<par>
A set of 10 histograms with fixed binning is filled with 50000 points
each.  The benchmark is focused on filling performance. The I/O part
is neglected since histograms are pretty small objects. It would be
anyway difficult to assess the I/O overhead, since &OBJ; transactions
ensure that buffers are synced on disk, while &HBOOK; I/O does not.
In the &HBOOK; case, timing is measured with the CERNLIB routine
<code>TIMED</code>. The C++ benchmark reports real time as measured by
RD45's <code>Timer</code> class.  HTL histograms are based on gravity
bins, so they harvest more information than their &HBOOK; counterpart,
and thus use CPU.
</par>
</subsection>

<subsection>
<stitle>Results of the benchmark</stitle>

<par>
The target machine used for the test was a Sparc Ultra:
</par>

<verbatim>
SunOS sunasd1 5.5.1 Generic_103640-12 sun4u sparc SUNW,Ultra-30
</verbatim>

<par>
The compilers used were the following: <code>C++ V 4.1</code> for
HistOO, <code>C++ V4.2</code> for HTL, and <code>f77 4.2</code> for
&HBOOK;.
</par>

<par>
The results are summarised in the table below.
</par>

<par>
<tabular preamble="@{}ll@{}">
<row><cell>&HBOOK;</cell><cell>860 ms</cell></row>
<row><cell>Transient HTL</cell><cell>790 ms</cell></row>
<row><cell>HistOO</cell><cell>3600 ms</cell></row>
<row><cell>Persistent HTL</cell><cell>2700 ms</cell></row>
<row><cell>Persistent HTL(fast-filling)</cell><cell>1150 ms</cell></row>
</tabular>
</par>

<par>
The timing on the second line of the persistent &HTL; case is for a
version optimised by using a fast filling method.
</par>

<par>
It should also be stressed that the &HTL; package allows you to create a
persistent Histogram out of a transient one so that it is possible
to work in a mixed mode: first histograms can be created
and filled as transient, and only at the end saved as persistent.
Thus one combines the advantages of a fastest possible filling 
with the those of profiting of object persistency.
</par>
</subsection>
</section>

<section>
<stitle>Conclusion</stitle>

<par>
&HTL; transient histograms are slightly faster than comparable &HBOOK;
ones, even though they provide the user with more accurate information
about bin centers.
</par>

<par>
&HTL; persistent histograms are slower. It would be possible, using
more advanced &OBJ; techniques such as
fast-filling methods and pinning in memory, to make them
almost as fast as transient ones. However, a more practical approach
in most cases is the use of transient histograms for repetitive operations such as
filling, combined with persistent copies of the filled histogram for storage.
</par>

<par>
When raw performance is absolutely crucial, faster &HTL; histograms 
are also available. However, they do not provide filling time statistics.
</par>

<par>
Since &HTL; allows you to mix persistent and transient histograms, the
optimal strategy when performance is an issue is to book and fill
transient histogram and save them at the end of the run using the
persistent histogram <code>copy</code> constructors (as explained in
chapter <ref refid="H1HTLglance"/>).
</par>

</section>
</chapter>

<!--D-->
<chapter id="H1APPrunexamples">
<stitle>Running the examples</stitle>

<section>
<stitle>One dimensional histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* create_Histo1D.cpp */
#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
// AIX workaround ...
#ifdef _AIX
#include "HTL/P_Histograms_2D.h"
#endif
#include "HTL/H_Statistics.h" 	// Computing statistics.
#include "HTL/H_Printout.h" 	// Computing statistics.

class Histo_App : public HepDbApplication
{
public:
	Histo_App( const char *a_db_name = 0 )
	{ db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
		// If no database name is provided then the default one is 
		// "Default_DB".

public:
	void run();
		// Create a 1D histo named "Histo 1D" and fill it.
		// Print simple properties and global statistics.

public:
	void init();

private:
	ooHandle(ooDBObj) db_; // Handle on the database.
	const char *db_name_; // Name of the database.

};
//
// Implementation:
//
void Histo_App::init()
{
	Init();
	startUpdate();
	db_ = db(db_name_);
}

void Histo_App::run()
{
	const Size bin_count = 20;
	const double x_min = 0.0;
	const double x_max = 20.0;

	// Create a histo 1D using Weighted_Bin and Even_Partition:
	// (The type of the points is double.)
	//

	H_P_REF(P_Histo1D) histo = new (db_) 
		P_Histo1D( "Histo_1D", bin_count, x_min, x_max );


	// Let's fill the histo with 50000 points:
	//
	long i;
	double x, w;
	for( i=0; i<50000; i++ ) {
		x = (i % 22) - 1;
		w = (x-9.5)*(x-9.5)+3;
		histo->fill(x,w);
	}
	// Let's print some properties of the new histo:
	//
	cout << "Histo name: " << histo->name() << endl
		<< "Bin count : " << histo->bin_count()
		<< " from " << histo->partition().lower_point()
		<< " to " << histo->partition().upper_point() << endl << endl;

	// Now display some statistics:
	//
	long in_entries = H_Statistics::in_range_entries_count(*histo);
	long extra_entries = H_Statistics::extra_entries_count(*histo);
	cout << "Entries count: " << (in_entries + extra_entries)
		<< " with IN_RANGE: " << in_entries
		<< " EXTRA: " << extra_entries << endl;

	//double mean = H_Statistics::mean( *histo );
	//cout << "MEAN (B.C.): " << mean << endl;
	//cout << "RMS  (B.C.): " << H_Statistics::rms(*histo, mean)
	//	<< endl << endl;

	cout << "MEAN (B.C.): " << histo->mean() << endl;
	cout << "RMS  (B.C.): " << histo->rms() << endl;

	// Print histo contents:
	//
	cout << ". UNDERFLOW: " << histo->extra_bin(H_UNDERFLOW).value();
	for( i=0; i<histo->bin_count(); i++ ) {
		cout << endl << ". " << setw(2) << i << ": "
			<< setw(9) << histo->i_bin(i).value() << " +/- "
			<< setw(4) << histo->i_bin(i).error();
	}
	cout << endl << ". OVERFLOW: " << histo->extra_bin(H_OVERFLOW).value();
	cout << endl <<  "TOTAL IN_RANGE: " 
		<< H_Bin_Helper::in_range_value( *histo ) << endl << endl;

	// Print histo with existing H_Printout class from the library:
	//
	H_Printout hp( cout );
	hp.print( *histo );
}
int main( int argc, char **argv )
{
	Histo_App app;
	app.init();
	app.run();
	app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>

<lprout>
<![CDATA[
Histo name: Histo_1D
Bin count : 20 from 0 to 20

Entries count: 50000 with IN_RANGE: 45455 EXTRA: 4545
MEAN (B.C.): 9.49851
RMS  (B.C.): 7.58048
. UNDERFLOW: 257417
.  0:    211957 +/- 4445.79
.  1:    171043 +/- 3587.62
.  2:    134675 +/- 2824.8
.  3:    102853 +/- 2157.34
.  4:   75577.2 +/- 1585.23
.  5:   52847.2 +/- 1108.47
.  6:   34663.2 +/- 727.059
.  7:   21025.2 +/- 441.003
.  8:   11933.2 +/- 250.299
.  9:   7387.25 +/- 154.947
. 10:   7387.25 +/- 154.947
. 11:   11933.2 +/- 250.299
. 12:   21025.2 +/- 441.003
. 13:   34663.2 +/- 727.059
. 14:   52847.2 +/- 1108.47
. 15:     75544 +/- 1584.88
. 16:    102808 +/- 2156.86
. 17:    134616 +/- 2824.18
. 18:    170968 +/- 3586.83
. 19:    211864 +/- 4444.81
. OVERFLOW: 257304
TOTAL IN_RANGE: 1.64762e+06

TYPE       : Histo1D
TITLE      : Histo_1D
BIN COUNT  : 20
BIN WIDTH  : 1

                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  2.574e+05 OVERFLOW :  2.573e+05
 IN RANGE :      45455 EXTRA    :       4545
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.580e+00
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>One dimensional variable histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* create_Histo1DVar.cpp */
#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
// AIX workaround ...
#ifdef _AIX
#include "HTL/P_Histograms_2D.h"
#endif
#include "HTL/H_Statistics.h" 	// Computing statistics.
#include "HTL/H_Printout.h" 	// Computing statistics.


class Histo_App : public HepDbApplication
{
public:
	Histo_App( const char *a_db_name = 0 )
	{ db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
		// If no database name is provided then the default one is 
		// "Default_DB".

public:
	void run();
		// Create a 1D histo named "Histo 1D" and fill it.
		// Print simple properties and global statistics.

public:
	void init();

private:
	ooHandle(ooDBObj) db_; // Handle on the database.
	const char *db_name_; // Name of the database.

};


//
// Implementation:
//
void Histo_App::init()
{
	Init();
	startUpdate();
	db_ = db(db_name_);
}

void Histo_App::run()
{
	const Size bin_count = 20;
	const double x_min = 0.0;
	const double x_max = 20.0;

	// Create a Histo1DVar using Weighted_Bin and Uneven_Partition:
	// (The type of the points is double.)
	//
	//
	// 	1/ Declare and define the vector of points that compose the
	// 	(uneven/variable) partition:
	//
	P_Points_Vector my_points(10);
	my_points[0] = 0.0; my_points[1] = 1.0;
	my_points[2] = 3.5; my_points[3] = 4.0;
	my_points[4] = 5.5; my_points[5] = 9.0;
	my_points[6] = 10.; my_points[7] = 15.;
	my_points[8] = 19.; my_points[9] = 20.;

	// 	2/ Now declare and define the Histo1DVar:
	//
	H_P_REF(P_Histo1DVar) histo = new (db_) 
		P_Histo1DVar( "Histo1DVar", my_points );


	// Let's fill the histo with 50000 points:
	//
	long i;
	double x, w;
	for( i=0; i<50000; i++ ) {
		x = (i % 22) - 1;
		w = (x-9.5)*(x-9.5)+3;
		histo->fill(x,w);
	}


	// Let's print some properties of the new histo:
	//
	cout << "Histo name: " << histo->name() << endl
		<< "Bin count : " << histo->bin_count()
		<< " from " << histo->partition().lower_point()
		<< " to " << histo->partition().upper_point() << endl << endl;

	// Now display some statistics:
	//
	long in_entries = H_Statistics::in_range_entries_count(*histo);
	long extra_entries = H_Statistics::extra_entries_count(*histo);
	cout << "Entries count: " << (in_entries + extra_entries)
		<< " with IN_RANGE: " << in_entries
		<< " EXTRA: " << extra_entries << endl;

	//double mean = H_Statistics::mean( *histo );
	//cout << "MEAN (B.C.): " << mean << endl;
	//cout << "RMS  (B.C.): " << H_Statistics::rms(*histo, mean)
	//	<< endl << endl;

	cout << "MEAN (B.C.): " << histo->mean() << endl;
	cout << "RMS  (B.C.): " << histo->rms() << endl;

	// Print histo contents:
	//
	cout << ". UNDERFLOW: " << histo->extra_bin(H_UNDERFLOW).value();
	for( i=0; i<histo->bin_count(); i++ ) {
		cout << endl << ". " << setw(2) << i << ": "
			<< setw(9) << histo->i_bin(i).value() << " +/- "
			<< setw(4) << histo->i_bin(i).error();
	}
	cout << endl << ". OVERFLOW: " << histo->extra_bin(H_OVERFLOW).value();
	cout << endl <<  "TOTAL IN_RANGE: " 
		<< H_Bin_Helper::in_range_value( *histo ) << endl << endl;

	// Print histo with existing H_Printout class from the library:
	//
	H_Printout hp( cout );
	hp.print( *histo );
}

int main( int argc, char **argv )
{
	Histo_App app;
	app.init();
	app.run();
	app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Histo name: Histo1DVar
Bin count : 9 from 0 to 20

Entries count: 50000 with IN_RANGE: 45455 EXTRA: 4545
MEAN (B.C.): 9.49851
RMS  (B.C.): 7.53709
. UNDERFLOW: 257417
.  0:    211957 +/- 4445.79
.  1:    408572 +/- 5050.21
.  2:         0 +/-    0
.  3:    128424 +/- 1934.33
.  4:   67621.8 +/- 886.424
.  5:   7387.25 +/- 154.947
.  6:    127856 +/- 1427.74
.  7:    483936 +/- 5292
.  8:    211864 +/- 4444.81
. OVERFLOW: 257304
TOTAL IN_RANGE: 1.64762e+06

TYPE       : Histo1D
TITLE      : Histo1DVar
BIN COUNT  : 9
BIN WIDTH  : 1

                           0.00e+00                        4.84e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     4.086e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   2     0.000e+00|
 4.000e+00   3     1.284e+05|XXXXXXXXXXXXX
 5.500e+00   4     6.762e+04|XXXXXXX
 9.000e+00   5     7.387e+03|
 1.000e+01   6     1.279e+05|XXXXXXXXXXXXX
 1.500e+01   7     4.839e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   8     2.119e+05|XXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  2.574e+05 OVERFLOW :  2.573e+05
 IN RANGE :      45455 EXTRA    :       4545
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.537e+00
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Two dimensional histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* create_Histo2D.cpp */
#include <iostream.h>
#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_2D.h" 	// Persistent histograms.
#include "HTL/H_Statistics.h" 	// Computing statistics.
#include "HTL/H_Printout.h" 	// Printing.


class Histo_App : public HepDbApplication
{
public:
	Histo_App( const char *a_db_name = 0 )
	{ db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
		// If no database name is provided then the default one is 
		// "Default_DB".

public:
	void run();
		// Create a 1D histo named "Histo 1D" and fill it.
		// Print simple properties and global statistics.

public:
	void init();

private:
	ooHandle(ooDBObj) db_; // Handle on the database.
	const char *db_name_; // Name of the database.
};


//
// Implementation:
//
void Histo_App::init()
{
	Init();
	startUpdate();
	db_ = db(db_name_);
}

void Histo_App::run()
{
	const int n_bin = 10;

	// Create a 2D histo using Weighted_Bin and Even_Partition:
	// (The type of the points is double.)
	//
	H_P_REF(P_Histo2D) histo = new (db_) P_Histo2D( "Histo_2D",
		n_bin, 5., 15., n_bin, 5., 15. );


	// Let's fill the histo with 50000 points:
	//
	double x, w = 0.5;
	for( long i=0; i<50000; i++ ) {
		x = -i*sin(float(i));
		histo->fill(x,x,w);
		histo->fill(20.-x,x,w);
	}


	// Let's print some properties of the new histo:
	//
	cout << "Histo name: " << histo->name() << endl
		<< "X: Bin count : " << histo->partition_X().bin_count()
		<< " from " << histo->partition_X().lower_point()
		<< " to "   << histo->partition_X().upper_point() << endl;
	cout << "Y: Bin count : " << histo->partition_Y().bin_count()
		<< " from " << histo->partition_Y().lower_point()
		<< " to "   << histo->partition_Y().upper_point() << endl;

	// Now some statistics:
	//
	long in_entries = H_Statistics::in_range_entries_count( *histo );
	long extra_entries = H_Statistics::extra_entries_count( *histo );
	cout << "Entries count: " << (in_entries + extra_entries)
		<< " with IN_RANGE: " << in_entries
		<< " EXTRA: " << extra_entries << endl;
	cout << "In Range values: " << H_Bin_Helper::in_range_value( *histo )
		<< endl;

	// Print histo contents:
	//
#define EH(h,i,j) 	h->extra_bin(i,j).value()

	cout << endl;
	cout << "(U,O): " << EH( histo, H_UNDERFLOW, H_OVERFLOW )
		<< " (I,O): " << EH( histo, H_IN_RANGE, H_OVERFLOW )
		<< " (O,O): " << EH( histo, H_OVERFLOW, H_OVERFLOW ) << endl;
	cout << "(U,I): " << EH( histo, H_UNDERFLOW, H_IN_RANGE )
		<< " (I,I): " << "XXXXXX"
		<< " (O,I): " << EH( histo, H_OVERFLOW, H_IN_RANGE ) <<endl;
	cout << "(U,U): " << EH( histo, H_UNDERFLOW, H_UNDERFLOW )
		<< " (I,U): " << EH( histo, H_IN_RANGE, H_UNDERFLOW )
		<< " (O,U): " << EH( histo, H_OVERFLOW, H_UNDERFLOW ) << endl;

	cout << endl;
	for( long y=0; y<histo->partition_Y().bin_count(); y++ )
	for( long x=0; x<histo->partition_X().bin_count(); x++ ) {
		if( histo->bin(x,y).value() != 0.0 ) {
			cout << "bin(" << x << "," << y << "): "
				<< histo->bin(x,y).value() << " -/+ "
				<< histo->bin(x,y).error() << endl;
		}
	}

	cout << endl;

	// Print using H_Printout:
	//
	H_Printout hp( cout );
	hp.print( *histo );
}


int main( int argc, char **argv )
{
	Histo_App app;
	app.init();
	app.run();
	app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Histo name: Histo_2D
X: Bin count : 10 from 5 to 15
Y: Bin count : 10 from 5 to 15
Entries count: 100000 with IN_RANGE: 58 EXTRA: 99942
In Range values: 29

(U,O): 12475 (I,O): 0 (O,O): 12475
(U,I): 0 (I,I): XXXXXX (O,I): 0
(U,U): 12510.5 (I,U): 0 (O,U): 12510.5

bin(0,0): 1 -/+ 0.707107
bin(9,0): 1 -/+ 0.707107
bin(1,1): 2 -/+ 1
bin(8,1): 2 -/+ 1
bin(2,2): 2 -/+ 1
bin(7,2): 2 -/+ 1
bin(3,3): 0.5 -/+ 0.5
bin(6,3): 0.5 -/+ 0.5
bin(4,4): 1 -/+ 0.707107
bin(5,4): 1 -/+ 0.707107
bin(4,5): 2 -/+ 1
bin(5,5): 2 -/+ 1
bin(3,6): 1 -/+ 0.707107
bin(6,6): 1 -/+ 0.707107
bin(2,7): 2 -/+ 1
bin(7,7): 2 -/+ 1
bin(1,8): 1.5 -/+ 0.866025
bin(8,8): 1.5 -/+ 0.866025
bin(0,9): 1.5 -/+ 0.866025
bin(9,9): 1.5 -/+ 0.866025

TYPE     : Histo2D
TITLE    : Histo_2D
X:  BINS :    10  WIDTH  : 1.000e+00  MIN    : 5.000e+00  MAX    : 1.500e+01
Y:  BINS :    10  WIDTH  : 1.000e+00  MIN    : 5.000e+00  MAX    : 1.500e+01


         0           
         0123456789  
        ************
       *            *
   0  *  7........7  *
   1  *  .F......F.  *
   2  *  ..F....F..  *
   3  *  ...3..3...  *
   4  *  ....77....  *
   5  *  ....FF....  *
   6  *  ...7..7...  *
   7  *  ..F....F..  *
   8  *  .B......B.  *
   9  *  B........B  *
       *            *
        ************

ENTRIES  :     100000   Z MIN    :          0
TOTAL C. :         29   Z STEP   :      0.133
Z SCALE  : .+23456789ABCDE

      1.25e+04 |          0 |   1.25e+04
    -----------|------------|-----------
             0 |         29 |          0
    -----------|------------|-----------
      1.25e+04 |          0 |   1.25e+04
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Two dimensional variable histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* create_Histo2DVar.cpp */
#include <iostream.h>
#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_2D.h" // Persistent histograms.
#include "HTL/H_Statistics.h" 	// Computing statistics.
#include "HTL/H_Printout.h" 	// Printing.


class Histo_App : public HepDbApplication
{
public:
	Histo_App( const char *a_db_name = 0 )
	{ db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
		// If no database name is provided then the default one is 
		// "Default_DB".

public:
	void run();
		// Create a 1D histo named "Histo 1D" and fill it.
		// Print simple properties and global statistics.

public:
	void init();

private:
	ooHandle(ooDBObj) db_; // Handle on the database.
	const char *db_name_; // Name of the database.
};


//
// Implementation:
//
void Histo_App::init()
{
	Init();
	startUpdate();
	db_ = db(db_name_);
}

void Histo_App::run()
{
	// Create a 2D histo using Weighted_Bin and Uneven_Partition:
	// (The type of the points is double.)
	//

	// 	1/ Declare and define the vectors of points that compose each
	// 	of the (uneven/variable) partitions:
	//
	P_Points_Vector my_points_on_X(10);
	my_points_on_X[0] = 0.0; my_points_on_X[1] = 1.0;
	my_points_on_X[2] = 3.5; my_points_on_X[3] = 4.0;
	my_points_on_X[4] = 5.5; my_points_on_X[5] = 9.0;
	my_points_on_X[6] = 10.; my_points_on_X[7] = 15.;
	my_points_on_X[8] = 19.; my_points_on_X[9] = 20.;

	P_Points_Vector my_points_on_Y(10);
	my_points_on_Y[0] = 0.0; my_points_on_Y[1] = 1.0;
	my_points_on_Y[2] = 2.5; my_points_on_Y[3] = 4.0;
	my_points_on_Y[4] = 6.0; my_points_on_Y[5] = 9.0;
	my_points_on_Y[6] = 12.; my_points_on_Y[7] = 14.;
	my_points_on_Y[8] = 18.; my_points_on_Y[9] = 20.;

	// 	2/ Now declare and define the Histo2DVar:
	//
	H_P_REF(P_Histo2DVar) histo = new (db_) P_Histo2DVar(
		"Histo2DVar", my_points_on_X, my_points_on_Y );


	// Let's fill the histo with 50000 points:
	//
	double x, w = 0.5;
	for( long i=0; i<50000; i++ ) {
		x = -i*sin(float(i));
		histo->fill(x,x,w);
		histo->fill(20.-x,x,w);
	}


	// Let's print some properties of the new histo:
	//
	cout << "Histo name: " << histo->name() << endl
		<< "X: Bin count : " << histo->partition_X().bin_count()
		<< " from " << histo->partition_X().lower_point()
		<< " to "   << histo->partition_X().upper_point() << endl;
	cout << "Y: Bin count : " << histo->partition_Y().bin_count()
		<< " from " << histo->partition_Y().lower_point()
		<< " to "   << histo->partition_Y().upper_point() << endl;

	// Now some statistics:
	//
	long in_entries = H_Statistics::in_range_entries_count( *histo );
	long extra_entries = H_Statistics::extra_entries_count( *histo );
	cout << "Entries count: " << (in_entries + extra_entries)
		<< " with IN_RANGE: " << in_entries
		<< " EXTRA: " << extra_entries << endl;
	cout << "In Range values: " << H_Bin_Helper::in_range_value( *histo )
		<< endl;

	// Print histo contents:
	//
#define EH(h,i,j) 	h->extra_bin(i,j).value()

	cout << endl;
	cout << "(U,O): " << EH( histo, H_UNDERFLOW, H_OVERFLOW )
		<< " (I,O): " << EH( histo, H_IN_RANGE, H_OVERFLOW )
		<< " (O,O): " << EH( histo, H_OVERFLOW, H_OVERFLOW ) << endl;
	cout << "(U,I): " << EH( histo, H_UNDERFLOW, H_IN_RANGE )
		<< " (I,I): " << "XXXXXX"
		<< " (O,I): " << EH( histo, H_OVERFLOW, H_IN_RANGE ) <<endl;
	cout << "(U,U): " << EH( histo, H_UNDERFLOW, H_UNDERFLOW )
		<< " (I,U): " << EH( histo, H_IN_RANGE, H_UNDERFLOW )
		<< " (O,U): " << EH( histo, H_OVERFLOW, H_UNDERFLOW ) << endl;

	cout << endl;
	for( long y=0; y<histo->partition_Y().bin_count(); y++ )
	for( long x=0; x<histo->partition_X().bin_count(); x++ ) {
		if( histo->bin(x,y).value() != 0.0 ) {
			cout << "bin(" << x << "," << y << "): "
				<< histo->bin(x,y).value() << " -/+ "
				<< histo->bin(x,y).error() << endl;
		}
	}

	cout << endl;

	// Print using H_Printout:
	//
	H_Printout hp( cout );
	hp.print( *histo );
}


int main( int argc, char **argv )
{
	Histo_App app;
	app.init();
	app.run();
	app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Histo name: Histo2DVar
X: Bin count : 9 from 0 to 20
Y: Bin count : 9 from 0 to 20
Entries count: 100000 with IN_RANGE: 123 EXTRA: 99877
In Range values: 61.5

(U,O): 12469 (I,O): 0 (O,O): 12469
(U,I): 0 (I,I): XXXXXX (O,I): 0.5
(U,U): 12500 (I,U): 0 (O,U): 12500

bin(0,0): 3.5 -/+ 1.32288
bin(8,0): 3 -/+ 1.22474
bin(1,1): 2.5 -/+ 1.11803
bin(7,1): 2.5 -/+ 1.11803
bin(1,2): 2 -/+ 1
bin(2,2): 0.5 -/+ 0.5
bin(7,2): 2.5 -/+ 1.11803
bin(3,3): 2.5 -/+ 1.11803
bin(4,3): 0.5 -/+ 0.5
bin(6,3): 1 -/+ 0.707107
bin(7,3): 2 -/+ 1
bin(4,4): 4.5 -/+ 1.5
bin(6,4): 4.5 -/+ 1.5
bin(4,5): 1 -/+ 0.707107
bin(5,5): 3 -/+ 1.22474
bin(6,5): 4 -/+ 1.41421
bin(4,6): 3.5 -/+ 1.32288
bin(6,6): 3.5 -/+ 1.32288
bin(1,7): 0.5 -/+ 0.5
bin(2,7): 1 -/+ 0.707107
bin(3,7): 3 -/+ 1.22474
bin(6,7): 1.5 -/+ 0.866025
bin(7,7): 3 -/+ 1.22474
bin(0,8): 2.5 -/+ 1.11803
bin(1,8): 0.5 -/+ 0.5
bin(7,8): 0.5 -/+ 0.5
bin(8,8): 2.5 -/+ 1.11803

TYPE     : Histo2D
TITLE    : Histo2DVar
X:  BINS :     9  WIDTH  : 1.000e+00  MIN    : 0.000e+00  MAX    : 2.000e+01
Y:  BINS :     9  WIDTH  : 1.000e+00  MIN    : 0.000e+00  MAX    : 2.000e+01


         012345678  
        ***********
       *           *
   0  *  B.......9  *
   1  *  .8.....8.  *
   2  *  .6+....8.  *
   3  *  ...8+.36.  *
   4  *  ....F.F..  *
   5  *  ....39D..  *
   6  *  ....B.B..  *
   7  *  .+39..49.  *
   8  *  8+.....+8  *
       *           *
        ***********

ENTRIES  :     100000   Z MIN    :          0
TOTAL C. :       61.5   Z STEP   :        0.3
Z SCALE  : .+23456789ABCDE

      1.25e+04 |          0 |   1.25e+04
    -----------|------------|-----------
             0 |       61.5 |        0.5
    -----------|------------|-----------
      1.25e+04 |          0 |   1.25e+04
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Profile histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* create_profile.cpp */
#include <stdlib.h>

#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "CLHEP/Random/Randomize.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
#include "HTL/H_Statistics.h" 	// Computing statistics.

// Workaround for AIX...
#ifdef _AIX
#include "HTL/P_Histograms_2D.h" 	// Persistent histograms.
#endif


class Histo_App : public HepDbApplication
{
public:
	Histo_App( const char *a_db_name = 0 )
	{ db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
		// If no database name is provided then the default one is 
		// "Default_DB".

public:
	void run();
		// Create a profile histo and fill it.
		// Print simple properties and global statistics.

public:
	void init();

private:
	ooHandle(ooDBObj) db_; // Handle on the database.
	const char *db_name_; // Name of the database.
};


//
// Implementation:
//
void Histo_App::init()
{
	Init();
	startUpdate();
	db_ = db(db_name_);
}

void Histo_App::run()
{
  // Create a profile histogram

  H_P_REF(P_ProfileHisto1D) histo=new(db_)P_ProfileHisto1D("Profile",20,0.,1.);


  // Let's fill the histo with 50000 points:
  //
  long i;
  double x;
  for( i=0; i<50000; i++ ) {
    double x  = RandFlat::shoot(1.);       // fnum  ]0,1.[
    histo->fill(x,x,1.);
  }


  // Let's print some properties of the new histo:
  //
  cout << "Histo name: " << histo->name() << endl
       << "Bin count : " << histo->bin_count()
       << " from " << histo->partition().lower_point()
       << " to " << histo->partition().upper_point() << endl << endl;

	// Now display some statistics:
	//
  long in_entries = H_Statistics::in_range_entries_count(*histo);
  long extra_entries = H_Statistics::extra_entries_count(*histo);
  cout << "Entries count: " << (in_entries + extra_entries)
       << " with IN_RANGE: " << in_entries
       << " EXTRA: " << extra_entries << endl;

	//double mean = H_Statistics::mean( *histo );
	//cout << "MEAN (B.C.): " << mean << endl;
	//cout << "RMS  (B.C.): " << H_Statistics::rms(*histo, mean)
	//	<< endl << endl;

  cout << "MEAN (B.C.): " << histo->mean() << endl;
  cout << "RMS  (B.C.): " << histo->rms() << endl;

	// Print histo contents:
	//
  cout << ". UNDERFLOW: " << histo->extra_bin(H_UNDERFLOW).value();
  for( i=0; i<histo->bin_count(); i++ ) {
    cout << endl << ". " << setw(2) << i << ": "
	 << setw(9) << histo->i_bin(i).value() << " Error "
	 << setw(4) << histo->i_bin(i).error() << " Spread Error "  
	 << setw(4) << histo->i_bin(i).error(1);
  }
  cout << endl << ". OVERFLOW: " << histo->extra_bin(H_OVERFLOW).value();
  cout << endl <<  "TOTAL IN_RANGE: " 
       << H_Bin_Helper::in_range_value( *histo ) << endl << endl;

	// Print histo with existing H_Printout class from the library:
	//
}

int main( int argc, char **argv )
{
  Histo_App app;
  app.init();
  app.run();
  app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Histo name: Profile
Bin count : 20 from 0 to 1

Entries count: 50000 with IN_RANGE: 50000 EXTRA: 0
MEAN (B.C.): 0.666312
RMS  (B.C.): 0.23552
. UNDERFLOW: 0
.  0: 0.0250647 Error 0.000286298 Spread Error 0.0142977
.  1: 0.0745166 Error 0.00029354 Spread Error 0.014568
.  2:  0.124837 Error 0.00028742 Spread Error 0.0144112
.  3:  0.175241 Error 0.000291741 Spread Error 0.0147236
.  4:   0.22449 Error 0.000283709 Spread Error 0.0144636
.  5:  0.274975 Error 0.000296557 Spread Error 0.0144767
.  6:  0.324576 Error 0.000287682 Spread Error 0.01441
.  7:  0.374858 Error 0.000290097 Spread Error 0.0145049
.  8:  0.425234 Error 0.000289333 Spread Error 0.0145877
.  9:  0.474736 Error 0.000289471 Spread Error 0.0142577
. 10:  0.525067 Error 0.000285902 Spread Error 0.01446
. 11:  0.574966 Error 0.000289958 Spread Error 0.0144631
. 12:  0.625205 Error 0.000287818 Spread Error 0.0143303
. 13:  0.674856 Error 0.000280593 Spread Error 0.0140885
. 14:  0.724543 Error 0.000283964 Spread Error 0.0141897
. 15:  0.774749 Error 0.000289397 Spread Error 0.0144959
. 16:  0.824429 Error 0.00029415 Spread Error 0.0146426
. 17:  0.875514 Error 0.00028748 Spread Error 0.0143337
. 18:  0.924988 Error 0.000286102 Spread Error 0.0143022
. 19:  0.975152 Error 0.000290712 Spread Error 0.0145588
. OVERFLOW: 0
TOTAL IN_RANGE: 9.998
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Filling histograms with random numbers</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* histo_random.cpp */
#include <iostream.h>
#include "CLHEP/Random/Randomize.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
// AIX workaround ...
#ifdef _AIX
#include "HTL/P_Histograms_2D.h"
#endif
#include "HTL/H_Printout.h" 	// Computing statistics.

typedef P_Histo1D PHisto;

class Histo_App : public HepDbApplication {
public:
  Histo_App( const char *a_db_name = 0 )
  { db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
  // If no database name is provided then the default one is 
  // "Default_DB".

public:
	void run();
	void init();
private:
	ooHandle(ooDBObj) db_; // Handle on the database.
	const char *db_name_; // Name of the database.
};


//
// Implementation:
//
void Histo_App::init()
{
	Init();
	startUpdate();
	db_ = db(db_name_);
}

void Histo_App::run()
{
  const int Nbin = 10;
  Init();        // initialise the db session
  startUpdate(); // start an update transaction

  H_P_REF(PHisto) histo = new (db_) PHisto( "Histo_1D", 20., 0.0, 20.0 );

  H_P_REF(PHisto) xhist = new (db_) PHisto(" Random Numbers ",40,0.0,20.0);

  // Clone histogram
  H_P_REF (PHisto) x2hist = xhist->clone(); 
  x2hist->set_name("Two Gaussians");

  /* -----Start of histogram manipulation-------------------------------- */

  // Fill histograms with random number 

  for(int i = 1;i <= 100000;i++)
    {
      double x  = RandFlat::shoot(20.);       // fnum  ]0,20[
      double n1 = RandGauss::shoot(5.,1.6);   // (mean=5, stDev=1.6)
      double n2 = RandGauss::shoot(15.2,0.7); // (mean=15.2, stDev=.7)
      xhist->fill(x,1.);
      x2hist->fill(n1,1.);
      x2hist->fill(n2,0.5);
    }

  cout << "Graphical Histogram Printout" << endl;
  
  H_Printout p(cout);
  
  p.print(*xhist); cout << endl; 
  p.print(*x2hist); 

  // Add x2hist to xhist, then divide by 2 
  
  x2hist->add(*xhist);
  x2hist->div(2.);      

  cout << endl 
       << "Graphical Histogram Printout of xhist2 after operations"
       << endl;

  x2hist->set_name("Two Gaussians + Random divided by 2");
  p.print(*x2hist);
  
  
}

int main( int argc, char **argv )
{
	Histo_App app;
	app.init();
	app.run();
	app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Graphical Histogram Printout
TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN COUNT  : 40
BIN WIDTH  : 0.5

                           2.33e+03                        2.58e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.511e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e-01   1     2.491e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   2     2.434e+03|XXXXXXXXXXXXXXXXXXXXX
 1.500e+00   3     2.537e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   4     2.510e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.500e+00   5     2.485e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   6     2.448e+03|XXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     2.547e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     2.542e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     2.565e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    2.532e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    2.328e+03|
 6.000e+00   12    2.543e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    2.534e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    2.529e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.500e+00   15    2.535e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   16    2.508e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.500e+00   17    2.504e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.000e+00   18    2.473e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.500e+00   19    2.457e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+01   20    2.585e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.050e+01   21    2.524e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.100e+01   22    2.473e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.150e+01   23    2.490e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.200e+01   24    2.425e+03|XXXXXXXXXXXXXXXXXXX
 1.250e+01   25    2.500e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.300e+01   26    2.576e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.350e+01   27    2.448e+03|XXXXXXXXXXXXXXXXXXXXXXX
 1.400e+01   28    2.483e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    2.581e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    2.447e+03|XXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    2.555e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    2.585e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.650e+01   33    2.431e+03|XXXXXXXXXXXXXXXXXXXX
 1.700e+01   34    2.480e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.750e+01   35    2.549e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   36    2.429e+03|XXXXXXXXXXXXXXXXXXXX
 1.850e+01   37    2.494e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   38    2.541e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.950e+01   39    2.391e+03|XXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  0.000e+00 OVERFLOW :  0.000e+00
 IN RANGE :     100000 EXTRA    :          0
 MEAN B.C.:  9.991e+00 RMS B.C. :  5.764e+00

TYPE       : Histo1D
TITLE      : Two Gaussians
BIN COUNT  : 40
BIN WIDTH  : 5.000e-01

                           0.00e+00                        1.40e+04 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     1.330e+02|
 5.000e-01   1     3.590e+02|X
 1.000e+00   2     8.710e+02|XXX
 1.500e+00   3     1.676e+03|XXXXXX
 2.000e+00   4     2.812e+03|XXXXXXXXXX
 2.500e+00   5     4.732e+03|XXXXXXXXXXXXXXXXX
 3.000e+00   6     6.835e+03|XXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     9.271e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     1.117e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     1.214e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    1.237e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    1.106e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   12    9.104e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    6.935e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    4.599e+03|XXXXXXXXXXXXXXXX
 7.500e+00   15    2.897e+03|XXXXXXXXXX
 8.000e+00   16    1.532e+03|XXXXX
 8.500e+00   17    8.560e+02|XXX
 9.000e+00   18    3.230e+02|X
 9.500e+00   19    1.440e+02|
 1.000e+01   20    5.700e+01|
 1.050e+01   21    2.000e+01|
 1.100e+01   22    5.000e+00|
 1.150e+01   23    2.000e+00|
 1.200e+01   24    1.500e+00|
 1.250e+01   25    4.650e+01|
 1.300e+01   26    3.340e+02|X
 1.350e+01   27    1.751e+03|XXXXXX
 1.400e+01   28    5.794e+03|XXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    1.140e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    1.403e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    1.039e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    4.743e+03|XXXXXXXXXXXXXXXXX
 1.650e+01   33    1.270e+03|XXXX
 1.700e+01   34    2.105e+02|
 1.750e+01   35    2.300e+01|
 1.800e+01   36    2.000e+00|
 1.850e+01   37    0.000e+00|
 1.900e+01   38    0.000e+00|
 1.950e+01   39    0.000e+00|
                         X |
                           V
UNDERFLOW :  9.100e+01 OVERFLOW :  0.000e+00
 IN RANGE :     199909 EXTRA    :         91
 MEAN B.C.:  8.400e+00 RMS B.C. :  4.996e+00

Graphical Histogram Printout of xhist2 after operations
TYPE       : Histo1D
TITLE      : Two Gaussians + Random divided by 2
BIN COUNT  : 40
BIN WIDTH  : 5.000e-01

                           1.20e+03                        8.24e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     1.322e+03|
 5.000e-01   1     1.425e+03|X
 1.000e+00   2     1.652e+03|XXX
 1.500e+00   3     2.106e+03|XXXXXX
 2.000e+00   4     2.661e+03|XXXXXXXXXX
 2.500e+00   5     3.608e+03|XXXXXXXXXXXXXXXXX
 3.000e+00   6     4.642e+03|XXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     5.909e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     6.858e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     7.353e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    7.450e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    6.696e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   12    5.824e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    4.734e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    3.564e+03|XXXXXXXXXXXXXXXXX
 7.500e+00   15    2.716e+03|XXXXXXXXXXX
 8.000e+00   16    2.020e+03|XXXXX
 8.500e+00   17    1.680e+03|XXX
 9.000e+00   18    1.398e+03|X
 9.500e+00   19    1.300e+03|
 1.000e+01   20    1.321e+03|
 1.050e+01   21    1.272e+03|
 1.100e+01   22    1.239e+03|
 1.150e+01   23    1.246e+03|
 1.200e+01   24    1.213e+03|
 1.250e+01   25    1.273e+03|
 1.300e+01   26    1.455e+03|X
 1.350e+01   27    2.100e+03|XXXXXX
 1.400e+01   28    4.139e+03|XXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    6.991e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    8.238e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    6.474e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    3.664e+03|XXXXXXXXXXXXXXXXX
 1.650e+01   33    1.850e+03|XXXX
 1.700e+01   34    1.345e+03|X
 1.750e+01   35    1.286e+03|
 1.800e+01   36    1.216e+03|
 1.850e+01   37    1.247e+03|
 1.900e+01   38    1.270e+03|
 1.950e+01   39    1.196e+03|
                         X |
                           V
UNDERFLOW :  4.550e+01 OVERFLOW :  0.000e+00
 IN RANGE :     299909 EXTRA    :         91
 MEAN B.C.:  9.037e+00 RMS B.C. :  5.374e+00
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Saving histogram as text table</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* histo_tables.cpp */
#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "HTL/T_Histograms_1D.h" // Transient histograms.
#include "HTL/H_HistoTable.h"

// Workaround for transient histograms on AIX...
#ifdef _AIX
T_Uneven_Partition::Points_Set v(0);
#endif

class Histo_App 
{
public:
  Histo_App() {}
public:
  void run();
  // Create one 1D transient histograms and save it a text table
private:
  void create1D ();
};


//
// Implementation:
//
void Histo_App::run() {
  create1D();
}

void Histo_App::create1D() {

  // Create a histo 1D

  H_T_REF(T_Histo1D) histo = new T_Histo1D("Histo_1D", 20, 0.0, 20.0 );


  // Let's fill the histo with 50000 points:
  //
  long i;
  double x, w;
  for( i=0; i<50000; i++ ) {
    x = (i % 22) - 1;
    w = (x-9.5)*(x-9.5)/100;
    histo->fill(x,w);
  }

  // Save the histogram in a ASCII table
  HistoTable1D ht1 ("histo.txt");
  ht1.write(*histo);
  delete (T_Histo1D *)histo;
}

int main( int argc, char **argv )
{
  Histo_App app;
  app.run();
}
]]>
</listing>
</subsection>

<subsection>
<stitle>PAW kumac for reading table</stitle>
<listing>
<![CDATA[
mess "Notice that this is an HTL histogram with gravity bins"
mess "The center of each bin is the bin center-of-mass"
mess "rather than the mid point"
* Read x,y,ey; ex are all zeros
ve/read x,y,ey histo.txt
ve/cre ex(20)
zone 2 2
* Draw as histogram
ve/draw y
* Fit with 2nd degree polynomial
ve/fit x y ey p2
* Display as markers+error bars
graphics/hplot/errors x y ex ey 20 25 .07 W
* Finally as a bar chart
graph 20 x y AWB
]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
0 2051.38 43.0276
1 1642.24 34.4459
2 1278.56 26.8177
3 960.343 20.1431
4 687.583 14.422
5 460.282 9.65439
6 278.443 5.84031
7 142.062 2.97975
8 51.1425 1.07271
9 5.6825 0.11919
10 5.6825 0.11919
11 51.1425 1.07271
12 142.062 2.97975
13 278.443 5.84031
14 460.282 9.65439
15 687.28 14.4188
16 959.92 20.1387
17 1278 26.8118
18 1641.52 34.4383
19 2050.48 43.0181
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Basic histogram operations</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* basic_operations.cpp */
/******************************************************************************

Demonstrate:
. how to create, fill and print a basic Histo1D
. how to create/clone a new histo out of an existing one.
  (constructor and cloning techniques demonstrated)
. how to perform basic operations.

******************************************************************************/

#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_1D.h" // Persistent histograms.
// AIX workaround ...
#ifdef _AIX
#include "HTL/P_Histograms_2D.h"
#endif
#include "HTL/H_Printout.h" 	// Printing.

class Histo_App : public HepDbApplication
{
public:
  Histo_App( const char *a_db_name = 0 )
  { db_name_ = ( a_db_name == 0 ) ? "Default_DB" : a_db_name; }
  // If no database name is provided then the default one is 
  // "Default_DB".

public:
  void run();

  void init()
  {
    Init();
    startUpdate();
    db_ = db(db_name_);
  }

private:
  ooHandle(ooDBObj) db_; // Handle on the database.
  const char *db_name_; // Name of the database.
};


// Implementation:
//

void Histo_App::run()
{
  const Size bin_count = 20;
  const double x_min = 0.0;
  const double x_max = 20.0;

  // Create a histo 1D using Gravity_Bin and Even_Partition:
  // (The type of the points is double.)
  //

  H_P_REF(P_Histo1D) histo1 = new(db_) 
    P_Histo1D( "Histo1: parabolic function", bin_count, x_min, x_max );


  // Let's fill the histo with 50000 points:
  //
  long i;
  double x, w;
  for( i=0; i<50000; i++ ) {
    x = (i % 22) - 1;
    w = (x-9.5)*(x-9.5)+3;
    histo1->fill(x,w);
  }

  // Print:
  //
  H_Printout hp( cout );
  cout << endl << endl; hp.print( *histo1 );


  // Now create a clone of histo1 and print it out:
  //
  H_P_REF(P_Histo1D) histo2 = histo1->clone();
  // Change name.
  histo2->set_name( "Histo2: a clone of Histo1" );
  cout << endl << endl; hp.print( *histo2 );

  // Add histo1 to histo2 and print the result:
  //
  histo2->add( *histo1 );
  histo2->set_name( "Histo2 =  Histo2+Histo1 = 2*Histo1" );
  cout << endl << endl; hp.print( *histo2 );

  //
  // It is also possible to clone and perform an operation on single
  // statement:
  // 	histo2 = histo1->clone()->add( histo1 );
  //


  // Now create a new histo out of histo2:
  // ... (So simple, huh?)
  //
  H_P_REF(P_Histo1D) histo3 = new(db_) P_Histo1D( *histo2 );

  // Sub histo1 to histo3 ==> histo3 should hold values of histo1
  // Mul by -1.0 ==> histo3 should now hold the opposite of histo1
  // And print the result:
  //
  histo3->sub( *histo1 );
  histo3->mul( -1.0 );
  histo3->set_name( "Histo3: -(Histo2 - Histo1) = -Histo1" );
  cout << endl << endl; hp.print( *histo3 );

}

int main( int argc, char **argv )
{
  Histo_App app;
  app.init();
  app.run();
  app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
TYPE       : Histo1D
TITLE      : Histo1: parabolic function
BIN COUNT  : 20
BIN WIDTH  : 1

                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  2.574e+05 OVERFLOW :  2.573e+05
 IN RANGE :      45455 EXTRA    :       4545
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.580e+00


TYPE       : Histo1D
TITLE      : Histo2: a clone of Histo1
BIN COUNT  : 20
BIN WIDTH  : 1.000e+00

                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  2.574e+05 OVERFLOW :  2.573e+05
 IN RANGE :      45455 EXTRA    :       4545
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.580e+00


TYPE       : Histo1D
TITLE      : Histo2 =  Histo2+Histo1 = 2*Histo1
BIN COUNT  : 20
BIN WIDTH  : 1.000e+00

                           1.48e+04                        4.24e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     4.239e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     3.421e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     2.694e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     2.057e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     1.512e+05|XXXXXXXXXXXXXXXXX
 5.000e+00   5     1.057e+05|XXXXXXXXXXX
 6.000e+00   6     6.933e+04|XXXXXX
 7.000e+00   7     4.205e+04|XXX
 8.000e+00   8     2.387e+04|X
 9.000e+00   9     1.477e+04|
 1.000e+01   10    1.477e+04|
 1.100e+01   11    2.387e+04|X
 1.200e+01   12    4.205e+04|XXX
 1.300e+01   13    6.933e+04|XXXXXX
 1.400e+01   14    1.057e+05|XXXXXXXXXXX
 1.500e+01   15    1.511e+05|XXXXXXXXXXXXXXXX
 1.600e+01   16    2.056e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    2.692e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    3.419e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    4.237e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  5.148e+05 OVERFLOW :  5.146e+05
 IN RANGE :      90910 EXTRA    :       9090
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.580e+00


TYPE       : Histo1D
TITLE      : Histo3: -(Histo2 - Histo1) = -Histo1
BIN COUNT  : 20
BIN WIDTH  : 1.000e+00

                           -2.12e+05                        -7.39e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0    -2.120e+05|
 1.000e+00   1    -1.710e+05|XXXXXXXXXX
 2.000e+00   2    -1.347e+05|XXXXXXXXXXXXXXXXXXX
 3.000e+00   3    -1.029e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4    -7.558e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   5    -5.285e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   6    -3.466e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   7    -2.103e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   8    -1.193e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.000e+00   9    -7.387e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+01   10   -7.387e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.100e+01   11   -1.193e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.200e+01   12   -2.103e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.300e+01   13   -3.466e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.400e+01   14   -5.285e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   15   -7.554e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   16   -1.028e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17   -1.346e+05|XXXXXXXXXXXXXXXXXXX
 1.800e+01   18   -1.710e+05|XXXXXXXXXX
 1.900e+01   19   -2.119e+05|
                         X |
                           V
UNDERFLOW : -2.574e+05 OVERFLOW : -2.573e+05
 IN RANGE :     136365 EXTRA    :      13635
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.580e+00
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Read histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* read_histo.cpp */
#include <iostream.h>
#include <iomanip.h>
#include "HepODBMS/clustering/HepDbApplication.h"
#include "HTL/P_Histograms_1D.h"
// AIX workaround ...
#ifdef _AIX
#include "HTL/P_Histograms_2D.h"
#endif
#include "HTL/H_Printout.h"

class Histo_App : public HepDbApplication
{
public:
  Histo_App( const char *a_db_name = 0 )
  { db_name_ = ( a_db_name != 0 ) ? a_db_name : "Default_DB"; }

  void create();
  // Create 3 histograms.
  void readHisto();
  // Read back the 2nd histogram from the database.

public:
  void init();

  private :
  ooHandle(ooDBObj)  histoDb;
  const char *db_name_;
};


void Histo_App::init()
{    
  Init();
  startUpdate();
  histoDb = db(db_name_);
}


void Histo_App::create()
{
  const int noOfBins=20;

  // Create three histograms with different names:
  H_P_REF(P_Histo1D) h1 = new(histoDb) P_Histo1D("Histo-1",noOfBins,0.0,20.0 );
  H_P_REF(P_Histo1D) h2 = new(histoDb) P_Histo1D( "Histo-2",noOfBins,0.0,20.0);
  H_P_REF(P_Histo1D) h3 = new(histoDb) P_Histo1D( "Histo-3",noOfBins,0.0,20.0);

  // Fill histos with different weights:
  double x;
  for( int i = 0; i < 50000; i++) {   
    x = (i % 22) - 1;          
    h1->fill(x, (x-9.5)*(x-9.5)+3);
    h2->fill(x, (x-9.5)*(x-9.5)+30);
    h3->fill(x, (x-9.5)*(x-9.5)+300);      
  }
}


void Histo_App::readHisto()
{
  ooItr(P_I_Histo_1D)  histo1D_itr;
  // Iterator on 1D histo interface.
  // Note:
  // 	ooItr(P_Histo1D)  histo1D_itr;
  // also work because we know a priori the actual type of the
  // histo we want to read.

  // Scan the database for the previous histo interface:
  // (We could restrict our search to a container only)
  histo1D_itr.scan( histoDb );
  cout << endl << "Start scanning. Looking for Histo-2" << endl;

  // Look for Histo 2:
  //
  for( int i = 1; histo1D_itr.next(); i++ ) { 
    cout << "Found: " << histo1D_itr->name() << endl;
    if( strcmp(histo1D_itr->name(), "Histo-2") == 0) {
      // Let's print it:
      cout << endl  << endl;
      H_Printout hp(cout);
      hp.print( *histo1D_itr);    
      cout << endl;
    }
  }
}



int main( int argc, char **argv)
{
  // Read database name from command line if any:
  const char *a_db_name = 0;
  if( argc > 1 ) a_db_name = argv[1];

  // Create application object:
  Histo_App my_app( a_db_name );

  my_app.init();
  my_app.create();
  my_app.commit();

  my_app.startRead();
  my_app.readHisto();
  my_app.commit();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Start scanning. Looking for Histo-2
Found: Histo2 =  Histo2+Histo1 = 2*Histo1
Found: Histo_1D
Found: Histo_1D
Found: Histo1DVar
Found: Profile
Found: Histo1: parabolic function
Found: Histo3: -(Histo2 - Histo1) = -Histo1
Found: Histo-1
Found: Histo-2


TYPE       : Histo1D
TITLE      : Histo-2
BIN COUNT  : 20
BIN WIDTH  : 1

                           6.88e+04                        2.73e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.733e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     2.324e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.960e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.642e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     1.369e+05|XXXXXXXXXXXXXXXXX
 5.000e+00   5     1.142e+05|XXXXXXXXXXX
 6.000e+00   6     9.603e+04|XXXXXX
 7.000e+00   7     8.240e+04|XXX
 8.000e+00   8     7.330e+04|X
 9.000e+00   9     6.876e+04|
 1.000e+01   10    6.876e+04|
 1.100e+01   11    7.330e+04|X
 1.200e+01   12    8.240e+04|XXX
 1.300e+01   13    9.603e+04|XXXXXX
 1.400e+01   14    1.142e+05|XXXXXXXXXXX
 1.500e+01   15    1.369e+05|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.642e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.960e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    2.323e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.732e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  3.188e+05 OVERFLOW :  3.186e+05
 IN RANGE :      45455 EXTRA    :       4545
 MEAN B.C.:  9.499e+00 RMS B.C. :  6.865e+00

Found: Histo-3
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Create transient histograms</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* create_transient.cpp */
#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "HTL/T_Histograms_1D.h" // Transient histograms.
#include "HTL/T_Histograms_2D.h" // Transient histograms.
#include "HTL/H_Statistics.h" 	// Computing statistics.
#include "HTL/H_Printout.h" 	// Printing.

// Workaround for transient histograms on AIX...
#ifdef _AIX
T_Uneven_Partition::Points_Set v(0);
#endif

class Histo_App 
{
public:
  Histo_App() {}
public:
  void run();
  // Create 1D & 2D transient histograms and fill them
  // Print simple properties and global statistics.
private:
  void create1D ();
  void create2D ();
};


//
// Implementation:
//
void Histo_App::run() {
  create1D();
  create2D();
}

void Histo_App::create1D() {

  // Create a histo 1D 

  H_T_REF(T_Histo1D) histo = new T_Histo1D("Histo_1D", 20, 0.0, 20.0 );


  // Let's fill the histo with 50000 points:
  //
  long i;
  double x, w;
  for( i=0; i<50000; i++ ) {
    x = (i % 22) - 1;
    w = (x-9.5)*(x-9.5)+3;
    histo->fill(x,w);
  }


  // Let's print some properties of the new histo:
  //
  cout << "Histo name: " << histo->name() << endl
       << "Bin count : " << histo->bin_count()
       << " from " << histo->partition().lower_point()
       << " to " << histo->partition().upper_point() << endl << endl;

  // Now display some statistics:
  //
  long in_entries = H_Statistics::in_range_entries_count(*histo);
  long extra_entries = H_Statistics::extra_entries_count(*histo);
  cout << "Entries count: " << (in_entries + extra_entries)
       << " with IN_RANGE: " << in_entries
       << " EXTRA: " << extra_entries << endl;

  //double mean = H_Statistics::mean( *histo );
  //cout << "MEAN (B.C.): " << mean << endl;
  //cout << "RMS  (B.C.): " << H_Statistics::rms(*histo, mean)
  //	<< endl << endl;

  cout << "MEAN (B.C.): " << histo->mean() << endl;
  cout << "RMS  (B.C.): " << histo->rms() << endl;

  // Print histo contents:
  //
  cout << ". UNDERFLOW: " << histo->extra_bin(H_UNDERFLOW).value();
  for( i=0; i<histo->bin_count(); i++ ) {
    cout << endl << ". " << setw(2) << i << ": "
	 << setw(9) << histo->i_bin(i).value() << " +/- "
	 << setw(4) << histo->i_bin(i).error();
  }
  cout << endl << ". OVERFLOW: " << histo->extra_bin(H_OVERFLOW).value();
  cout << endl <<  "TOTAL IN_RANGE: " 
       << H_Bin_Helper::in_range_value( *histo ) << endl << endl;

  // Print histo with existing H_Printout class from the library:
  //
  H_Printout hp( cout );
  hp.print( *histo );
  delete (T_Histo1D *)histo;
}

void Histo_App::create2D()
{
  const int n_bin = 10;

  // Create a 2D histo 
  //
  H_T_REF(T_Histo2D) histo = new T_Histo2D( "Histo_2D",
				    n_bin, 5., 15., n_bin, 5., 15. );


  // Let's fill the histo with 50000 points:
  //
  double x, w = 0.5;
  for( long i=0; i<50000; i++ ) {
    x = -i*sin(float(i));
    histo->fill(x,x,w);
    histo->fill(20.-x,x,w);
  }


  // Let's print some properties of the new histo:
  //
  cout << "Histo name: " << histo->name() << endl
       << "X: Bin count : " << histo->partition_X().bin_count()
       << " from " << histo->partition_X().lower_point()
       << " to "   << histo->partition_X().upper_point() << endl;
  cout << "Y: Bin count : " << histo->partition_Y().bin_count()
       << " from " << histo->partition_Y().lower_point()
       << " to "   << histo->partition_Y().upper_point() << endl;

  // Now some statistics:
  //
  long in_entries = H_Statistics::in_range_entries_count( *histo );
  long extra_entries = H_Statistics::extra_entries_count( *histo );
  cout << "Entries count: " << (in_entries + extra_entries)
       << " with IN_RANGE: " << in_entries
       << " EXTRA: " << extra_entries << endl;
  cout << "In Range values: " << H_Bin_Helper::in_range_value( *histo )
       << endl;

  // Print histo contents:
  //
#define EH(h,i,j) 	h->extra_bin(i,j).value()

  cout << endl;
  cout << "(U,O): " << EH( histo, H_UNDERFLOW, H_OVERFLOW )
       << " (I,O): " << EH( histo, H_IN_RANGE, H_OVERFLOW )
       << " (O,O): " << EH( histo, H_OVERFLOW, H_OVERFLOW ) << endl;
  cout << "(U,I): " << EH( histo, H_UNDERFLOW, H_IN_RANGE )
       << " (I,I): " << "XXXXXX"
       << " (O,I): " << EH( histo, H_OVERFLOW, H_IN_RANGE ) <<endl;
  cout << "(U,U): " << EH( histo, H_UNDERFLOW, H_UNDERFLOW )
       << " (I,U): " << EH( histo, H_IN_RANGE, H_UNDERFLOW )
       << " (O,U): " << EH( histo, H_OVERFLOW, H_UNDERFLOW ) << endl;

  cout << endl;
  for( long y=0; y<histo->partition_Y().bin_count(); y++ )
    for( long x=0; x<histo->partition_X().bin_count(); x++ ) {
      if( histo->bin(x,y).value() != 0.0 ) {
	cout << "bin(" << x << "," << y << "): "
	     << histo->bin(x,y).value() << " -/+ "
	     << histo->bin(x,y).error() << endl;
      }
    }

  cout << endl;

  // Print using H_Printout:
  //
  H_Printout hp( cout );
  hp.print( *histo );
  delete (T_Histo2D *)histo;
}


int main( int argc, char **argv )
{
  Histo_App app;
  app.run();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
Histo name: Histo_1D
Bin count : 20 from 0 to 20

Entries count: 50000 with IN_RANGE: 45455 EXTRA: 4545
MEAN (B.C.): 9.49851
RMS  (B.C.): 7.58048
. UNDERFLOW: 257417
.  0:    211957 +/- 4445.79
.  1:    171043 +/- 3587.62
.  2:    134675 +/- 2824.8
.  3:    102853 +/- 2157.34
.  4:   75577.2 +/- 1585.23
.  5:   52847.2 +/- 1108.47
.  6:   34663.2 +/- 727.059
.  7:   21025.2 +/- 441.003
.  8:   11933.2 +/- 250.299
.  9:   7387.25 +/- 154.947
. 10:   7387.25 +/- 154.947
. 11:   11933.2 +/- 250.299
. 12:   21025.2 +/- 441.003
. 13:   34663.2 +/- 727.059
. 14:   52847.2 +/- 1108.47
. 15:     75544 +/- 1584.88
. 16:    102808 +/- 2156.86
. 17:    134616 +/- 2824.18
. 18:    170968 +/- 3586.83
. 19:    211864 +/- 4444.81
. OVERFLOW: 257304
TOTAL IN_RANGE: 1.64762e+06

TYPE       : Histo1D
TITLE      : Histo_1D
BIN COUNT  : 20
BIN WIDTH  : 1

                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
UNDERFLOW :  2.574e+05 OVERFLOW :  2.573e+05
 IN RANGE :      45455 EXTRA    :       4545
 MEAN B.C.:  9.499e+00 RMS B.C. :  7.580e+00
Histo name: Histo_2D
X: Bin count : 10 from 5.000e+00 to 1.500e+01
Y: Bin count : 10 from 5.000e+00 to 1.500e+01
Entries count: 100000 with IN_RANGE: 58 EXTRA: 99942
In Range values: 2.900e+01

(U,O): 1.248e+04 (I,O): 0.000e+00 (O,O): 1.248e+04
(U,I): 0.000e+00 (I,I): XXXXXX (O,I): 0.000e+00
(U,U): 1.251e+04 (I,U): 0.000e+00 (O,U): 1.251e+04

bin(0,0): 1.000e+00 -/+ 7.071e-01
bin(9,0): 1.000e+00 -/+ 7.071e-01
bin(1,1): 2.000e+00 -/+ 1.000e+00
bin(8,1): 2.000e+00 -/+ 1.000e+00
bin(2,2): 2.000e+00 -/+ 1.000e+00
bin(7,2): 2.000e+00 -/+ 1.000e+00
bin(3,3): 5.000e-01 -/+ 5.000e-01
bin(6,3): 5.000e-01 -/+ 5.000e-01
bin(4,4): 1.000e+00 -/+ 7.071e-01
bin(5,4): 1.000e+00 -/+ 7.071e-01
bin(4,5): 2.000e+00 -/+ 1.000e+00
bin(5,5): 2.000e+00 -/+ 1.000e+00
bin(3,6): 1.000e+00 -/+ 7.071e-01
bin(6,6): 1.000e+00 -/+ 7.071e-01
bin(2,7): 2.000e+00 -/+ 1.000e+00
bin(7,7): 2.000e+00 -/+ 1.000e+00
bin(1,8): 1.500e+00 -/+ 8.660e-01
bin(8,8): 1.500e+00 -/+ 8.660e-01
bin(0,9): 1.500e+00 -/+ 8.660e-01
bin(9,9): 1.500e+00 -/+ 8.660e-01

TYPE     : Histo2D
TITLE    : Histo_2D
X:  BINS :    10  WIDTH  : 1.000e+00  MIN    : 5.000e+00  MAX    : 1.500e+01
Y:  BINS :    10  WIDTH  : 1.000e+00  MIN    : 5.000e+00  MAX    : 1.500e+01


         0           
         0123456789  
        ************
       *            *
   0  *  7........7  *
   1  *  .F......F.  *
   2  *  ..F....F..  *
   3  *  ...3..3...  *
   4  *  ....77....  *
   5  *  ....FF....  *
   6  *  ...7..7...  *
   7  *  ..F....F..  *
   8  *  .B......B.  *
   9  *  B........B  *
       *            *
        ************

ENTRIES  :     100000   Z MIN    :          0
TOTAL C. :         29   Z STEP   :      0.133
Z SCALE  : .+23456789ABCDE

      1.25e+04 |          0 |   1.25e+04
    -----------|------------|-----------
             0 |         29 |          0
    -----------|------------|-----------
      1.25e+04 |          0 |   1.25e+04
]]>
</lprout>
</subsection>
</section>

<section>
<stitle>Create sliced projections</stitle>
<subsection>
<stitle>Input program</stitle>
<listing>
<![CDATA[/* slice_proj.cpp */
#include <iostream.h>
#include <iomanip.h> 		// Formatting output string.

#include "HTL/T_Histograms_1D.h" // Transient histograms.
#include "HTL/T_Histograms_2D.h" // Transient histograms.
#include "HTL/H_2D_Helper.h" 	

// Workaround for transient histograms on AIX...
#ifdef _AIX
T_Uneven_Partition::Points_Set v(0);
#endif

class Histo_App 
{
public:
  Histo_App() {}
public:
  void run();
private:
  void slice ();
  void project ();
  H_T_REF(T_Histo2D) histo;
};

//
// Implementation:
//
void Histo_App::run() {
  // Create a 2D histo using Weighted_Bin and Even_Partition:
  histo = new T_Histo2D( "Histo_2D",10, 5., 15., 10, 5., 15. );
  // Let's fill the histo with 50000 points:
  double x, w = 0.5;
  for( long i=0; i<50000; i++ ) {
    x = -i*sin(float(i));
    histo->fill(x,x,w);
    histo->fill(20.-x,x,w);
  }
  cout << "2D histogram content" << endl;
  for( long y=0; y<histo->partition_Y().bin_count(); y++ )
    for( long x=0; x<histo->partition_X().bin_count(); x++ ) {
	cout << "bin(" << x << "," << y << "): "
	     << histo->bin(x,y).value() << " -/+ "
	     << histo->bin(x,y).error() << endl;
    }

  // Make two slices
  slice();
  // and two projections
  project();
  delete (T_Histo2D *)histo;
}


void Histo_App::slice() {
  long x;
  H_2D_Helper mySlicer;
  // First slice in X . The 2nd parameter is the bin no. (0->first bin)
  H_T_REF(T_Histo1DVar) slice1 = mySlicer.xBand (*histo,0);
  // First slice in Y . The 2nd parameter is the bin no. (0->first bin)
  H_T_REF(T_Histo1DVar) slice2 = mySlicer.yBand (*histo,0);

  cout << endl << "First slice";
  for( x=0; x<slice1->bin_count(); x++ ) {
    cout << endl << ". " << setw(2) << x << ": "
	 << setw(9) << slice1->i_bin(x).value() << " +/- "
	 << setw(4) << slice1->i_bin(x).error();
  }

  cout << endl << endl << "Second slice";
  for( x=0; x<slice2->bin_count(); x++ ) {
    cout << endl << ". " << setw(2) << x << ": "
	 << setw(9) << slice2->i_bin(x).value() << " +/- "
	 << setw(4) << slice2->i_bin(x).error();
  }
  delete (T_Histo1DVar *)slice1;
  delete (T_Histo1DVar *)slice2;
}

void Histo_App::project() {
  long x;
  H_2D_Helper myProjector;
  H_T_REF(T_Histo1DVar) proj1 = myProjector.xProject (*histo);
  H_T_REF(T_Histo1DVar) proj2 = myProjector.yProject (*histo);

  cout << endl << endl << "First projection";
  for( x=0; x<proj1->bin_count(); x++ ) {
    cout << endl << ". " << setw(2) << x << ": "
	 << setw(9) << proj1->i_bin(x).value() << " +/- "
	 << setw(4) << proj1->i_bin(x).error();
  }

  cout << endl << endl << "Second projection";
  for( x=0; x<proj2->bin_count(); x++ ) {
    cout << endl << ". " << setw(2) << x << ": "
	 << setw(9) << proj2->i_bin(x).value() << " +/- "
	 << setw(4) << proj2->i_bin(x).error();
  }

  cout << endl;
  delete (T_Histo1DVar *)proj1;
  delete (T_Histo1DVar *)proj2;
}

int main( int argc, char **argv )
{
  Histo_App app;
  app.run();
}]]>
</listing>
</subsection>

<subsection>
<stitle>Output Generated</stitle>
<lprout>
<![CDATA[
2D histogram content
bin(0,0): 1 -/+ 0.707107
bin(1,0): 0 -/+ 0
bin(2,0): 0 -/+ 0
bin(3,0): 0 -/+ 0
bin(4,0): 0 -/+ 0
bin(5,0): 0 -/+ 0
bin(6,0): 0 -/+ 0
bin(7,0): 0 -/+ 0
bin(8,0): 0 -/+ 0
bin(9,0): 1 -/+ 0.707107
bin(0,1): 0 -/+ 0
bin(1,1): 2 -/+ 1
bin(2,1): 0 -/+ 0
bin(3,1): 0 -/+ 0
bin(4,1): 0 -/+ 0
bin(5,1): 0 -/+ 0
bin(6,1): 0 -/+ 0
bin(7,1): 0 -/+ 0
bin(8,1): 2 -/+ 1
bin(9,1): 0 -/+ 0
bin(0,2): 0 -/+ 0
bin(1,2): 0 -/+ 0
bin(2,2): 2 -/+ 1
bin(3,2): 0 -/+ 0
bin(4,2): 0 -/+ 0
bin(5,2): 0 -/+ 0
bin(6,2): 0 -/+ 0
bin(7,2): 2 -/+ 1
bin(8,2): 0 -/+ 0
bin(9,2): 0 -/+ 0
bin(0,3): 0 -/+ 0
bin(1,3): 0 -/+ 0
bin(2,3): 0 -/+ 0
bin(3,3): 0.5 -/+ 0.5
bin(4,3): 0 -/+ 0
bin(5,3): 0 -/+ 0
bin(6,3): 0.5 -/+ 0.5
bin(7,3): 0 -/+ 0
bin(8,3): 0 -/+ 0
bin(9,3): 0 -/+ 0
bin(0,4): 0 -/+ 0
bin(1,4): 0 -/+ 0
bin(2,4): 0 -/+ 0
bin(3,4): 0 -/+ 0
bin(4,4): 1 -/+ 0.707107
bin(5,4): 1 -/+ 0.707107
bin(6,4): 0 -/+ 0
bin(7,4): 0 -/+ 0
bin(8,4): 0 -/+ 0
bin(9,4): 0 -/+ 0
bin(0,5): 0 -/+ 0
bin(1,5): 0 -/+ 0
bin(2,5): 0 -/+ 0
bin(3,5): 0 -/+ 0
bin(4,5): 2 -/+ 1
bin(5,5): 2 -/+ 1
bin(6,5): 0 -/+ 0
bin(7,5): 0 -/+ 0
bin(8,5): 0 -/+ 0
bin(9,5): 0 -/+ 0
bin(0,6): 0 -/+ 0
bin(1,6): 0 -/+ 0
bin(2,6): 0 -/+ 0
bin(3,6): 1 -/+ 0.707107
bin(4,6): 0 -/+ 0
bin(5,6): 0 -/+ 0
bin(6,6): 1 -/+ 0.707107
bin(7,6): 0 -/+ 0
bin(8,6): 0 -/+ 0
bin(9,6): 0 -/+ 0
bin(0,7): 0 -/+ 0
bin(1,7): 0 -/+ 0
bin(2,7): 2 -/+ 1
bin(3,7): 0 -/+ 0
bin(4,7): 0 -/+ 0
bin(5,7): 0 -/+ 0
bin(6,7): 0 -/+ 0
bin(7,7): 2 -/+ 1
bin(8,7): 0 -/+ 0
bin(9,7): 0 -/+ 0
bin(0,8): 0 -/+ 0
bin(1,8): 1.5 -/+ 0.866025
bin(2,8): 0 -/+ 0
bin(3,8): 0 -/+ 0
bin(4,8): 0 -/+ 0
bin(5,8): 0 -/+ 0
bin(6,8): 0 -/+ 0
bin(7,8): 0 -/+ 0
bin(8,8): 1.5 -/+ 0.866025
bin(9,8): 0 -/+ 0
bin(0,9): 1.5 -/+ 0.866025
bin(1,9): 0 -/+ 0
bin(2,9): 0 -/+ 0
bin(3,9): 0 -/+ 0
bin(4,9): 0 -/+ 0
bin(5,9): 0 -/+ 0
bin(6,9): 0 -/+ 0
bin(7,9): 0 -/+ 0
bin(8,9): 0 -/+ 0
bin(9,9): 1.5 -/+ 0.866025

First slice
.  0:         1 +/- 0.707107
.  1:         0 +/-    0
.  2:         0 +/-    0
.  3:         0 +/-    0
.  4:         0 +/-    0
.  5:         0 +/-    0
.  6:         0 +/-    0
.  7:         0 +/-    0
.  8:         0 +/-    0
.  9:       1.5 +/- 0.866025

Second slice
.  0:         1 +/- 0.707107
.  1:         0 +/-    0
.  2:         0 +/-    0
.  3:         0 +/-    0
.  4:         0 +/-    0
.  5:         0 +/-    0
.  6:         0 +/-    0
.  7:         0 +/-    0
.  8:         0 +/-    0
.  9:         1 +/- 0.707107

First projection
.  0:         2 +/-    1
.  1:         4 +/- 1.41421
.  2:         4 +/- 1.41421
.  3:         1 +/- 0.707107
.  4:         2 +/-    1
.  5:         4 +/- 1.41421
.  6:         2 +/-    1
.  7:         4 +/- 1.41421
.  8:         3 +/- 1.22474
.  9:         3 +/- 1.22474

Second projection
.  0:       2.5 +/- 1.11803
.  1:       3.5 +/- 1.32288
.  2:         4 +/- 1.41421
.  3:       1.5 +/- 0.866025
.  4:         3 +/- 1.22474
.  5:         3 +/- 1.22474
.  6:       1.5 +/- 0.866025
.  7:         4 +/- 1.41421
.  8:       3.5 +/- 1.32288
.  9:       2.5 +/- 1.11803
]]>
</lprout>
</subsection>
</section>
</chapter>
</appendix>
</bodymatter>
</document>
