<!-- 	$Id: lhcppintro.sgml,v 1.13 1998/11/27 17:17:32 goossens Exp goossens $	 -->
<!DOCTYPE HTML PUBLIC  "-//W3C//DTD HTML 3.2//EN" [
<!ENTITY quot "&#34;">
<!ENTITY GNU  "GNU">
<!ENTITY NICE "Nice">
<!ENTITY OBJ  "Objectivity/DB">
<!ENTITY UNIX "Unix">
<!ENTITY WNT  "Windows/NT">
]>
<HTML>
<HEAD>
<TITLE>C++ Libraries for HEP</TITLE>
<!-- Changed by: Michel Goossens, 24-Mar-1998 -->
</HEAD>
<BODY>

<!--filename=PresentingLHCPP.html-->
<H1><A NAME="H1PresentingLHCPP">Presenting LHC++</A></H1>

<H2>A short historical introduction</H2>
!!TEX!!\index{History of LHC++}\index{LHC++!history}%

<P>In 1995 a working group, called <EM>LHC++</EM>, consisting of
representatives of IT Division's ASD Group and of the various LHC
experiments, was created to investigate how the approximate equivalent
of the current CERNLIB environment could be provided in the LHC
!!TEX!!\index{CERNLIB}%
era. Although the primary objectives of the discussions concentrated
on proposing solutions for future LHC experiments, it is essential
that other HEP experiments which are coming online in the next couple
of years will also be able to benefit from the proposed strategy.</P>

<P>It is clear that (industry) standard solutions should be used
whenever possible. This is nothing new since in the past commercial
libraries or programs, such as GKS/GTS, Numerical Algorithms Group
(NAG) libraries, Phigs, Historian, and CMZ)
!!TEX!!\index{NAG}\index{Numerical Algorithms Group Ltd}%
!!TEX!!\index{GKS}\index{GTS}%
!!TEX!!\index{Phigs}%
!!TEX!!\index{Historian}%
!!TEX!!\index{CMZ}%
have been used in the CERNLIB environment.  Intensive investment of
!!TEX!!\index{CERNLIB}%
manpower should only be made in HEP-specific developments, where the
needed functionality cannot be obtained <EM>off the shelf</EM> at
affordable prices. An instance of such a HEP development is the CLHEP
class library, which is also a nice example of reuse.</P>

<P>Working closely with the LHC collaborations and other HEP
Laboratories in 1996 and 1997 an interim strategy was defined and a
number of licences for the commercial components was obtained.  When
several <EM>a priori</EM> solutions were available, a study was made
to determine which was the most suited in the HEP context.  We also
tested the proposed solutions at a few sites and ensured that it is a
workable environment.</P>

<H2>Objectives</H2>

<P>The main objective of LHC++ is to satisfy the requirements of the
LHC experiments in terms of the overall software environment that
today is provided by CERNLIB, as requested in these experiments'
!!TEX!!\index{CERNLIB}%
<EM>Computing Technical Proposals</EM></P>

<P>This translates into the following key points for the short to
medium term:</P>

<UL> 
<LI>identify and provide key HEP-specific functions;</LI>
<LI>define affordable solutions for the non-HEP-specific parts;</LI>
<LI>monitor the non-HEP world for possible future useful
software;</LI>
<LI>study and understand the requirements of the LHC experiments for
C++-based mathematical libraries, and evaluate existing and future
developments, both commercial and otherwise in this area;</LI>
<LI>study the requirements for a minimisation package
(Minuit-replacement), in particular follow closely developments of
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR>
the STABLE project, which should provide the needed functionality,
!!TEX!!\index{STABLE}\index{Minimisation!STABLE}%<BR>
both stand-alone and in the framework of IRIS Explorer;</LI>
<LI>undertake a number of pilot projects with the experiments 
to test the overall functionality of the LHC++ environment;</LI>
<LI>supplement, where necessary, the existing documentation, both 
printed and online, with a set of user guides and tutorials;</LI>
<LI>agree with the experiments and other HEP laboratories on
a scheme for managing licenses, so that the best possible deals 
can be negotiated.</LI>
</UL>

<P>The scope of the LHC++ project covers the following:</P>

<UL>
<LI>foundation level class libraries;</LI>
<LI>mathematical libraries;</LI>
<LI>graphical libraries;</LI>
<LI>visualisation tool-kits, data analysis, histograms;</LI>
<LI>event generators (in collaboration with, e.g., Lund);</LI>
<LI>detector simulation (GEANT-4 via RD44 at present);
!!TEX!!\index{GEANT 4}\index{RD44 Project}
</LI>
<LI>object persistency (&OBJ; via RD45 at present).
!!TEX!!\index{RD45 Project}\index{&OBJ;}%<BR>
</LI>
</UL>

<P>The primary focus is on C++-based solutions, although, of course,
developments in the software arena, in particular the increased
importance of Java, are closely watched.</P>

<H2>Collaboration with the experiments</H2>

<P>The LHC++ project is a joint effort between IT Division (mainly ASD
Group), the LHC experiments, plus NA45, Compass,...  Jamie Shiers, as
LHC++ Librarian/Project Leader is responsible for its overall
coordination.</P>

<P>Regular (bi-weekly) LHC++ and RD45 meetings are held in Building 40. This
!!TEX!!\index{Regular meetings (LHC++, RD45)}%
!!TEX!!\index{LHC++!Regular meetings}%
is an ideal forum for communication with the physics community since
its allows us to bring our users regularly up to date with the latest
news. Also, and more importantly, it provides us with an input channel
from the experiments about how they use the software, which are
possible problem areas which have to be addressed, and what are the
future developments they would like to see.
The minutes as well as material presented on the progress
in the various areas are available on the <A HREF="http://wwwinfo.cern.ch/asd/lhc++/meetings.html">Web</A>.</P> 

<P>Twice a year a formal <A
HREF="http://wwwinfo.cern.ch/asd/lhc++/workshops.html"><EM>LHC++
Workshop</EM></A>
!!TEX!!\index{LHC++!workshop}\index{Workshop (LHC++)}%
take place where progress reports are presented by all HEP-wide
collaborations who are using LHC++ software. This Workshop provides an
efficient forum for feedback from the experiments and permits us to
steer long-term development in the right direction by taking into 
account constraints and requirements of as wide a user base as possible.</P>

<P>The LHC++ Project also wrote a <EM>Project Execution Plan</EM> <A
HREF="http://wwwinfo.cern.ch/asd/lhc++/pep/pep97.html">(PEP)</A> and
as such presents regularly reports to the <EM>LHC Computing
Board</EM>(LCB).</P>
!!TEX!!\index{LCB}%
!!TEX!!\index{LHC Computing Board}%

<P>In order to optimise communication and ensure that the development
team keeps synchronised with user demands and can react to them
quickly, each of the large experiments has a contact person inside ASD
Group.</P>

<P>It is important to note that BaBar and Compass, with whom we are in
close contact, have both chosen a similar software strategy, although
their priorities somewhat differ from ours since they face a much
tighter time-scale than the LHC. Of course, such collaborations with
similar activities at other laboratories is one of our main aims and
strengths.
</P>

<P>
Many of the members of the LHC++ development team are also active in
the detector simulation <A
HREF="http://wwwinfo.cern.ch/asd/geant/geant4.html">RD44 (GEANT-4)</A>
!!TEX!!\index{GEANT 4}\index{RD44 Project}%
and object persistency <A
HREF="http://wwwinfo.cern.ch/asd/cernlib/rd45/index.html">RD45 (&OBJ;
at present)</A> initiatives.
!!TEX!!\index{RD45 Project}\index{&OBJ;}%<BR>
This symbiosis ensures that all these projects develop in a harmonious
and compatible way and exploit maximally the reuse of components.
In particular, both RD44 and RD45 have contributed classes to CLHEP,
a component of LHC++.</P>

<P>All three LCB common projects (RD44, RD45, LHC++) stress the formal
gathering of use of requirements. Equally the priorities for these
projects, each of which is dominated by members of LHC and other
HEP experiments, are agreed at the level of the LCB, which is itself
mainly composed of experimental representatives.</P>

<H2>Current Situation</H2>

<P>
By using commodity solutions where-ever possible, we ensure that
the proposed solutions are widely used, well-debugged and well
documented, and are also more affordable. These solutions are being
complemented by HEP-specific components, where needed, by building a
HEP user-layer on top of standards-conforming products.
</P>

<P>
To ensure that the commercial components work well together, the
LHC++ strategy closely adheres to standards - both <EM>de-facto</EM>
and <EM>de-jure</EM>.  Examples of <EM>de-jure</EM> standards include
the <A
HREF="http://www.objectspace.com/Products/CCS/Standards/standards.html"><EM>Standard
C++ Library</EM></A> 
and ODMG-compliant Object Database Management
!!TEX!!\index{Standard Library}%
Systems (ODBMS), while instances of <EM>de-facto</EM> standards 
!!TEX!!\index{ODBMS}\index{Object Database Management System}%
are industry standard graphics packages,
such as OpenGL, Open Inventor and IRIS Explorer
<A HREF="http://www.nag.co.uk/visual/IE/iecbb/Tutorial/index.html">
<EM>(tutorial)</EM></A>, all originally from Silicon Graphics (SGI).
!!TEX!!\index{OpenGL}%
!!TEX!!\index{Open Inventor}%
!!TEX!!\index{IRIS Explorer}%
!!TEX!!\index{SGI}%
!!TEX!!\index{Silicon Graphics}%
</P>

<P>
The table below shows this layered structure more schematically.
Licenses for all commercial components are available at CERN, where
the software has been installed on all &UNIX; platforms (Dec, HP, and
Sun for IRIS Explorer 3.9) on AFS in <TT>/afs/cern.ch/sw/lhcxx</TT>,
while on &NICE;/&WNT; it is available under <TT>z:\p32\lhcxx</TT>.
!!TEX!!\index{AFS}\index{&WNT;}\index{&NICE;}%
</P>

<TABLE BORDER="1">
<TR><TD ALIGN="center">GEANT-4, MCLIBS++</TD></TR>
<TR><TD ALIGN="center">HEPExplorer, IRIS Explorer</TD></TR>
<TR><TD ALIGN="center">HepVis, HEPInventor</TD></TR>
<TR><TD ALIGN="center">OpenGL, Open Inventor, Master Suite</TD></TR>
<TR><TD ALIGN="center">HepMATH, including GEMINI</TD></TR>
<TR><TD ALIGN="center">NAG C library (with C++ headers)</TD></TR>
<TR><TD ALIGN="center">CLHEP</TD></TR>
<TR><TD ALIGN="center">HistOOgrams</TD></TR>
<TR><TD ALIGN="center">HEPODBMS</TD></TR>
<TR><TD ALIGN="center">ODMG, ODBMS (&OBJ;) + persistent STL</TD></TR>
<TR><TD ALIGN="center">Standard C++ Libraries</TD>
</TABLE>
!!TEX!!\index{NAG}\index{GEANT 4}%<BR>

<P>All of the commercial LHC++ components come with excellent online
documentation. In most cases, printed documentation, often in the form
of published books, is also available and can be bought from the User
Consultancy Office (UCO) at CERN. HEP-specific examples and other
information specific to the HEP environment is clearly not available
from the vendors.</P>

<P>
The main purpose of the present manual is to provide a tutorial
introduction to the use of LHC++ tools for physicist new to the LHC++
computing paradigm.  The current guide describes the present state of
some of the HEP extensions.  Their precise form and application
program interface (API) probably needs to be refined or extended in
a few places. Therefore we invite all users of the LHC++ software to
forward their comments and suggestions to the LHC++ team,
preferably at the LHC++ regular meetings mentioned above.</P>
!!TEX!!\index{Regular meetings (LHC++, RD45)}%
!!TEX!!\index{LHC++!Regular meetings}%

<H2>An overview of the commercial components</H2>

<P>The commercial components of LHC++ are chosen because they offer a
coherent set of inter-operable solutions. They are built on standards
and often come as part of the standard hardware or software bundled
with the computer. Cost effectiveness has also been optimised both
for CERN and for the general CERN HEP program participants.

<H3>OpenGL</H3>
!!TEX!!\index{OpenGL|(}

<P>
<A
HREF="http://www.sgi.com/Products/Dev_environ_ds.html"><EM>OpenGL</EM></A>
is a industry standard for graphics. It is vendor-neutral and
multi-platform, and is optimised for building environments for
developing 2D and 3D visual applications. Several vendors already
offer a hardware implementation of the standard, thus ensuring
that rendering speed will be optimal.</P>

<P>
The about 250 OpenGL procedures provide a wide range of graphics
features, such as a set of geometric and raster primitives, various
colour modes, display list or immediate mode, viewing and modelling
transformations, lighting and shading, hidden surface removal and
translucency, anti-aliasing, texture mapping, effects using fog,
smoke, or haze, etc.  As all licensed OpenGL implementations are
required to pass a set of conformance tests, and implement the same
specification and language binding document full portability between
multiple platforms is guaranteed.</P>

<P>Documentation is available as two books: the <EM>OpenGL Programming
Guide</EM>, and the <EM>OpenGL Reference Manual</EM>, both published
by Addison and Wesley (and available from the UCO at CERN).</P>
!!TEX!!\index{OpenGL|)}

<H3>Open Inventor</H3>
!!TEX!!\index{Open Inventor|(}

<P><A HREF="http://www.sgi.com/Technology/Inventor/index.html"><EM>Open
Inventor</EM></A> is an object-oriented 3D toolkit to provide a
comprehensive solution to interactive graphics programming.  Its
programming model is based on a 3D scene database optimised to ease
building graphics applications. It includes a large set of objects,
such as cubes, polygons, text, materials, cameras, lights,
track-balls, handle boxes, 3D viewers, and editors.</P>

<P>Open Inventor is built on top of OpenGL. It defines a standard file
format (IV) for 3D data interchange and introduces a simple event model for
3D interaction. Animation is provided with <EM>Engines</EM>. Open
Inventor offers a convenient multi-platform 3D graphics development
environment, which allows efficient manipulation of objects in a
windows and operating system independent way.</P>

<P>Open Inventor's IV files serve as the basis for the <a
href="http://vrml.wired.com"><EM>VRML (Virtual Reality Modelling
Language)</EM></A> standard. The Open Inventor toolkit is conveniently
documented in three books <EM>The Inventor Mentor</EM>, <EM>The
Inventor Toolmaker</EM>, and <EM>The Open Inventor C++ Reference
Manual</EM> published by Addison-Wesley (available from the UCO at
CERN).</P>
!!TEX!!\index{Open Inventor|)}

<H3>MasterSuite</H3>
!!TEX!!\index{MasterSuite|(}%

<P><a
href="http://wwwinfo.cern.ch/asd/lhc++/MASTER_SUITE/MasterDocHTML/msuite.htm"><EM>MasterSuite</EM></A>
is a C++ toolkit for data visualisation, containing class libraries
with extension nodes to Open Inventor. These extensions cover 2D
drawing and charting, 3D drawing, legends, etc., and provide a set of
input devices to ease cross-platform design of user interfaces, as
well as set of classes to develop viewers for scientific data for
output on screen as well as on several types of printers in
vector-graphics mode.  It supports vector graphics output, in
particular PostScript output and is easily extensible by programming
new user-defined customisable objects.</P>

<P>MasterSuite comes with four components, DialogMaster, PlotMaster,
GraphMaster, and 3DDataMaster.  Because it is built on top of Open
Inventor you always have access to all Open Inventor rendering
capabilities, such as camera, lighting, texturing, fog, etc. Similarly
Master Suite node fields can interact with Open Inventor engines for
providing animation of building sensors to change data values.  Data
can be saved in an Open Inventor database and metafile, in particular
in IV format, thus allowing one to distribute visualisation over the
Internet in a natural and straightforward way.</P>
!!TEX!!\index{MasterSuite|)}%

<H3>IRIS Explorer</H3> 
!!TEX!!\index{IRIS Explorer|(}

<P>
<A HREF="http://www.sgi.com/Technology/explorer.html"><EM>IRIS Explorer
(IE)</EM></A> is a toolkit for visualisation of scientific data, which can
be manipulated via visual programming tools.  Users analyse their data
by connecting building blocks, called <EM>modules</EM>.  Modules act
like <EM>filters</EM>: they read one of more streams of input data and
produce one of more streams of output data. The behaviour of modules
are controlled (interactively) by a set of parameters. IE comes will a
rather complete set of modules for performing basic data
transformations, and it is straightforward to create new modules.  It
is noteworthy that, because of its wide use, a lot of modules
developed by various user communities are available publicly, while
some can be obtained commercially (see below).</P>

<P>
To transform user data, one constructs a <EM>map</EM>, which is a
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
network of interconnections between a set of modules. The various
components of a map can be manipulated individually and interactively,
and a map can be saved for later retrieval. If one of the modules is
time-consuming or needs special hardware then it can be run on a
different node of the network, thus parallel processing possibilities
are part of the system.</P>

<P>
A well-written <a
href="http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html"><EM>tutorial</EM></A>
by the <EM>IRIS Explorer Centre of Excellence (IECOE)</EM> at the
!!TEX!!\index{IECOE!IRIS Explorer Centre of Excellence}
University of Leeds will you teach how to master the basics of the
program. The <A HREF="http://www.scs.leeds.ac.uk/iecoe/"><EM>IECOE
website</EM></A> also provides a series of hyperlinks to other sites from
where IE modules can be downloaded. A printed and bound copy of the
<EM>IRIS Explorer User's Guide</EM> can be obtained from the UCO.</P>
!!TEX!!\index{IRIS Explorer|)}

<H3>&OBJ;, the Object Database</H3>
!!TEX!!\index{&OBJ;|(}

<P>In order to study solutions for storing and handling the
multi-Pbyte data samples expected with LHC, the <a
href="http://wwwinfo.cern.ch/asd/cernlib/rd45/index.html"><EM>RD45
Project</EM></A> was established in 1995.  The proposed solution
!!TEX!!\index{RD45 Project}\index{&OBJ;}%<BR>
should also be able to cope with other persistent objects, such as
histograms, calibration monitoring data, etc. It was found that the
best candidate for handling this problem is a <A
HREF="http://www.odmg.org/"><EM>ODMG</EM></A> (Object Database
Management Group) compliant object database used together with a mass
storage system, based upon the IEEE reference model for mass storage
systems. After considering a few alternatives, the presently favoured
solution uses <A HREF="http://www.objy.com/"><EM>&OBJ;</EM></A> and <a
href="http://www.sdsc.edu/hpss/"><EM>HPSS</EM></A> (High Performance
!!TEX!!\index{HPSS}%
!!TEX!!\index{High Performance Storage System}%
Storage System).</P>

<P>The &OBJ; database provides object-persistency services for GEANT-4
!!TEX!!\index{GEANT 4}%<BR> 
and the experimental data. It must fully support HEP meta-data, not
only the persistent data collections themselves, but it must also
handle the selections producing these collections, and the predicates
themselves. Replication of large database images on local area and
wide area network configurations containing heterogeneous hardware
must allow collaborators all over the world to actively participate in
data analysis. Given the large time scales (the lifetime of the LHC
software will span at least twenty years) schema evolution and
versioning are important aspects which must be taken into account.
&OBJ; comes with a set of administrative tools to ease database
management. &OBJ; also comes with an <EM>Advanced Multi-threaded
Server</EM> (AMS) and an interface to HPSS.
!!TEX!!\index{Advanced Multi-threaded Server}\index{&OBJ;}%
!!TEX!!\index{AMS}%
!!TEX!!\index{HPSS}%
This provides fast access to data and offers a large performance
improvement when updating data stored in remote databases. It is
expected that each experiment will run starting in 1998 a production
service of one or more of these servers.</P>

<P>&OBJ; has a layered logical storage level, with at its top the
<EM>federated database</EM>. Each federated database logically
contains one or more <EM>databases</EM>, with the latter containing
the <EM>objects</EM>, which are clustered, for efficiency, inside
<EM>containers</EM>. An <EM>object</EM> itself consists of standard
C++ constructs, variable-size arrays, relationships and references to
other objects, and type constraints. Persistent objects can be created
and deleted dynamically by any application. The data model, or
<EM>schema</EM> is stored inside the federated database.</P>
!!TEX!!\index{Object}\index{Federated database}\index{Database}%<BR>
!!TEX!!\index{Container}\index{Data model}\index{Schema}%<BR>
!!TEX!!\index{&OBJ;|)}

<H3>Mathematical Libraries</H3>
!!TEX!!\index{Mathematical libraries}

<P>
CERN no longer has any in-house mathematician supporting mathematics
libraries. Therefore, we shall have to rely on libraries developed
outside CERN, and it was decided to make the <a
href="http://www.nag.co.uk/numeric/CL.html"><EM>NAG
C-language</EM></A> library available.  Although the NAG C Library
provides the basic functionality required by HEP, a small number of
routines (basically special functions) are currently unavailable.  A
future release of the above library is likely to incorporate these
routines.
!!TEX!!\index{NAG}%
!!TEX!!\index{Numerical Algorithms Group Ltd}%
</P>

<H3>Statistical Data Analysis: the Gemini package</H3>
!!TEX!!\index{Gemini}\index{Minimisation!Gemini}%<BR>

<P>
Gemini is a GEneral MINImization and error analysis package
implemented as a C++ class library. Minuit's functionality is provided
in a <EM>Minuit-style</EM> (even if, internally, another minimizer may
actually do the work) and new functionality offered by NAG C
minimizers is added. Gemini thus provides a unified C++ API both to
standard Minuit and to NAG C family of minimizers. For the common
subset of functionality, it is up to the user which minimization
engine does the work: Minuit or NAG C. The user can easily switch
between various minimizers without essential changes in the
application code. The currently supported set of minimizers (Minuit
and NAG C) can be extended without essential changes in the API.
</P>
<P>
The abstract base class <TT>GEmini</TT> defines an interface to the
common functionality. The <TT>CMinuit</TT> class is derived from
<TT>GEmini</TT> and provides a Minuit-based implementation of the
GEmini functionality plus Minuit-specific extensions. Similarly, the
<TT>NAGmin</TT> class is derived from <TT>GEmini</TT> as well and
provides a NAG-based implementation of the <TT>GEmini</TT>
functionality plus NAG-specific extensions.
</P>
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR> 

<P>
There is no single class which contains references both to Minuit and
to NAG C, so that orthodox Minuit or Nag C users are not forced to
link the other library.
</P>
<P>
Gemini finds a minimum of an objective function, possibly subject to
general constraints, and performs an error analysis. The concept of
errors is that of Minuit, so that it is the user's responsibility to
properly scale the inversed Hessian, and to properly interpret the
results. Both Hessian based errors and Minos errors are
implemented. Correspondingly, two types of function contours (or
confidence regions, in statistical problems) are available: elliptical
and Minos ones. Minos error analysis is, however, possible only for
bound constraint problems.
</P>

<P>On a longer timescale we are also following the STABLE Project,
which is funded by the European Commission and involves NAG and other
partners. The aim of the project is to design, build and demonstrate a
modern Statistical Application Building Environment.</P>

<P>The STABLE project will integrate an existing application building
system, IRIS Explorer, and an existing widely used statistical
software system, Genstat, along with other available statistical
algorithms. The STABLE system will then be evaluated by constructing
end-user tools in different application areas.</P>

<H2>Overview of the HEP-specific components</H2>

<P>
Although commercial and public-domain packages offer a great deal
of functionality, there is a clear need to supplement them with
HEP-specific extensions. Some of these extensions take the form of
complete class-libraries, such as CLHEP. Others represent large
toolkits, such as 
<A HREF="http://wwwinfo.cern.ch/asd/geant/geant4.html"><EM>GEANT-4</EM></A>. 
!!TEX!!\index{GEANT 4}%<BR>
Moreover, in areas such as graphics and visualisation, the basic
tools, such as Open Inventor for basic graphics and IRIS Explorer for
!!TEX!!\index{Open Inventor}\index{IRIS Explorer}%
visualisation, need to be extended to cope with the specific needs of
the HEP experiments.</P>

<H3>HEPODBMS</H3>
!!TEX!!\index{HEPODBMS|(}
<P>
HepODBMS is a set of class libraries built on top of the ODMG C++
interface. Their purpose is to provide a higher level interface than
is specified by the ODMG, to simplify the porting of existing
applications and provide a minimum level of support for
transient-persistent switching. Furthermore, these libraries help to 
insulate applications against  changes between releases from 
a given vendor and between the products of different vendors.
!!TEX!!\index{ODMG}%
</P>
!!TEX!!\index{HEPODBMS|)}

<H3>CLHEP</H3>
!!TEX!!\index{CLHEP|(}

<P>The <a
href="http://wwwinfo.cern.ch/asd/lhc++/clhep/index.html"><EM>CLHEP</EM></A>
project was initiated at CHEP'92; it intends to provide <EM>foundation
level</EM> classes required in HEP. At present they include
<UL>
<LI><TT>Alist</TT> for lists and list iterators;
<LI><TT>Combination</TT>;
<LI><TT>Geometry</TT> for vectors, rotations, transformations;
<LI><TT>Matrix</TT> for matrix manipulations;
<LI><TT>Random</TT> for random numbers;
<LI><TT>String</TT> for different string types;
<LI><TT>Units</TT> for system of units and physical constants;
<LI><TT>Vector</TT> for vector operations (3-vector and Lorentz-type).
</UL>
<P>CLHEP became formally part of LHC++ in 1995. The first official release
of CLHEP (V1.0) took place in April 1997 (CHEP'97). CLHEP-based
classes will be integrated in the beta-release of GEANT 4 early 1998.
!!TEX!!\index{GEANT 4}%<BR>
The complete user documentation, with a detailed description of 
all classes is being written and will be available by the end of 1997.</P>
!!TEX!!\index{CLHEP|)}

<H3>The HistOOgram class library</H3>

<P>The HistOOgram class library provides Object Oriented histograms.
They come in two versions:</P>

<UL>
<LI>Persistent HistOOgrams (based on &OBJ;)</LI>
<LI>Transient HistOOgrams (text file I/O)</LI>
</UL>

<P>For HEPExplorer (see below) the persistent version of the library
is needed, since HistOOgrams are passed among IRIS Explorer Modules as
&OBJ; objects, identified by their object identifier (&OBJ; is used as
an <EM>object broker</EM> by the IE modules).</P>

<H3>HEPInventor</H3>
!!TEX!!\index{HEPInventor|(}

<P><A
HREF="http://wwwinfo.cern.ch/asd/lhc++/dat/hepinventor.html"><EM>HEPInventor</EM></A>
proposes an easily understandable and user-friendly way to present
data in physics programs. It is implemented as a graphical class
library build on top of MasterSuite (TGS) to provide an interface
between 
!!TEX!!\index{MasterSuite}%
data structures (like HistOOgrams) and graphics.</P>
!!TEX!!\index{HEPInventor|)}

<H3>HepVis</H3>
!!TEX!!\index{HepVis|(}

<P>
The goal of the <a
href="http://www.cern.ch/Physics/Workshops/HepVis/"><EM>HepVis Project</EM></A>
is to create and distribute a toolkit library consisting of graphical
objects capable of representing the most common entities of a collider
physics experiment. Previous experience has shown that mere
representations of objects on a workstation screen is insufficient,
and that native support for picking objects with user-defined actions,
and a high-degree of interactivity, both local and global, is needed.
Therefore, the HepVis toolkit is being implemented as an extension to
Open Inventor, providing common physics objects as subclasses or as
real extensions.  Only the graphical representation of the objects
will be defined, leaving it up to the experiments to define physics
objects and their behaviour, and whether to integrate these with
the graphical objects in question.
!!TEX!!\index{HepVis|)}
</P>


<H3>HEPExplorer</H3>
!!TEX!!\index{HEPExplorer|(}

<P>
<EM>HEPExplorer (HE)</EM> is a set of HEP-specific IRIS Explorer
modules, which help a physicist set up an environment to analyse
experimental data, produce histograms, fit models and prepare data
presentation plots using LHC++'s IE framework. It is based on
HEPInventor, histOOgrams, and HepODBMS.
</P>

<P>HEPExplorer consists of the following parts.</P>

<UL>
<LI>
<P><EM>IRIS Explorer user types for HEP</EM></P> <P>In order to extend
the type of data that can be passed among IRIS Explorer Modules, new
data types have been defined to deal with HEP objects.</P></LI>
<LI><P><EM>IRIS Explorer HEP-specific modules</EM></P> <P>A set of
HEP-specific IRIS Explorer modules is stored on AFS/&NICE; and is
available after setting up your environment in an appropriate
way. These modules allow for histogram handling and Ntuple-like analysis.
!!TEX!!\index{Ntuple}%
</P></LI>
</UL>

<P>Note that, since HE needs &OBJ; to store HistOOgrams and their
associated schema, an &OBJ; database is a prerequisite for using HEPExplorer
with histOOgrams.</P>
!!TEX!!\index{HEPExplorer|)}

<H2>Problem tracking</H2>
!!TEX!!\label{S-GNATS}%

<P>LHC++ has been incorporated into the GNATS-based <A
HREF="http://gnats.cern.ch/"><EM>IT Problem Report Management
System</EM></A>, under the heading <EM>LHC++ Support Services</EM>.
!!TEX!!\index{GNATS}\index{Problem reporting}%
!!HTML!!The Web interface can be accessed
!!HTML!!<A HREF="http://gnats.cern.ch/cgi-bin/wwwgnats.pl/LHCXX/">here</A>.
!!TEX!!The Web interface is shown in Figure \ref{GNATS}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{gnats.eps}
!!TEX!!\caption{LHC++ GNATS Web problem reporting system}
!!TEX!!\label{GNATS}
!!TEX!!\end{figure}

<P>Users are invited to primarily use this system to submit problem
reports. This ensures that the problems are documented, can be easily
tracked, and also become available to other users, who can then browse
the problem database and profit from the proposed solutions.</P>

<!--filename=LHCPPObjectModel.html-->
<H1><A NAME="H1LHCPPObjectModel">LHC++ Object Model</A></H1>

<H2>A historical digression: Ntuples and PAW</H2>

<P>
During the past decade, many HEP experiments  have based their
interactive data analysis on the following steps
(see the top half of
!!TEX!!Figure \ref{NTUPLETAGDB}).<BR>
!!HTML!!the figure below).
</P>

<OL>
<LI>
<EM>Raw and reconstructed</EM> data are stored in <EM>banks</EM> in an
experiment-specific hierarchical format.  Most of the time one uses
many different files on several distinct hosts.
</LI>
<LI>
These data are <EM>distilled</EM> and <EM>reclustered</EM> to obtain a
more compact and thus more efficient representation. This permits a
significant speed-up for the down-stream analysis compared to using
the data in their raw form as described in point 1.  This format
corresponds to the so-called HBOOK Ntuples.  One drawback of this
method is that the direct relation to the raw <EM>event data</EM> is
lost.
!!TEX!!\index{HBOOK}\index{Ntuple}
</LI>
<LI>
Ntuple files are analysed <EM>interactively</EM> with programs
like PAW. Plots of physics variables are produced by extracting
information contained in one or more of the Ntuple rows or columns,
binning them in HBOOK histograms and then operating on these histograms
to obtain the best representation. 
!!TEX!!\index{HBOOK}%
</LI>
</OL>

<P>
The advantage of Ntuples is that their format is known and simple enough, 
!!TEX!!\index{Ntuple}\index{PAW}%
so that a general purpose analysis tool, such as PAW can cope with data
coming from any experiment. On the other hand, since no link to the
original data exists, Ntuples impose a limitation on the structure of
the data physicists can use for their analysis. On top of that, since
the data were copied from the original files into a dedicated Ntuple
file, each time original dataset changed most Ntuple files had to be
regenerated.
</P>
<P>
Two kinds of Ntuples exists. <EM>Row-Wise Ntuples</EM> transform a
complex data structure into a simple tabular form.  <EM>Column-Wise
Ntuples</EM> on the other hand improve the flexibility of the Ntuple data
model by allowing the definition of variable-length items, but they
still are difficult to use to describe complex data structures, like
those of the reconstructed data.  Moreover, the Ntuple Query language
is rather non-intuitive and complex to master.
</P>

<H2><A NAME="NEWDATAMODEL">The new Data Model</A></H2>
!!TEX!!\label{SNEWDATAMODEL}%

<P>
Most new HEP experiments assume that it will be possible to make both
raw data and reconstructed data available <EM>on-line</EM> thanks to
the integration between &OBJ; and HPSS. Each experiment will
!!TEX!!\index{HPSS}%
have its own data model and physicists should be able to
<EM>navigate</EM> through it. This is a major problem for a
general-purpose Interactive Analysis environment, since, unlike the
Ntuple case, there no longer exists a common and pre-defined data
!!TEX!!\index{Ntuple}%
model shared amongst all experiments. This problem can be solved but there
is no easy way out: the general-purpose tool should be able to access
the arbitrary experiment data model using some kind of run time type
information or the initial data model definition.
</P>

<P>
Since all data is supposed to be <EM>on-line</EM>, the role of the Ntuple
replacement could be quite different. While reasonably small
<EM>personal</EM> data collections will still exist, the main concern
will probably be how to index large event stores to speed up the
analysis. 
</P>

<P>
The RD45 Project suggested one approach to deal with both problems.
!!TEX!!\index{RD45 Project}%<BR>
The idea it to speed up queries by defining for each event a <EM>Tag</EM>, 
!!TEX!!\index{Tag}\index{Event}%
i.e., a small collection of its most important physics attributes plus
an association with the event where the Tag data come from. Such
!!TEX!!\index{Event association}\label{sec:eventassociation}%
<EM>Concrete</EM> Tags contain copies of data members of a 
!!TEX!!\index{Concrete tag}%
persistent data class. A collection of tag objects 
!!TEX!!\index{Tag!concrete}\index{Tag!database}%
is saved together in a Tag Database, something 
intermediate between an Event Directory and an Ntuple.
!!TEX!!\index{Ntuple}%
Since they are globally defined for the whole experiment, concrete
tags can be optimized so that they offer a very efficient way to make
initial cuts on attributes, thus achieving a high degree of
selectivity.  On top of that, at any moment you are able to cross the
association to the event if you want to retrieve any other details
!!TEX!!\index{Event association}%
about the full event, which are not contained in the Tag (see bottom
part of
!!TEX!!Figure \ref{NTUPLETAGDB}).<BR>
!!HTML!!the figure below).
</P>
!!HTML!!<P><IMG SRC="./ntuple_tagdb.gif"></P>
!!HTML!!<P>The Ntuple and TagDB models</P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\begin{center}
!!TEX!!\includegraphics[width=.8\linewidth]{ntuple_tagdb.eps}
!!TEX!!\end{center}
!!TEX!!\caption{The Ntuple and TagDB models}
!!TEX!!\label{NTUPLETAGDB}
!!TEX!!\index{Tag}\index{Ntuple}
!!TEX!!\index{Data model}\index{&OBJ;}%
!!TEX!!\small
<P>
The <EM>top part</EM> of the picture shows schematically the present
<EM>traditional</EM> approach. The event data (raw, reconstructed
events, calibration constants, etc.) are represented at the left hand
side . They are distributed over many files residing on various hosts. 
An <em>ad-hoc</EM> program reads a set of interesting quantities in
these files and writes the retrieved information into an Ntuple file.
In this Ntuple file data are reclustered most of the time 
according to a simple table structure (more complex arrangements are,
of course, possible). As the Ntuple file format is known, 
interactive visualisation programs can efficiently
read these data files, thus allowing a fast and convenient
physics data analysis system to be set up. Note, however, that these
Ntuple files are completely disconnected from the original data, so
that it is impossible to automatically update in the Ntuple files
information which changes in the original. Also, it is
not possible to retrieve transparently from the original files data
which were not saved in the Ntuple when it was created.
!!TEX!!\index{Ntuple}%
</P>
<P>
The <EM>lower part</EM> of the picture shows what the situation looks like in
the Tag model. In this case often-used data are once more reclustered
(using experiment-wide concrete tags or user-defined generic tags),
but all data remain inside the same federated database, and
!!TEX!!\index{Federated database}\index{Database}%
there exists a bidirectional link between the reclustered and the
original data. In this way, when the original data are reprocessed, it
is trivial to update the tag data, so that they remain always
up-to-date.  Conversely, when for a given event the information in the
tag database is not sufficient, then the link to the complete event data
allows you to retrieve the supplementary information in a convenient
and straighforward way <em>on the fly</EM>.
!!TEX!!\end{figure}

<P>
In general the selection of <EM>key</EM> attributes characterising 
events will be made by the experiment or group, so that concrete tags
are mostly defined for experiment-wide or
!!TEX!!\index{Tag!concrete}%
workgroup-wide data sets. However, individual physicists have
the possibility to define their own simpler data collection by using
the <EM>Generic Tag</EM> mechanism. This second light-weight procedure
allows you to define a tag <EM>on the fly</EM>, without creating a
persistent class. Compared to the concrete tag, there is, of course, a
small performance penalty, but this is most of the time balanced by
an increased flexibility, since at any time new fields can be added to
the tag and the association to the complete event data remains
!!TEX!!\index{Event association}%
available. Presently, both the concrete tag
!!TEX!!\index{Tag!concrete}\index{Concrete tag}%
!!TEX!!\index{Generic tag}\index{Tag!generic}%
and the generic tag are defined in a C++ program before being
used in the Interactive Analysis framework.
</P>

<H2>Implementing the Data Model: explorable collections</H2>

<P>
When creating a tag (either generic or concrete) a description of its
fields (name and type) must be provided. This information is used
later to access the data. The set of individual
tags is called an <EM>Explorable Collection</EM>,
!!TEX!!\index{Explorable collection}%
i.e., a collection of objects implementing an IRIS Explorer access
interface.
!!TEX!!\index{IRIS Explorer}%
!!TEX!!\index{Tag}%
</P>

<P>
Explorable collections are data that you can analyse using
!!TEX!!\index{Explorable collection}%
HEPExplorer Interactive Analysis modules.
The principle of operation in described in 
!!TEX!!Figure \ref{FIAM}.<BR>
!!HTML!!the figure below.
</P>
!!HTML!!<P><IMG SRC="./interactive-analysis-map.gif"></P>
!!TEX!!\begin{figure}[h]
!!TEX!!\begin{center}
!!TEX!!\includegraphics[width=\linewidth]{interactive-analysis-map.eps}
!!TEX!!\end{center}
!!TEX!!\caption{Principle of operation of Interactive Analysis Map}
!!TEX!!\label{FIAM}
!!TEX!!\index{Tag}
!!TEX!!\index{Data model}\index{&OBJ;}%
!!TEX!!\index{Explorable collection}%
!!TEX!!\end{figure}
<P>
To plot an histogram, you start by picking your explorable collection
!!TEX!!\index{Explorable collection}%
using the Browser, and then define your cuts and histogram variables
using the Selector, before filling your Histogram.  Apart from
!!TEX!!\index{Histogram!filling}%
accessing the data in the tag, you are able to invoke C++ methods that
implement, e.g., common physics or access the experiment specific
event object (by traversing the association between a tag and its
!!TEX!!\index{Event association}%
related event). User-defined functions can be used whenever a C++
expression is allowed.
All these possibilities are explained in much more detail
!!HTML!!<A HREF="#HEPExplorerexplorable">here</A>.
!!TEX!!in Section \ref{SHEPExplorerexplorable}.
!!TEX!!\index{HEPExplorer}
</P>


<!--filename=SetUpUserEnvironment.html-->
<H1><A NAME="H1SetUpUserEnvironment">Setting up the user environment</A></H1>

<P>
!!TEX!!\fbox{\parbox{.96\linewidth}{%
At the beginning of 1999 a central database service will be run for
the various experiments using &OBJ;. However, as we want users to be
able to test the LHC++ environment <EM>today</EM> the &UNIX; installation
procedure will presently create a database in your AFS space <EM>on a
given machine</EM>. So, until your experiment will have set up its
central &OBJ; database server, you <EM>must</EM> always connect to
that same machine if you want to access your database. This
inconvenience is only temporary and, apart from having to connect to
the given node, everything else is completely transparent and all your C++
code will work unchanged in the future 
!!HTML!!configuration.
!!TEX!!configuration.}}\index{AMS}\index{&OBJ;}\index{Database}%
</P>

<H2>Installing for the first time</H2>
!!TEX!!\index{HEPExplorer!installation}%<BR>

<P>The HEPExplorer environment is essentially a combination of &OBJ;,
IRIS Explorer, and HEP-specific add-ons.  Therefore, you should first
check that the following preliminary conditions are met.</P>
!!TEX!!\index{&OBJ;}\index{HEPExplorer}\index{IRIS Explorer}%<BR>

<UL>
<LI>Your computing platform is supported. At present it must be
one of the following:
HP-UX 10.20, Solaris 2.5 and 2.6, AIX 4.2, DEC UNIX 4.0, and
&WNT;.
<LI>You have an IRIS Explorer licence (only relevant outside CERN, 
    since CERN has a site licence).</LI>
<LI>You have a licence for &OBJ; (&OBJ; licenses are managed by the
    experiments; see below).
!!TEX!!\index{&OBJ;}\index{RD45 Project}%<BR>
</LI>
<LI>At CERN, when on &UNIX;, your host must be connected to AFS or for
    &WNT; connected to &NICE;. Outside CERN, or on non-connected nodes at CERN,
    you must first get access to the distribution kit and then install it.
!!TEX!!\index{AFS}\index{&NICE;}\index{&WNT;}%<BR>
</LI>
</UL>

<P>At CERN, IRIS Explorer is available centrally and some Work Group
Servers.</P>

<P>Thus, a prerequisite for using HEPExplorer is that you have access
to an &OBJ; database to contain your histograms and the proper schema
for the histogram classes.  If you do not yet have such a database set
up, you should contact your experiment's or group's &OBJ; coordinator,
who will take the necessary steps to register you for database use.
You will then be assigned a <EM>Federated Database IDentifier</EM>
(FDID), to uniquely identify your federated database to the &OBJ;
servers. This number should be specified when first installing the
database environment, as described below.
!!TEX!!\index{Registering for &OBJ; database use}%
!!TEX!!\index{FDID}%
!!TEX!!\index{Federated database!IDentifier (FDID)}%
</P>

<P>
Once you are registered for use of the database, and you know your
unique database identifier <TT>MY_FDID</TT>, you can install the
database and the other parts of HEPExplorer. This mainly involves
copying something from the AFS or &NICE; space to your account, and
setting some environment variables.
</P>

<P>
The initial installation procedure does not require user
intervention. Whenever there's a choice and no further information is
provided, a reasonable default that should be satisfactory for most
users will be selected.
</P>

<H3>&UNIX;-specific procedures</H3>

<P>
To fully install the different components you need to use
HEPExplorer you should merely type two commands (the first defines 
your FDID, the second starts the intallation).
</P>

<UL>
<LI>csh flavour
<PRE>
  setenv MY_FDID 99999 
  source /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.csh
</PRE>
</LI>
<LI>ksh flavour
<PRE>
  export MY_FDID=99999
  . /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.ksh
</PRE>
</LI>
</UL>
<P>
Here the number <TT>99999</TT> is an invalid value (chosen on
purpose).  
</P>

<P>We have chosen the ksh variant while being logged on to the machine
<tt>hpplus16</TT> (this is important, since to use the database we
shall have to log in to this same node later). The following log shows
the various steps in the installation script.</P>

<PRE>
><EM>. /afs/cern.ch/sw/lhcxx/share/HEPEXPLORER/pro/install/f_inst.ksh</EM>
Installing IRIS Explorer user datatypes
Removing old types
Please wait...
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   genericOid.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   histOOgram.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   hepExplorable.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   hepSharedLibName.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
+ /usr/explorer/bin/cxInst -c -m 0444 -idb explorer.sw.eoe \
   ObjyContainer.type /afs/cern.ch/user/g/goossens/HP-UX/explorer/types
Installing IRIS Explorer DataFit environment
Removing old DataFit environment
Please wait...
Installing HepExplorer Interactive add-ons
IE add-ons installed

Objectivity/DB (TM) Lock Server Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1989, 1996. All rights reserved.

Lock Server is already running.
Installing HistOOgram database: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP using FDID:  30500
get db from HISTO (new name will be HEPEXP)
End of HistOOgram database installation
HistOOgram test
Copying the testprogram and Makefile
Compiling the testprogram
CC example_filling.cpp -o example_filling -z \
  -I/afs/cern.ch/sw/lhcxx/specific/@sys/RW/tools/7.0.2/rogue \
  -I/afs/cern.ch/sw/lhcxx/specific/hp/Objectivity/4.0.2/include \
  -I/afs/cern.ch/sw/lhcxx/specific/@sys/HepODBMS/development/include \
  -g -I/afs/cern.ch/sw/lhcxx/specific/@sys/HEPEXPLORER/pro/include \
  -L/afs/cern.ch/sw/lhcxx/specific/@sys/HEPEXPLORER/pro/lib \
  -lHistoxx  -lm \
  -L/afs/cern.ch/sw/lhcxx/specific/@sys/HepODBMS/development/lib \
  -lgoodies -L/afs/cern.ch/sw/lhcxx/specific/hp/Objectivity/4.0.2/lib \
  -loo.4.02

Running the testprogram
 Histogram name :  Test Histo1D 
 Nbins = 10 from: 0 to: 20

 no. of entries   : 50000
 total contents   : 1.66241e+06
 nequival         : 29886.3
 min bin contents : 22372
 max bin contents : 443399
 mean             : 8.09693
 rms              : 7.1173
 underflow        : 0
 overflow         : 0

 bin 0 contents = 443399 error = 6146.7
 bin 1 contents = 275044 error = 3824.79
 bin 2 contents = 148708 error = 2081.49
 bin 3 contents = 64484 error = 915.044
 bin 4 contents = 22372 error = 316.773
 bin 5 contents = 22372 error = 316.773
 bin 6 contents = 64459.5 error = 914.87
 bin 7 contents = 148652 error = 2081.09
 bin 8 contents = 274940 error = 3824.06
 bin 9 contents = 197983 error = 3859.82
Removing SimpleTestDatabase as required by the user

Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.

Deleted the Database "SimpleTestDatabase" (ID = 2).

Making your startup script
Removing old startup script



***********************************************************
Your setup script is ~/$OS/hepexp.ksh
Don't forget to source it in your .profile script
***********************************************************
</PRE>
!!TEX!!\index{login@{\texttt{.login} file}}%
!!TEX!!\index{profile@{\texttt{.profile} file}}%

<P>
Let us have a look at what the installation script did (<EM>if you are
not interested in this, you can skip this paragraph; however, you
should still verify the last part of the output, as we shall explain
below.</EM>) The installation script starts by copying IRIS Explorer related
information, such as types, include files, man pages, DataFit 
and HEPExplorer files, into your IRIS Explorer directory (defined
with the <TT>EXPLORERUSERHOME</TT> environment variable).
Then it installs the &OBJ; database, in the <tt>explorer</TT> subdirectory
(<TT>/afs/cern.ch/user/g/goossens/HP-UX/explorer</TT> in our case).
The boot file is called <TT>HEPEXP</TT>, the federated database
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
itself <TT>HEPEXP.FDDB</TT> (see the directory listing below).</P>
<PRE>
-rw-r--r--   1 goossens   dl             241 Oct 29 17:56 HEPEXP
-rw-rw-r--   1 goossens   dl         2080768 Oct 29 17:57 HEPEXP.FDDB
</PRE>
<P>It is the environment variable <TT>OO_FD_BOOT</TT>, containing the
full path name of the boot file, which will be used by &OBJ; to get
access to the database in subsequent sessions. Note that we have
specified our unique federated database identifier which we got from
our database administrator by setting the <TT>MY_FDID</TT> variable
(the value used was <TT>30500</TT>, which should <EM>NEVER</EM> be
used by anybody else).  Now that the database is set up, a small test
program like the one described 
!!TEX!!in Section \ref{HIST1DEXA}
!!HTML!!<A HREF="#HIST1DEXA">here</A>
is copied to the <TT>explorer</TT> directory, compiled and run.
</P>

<P>
It is <EM>important</EM> that everybody checks whether the output
generated at the end of the installation corresponds to the lines
shown above. Also, the startup script (<TT>hepexp.ksh</TT> above) will be
prepared. This small script defines a set of environment variables for
IRIS Explorer, the <TT>OO_FD_BOOT</TT> variable, identifying the &OBJ;
boot file, and checks whether you are logged in to the same node as
where the database was created (<TT>hpplus16</TT> in the example).
</P>

<P>
You <em>must</EM> execute this small shell script 
every time you login on the system as described below.
</P>

<UL>
<LI>
<P>
<EM>csh flavour</EM>: the file is named <TT>~/$OS/hepexp.csh</TT> and
you should add to your <TT>.login </TT>script the following line:
</P>
<P>
<TT>source ~/$OS/hepexp.csh</TT>
</P>
</LI>
<LI><P>
<EM>ksh flavour</EM>: the file is named <TT>~/$OS/hepexp.ksh</TT> and you
should add to your <TT>.profile </TT>script the following line:
</P>
<P>
<TT>. ~/$OS/hepexp.ksh</TT>
</P>
</LI>
</UL>

<P><EM>If you forget to update your startup script (<TT>.login</TT> or
<TT>.profile</TT>) you will not be able to use any HEPExplorer
component on your next login. On top of that, to have the environment
variables initialized correctly, you must logout and then login
again.</EM></P> 
!!TEX!!\index{login@{\texttt{.login} file}}%
!!TEX!!\index{profile@{\texttt{.profile} file}}%

<H3>&WNT;-specific procedures</H3>

<P>In order to keep as many similarities as possible between the NT
and &UNIX; versions, we also chose to use &UNIX; tools on &WNT;
(e.g., <TT>gmake</TT>), rather than go for a <EM>native</EM>
version. This policy could change in the future, according to general
guidelines for multiplatform support agreed with the experiments.
</P>

<H4>&UNIX; utilities on NT</H4>

<P>The present general policy of IT division is to use the utilities
provided by <A HREF="http://www.cygnus.com">Cygnus</A>. They are
installed on &NICE; and provide the most common &GNU;/&UNIX; tools,
such as, <TT>gmake</TT>, <TT>bash</TT>, <TT>tar</TT>, etc.
Users have the choice to work with &GNU;'s <TT>bash</TT>
shell, or &WNT's native <TT>cmd</tt> shell.

<H4>Locating the LHC++ components on &NICE;</H4>

<P>The directory structure of the LHC++ installation tree on &NICE;
mimics the structure of &UNIX; on AFS as closely as possible. 
</P>
<P>Therefore, whenever the procedures and examples for &UNIX; in this
guide refer to the path <TT>/afs/cern.ch/sw/lhcxx</TT>, on &NICE; the
equivalent path is <TT>Z:\P32\lhcxx</TT>. This applies to libraries,
include files, etc. Moreover, uses of the environment variable
<TT>LHCXXTOP</TT>, which refer to the above path, on &WNT; map to
<TT>%LHCXXTOP%</TT> with the <TT>cmd</TT> shell, and remain unchanged
<TT>$LHCXXTOP</TT> with the <tt>bash</TT> shell.
</P>

<H4>Running the installation scripts</H4>

<P>Although the environment is installed on &NICE; disk servers, we do
not use &NICE; menus and scripts to access LHC++ components at
present. We follow a &UNIX;-like approach where the LHC++ applications are
executed inside an environment that is setup by a script.  This allows
quick and easy customization of the users' environment without
touching the general PC configuration.</P>

<P>Details on how to install LHC++ on your &WNT; system are
available in the following file on &NICE;.
</P>
!!HTML!!<PRE>
!!HTML!!Z:\P32\lhcxx\specific\windows_NT\Hepexplorer\dev\install\install_NT.txt
!!HTML!!</PRE>
!!TEX!!\begin{verbatim}
!!TEX!!Z:\P32\lhcxx\specific\windows_NT\Hepexplorer\dev\install\install_NT.txt
!!TEX!!\end{verbatim}

<H2>Full re-installation procedure on &UNIX;</H2>

<P>If you already had an &OBJ; database before, and want to reinstall
everything, you must clean up your environment first. Thus, if you
have any environment settings related to &OBJ; or IRIS Explorer you
should remove them (you can still customise your environment later).
Please check that your <TT>PATH</TT> environment variable and the
shared library path environment variable (<TT>SHLIB_PATH</TT> or
!!TEX!!\index{Shared library}%
<TT>LD_LIBRARY_PATH</TT> or <TT>LIBPATH</TT>, depending on your &UNIX;
flavour) contain just the minimum needed for your current needs.</P>

<H2>Customising the installation procedure on &UNIX;</H2>

<P>The installation procedure can be customised to provide different
locations for your IRIS Explorer home directory and for the Federated
Database.</P>
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{Data model}\index{&OBJ;}%

<UL>
<LI><P>To define a different IRIS Explorer home directory set the 
<TT>EXPLORERUSERHOME</TT> environment variable, e.g.,</P>
<P>csh flavour</P>
<PRE>
  setenv EXPLORERUSERHOME ~/explorer
</PRE>
<P>ksh flavour</P>
<PRE>
  export EXPLORERUSERHOME=~/explorer
</PRE>
</LI>
<LI><P>To define a different location for your <EM>starter</EM> 
Federated Database set the <TT>OO_FD_BOOT</TT> environment variable,
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
e.g.,</P>  
<P>csh flavour</P>
<PRE>
  setenv OO_FD_BOOT ~/myfd/MYFDNAME
</PRE>
<P>ksh flavour</P>
<PRE>
  export OO_FD_BOOT=~/myfd/MYFDNAME
</PRE>
</LI>
</UL>

<P>By defining more environment variables the installation procedure
can be instructed to skip part of the installation.</P>

<UL>
<LI><P>To skip the HEPExplorer setup (user types and fitting add-ons) set
the <TT>NO_INSTALL_HEPEXP</TT> environment variable, e.g.,</P>
<P>csh flavour</P>
<PRE>
  setenv NO_INSTALL_HEPEXP 1
</PRE>
<P>ksh flavour</P>
<PRE>
  export NO_INSTALL_HEPEXP=1
</PRE>
</LI>
<LI>To skip the installation of the <EM>starter</EM> Federated
Database set the <TT>NO_INSTALL_HISTODB</TT> environment variable,
e.g.,
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{Data model}\index{&OBJ;}%
<P>csh flavour</P>
<PRE>
  setenv NO_INSTALL_HISTODB 1
</PRE>
<P>ksh flavour</P>
<PRE>
  export NO_INSTALL_HISTODB=1
</PRE>
</LI>
</ul>

<H2>Check list on &UNIX;</H2>
!!TEX!!\index{Check list}%

<P>Right after logging in you should check that there are no warning
messages generated by the HEPExplorer startup script. In particular,
check whether you have no message of the type:</P>
<PRE>
HEPExplorer message: you logged in on the wrong node
Please logout and login again on hpplus16
</PRE>
<P>In this case, the original database was created on the node
<TT>hpplus16</TT>, so that only from that node you can read and
modify the database.</P>

<P>Similarly, using the <TT>env</TT> command, check that the following
environment variables are set (correctly):</P>

<UL>
<LI><TT>OO_FD_BOOT</TT></LI>
<LI><TT>EXPLORERHOME</TT></LI>
<LI><TT>EXPLORERUSERHOME</TT></LI>
</ul>

<P>If one of them is not set, then it is very likely that you forgot
to update your startup script (check your <TT>.login</TT> or 
<TT>.profile</TT> file).</P>
!!TEX!!\index{login@{\texttt{.login} file}}%
!!TEX!!\index{profile@{\texttt{.profile} file}}%

<H3>Installation troubleshooting</H3>
!!TEX!!\index{Installation!troubleshooting}\index{Troubleshooting}

<P>
Installation procedure failure is usually due to one of the following
reasons.
</P>

<UL>
<LI>
<EM>Missing access rights to the Objectivity package.</EM>
In this case the installation exits with an error message and you should
get your Objectivity licence before trying again.
</LI>
<LI>
<EM>Lockserver running in autorecovery mode.</EM>
Use the &UNIX; <TT>ps</TT> command to find out the lockserver's running mode:
<PRE>
ps -ef | grep ools
</PRE>
If you see something like:
<PRE>
dinofm 20536 1 0 Oct 27 ? 1:37 ools
</PRE>
restart the lockserver in the proper mode:
<PRE>
> ookillls
> oolockserver -noautorecovery
> ps -ef | grep ools
</PRE>
where the <TT>ps</TT> command should show something like:
<PRE>
dinofm 20536 1 0 Oct 27 ? 1:37 ools -OO_NO_AUTOREC
</PRE>
</LI>
<LI>
<EM>Polluted environment.</EM>
If your installation fails and you retry 
a reinstall immediately, there might still be some
environment variables set from your previous try. Therefore,
if your installation fails, it is advisable to logout and login again 
to try and install the system once more.
</LI>
</UL>

<!--filename=AccessOBJDatabase.html-->
<H1><A NAME="H1AccessOBJDatabase">Accessing the &OBJ; database</A></H1>
<!--
~/HP-UX/explorer/examples$ oodeletedb -all -f

Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.

Deleted the Database "SimpleTestDatabase" (ID = 3).

Deleted the Database "System" (ID = 4).

Deleted the Database "Tag" (ID = 5).

Deleted the Database "Events" (ID = 6).
-->

<H2>What does the user have to know about the database?</H2>

<P>
Ideally, the hierarchical structure of the data storage should be
completely transparent to the average user. Therefore, the LHC++ Team
has done its best to hide the impact of the database on the C++
user code to a minimum. However, it is best that the users of the
modules are aware of some basic principles, and how they relate to the
experimental data model used by the various analysis programs.
</P>

<P>
Let us first have a look at 
!!HTML!!the picture below.
!!TEX!!Figure \ref{STORAGEUSER}.
!!HTML!!<P><IMG SRC="./storage_user.gif">
</P>
<P>
It shows the storage hierarchy used to store event data at the
left, together with the user's view of these data at the right.
</P>
!!TEX!!\begin{figure}[h]
!!TEX!!\begin{center}
!!TEX!!\centering\includegraphics[width=.8\linewidth]{storage_user.eps}
!!TEX!!\end{center}
!!TEX!!\caption{The storage hierarchy and the user view}
!!TEX!!\label{STORAGEUSER}
!!TEX!!\end{figure}

<P>
We start with the user's view (right hand side of the picture).
The user likes to think in terms of events (the octagons), and wants
to deal with, for instance reconstructed tracks (the triangles), hits in
the forward calorimeter (the diamonds), or the calibration for the TPC
(the pentagons), etc. Users should not be directly concerned (apart
perhaps for efficiency considerations) how these various data elements
are actually stored in files and distributed over a network. They
prefer to have a <EM>logical</EM> view of their event and navigate
between its various componenents in a transparent way. It is up to the
data administrator to make sure that the data are stored in a way
optimising performance and throughput for the end user.
</P>

<P>
This is possible using an object oriented database system, such as
&OBJ; (left hand side of the picture). All data are kept in one
<EM>federated database</EM>, which is basically just a file containing
the catalog of the database files and the hostnames where they
reside. It also contains the <EM>schema</EM> (object model) used by
the data in the various databases.
!!TEX!!\index{Federated database}\index{Database}\index{Schema}%
</P>

<P>
The <EM>databases</EM> themselves are also separate files, which can
reside on different nodes and they can consist of multiple
<EM>containers</EM>, that can be thought of a contiguous areas on a
file.
</P>
!!TEX!!\index{Data model}\index{Container}\index{&OBJ;}%
<P>
Finally, each container consists of one or more <EM>persistent</EM>
objects (e.g., histograms, reconstructed tracks, fits). As seen in the
picture, the mapping of the event to its components is very flexible,
allowing different parts of an event to reside in different
containers, and/or databases (even on remote nodes). Moreover, since
the end users only access the full data through the logical structure,
they are never affected by changes in the physical layout of the
database.
</P>

<H2>Getting access to an &OBJ; database</H2>

<P>
In 1999 a central service will be run for the various experiments using &OBJ;
to provide access to their databases
from various platforms using AMS. However, at present, it is necessary to
!!TEX!!\index{AMS}\index{&OBJ;}%
associate a federated database with a given machine, so that you must
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
always connect to that same machine if you want to access that
database.
</P>

<P>
In particular, when working on a cluster (such as hpplus) you must
remember the real node name (e.g., <TT>hpplus16</TT>, as in the
example in the previous chapter) of the machine which you used to
create the database.  When you want to use the database in a later
session, you must always connect to that node, otherwise you will not
be able to access your data (unless your experiment is running &OBJ;'s
AMS, a facility to share databases
!!TEX!!\index{&OBJ;}%
across the network).</P>

<P>
The first step (after creating the database) is to tell &OBJ;
where it can be found. This is done with the environment variable
<TT>OO_FD_BOOT</TT>, which should be set to the full path name
!!TEX!!\index{OOFDBOOK@{\ttfamily OO_FD_BOOT}}\index{&OBJ;}%
of the boot file of the database that you want to access.  This boot
file is actually a small ASCII file, which contains valuable
information about your federated database.
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
</P>
<PRE>
> more $OO_FD_BOOT 
ooFDNumber=30500
ooLFDNumber=65535
ooPageSize=8192
ooLockServerName=hpplus16
ooFDDBHost=hpplus16
ooFDDBFileName=/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
ooJNLHost=hpplus16
ooJNLPath=/afs/cern.ch/user/g/goossens/HP-UX/explorer
</PRE>
!!HTML!!<P><B>You should <EM>NEVER</EM> change its contents!</B></P>
!!TEX!!<P>\fbox{You should <EM>NEVER</EM> change its contents!}</P>
<P>
In particular, changing the path of the federated database in this
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
file after you moved it will <em>not</em> work.
</P>

<P>
Once the <TT>OO_FD_BOOT</TT> variable is set correctly, you can
run the &OBJ; management tools. For instance the program
<TT>oodumpcatalog</TT> displays the catalog, showing the different
databases associated to the current federated database.
!!TEX!!\index{oodumpcatalog@{\ttfamily oodumpcatalog}}%
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
</P>
<PRE>
> oodumpcatalog

Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.

FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16

DB Name   = SimpleTestDatabase
DB ID     = 3
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/SimpleTestDatabase.HEPEXP.DB
</PRE>

<P>
Thus, in the example above, we see that we need to connect to the node
<TT>hpplus16</TT> (the so-called <EM>Lock Host</EM>).  It should also
be noted that each federated database should have a different
!!TEX!!\index{Federated database}\index{Database}%
federated database number to enforce proper locking management when
the same lockserver is used by more than one federation (e.g., when
the lockserver is running on a central service, such as hpplus).  A
series of federated database numbers have been allocated to
experiments and user groups (a proposed list can be found in <A
HREF="http://wwwinfo.cern.ch/asd/cernlib/rd45/recommendations/dba.html"><EM>RD45
DBA Recommendations</EM></A>). As explained above, when registering as
!!TEX!!\index{RD45 Project}%
a database user with your experiment's or group's &OBJ;'s coordinator,
you get a unique number assigned to ensure the uniqueness of the
federated database number.
</P>

<H2><A NAME="H2AccesssOBJ">Accessing the &OBJ; from inside a C++ program</A></H2>

<P>After the initial installation, you have a federated database,
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}% which has no associated databases yet. This can
be seen by using the &OBJ; tool <TT>ootoolmgr</TT> (<TT>oobrowse</TT>
on &WNT;), which allows you to browse the contents of all
databases (down to the object level) in a federated database.  If you
want to run <TT>ootoolmgr</TT> just type
<PRE>
> ootoolmgr
</PRE>
!!TEX!!\index{ootoolmgr@{\ttfamily ootoolmgr}}
on the command line. You will then get an &OBJ; panel, as shown
!!TEX!!in Figure \ref{OOTOOLMGRPANEL}.<BR>
!!HTML!!below.
!!HTML!!<P><IMG SRC="./ootoolmgrpanel.gif"></P>
<P>Then in the <TT>File</TT> pull-down menu you choose the database
(most of the time it is enough to click the default setting at the
bottom, which corresponds to the database selected with the
<TT>OO_FD_BOOT</TT> environment variable). Then you can go to the
<TT>Tools</TT> pull-down menu and choose <TT>Browse FD</TT> at the
top. Then you will see the <TT>&OBJ; - Browse FD</TT> appear, with 
four main windows, namely the names of the <EM>Databases</EM>,
<EM>Containers</EM>, <EM>Basic Objects</EM>, and finally, at the
bottom, the contents of the selected object. Just after
initialisation, there are no databases yet, as seen 
!!TEX!!in Figure \ref{OOTOOLMGREMPTY}.<BR>
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="./ootoolmgrempty.gif"></P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\begin{minipage}{.4\linewidth}
!!TEX!!\centering\includegraphics[width=\linewidth]{ootoolmgrpanel.eps}
!!TEX!!\caption{The \texttt{ootoolmgr} initial panel}
!!TEX!!\label{OOTOOLMGRPANEL}
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.56\linewidth}
!!TEX!!\centering\includegraphics[width=\linewidth]{ootoolmgrempty.eps}
!!TEX!!\caption{Using the tool \texttt{ootoolmgr}}
!!TEX!!\label{OOTOOLMGREMPTY}
!!TEX!!\index{ootoolmgr@{\ttfamily ootoolmgr}}
!!TEX!!\end{minipage}
!!TEX!!\end{figure}

<P>
Before writing our first C++ program to use the database, let us
first establish three basic rules.
</P>
<OL>
<LI>
One must first establish a connection to the database with the
<TT>Init</TT> method.
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
</LI>
<LI>
<EM>Transactions</EM> are used to retrieve or store persistent
!!TEX!!\index{&OBJ;!transaction}%
objects.
<UL>
<LI>
A transaction is set up using the <TT>startUpdate</TT>
or <TT>startRead</TT> methods.
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
!!TEX!!\index{startread@{\texttt{startRead}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startread@{\texttt{startRead}}}%
</LI>
<LI>
A transaction is terminated using the <TT>commit</TT>
!!TEX!!\index{&OBJ;!transaction}%
or <TT>abort</TT> methods. The <TT>commit</TT> method
will save all changed objects in the database, whereas  <TT>abort</TT>
will revert the database to the state before the transaction was
initiated.
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{abort@{\texttt{abort}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!abort@{\texttt{abort}}}%
</LI>
</UL>
<LI>
To access persistent objects <EM>smart</EM> pointers are provided.
They are indistinguishable from normal C++ pointers, they are merely
declared with a different syntax using <TT>HepRef</TT>, e.g.,
for a 1D histogram we would declare
!!TEX!!\index{Smart pointer}
<PRE>
HepRef(Histo1D) myHisto (...);
</PRE>
while for a pointer to a non-persistent C++ object you would write
<PRE>
Histo1D *myHisto ...
</PRE>
Once you have declared your smart pointers to your persistent object,
all navigation between objects is completely like in the case of
normal pointers; whenever a reference is made to a smart pointer, a
callback to the database will automatically fetch the required
data. Moreover at the end of the transaction all modified objects will
!!TEX!!\index{&OBJ;!transaction}%
automatically be stored in the database at commit time.
</LI>
</OL>
<P>If, while reading through the examples, you want to know more
details about the HepODBMS classes, you can have a look at the
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/reference-manual/HepODBMS.html">
!!HTML!!Class Reference Guide</A>.
!!TEX!!<EM>Class Reference Guide</EM> at the 
!!TEX!!url \url{http://wwwinfo.cern.ch/asd/lhc++/HepODBMS/reference-manual/HepODBMS.html}.
</P>

<P>
We are now finally ready to write a program to create a new database
and save an histogram in it (see the beginning of Chapter
!!TEX!!\vref{H1HistogramTagClasses}
!!HTML!!<A HREF="#H1HistogramTagClasses">Histogram and tag classes</A>
to find out how to get the code of an example and run it.)
</P>

<PRE>
/* simpleHisto.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h>
#include &lt;math.h>

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    HepDatabaseRef  MyDb = db("MyDB"); //create a new database
    HepRef(Histo1D) histo   = new(MyDb) Histo1D("Test_Histo1D",20,0.0,50000.0);
    
    for( int i = 0; i < 50000; i++)      // fill the histo in a loop
    {
        histo->fill(i,10*sin(i)+cos(i)*cos(i));  
    }

    // print global histogram properties
    cout << "Histogram name : " << histo->get_name()                     << endl
         << "No. of entries : " << histo->get_entries_number()           << endl
         << "Mean (bin cont): " << histo->compute_mean(bin_content_stats)<< endl
         << "RMS  (bin cont): " << histo->compute_RMS(bin_content_stats) << endl;

    commit();    // commit this transaction
    return 0;
  }
};
int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{histo1d@{\texttt{Histo1D}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo1d@{\texttt{Histo1D}}}%
!!TEX!!\index{fill@{\texttt{fill}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!fill@{\texttt{fill}}}%
!!TEX!!\index{getname@{\texttt{get_name}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getname@{\texttt{get_name}}}%
!!TEX!!\index{getentriesnumber@{\texttt{get_entries_number}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getentriesnumber@{\texttt{get_entries_number}}}%
!!TEX!!\index{computemean@{\texttt{compute_mean}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!computemean@{\texttt{compute_mean}}}%
!!TEX!!\index{computerms@{\texttt{compute_RMS}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!computerms@{\texttt{compute_RMS}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%

<P>In the C++ program above, we start by initialising the database
session (as always, we implicitly use the federated database addressed
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
by the <TT>OO_FD_BOOT</TT> variable), and then start a transaction,
!!TEX!!\index{&OBJ;!transaction}%
thus telling &OBJ; that we are going to update the database.</P>
<PRE>
    Init();        // initialise the db session
    startUpdate(); // start an update transaction
</PRE>
<P>
The next command creates a database <TT>MyDB</TT> 
(or opens it if it already exists) in the federated database.
</P>
<PRE>
    HepDatabaseRef  MyDb = db("MyDB"); 
</PRE>
<P>
Then, we create a histogram and fill it (this code will be explained in
a later chapter, so we will not go into any detail here).
We print some info about the histogram, then commit the changes to the
database.
</P>
<PRE>
    commit();
</PRE>
<P>
If, for some reason, the program aborts before reaching the commit
command, the database will <EM>not</EM> be changed. Nevertheless, you
might have to clean up the state of the federated database, since it
!!TEX!!\index{Federated database}\index{Database}%
will still be waiting for the transaction to complete, thus possibly
!!TEX!!\index{&OBJ;!transaction}%
preventing other processing from changing the database. In our case
everything went all right and we got the following output.
</P>
<PRE>
Histogram name : Test_Histo1D
No. of entries : 50000
Mean (bin cont): 24996.6
RMS  (bin cont): 14427.1
</PRE>

<P>
If you encounter problems during a transaction, then the proper way to
!!TEX!!\index{&OBJ;!transaction}%
remove pending transactions is the &OBJ; utility <TT>oocleanup</TT>.
For instance, to remove pending transactions on the local node you can
issue the command:
</P>
<PRE>
oocleanup -loc
</PRE>
!!TEX!!\index{oocleanup@{\ttfamily oocleanup}}%
!!TEX!!\index{&OBJ;!transaction}

<P>
If we take another look at the databases with 
<TT>ootoolmgr</TT>, then we indeed find our <TT>MyDB</TT> database 
(plus <TT>System</TT>), as seen
!!TEX!!in Figure \ref{OOTOOLMGR1}.<BR>
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="./ootoolmgr1.gif"></P>
!!TEX!!\begin{figure}[!ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{ootoolmgr1.eps}
!!TEX!!\caption{Selecting a database container with \texttt{ootoolmgr}}
!!TEX!!\label{OOTOOLMGR1}
!!TEX!!\index{ootoolmgr@{\ttfamily ootoolmgr}}
!!TEX!!\end{figure}
<P>
We select our database and the default container, plus one of the
basic objects (unfortunately, with the &OBJ; tools, we only see the
internal names of the objects). HEPExplorer, as explained later,
has a module
!!HTML!!<A HREF="#HISTOOGRAMREADER"><EM>HistOOgramReader</EM></A>,
!!TEX!!<EM>HistOOgramReader</EM> (see Section \ref{HISTOOGRAMREADER}),%
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
which also shows the name of the objects (<TT>Test_Histo1D</TT> in our
example). Thus, in general, it is easier to use
the HEPExplorer tools to view the contents of a database.
Nevertheless, it is sometimes necessary to look inside a database,
and then <TT>ootoolmgr</TT> is a big help.
In particular, you can look at the detailed structure of an object in
the database, for instance the histogram object we created is shown
!!TEX!!in Figure \ref{OOTOOLMGR2}.<BR>
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="./ootoolmgr2.gif"></P>
!!TEX!!\begin{figure}[!ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{ootoolmgr2.eps}
!!TEX!!\caption{Viewing an object in the database with \texttt{ootoolmgr}}
!!TEX!!\label{OOTOOLMGR2}
!!TEX!!\index{ootoolmgr@{\ttfamily ootoolmgr}}
!!TEX!!\end{figure}
<P>
We recognize the name of the histogram <TT>Test_Histo1D</TT>, the
number of data points (50000), etc., but more importantly, we can step
through all the bins and look at their contents (in the figure the
information for bin 10 is displayed and you see the value and the sum
of squares). More generally, the contents of every object in the
database can be studied in detail, thus facilitating debugging and
providing an interesting tool for studying the data model.
</P>

<H2>Manipulating the &OBJ; database and its containers in a C++ program</H2>

<P>
To show a few more of the class methods available to manipulate an
&OBJ; database, we can look at the following code.
</P>
<PRE>
/* dbAccess.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepEvent.h"

class dbAccessApp : public HepTagDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  dbAccessApp(const char *name) : HepTagDbApplication(name)
  {};
  
  int run()
  {
    // print an 
    message("about to initialise the db connection");
    Init();        // initialise the db session
    message("starting an update transaction");
    startUpdate(); // start an update transaction

    // create a new database (file)
    HepDatabaseRef  myDb = db("MyDatabase");

    // if the database ref is not valid:
    // - print a message
    // - exit the application with an error code 
    if (myDb == 0)
      fatal("could not find or create MyDatabase");
    
    // create a new container in this database
    HepContainerRef cont = container("MyContainer"); 
    if (cont == 0 )
      fatal("could not find or create MyDatabase");

    // work with the container and database
    // (e.g. create histograms, tags or other persistent objects)
      
    for (short i=0; i<1000; i++)
    {
      // create a new event in my container
      HepRef(HepEvent) event = new(cont) HepEvent;
      if (event == 0) 
        fatal("could not create a new event");
    }
    message("created 1000 events");

    printContainerMap( ) ;

    // delete the container from the database
    // including all events
    HepDelete(cont);
    warning("deleted the container");

    // delete the database from the federation
    HepDelete(myDb);
    warning("deleted the database");

    // commit all changes made during this transaction
    commit();
    return 0;
  }
  
};

int main(int argc, const char *argv[])
{
  dbAccessApp myApp(argv[0]);  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{hepdbapplication@{\texttt{HepDbApplication}} class (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!classes!hepdbapplication@{\texttt{HepDbApplication}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
!!TEX!!\index{fatal@{\texttt{fatal}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!fatal@{\texttt{fatal}}}%
!!TEX!!\index{warning@{\texttt{warning}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!warning@{\texttt{warning}}}%
!!TEX!!\index{message@{\texttt{message}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!message@{\texttt{message}}}%
!!TEX!!\index{HepDelete@{\texttt{HepDelete}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!HepDelete@{\texttt{HepDelete}}}%
!!TEX!!\index{printcontainermap@{\texttt{PrintContainerMap}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!printcontainermap@{\texttt{PrintContainerMap}}}%
<P>
The <TT>HepDbApplication</TT> class defines the transaction methods 
!!TEX!!\index{&OBJ;!transaction}%
<TT>abort</TT>, <TT>commit</TT>, <TT>startRead</TT>, 
<TT>startUpdate</TT> (described already in Section
!!HTML!!<A HREF="#H2AccesssOBJ">here</A>),
!!TEX!!\vref{H2AccesssOBJ}),
!!TEX!!\index{hepdbapplication@{\texttt{HepDbApplication}} class (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!classes!hepdbapplication@{\texttt{HepDbApplication}}}%
!!TEX!!\index{abort@{\texttt{abort}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!abort@{\texttt{abort}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{startread@{\texttt{startRead}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startread@{\texttt{startRead}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
as well as four methods for sending an informative string to the
user console: <TT>fatal</TT> (prints a fatal error message and
aborts), <TT>error</TT> and <TT>warning</TT>,  (prints an 
error and warning message and continue), and
<TT>message</TT> (just prints a message).
!!TEX!!\index{fatal@{\texttt{fatal}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!fatal@{\texttt{fatal}}}%
!!TEX!!\index{warning@{\texttt{warning}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!warning@{\texttt{warning}}}%
!!TEX!!\index{message@{\texttt{message}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!message@{\texttt{message}}}%
!!TEX!!\index{error@{\texttt{error}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!error@{\texttt{error}}}%
</P>
<P>
The <TT>HepDatabaseRef</TT> declaration sets up a database handle
<TT>myDb</TT> using the <TT>db</TT> method from the <TT>ooSession</TT>
class. Once we have opened a database, we declare a container with
<TT>HepContainerRef</TT>, which returns us a handle <TT>cont</TT>
using the <TT>container</TT> method from the <TT>ooSession</TT>
class. The container handle is then used to store one thousand events
of type <TT>HepEvent</TT> inside the <TT>for</TT> loop. Just before we
delete our database we print a map of the containers with the
<TT>printContainerMap</TT> method, which shows the containers together
with their object identifiers (the <TT>HepSystem</TT> and
<TT>ExplorableDescr</TT> containers are created when HEPODBMS is set
up in the <TT>System</TT> database).  Finally, we delete the container
and database by specifying their respective handles to the
<TT>HepDelete</TT> method. Below, the output generated by the above
C++ code is shown.
</P>
<PRE>
dbAccess: about to initialise the db connection
dbAccess: starting an update transaction
dbAccess: created 1000 events
HepSystem --- #3-4-3-1
ExplorableDescr --- #3-5-3-1
MyContainer --- #12-3-1-1
WARNING: dbAccess: deleted the container
WARNING: dbAccess: deleted the database
</PRE>

<H2>&OBJ; administration tools</H2>

<P>
&OBJ; provides a whole set of administration tools to manage a
federated database. These tools are described in detail in the
<EM>&OBJ; Administration</EM> manual. In this section we briefly
describe the more useful from the physicists' point of view.
</P>
<UL>
<LI><TT>oodumpcatalog</TT> provides summary information about a
!!TEX!!\index{oodumpcatalog@{\ttfamily oodumpcatalog}}\index{&OBJ;}%
    federated database;</LI> 
<LI><TT>ootoolmgr</TT> (<TT>oobrowse</TT>
    on &WNT;) allows you to browse federated database schema and
    data;</LI>
<LI><TT>oocleanup</TT> resets pending locks;</LI>
<LI><TT>oodeletedb</TT> deletes a <EM>physical</EM> database.</LI>
</UL>

<!--filename=HistogramTagClasses.html-->
<H1><A NAME="H1HistogramTagClasses">Histogram and tag classes</A></H1>

<P>
All classes are being documented and a user guide and
reference manual for the available components will be available soon.
In this chapter we shall describe the main characteristics of the
HistOOgram classes and also learn about the tag classes. 
As explained before, ready-to-run examples can be found in the 
following two directories.
</P>
<PRE>
$LHCXXTOP/share/HepODBMS/pro/HepODBMS/examples
$LHCXXTOP/share/HISTOOGRAMS/pro/examples/
</PRE>
<P>
!!TEX!!As already explained in the preface at the beginning of the 
!!TEX!!document (see page~\pageref{SEC:DOCEXA}), each
!!TEX!!\index{Examples!location}\index{Examples!running \~{}}
!!HTML!!Each 
example has its own subdirectory (corresponding to the first part
of the filename, i.e., preceding the suffix <tt>.cpp</TT>, specified
as a comment on the first line of the examples' C++ code in this
manual), which contains the C++ source code in a file with extension
<TT>cpp</TT>, as well as a <TT>GNUmakefile</TT> which will compile,
link and generate an executable if run with <TT>gmake</TT>. These
example programs should form an excellent basis to get started writing
your own application programs.
</P>

<H2><A NAME="PERSISTENTHISTOS">The Persistent HistOOgram package</A></H2>

<P>
The Persistent HistOOgram Package provides the basic histogramming
functionality of HBOOK along with some additional features:
!!TEX!!\index{HBOOK}%
</P>

<UL>
<LI>booking and filling 1D, 2D histograms (equidistant binning);</LI>
<LI>storing errors at bin level;</LI>
<LI>computing mean and RMS at histogram level;</LI>
<LI>retrieving basic histogram characteristics;</LI>
<LI>histogram operations;</LI>
<LI>multidimensional histograms (dim&gt;2).</LI>
</UL>

<P>The package consists of several parts:</P>

<UL>
<LI>a histogram library (C++ binary code);</LI>
<LI>C++ header files;</LI>
<LI>an &OBJ; federated database prepared to be used with the histogram
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
library;</LI>
<LI>a <TT>GNUmakefile</TT> to simplify creating applications and
(re-)building the library;</LI>
<LI>examples of applications.</LI>
</UL>

<!--
<H3><A NAME="Installation">Installing the HistOOgrams library</A></H3>

<P>On top of classes and methods needed to provide the basic
functionality for operating on histograms, the HistOOgrams library
also has a whole set of histogram management IE modules. This section
explains how to install these modules. At present, this installation
procedure creates in the user's disk space area an empty Federated
Database containing the schema for the HistOOgram package. This means
that you must be registered as an &OBJ; user (please contact
you group administrator if needed), so that your user environment is
set up correctly for that database (see <A
HREF="http://wwwinfo.cern.ch/asd/cernlib/rd45/installObjy4.0.2.htm"><EM>&OBJ;
4.0.2 Installation</EM></A> if you are unsure or want more details).
</P>

<P>Before running the script you should set the environment variable
<TT>OO_FD_BOOT</TT> to the full pathname of the federated database. If
you do not have a database yet, a reasonable choice is to put it in
the Explorer home directory. So you would execute:</P>
<UL>
<LI>For C-like shells:
<PRE>
  setenv OO_FD_BOOT ~/explorer/HISTO
  source /afs/cern.ch/sw/lhcxx/share/histOO/histOO_install.csh
</PRE>
</LI>
<LI>For Bourne-like shells:
<PRE>
  export OO_FD_BOOT=~/explorer/HISTO
  source /afs/cern.ch/sw/lhcxx/share/histOO/histOO_install.ksh
</PRE>
</LI>
</UL>

<P>The above procedure will install an empty histogram database in the
directory specified. An example Makefile and test program are also
provided in the source directory. To verify the installation, you can
copy the files, compile and run the example, as follows:</P>
<PRE>
  cp /afs/cern.ch/sw/lhcxx/share/histOO/GNUmakefile . 
  cp /afs/cern.ch/sw/lhcxx/share/histOO/example_filling.cpp .
  gmake example_filling
  ./example_filling
</PRE>
-->

<H3><A NAME="HIST1DEXA">A one-dimensional histogram</A></H3>

<P>
The source code for booking a one-dimensional histogram is shown
below.
</P>

<PRE>
/* createHisto1d.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int noOfBins=20;
    
    HepDatabaseRef  histoDb = db("HistoDB"); //create a new db or use an existing one
    HepRef(Histo1D) histo   = new(histoDb) Histo1D("Test_Histo1D",noOfBins,0.0,20.0);
    
    for( int i = 0; i &lt; 50000; i++) {   // fill histo in a loop
      double x = (i % 22) - 1;          // calculate x    
      histo-&gt;fill(x,(x-9.5)*(x-9.5)+3); // fill x with weights computed by dummy formula
    }
    
    // print global histogram properties
    cout &lt;&lt; " Histogram name : " &lt;&lt; histo-&gt;get_name() &lt;&lt; endl
         &lt;&lt; " Nbins = " &lt;&lt; histo-&gt;get_nBins() &lt;&lt; " from " &lt;&lt; histo-&gt;get_xmin()
         &lt;&lt; " to "      &lt;&lt; histo-&gt;get_xmax()  &lt;&lt; endl &lt;&lt; endl;
    
    // print histogram statistics
    cout &lt;&lt; " no. of entries   : " &lt;&lt; histo-&gt;get_entries_number()               &lt;&lt; endl
         &lt;&lt; " total contents   : " &lt;&lt; histo-&gt;get_all_bins()                     &lt;&lt; endl
         &lt;&lt; " nequival         : " &lt;&lt; histo-&gt;get_nequival()                     &lt;&lt; endl
         &lt;&lt; " min bin contents : " &lt;&lt; histo-&gt;find_min_bin()                     &lt;&lt; endl
         &lt;&lt; " max bin contents : " &lt;&lt; histo-&gt;find_max_bin()                     &lt;&lt; endl
         &lt;&lt; " mean (fill time) : " &lt;&lt; histo-&gt;compute_mean(filling_time_stats)   &lt;&lt; endl
         &lt;&lt; " rms  (fill time) : " &lt;&lt; histo-&gt;compute_RMS(filling_time_stats)    &lt;&lt; endl
         &lt;&lt; " mean (bin cont)  : " &lt;&lt; histo-&gt;compute_mean(bin_content_stats)    &lt;&lt; endl
         &lt;&lt; " rms  (bin cont)  : " &lt;&lt; histo-&gt;compute_RMS(bin_content_stats)     &lt;&lt; endl
         &lt;&lt; " underflow        : " &lt;&lt; histo-&gt;get_bin_value(underflow_bin)       &lt;&lt; endl
         &lt;&lt; " overflow         : " &lt;&lt; histo-&gt;get_bin_value(overflow_bin)        &lt;&lt; endl &lt;&lt; endl;
    
    // print histogram bin content
    for(i=0; i &lt; histo-&gt;get_nBins(); i++)
      cout &lt;&lt; " bin [" &lt;&lt; setw(2) &lt;&lt; i &lt;&lt;"] "
           &lt;&lt; "= "     &lt;&lt; setw(9) &lt;&lt; histo-&gt;get_bin_value(i)
           &lt;&lt; " +/- "  &lt;&lt; setprecision(4) &lt;&lt; histo-&gt;get_bin_error(i)   &lt;&lt; endl;

    commit();    // commit this transaction
    return 0;
  }
  
};

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{histo1d@{\texttt{Histo1D}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo1d@{\texttt{Histo1D}}}%
!!TEX!!\index{fill@{\texttt{fill}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!fill@{\texttt{fill}}}%
!!TEX!!\index{getname@{\texttt{get_name}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getname@{\texttt{get_name}}}%
!!TEX!!\index{getnbins@{\texttt{get_nBins}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getnbins@{\texttt{get_nBins}}}%
!!TEX!!\index{getxmin@{\texttt{get_xmin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getxmin@{\texttt{get_xmin}}}%
!!TEX!!\index{getxmax@{\texttt{get_xmax}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getxmax@{\texttt{get_xmax}}}%
!!TEX!!\index{getentriesnumber@{\texttt{get_entries_number}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getentriesnumber@{\texttt{get_entries_number}}}%
!!TEX!!\index{getallbins@{\texttt{get_all_bins}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getallbins@{\texttt{get_all_bins}}}%
!!TEX!!\index{getnequival@{\texttt{get_nequival}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getnequival@{\texttt{get_nequival}}}%
!!TEX!!\index{findminbin@{\texttt{find_min_bin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!findminbin@{\texttt{find_min_bin}}}%
!!TEX!!\index{findmaxbin@{\texttt{find_max_bin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!findmaxbin@{\texttt{find_max_bin}}}%
!!TEX!!\index{computemean@{\texttt{compute_mean}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!computemean@{\texttt{compute_mean}}}%
!!TEX!!\index{computerms@{\texttt{compute_RMS}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!computerms@{\texttt{compute_RMS}}}%
!!TEX!!\index{getbinvalue@{\texttt{get_bin_value}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getbinvalue@{\texttt{get_bin_value}}}%
!!TEX!!\index{getbinerror@{\texttt{get_bin_error}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getbinerror@{\texttt{get_bin_error}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%

<P>When everything ran all right, then you will see the output
below. Apart from the &OBJ; database-specific code, which will be
discussed below, you will have noticed the correspondence between
the C++ methods for the one-dimensional histogram <TT>xhist</TT> in
the source and the output it generated.
</P>

<PRE>
 Histogram name : Test_Histo1D
 Nbins = 20 from 0 to 20

 no. of entries   : 50000
 total contents   : 2.16234e+06
 nequival         : 29609.4
 min bin contents : 7387.25
 max bin contents : 211957
 mean (fill time) : 9.49832
 rms  (fill time) : 8.36832
 mean (bin cont)  : 7.61848
 rms  (bin cont)  : 6.93551
 underflow        : 257417
 overflow         : 257304

 bin [ 0] =    211957 +/- 4446
 bin [ 1] =  1.71e+05 +/- 3588
 bin [ 2] = 1.347e+05 +/- 2825
 bin [ 3] = 1.029e+05 +/- 2157
 bin [ 4] = 7.558e+04 +/- 1585
 bin [ 5] = 5.285e+04 +/- 1108
 bin [ 6] = 3.466e+04 +/- 727.1
 bin [ 7] = 2.103e+04 +/- 441
 bin [ 8] = 1.193e+04 +/- 250.3
 bin [ 9] =      7387 +/- 154.9
 bin [10] =      7387 +/- 154.9
 bin [11] = 1.193e+04 +/- 250.3
 bin [12] = 2.103e+04 +/- 441
 bin [13] = 3.466e+04 +/- 727.1
 bin [14] = 5.285e+04 +/- 1108
 bin [15] = 7.554e+04 +/- 1585
 bin [16] = 1.028e+05 +/- 2157
 bin [17] = 1.346e+05 +/- 2824
 bin [18] =  1.71e+05 +/- 3587
 bin [19] = 2.119e+05 +/- 4445
</PRE>

<P>After the run you should have an &OBJ; database named
<TT>HistoDB.HEPEXP.DB</TT> in your Explorer home directory. You can
now use this example program as a basis to write other C++ programs
using the HistOOgram library, which will be described in the following
sections. In particular, you should know that the C++ header files are
in the directory:</P>
<PRE>
/afs/cern.ch/sw/lhcxx/specific/@sys/HISTOOGRAMS/pro/code
</PRE>


<H3><A NAME="HistStatistics">Histogram statistics</A></H3>
!!TEX!!\label{SHistStatistics}%
!!TEX!!\index{Histogram!statistics}%
!!TEX!!\index{Histogram!bin contents}%
!!TEX!!\index{Histogram!mean}%
!!TEX!!\index{Histogram!RMS}%
!!TEX!!\index{Bin contents}%
!!TEX!!\index{Mean!histogram contents}%
!!TEX!!\index{RMS!histogram contents}%
!!TEX!!\index{Statistics!histogram contents}%
!!TEX!!\index{Statistics!bin contents}%

<P>Two methods have been implemented to compute histogram statistics.
They are identified by the enumeration <TT>Histogram_stats_type</TT>,
which can have the two values <TT>filling_time_stats</TT> and 
<TT>bin_content_stats</TT>. These types can be given as argument
to the methods <TT>compute_mean</TT> and <TT>compute_RMS</TT>, 
as seen in the example code above. Also, in the printout of the
histograms 
!!HTML!!(see <A HREF="#Printing-histograms">Printing histograms</A>)
!!TEX!!(see Section \ref{SPrintinghistograms}) %
the mean value and the RMS of the histogram are calculated for both
methods (respectively labelled <TT>MEAN F.T.</TT>, <TT>RMS F.T.</TT>
for <EM>Filling Time</EM> and <TT>MEAN B.C.</TT>, <TT>RMS B.C.</TT> 
for <EM>Bin Content</EM>). The two methods are described below.</P>

<H4>Fill time statistics (<TT>filling_time_stats</TT>)</H4>
!!TEX!!\index{Histogram!fill time statistics}%
!!TEX!!\index{fillingtimestats@{\ttfamily filling_time_stats}}%
!!TEX!!\index{Statistics!histogram!filling time}%
!!TEX!!\index{Statistics!histogram!mean}%
!!TEX!!\index{Statistics!histogram!RMS}%

<UL>
<LI>the histogram statistics are calculated from each individual entry
stored in the histogram;</LI>
<LI>the information is stored and updated during filling time;</LI>
<LI>after filling the histogram the time required to extract the
<TT>MEAN</TT> and <TT>RMS</TT> is constant (and small).</LI>
</UL>

<H4>Bin contents statistics (<TT>bin_content_stats</TT>)</H4>
!!TEX!!\index{Histogram!bin contents statistics}%
!!TEX!!\index{bin_contentstats@{\ttfamily bin_content_stats}}%
!!TEX!!\index{Statistics!histogram!bin contents}%
!!TEX!!\index{Statistics!histogram!mean}%
!!TEX!!\index{Statistics!histogram!RMS}%

<UL>
<LI>the histogram statistics are calculated from information stored in
the bins;</LI>
<LI>the contents of special bins (underflow/overflow) is <EM>not</EM>
used during the computation;</LI>
<LI>the whole computation is performed on request after the histogram 
has been filled;</LI>
<LI>in the case of a one-dimensional histogram the position
of the bin is taken as the middle of the bin interval;</LI>
<LI>this method is less accurate than the previous one;</LI>
<LI>the computing time of <TT>MEAN</TT> and <TT>RMS</TT> is linear
with respect to the number of bins.</LI>
</UL>


<!--
<H3><A NAME="Database-and-your-application">The &OBJ; database and your
application</A></H3>

<P>Histograms created by application programs are stored in the &OBJ;
database and thus become persistent and remain fully accessible after
the application terminates. Therefore, apart from simple transient
histograms, which will be described later, an application using the
histogram package cannot be run without an &OBJ; database.
Therefore, 
Let us go through the various steps of setting up the database in
question (for those wanting to have more details, please read the
<EM>&OBJ;</EM> documentation.</P>

<P>First you should tell &OBJ; where the database is to be found. This
is done by setting the environment variable to the <EM>full
pathname</EM> of the bootfile of the federated database, for instance
(see above):</P>
<PRE>
setenv OO_FD_BOOT ~/explorer/HEPEXP             (for csh, tsh)
export OO_FD_BOOT=~/explorer/HEPEXP             (for ksh, bash, zsh)
</PRE>
<P>
In this example <TT>HEPEXP</TT> is the name given by default by the
installation procedure.
</P>

<P>Then, in your C++ program, you first include the header files for
the library, then initialise the database, and start a new
transaction.</P>

<PRE>
    Init();        // initialise the db session
    startUpdate(); // start an update transaction
    HepDatabaseRef  histoDb = db("HistoDB"); //create a new db or use an existing one
</PRE>

<P>Now, we initialise the database and start an update transaction.
At the end of you job, or after a certain time (it is bad practice to
have the database locked too long)
you might want to
commit the changes to the database. This is performed as follows:</P>

<PRE>
    commit();      // commit the transaction
</PRE>
<P>Note that if the program aborts due to any error before you commit the
transaction, all recent changes will be discarded. This is a protection
against data corruption.</P>

<P>All these commands are used in the one-dimensional histogram
example program <TT>Histo1D DEMO</TT>, mentioned in the Section on <A
HREF="#Installation"><EM>installation</EM></A>.

<H4><A NAME="ODMG-types">Platform-independent types</A></H4>

<P>The HistOOgram library uses ODMG fundamental type definitions. This
means that instead of using plain types (the size of a plain type
depends on the platform and the particular compiler) we use their ODMG
equivalents.  They have the same range of values across multiple
platforms. For your program this means that instead of using
<TT>double</TT> you should use <TT>d_Double</TT>, instead of
<TT>long</TT> you use <TT>d_Long</TT>, with a similar pattern
applicable to all other types.</P>
-->

<H3><A NAME="Booking-and-accessing-histograms">Booking and accessing
histograms</A></H3>

<P>
The general syntax for creating a new histogram is:
</P>
<PRE>
HepRef(HistogramClass) handle_name = new(object_handle) HistogramClass(...);
</PRE>

<P>
<TT>object_handle</TT> can be a handle to a database, a container
or any ordinary object. In our examples we use a database handle
obtained via a command of the type:
</P>
<PRE>
HepDatabaseRef  dbHist = db("MyDB"); //open the database
</PRE>
<P>
In this case &OBJ; will open the database with name
<TT>MyDB</TT>. From now on inside our program we communicate with the
database using the database handle <TT>dbHist</TT>.
</P>

<P>
For a one-dimensional histogram (the class is <TT>Histo1D</TT>), this
becomes more explicitly something like:
</P>
<PRE>
HepRef(Histo1D) histo = new(dbHist) Histo1D("Test_Histo1D",10,0.0,20.0);
</PRE>

<P>
This creates a new persistent histogram, which will be addressed with
the <EM>smart</EM> pointer <TT>histo</TT> (declared with
<TT>HepRef</TT>).  Users can, however, use normal pointer syntax, so
that, for instance, to fill a histogram with the value of <TT>X</TT>,
you can write:
</P>
<PRE>
histo-&gt;fill(X);
</PRE>

<P>
Later, when the changes are committed, the histogram will be 
automatically saved in the database.
</P>

<H3><A NAME="HBOOK-style-basic-histograms">HBOOK-style basic
histograms</A></H3> 
!!TEX!!\index{HBOOK}%

<P>
This and the following sections will briefly review the various types
of histogram objects, which are available at present. They are
described in detail in the <A
HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html"><EM>HistOOgram
Class Reference manual</EM></A>.
!!TEX!!\index{HistOOgram!class reference}%

<H4>Simple one- and two-dimensional histograms</H4>

<P>The classes 
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#Histo1D   (HBOOK1)">
!!HTML!!<EM>Histo1D</EM></A> 
!!TEX!!<EM>Histo1D</EM>
!!TEX!!\index{histo1d@{\texttt{Histo1D}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo1d@{\texttt{Histo1D}}}%
(for equidistant bins in one dimension), 
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#Histo1DVar">
!!HTML!!<EM>Histo1DVar</EM></A>
!!TEX!!<EM>Histo1DVar</EM>
!!TEX!!\index{histo1dvar@{\texttt{Histo1DVar}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo1dvar@{\texttt{Histo1DVar}}}%
(for non-equidistant bins in one dimension),
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#Histo2D   (HBOOK2)">
!!HTML!!<EM>Histo2D</EM></A> 
!!TEX!!<EM>Histo2D</EM>
!!TEX!!\index{histo2d@{\texttt{Histo2D}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo2d@{\texttt{Histo2D}}}%
(for equidistant bins in two dimensions), and
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#Histo2DVar">
!!HTML!!<EM>Histo2DVar</EM></A>
!!TEX!!<EM>Histo2DVar</EM>
!!TEX!!\index{histo2dvar@{\texttt{Histo2DVar}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo2dvar@{\texttt{Histo2DVar}}}%
(for non-equidistant bins in two dimensions)
offer a simple user interface, which make them easy to learn.  A rich
set of methods is available for these classes for getting access to
the characteristics of the histogram data.
</P>

We already looked at the one-dimensional case above, so let us
study a two-dimensional example.
<PRE>
/* createHisto2d.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h&gt;
#include "CLHEP/Random/Randomize.h"

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int Nbin = 10;

    HepDatabaseRef  myDb = db("MyDB"); //open the database

    HepRef(Histo2D) xhist = new(myDb) 
      Histo2D(" Test Histo2D ", Nbin, 5., 15., Nbin, 5., 15.);

/* -----Start of histogram manipulation-------------------------------- */

    cout &lt;&lt; endl &lt;&lt; " Histogram name : " &lt;&lt; xhist-&gt;get_name() &lt;&lt; endl;;

    cout &lt;&lt; " X axis : ";
    cout &lt;&lt; " Nbins = " &lt;&lt; xhist-&gt;get_nxBins() &lt;&lt; " from: " &lt;&lt; xhist-&gt;get_xmin()
         &lt;&lt; " to: " &lt;&lt; xhist-&gt;get_xmax() &lt;&lt; endl ;
  
    cout &lt;&lt; " Y axis : ";
    cout &lt;&lt; " Nbins = " &lt;&lt; xhist-&gt;get_nyBins() &lt;&lt; " from: " &lt;&lt; xhist-&gt;get_ymin()
         &lt;&lt; " to: " &lt;&lt; xhist-&gt;get_ymax() &lt;&lt; endl ;
 
    for(int i = 0;i &lt; 50000;i++)
    {
      double x  = RandFlat::shoot(20.);       // fnum  ]0,20[
     
      xhist-&gt;fill(x,x,0.5);    // fill diagonal
      xhist-&gt;fill(20-x,x,0.5); // fill anti-diagonal
    }

    cout &lt;&lt; endl &lt;&lt; " no. of entries   : " &lt;&lt; xhist-&gt;get_entries_number()
         &lt;&lt; endl &lt;&lt; " total contents   : " &lt;&lt; xhist-&gt;get_all_bins() 
         &lt;&lt; endl &lt;&lt; " nequival         : " &lt;&lt; xhist-&gt;get_nequival()
         &lt;&lt; endl &lt;&lt; " min bin contents : " &lt;&lt; xhist-&gt;find_min_bin()
         &lt;&lt; endl &lt;&lt; " max bin contents : " &lt;&lt; xhist-&gt;find_max_bin()
         &lt;&lt; endl &lt;&lt; " X-Y  underflow/overflow bins "
         &lt;&lt; endl &lt;&lt; " u-u        : " &lt;&lt; xhist-&gt;get_bin_value(underflow_bin,underflow_bin)
         &lt;&lt; endl &lt;&lt; " u-i        : " &lt;&lt; xhist-&gt;get_bin_value(underflow_bin,inrange_bin)
         &lt;&lt; endl &lt;&lt; " u-o        : " &lt;&lt; xhist-&gt;get_bin_value(underflow_bin,overflow_bin)
         &lt;&lt; endl &lt;&lt; " i-u        : " &lt;&lt; xhist-&gt;get_bin_value(inrange_bin,underflow_bin)
         &lt;&lt; endl &lt;&lt; " i-o        : " &lt;&lt; xhist-&gt;get_bin_value(inrange_bin,overflow_bin)
         &lt;&lt; endl &lt;&lt; " o-u        : " &lt;&lt; xhist-&gt;get_bin_value(overflow_bin,underflow_bin)
         &lt;&lt; endl &lt;&lt; " o-i        : " &lt;&lt; xhist-&gt;get_bin_value(overflow_bin,inrange_bin)
         &lt;&lt; endl &lt;&lt; " o-o        : " &lt;&lt; xhist-&gt;get_bin_value(overflow_bin,overflow_bin)
         &lt;&lt; endl;

    for(int ix=0;ix&lt;Nbin;ix++)
     for(int iy=0;iy&lt;Nbin;iy++)
     { 
       if (xhist-&gt;get_bin_value(ix,iy) &gt; 0.0)
       cout &lt;&lt; endl &lt;&lt; " bin (" &lt;&lt; ix &lt;&lt; "," &lt;&lt; iy 
	    &lt;&lt; ") contents = " &lt;&lt; xhist-&gt;get_bin_value(ix,iy)
            &lt;&lt; " error = "     &lt;&lt; xhist-&gt;get_bin_error(ix,iy);
     }              // end of for loop 
    cout &lt;&lt; endl;               

/*  -----End of histogram manipulation--------------------------------- */

    commit();    // commit this transaction
    return 0;
  }
};  // end of class definition 

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{fill@{\texttt{fill}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!fill@{\texttt{fill}}}%
!!TEX!!\index{getbinvalue@{\texttt{get_bin_value}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getbinvalue@{\texttt{get_bin_value}}}%
!!TEX!!\index{getentriesnumber@{\texttt{get_entries_number}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getentriesnumber@{\texttt{get_entries_number}}}%
!!TEX!!\index{getbinerror@{\texttt{get_bin_error}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getbinerror@{\texttt{get_bin_error}}}%
!!TEX!!\index{getallbins@{\texttt{get_all_bins}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getallbins@{\texttt{get_all_bins}}}%
!!TEX!!\index{getname@{\texttt{get_name}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getname@{\texttt{get_name}}}%
!!TEX!!\index{getnequival@{\texttt{get_nequival}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getnequival@{\texttt{get_nequival}}}%
!!TEX!!\index{findminbin@{\texttt{find_min_bin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!findminbin@{\texttt{find_min_bin}}}%
!!TEX!!\index{findmaxbin@{\texttt{find_max_bin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!findmaxbin@{\texttt{find_max_bin}}}%
!!TEX!!\index{getnxbins@{\texttt{get_nxBins}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getnxbins@{\texttt{get_nxBins}}}%
!!TEX!!\index{getnybins@{\texttt{get_nyBins}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getnybins@{\texttt{get_nyBins}}}%
!!TEX!!\index{getxmin@{\texttt{get_xmin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getxmin@{\texttt{get_xmin}}}%
!!TEX!!\index{getxmax@{\texttt{get_xmax}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getxmax@{\texttt{get_xmax}}}%
!!TEX!!\index{getymin@{\texttt{get_ymin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getymin@{\texttt{get_ymin}}}%
!!TEX!!\index{getymax@{\texttt{get_ymax}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getymax@{\texttt{get_ymax}}}%
!!TEX!!\index{histo2d@{\texttt{Histo2D}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!histo2d@{\texttt{Histo2D}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
!!TEX!!\index{randflat@{\texttt{RandFlat}} method (CLHEP)}%
!!TEX!!\index{CLHEP!methods!randflat@{\texttt{RandFlat}}}%
<P>
In this example we create a two-dimensional histogram
with 10 bins in X and Y. We fill it along the diagonal and the
anti-diagonal, and then call some of the methods to access the
histogram statistics. Finally, before committing the histogram in the
dabatase, we print the non-empty bins. The output is shown below.
<PRE>
 Histogram name :  Test Histo2D 
 X axis :  Nbins = 10 from: 5 to: 15
 Y axis :  Nbins = 10 from: 5 to: 15

 no. of entries   : 100000
 total contents   : 50000
 nequival         : 100000
 min bin contents : 0
 max bin contents : 1279
 X-Y  underflow/overflow bins 
 u-u        : 6308.5
 u-i        : 0
 u-o        : 6240
 i-u        : 0
 i-o        : 0
 o-u        : 6308.5
 o-i        : 0
 o-o        : 6240

 bin (0,0) contents = 1191.5 error = 24.408
 bin (0,9) contents = 1248.5 error = 24.985
 bin (1,1) contents = 1254.5 error = 25.045
 bin (1,8) contents = 1260.5 error = 25.1048
 bin (2,2) contents = 1250 error = 25
 bin (2,7) contents = 1239.5 error = 24.8948
 bin (3,3) contents = 1271 error = 25.2091
 bin (3,6) contents = 1244 error = 24.9399
 bin (4,4) contents = 1213 error = 24.6272
 bin (4,5) contents = 1279 error = 25.2883
 bin (5,4) contents = 1213 error = 24.6272
 bin (5,5) contents = 1279 error = 25.2883
 bin (6,3) contents = 1271 error = 25.2091
 bin (6,6) contents = 1244 error = 24.9399
 bin (7,2) contents = 1250 error = 25
 bin (7,7) contents = 1239.5 error = 24.8948
 bin (8,1) contents = 1254.5 error = 25.045
 bin (8,8) contents = 1260.5 error = 25.1048
 bin (9,0) contents = 1191.5 error = 24.408
 bin (9,9) contents = 1248.5 error = 24.985
</PRE>
<P>We filled the histogram along both diagonals with a
random number between zero and twenty. However, the boundary values of the
histogram were five and fifteen, so that we expect half of the 100000 entries
to be in the underflow and overflow bins, and the other half spread 
evenly along the twenty bins of the two diagonals. As the weight of the
events is 0.5, we indeed get about 1250 events inside the bins of the
histogram, and about 6250 in the four underflow/overflow bins
(<TT>u-u</TT>, <TT>u-o</TT>, <TT>o-u</TT> and <TT>o-o</TT>).

<H3><A NAME="More-general-histograms">More general histograms</A></H3>

<P>The classes described previously provide a HBOOK-like interface,
!!TEX!!\index{HBOOK}%
which is familiar to most HEP physicists, thus allowing them to
develop applications rapidly and simply.  However, sometimes more
complex histograms are needed, and this simple interface is not
sufficient.
</P>

<P>Therefore, we introduce a generalised type of histogram, whose
basic component is the <TT>Partition</TT> class. It defines the
following:</P>
!!TEX!!\index{partition@{\texttt{Partition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!partition@{\texttt{Partition}}}%

<UL>
<LI>the dimension of the problem space;</LI> 
<LI>the data type for each dimensional component (in the current
    version only real numbers of type <TT>double</TT> are provided);</LI>
<LI>the description of the bins (partition).</LI>
</UL>

<P>Data type information and the bin description is supplied by
classes derived from 
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#ElementaryPartition.html">
!!HTML!!<EM>ElementaryPartition</EM></A>.
!!TEX!!<EM>ElementaryPartition</EM>.
!!TEX!!\index{elementarypartition@{\texttt{ElementaryPartition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!elementarypartition@{\texttt{ElementaryPartition}}}%
Each <EM>ElementaryPartition</EM> represents one dimension in the problem
space. Presently, one can use the following elementary partitions:</P>

<UL>
<LI>
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#FixedLengthElementaryPartition">
!!HTML!!<EM>FixedLengthPartition</EM></A>
!!TEX!!<EM>FixedLengthPartition</EM>
!!TEX!!\index{fixedlengthpartition@{\texttt{FixedLengthPartition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!fixedlengthpartition@{\texttt{FixedLengthPartition}}}%
for <EM>equidistant bins</EM> over the real axis;</LI> 
<LI>
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#VariableLengthPartition">
!!HTML!!<EM>VariableLengthPartition</EM></A>
!!TEX!!<EM>VariableLengthPartition</EM>
!!TEX!!\index{variablelengthpartition@{\texttt{VariableLengthPartition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!variablelengthpartition@{\texttt{VariableLengthPartition}}}%
for <EM>variable length bins</EM>, where each one has to be defined
separately.</LI>
</UL>

<H4>Standard way to book a general histogram</H4>
!!TEX!!\index{Histogram!general}%

<P>
<OL>
<LI>Create any number of elementary partitions:
!!TEX!!\index{Partition!elementary!create}%
<PRE>
HepRef(ElemPartType1) p1 = new (myDB) ElemPartType1(...);
   ...
HepRef(ElemPartTypeN) pN = new (myDB) ElemPartTypeN(...);
</PRE>
</LI>
<LI>Create a <EM>partition</EM> and insert the elementary partitions created in
the first step (the order of adding elementary partitions is
significant);
!!TEX!!\index{Partition!creation}%
!!TEX!!\index{Partition!elementary!add}%
<PRE>
HepRef(Partition) part = new (myDB) Partition();
part->add_part( p1 ); 
     ... 
part->add_part( pN );
</PRE>
!!TEX!!\index{addpart@{\texttt{add_part}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!addpart@{\texttt{add_part}}}%
</LI>
<LI>Create a <EM>DataHistogram</EM> using the partition above.
!!TEX!!\index{DataHistogram!creation}%
<PRE>
HepRef(DataHistogram) hist = new (myDB) DataHistogram("name",part);
</PRE></LI>
</OL>

<H4><A NAME="Misc-Bins-endpoint-conventions">A note on endpoint
conventions</A></H4>
!!TEX!!\index{Endpoint convention}

<P>The <EM>endpoint convention</EM> specifies to which of two
neighbouring intervals (<TT>LEFT</TT> chooses the interval to the left
of the endpoint, <TT>RIGHT</TT> the one to the right) the given endpoint
belongs. 
For instance, suppose we have <TT>N</TT> bins. Then we could
specify an array like,
<PRE>
side eps[N+1] = {LEFT,LEFT,...,LEFT,RIGHT};
</PRE>
which would yield the following pattern (the square brackets signaling
which side the endpoint is included).
<PRE>
-und-]1(--]2(--]3( .... ]N-1(--)N[-ovr-
</PRE>
<P>
Note that since we specify a characteristic of the endpoint rather
than the bin we must give <TT>N+1</TT> values.
The notation <TT>-und-</TT>, <TT>-ovr-</TT> stands for 
underflow, overflow, respectively.
</P>

<H4>Example of a Data Histogram</H4>

<P>Let us look at an example of the use of partitions and data
histograms. The source of the program will be shown first.</P>

<PRE>
/* dataHistogram.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;math.h&gt;
#include &lt;iostream.h&gt;
#include "CLHEP/Random/Randomize.h"

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    HepDatabaseRef  myDb = db("HistoDB"); //create or open db "HistoDB"

    const int Nbinx = 10, Nbiny = 10, Nbinz = 5;

    // Create elementary partitions

    HepRef(FixedLengthPartition) 
     p1 = new (myDb) FixedLengthPartition(Nbinx, 0., 1.0, LEFT );

    HepRef(FixedLengthPartition) 
     p2 = new (myDb) FixedLengthPartition(Nbiny, 0., 1.0, RIGHT );

    double ep_list[Nbinz+1] = {0.,0.25,0.5,0.7,0.85,1.};
    side   ep_conv_list[Nbinz+1] = {LEFT,LEFT,RIGHT,LEFT,LEFT,LEFT};

    HepRef(VariableLengthPartition) 
     p3 = new (myDb) VariableLengthPartition(ep_list,Nbinz+1, ep_conv_list, Nbinz+1);

    // Create partition

    HepRef(Partition) part = new (myDb) Partition();

    // Add elementary partitions in partition

    part-&gt;add_part( p1 );
    part-&gt;add_part( p2 );
    part-&gt;add_part( p3 );

    // Create datahistogram    

    HepRef(DataHistogram) 
     xhist = new(myDb) DataHistogram(" Test General 3D Histo  ", part);

/* -----Start of histogram manipulation-------------------------------- */

    printf(" Histogram name : %s \n",xhist-&gt;get_name());

    for(int i = 1;i &lt;= 50000;i++)
    {
      double x[3];
      double ran;
      ran  = RandFlat::shoot(1.);       // fnum  ]0,1[
      x[0] = ran;
      ran  = RandFlat::shoot(1.);       // fnum  ]0,1[
      x[1] = pow(ran,2);
      ran  = RandFlat::shoot(1.);       // fnum  ]0,1[
      x[2] = pow(ran,0.3);
 
      xhist-&gt;add_data_point(x,1.0);  // fill 3D datahistogram
   
    }

    cout &lt;&lt; endl &lt;&lt; " no. of entries   : " &lt;&lt; xhist-&gt;get_entries_number()
         &lt;&lt; endl &lt;&lt; " total contents   : " &lt;&lt; xhist-&gt;get_all_bins() 
         &lt;&lt; endl &lt;&lt; " nequival         : " &lt;&lt; xhist-&gt;get_nequival()
         &lt;&lt; endl &lt;&lt; " min bin contents : " &lt;&lt; xhist-&gt;find_min_bin()
         &lt;&lt; endl &lt;&lt; " max bin contents : " &lt;&lt; xhist-&gt;find_max_bin()
         &lt;&lt; endl;

    for(int ix=0;ix&lt;Nbinx;ix++)
     for(int iy=0;iy&lt;Nbiny;iy++)
      for(int iz=0;iz&lt;Nbinz;iz++)
      {
        int a[3];
        a[0] = ix; a[1] = iy; a[2] = iz;

        cout &lt;&lt; endl &lt;&lt; " bin (" &lt;&lt; ix &lt;&lt; "," &lt;&lt; iy &lt;&lt; "," &lt;&lt; iz
                     &lt;&lt; ") contents = " &lt;&lt; xhist-&gt;get_bin_value(a);
      }
       
    cout &lt;&lt; endl;               

/*  -----End of histogram manipulation--------------------------------- */
    
    commit();    // commit this transaction
    return 0;
  }
  
};   // end of class definition


int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{fixedlengthpartition@{\texttt{FixedLengthPartition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!fixedlengthpartition@{\texttt{FixedLengthPartition}}}%
!!TEX!!\index{variablelengthpartition@{\texttt{VariableLengthPartition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!variablelengthpartition@{\texttt{VariableLengthPartition}}}%
!!TEX!!\index{partition@{\texttt{Partition}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!partition@{\texttt{Partition}}}%
!!TEX!!\index{datahistogram@{\texttt{DataHistogram}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!datahistogram@{\texttt{DataHistogram}}}%
!!TEX!!\index{addpart@{\texttt{add_part}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!addpart@{\texttt{add_part}}}%
!!TEX!!\index{adddatapoint@{\texttt{add_data_point}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!adddatapointe@{\texttt{add_data_point}}}%
!!TEX!!\index{getentriesnumber@{\texttt{get_entries_number}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getentriesnumber@{\texttt{get_entries_number}}}%
!!TEX!!\index{getbinvalue@{\texttt{get_bin_value}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getbinvalue@{\texttt{get_bin_value}}}%
!!TEX!!\index{getallbins@{\texttt{get_all_bins}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getallbins@{\texttt{get_all_bins}}}%
!!TEX!!\index{getnequival@{\texttt{get_nequival}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!getnequival@{\texttt{get_nequival}}}%
!!TEX!!\index{findminbin@{\texttt{find_min_bin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!findminbin@{\texttt{find_min_bin}}}%
!!TEX!!\index{findmaxbin@{\texttt{find_max_bin}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!findmaxbin@{\texttt{find_max_bin}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
!!TEX!!\index{randflat@{\texttt{RandFlat}} method (CLHEP)}%
!!TEX!!\index{CLHEP!methods!randflat@{\texttt{RandFlat}}}%

<P>In the above program we declare two fixed length (<TT>p1</TT> and
<TT>p2</TT>) and a variable length elementary partitions
(<TT>p3</TT>), then a base partition <TT>part</TT>, to which the three
elementary partitions are added with the <TT>add_part</TT> method. A
3-dimensional data histogram <TT>xhist</TT> is declared next, and we
fill it with some random data. Finally, before committing the
histogram to the database, we print some statistical information, as
well as the contents of the bins. The output is (partially) reproduced
below.

<PRE>
 Histogram name :  Test General 3D Histo   

 no. of entries   : 50000
 total contents   : 50000
 nequival         : 50000
 min bin contents : 1
 max bin contents : 707

 bin (0,0,0) contents = 9
 bin (0,0,1) contents = 154
 bin (0,0,2) contents = 329
 bin (0,0,3) contents = 425
 bin (0,0,4) contents = 658
     <EM>.... many lines omitted</EM>
 bin (9,9,0) contents = 4
 bin (9,9,1) contents = 29
 bin (9,9,2) contents = 53
 bin (9,9,3) contents = 63
 bin (9,9,4) contents = 116
</PRE>

<H3><A NAME="Printing-histograms">Printing histograms</A></H3>
!!TEX!!\label{SPrintinghistograms}%

<P>You can create text-graphics printouts on standard C++ streams of
<TT>Histo1D</TT> and <TT>Histo2D</TT> histograms
with the class 
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#HistPrintout">
!!HTML!!<EM>HistPrintout</EM></A>
!!TEX!!<EM>HistPrintout</EM>
!!TEX!!\index{histprintout@{\texttt{HistPrintout}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histprintout@{\texttt{HistPrintout}}}%
is responsible for creating printouts . You can specify the page size
into which the printed output must fit. In case the graph does not fit
on the page a warning message is issued and inserted on the top
of the printout. The page size restriction affects only the graph
itself and not the additional textual information which is printed
next to the graph.</P>

<P>The way how to use this functionality is shown in the following
source code example.</P>

<PRE>
/* printHistos.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include "CLHEP/Random/Randomize.h"
#include &lt;iostream.h&gt;
#include &lt;math.h&gt;

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int NBins = 10;

    HepDatabaseRef  histoDb = db("HistoDB"); //create or open "HistoDB" db
  
    HepRef(Histo1D) xhist = 
      new(histoDb) Histo1D("1D Histo",NBins,0.0,20.0);

    double epl[10] = { 0.0, 1.0, 2.0, 4.0, 8.0, 10.0, 11.0, 20.0, 30.0, 100.0 };

    HepRef(Histo1DVar) xhistvar = 
      new(histoDb) Histo1DVar("Variable bin Histo1D", epl, 10, RIGHT);

    HepRef(Histo2D) xyhist = 
      new(histoDb) Histo2D("2D Histo", 40, -0.1, 0.5, 30, -.1, 0.5);

    HepRef(Histo2DVar) xyhistvar = 
      new (histoDb) Histo2DVar("Variable bin Histo2D", epl, 10, LEFT, epl, 10, LEFT);

/* -----Start of histogram manipulation-------------------------------- */

    for(int i = 0;i &lt; 50000;i++)
    {
      double x,y;

      x  = double(i%19);  
      xhist-&gt;fill(x, abs(sin(i)));

      x  = RandFlat::shoot(100.);       // fnum  ]0,100[
      xhistvar-&gt;fill(x,1/(x+1));

      x  = RandFlat::shoot(3.14159);    // fnum  ]0,2pi[
      x  = 0.5*cos(x); 
      y  = RandFlat::shoot(3.14159);    // fnum  ]0,2pi[
      y  = 0.5*sin(y);
      xyhist-&gt;fill(x*x+x*y,y*y-x*y,y*y);

      x  = RandGauss::shoot(15.,16.);   // (mean=15, stDev=16)
      y  = RandGauss::shoot(16.,7.);    // (mean=16, stDev=7)
      xyhistvar-&gt;fill(x,y,1);
    }

    // Print histograms (first 1D, then 2D)

    HistPrintout p(cout);

    p.print(*xhist);    cout &lt;&lt; endl; 
    p.print(*xhistvar); cout &lt;&lt; endl; 
    p.print(*xyhist);   cout &lt;&lt; endl; 
    p.print(*xyhistvar);

/*  -----End of histogram manipulation--------------------------------- */
    
    commit();    // commit this transaction
    return 0;
  }
  
};  // end of class definition

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{fill@{\texttt{fill}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!fill@{\texttt{fill}}}%
!!TEX!!\index{print@{\texttt{print}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!print@{\texttt{print}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
!!TEX!!\index{randflat@{\texttt{RandFlat}} method (CLHEP)}%
!!TEX!!\index{CLHEP!methods!randflat@{\texttt{RandFlat}}}%
!!TEX!!\index{randgauss@{\texttt{RandGauss}} method (CLHEP)}%
!!TEX!!\index{CLHEP!methods!randgauss@{\texttt{RandGauss}}}%

<P>Let us have a closer look at this code. After the usual
initialisation of the &OBJ; database, we generate two one- and
two-dimensional histograms (one with fixed and one with variable bins
for each). Then we fill these histograms with a combination of
trigonometric mathematical functions and random numbers. 
If we want to print these
histograms to standard output (<TT>cout</TT>) then the following steps
must be taken:</P>

<OL>
<LI>Create a printout object <TT>p</TT>, which will use <TT>cout</TT>
as output stream.
<PRE>
  HistPrintout p(cout);
</PRE>
</LI>
<LI>Set the page size. A page size has 80 columns by default, while
its depth (number of lines) is at first 0 (unlimited).
<PRE>
  p.columns = 120; // any numbers of your choice
  p.lines = 0;     // unlimited
</PRE>
Of course, any values can be chosen for these numbers.  In particular,
the page size can be adjusted automatically to fill the width of
the terminal window.
<PRE>
  p.auto_setup();  // get COLUMNS and LINES from environment variables
</PRE>
</LI>
<LI>Printing out the histograms. This is quite simple: just
call the <TT>print</TT> message, with as argument the dereferenced
pointer to the histogram object. 
<PRE>
  p.print( *xhist ); // *xhist dereferences the pointer to type <TT>HepRef</TT>.
</PRE>
Note that only one- and two-dimensional histograms can be printed in
this way.
</LI>
</OL>
<P>The output generated by the code above is seen below.
We note in particular the way the definition of the variable-width
bins are printed in the output, together with the end-point definitions.</P>
!!TEX!!\index{Endpoint convention}
<PRE>
BINS' ENDPTS: -und-)0[--)1[--)2[--)4[--)8[--)10[--)11[--)20[--)30[--)100[-ovr-
</PRE>
<P>
This corresponds to the definition for the variable-bin 1-D histogram of
our example program, where the bins indeed correspond to those defined
with the <TT>epl</TT> array.
</P>
<P>
You should also note the two calculated values for the mean
and RMS values of the contents of the histogram. These values
are calculated at fill time (label <TT>F.T.</TT>)
and after filling the histogram from the bin contents
themselves (label <TT>B.C.</TT>), respectively. See
!!HTML!!<A HREF="#HistStatistics">Histogram statistics</A>
!!TEX!!Section \ref{SHistStatistics}%
for a detailed explanation. The differences between the two values are
small in most cases, although the value calculated at filling time
should be the more precise.</P>
!!TEX!!\index{Histogram!statistics}%
!!TEX!!\index{Histogram!bin contents}%
!!TEX!!\index{Histogram!mean}%
!!TEX!!\index{Histogram!RMS}%
!!TEX!!\index{Bin contents}%
!!TEX!!\index{Mean!histogram contents}%
!!TEX!!\index{RMS!histogram contents}%
!!TEX!!\index{Statistics!histogram contents}%
!!TEX!!\index{Statistics!bin contents}%

<PRE>
TYPE       : Histo1D
TITLE      : 1D Histo
BIN NUMBER : 10
BIN WIDTH  : 2

                           1.67e+03                        3.35e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   1     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   2     3.352e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   3     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   4     3.351e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+01   5     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.200e+01   6     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.400e+01   7     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   8     3.350e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   9     1.675e+03|
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  3.183e+04 NEQUIVAL :  4.053e+04
 MEAN F.T.:  8.999e+00 MEAN B.C.:  9.526e+00 UNDERFLOW:  0.000e+00
 RMS F.T. :  5.477e+00 RMS B.C. :  5.500e+00 OVERFLOW :  0.000e+00

TYPE        : Histo1D Variable Length Bins
TITLE       : Variable bin Histo1D
BIN NUMBER  : 9
BINS' ENDPTS: -und-)0.000e+00[--)1.000e+00[--)2.000e+00[--)4.000e+00[
                 --)8.000e+00[--)1.000e+01[--)1.100e+01[
                 --)2.000e+01[--)3.000e+01[--)1.000e+02[-ovr-

                           4.50e+01                        5.89e+02 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     3.618e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.945e+02|XXXXXXXXXXXXXX
 2.000e+00   2     2.565e+02|XXXXXXXXXXXXXXXXXXX
 4.000e+00   3     3.034e+02|XXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   4     1.055e+02|XXXXX
 1.000e+01   5     4.504e+01|
 1.100e+01   6     2.816e+02|XXXXXXXXXXXXXXXXXXXXXX
 2.000e+01   7     1.929e+02|XXXXXXXXXXXXX
 3.000e+01   8     5.891e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  2.330e+03 NEQUIVAL :  1.067e+04
 MEAN F.T.:  2.045e+01 MEAN B.C.:  2.230e+01 UNDERFLOW:  0.000e+00
 RMS F.T. :  2.512e+01 RMS B.C. :  2.575e+01 OVERFLOW :  0.000e+00

TYPE     : Histo2D
TITLE    : 2D Histo
X:  BINS :    40  WIDTH  : 1.500e-02  MIN    : -1.000e-01  MAX    : 5.000e-01
Y:  BINS :    30  WIDTH  : 2.000e-02  MIN    : -1.000e-01  MAX    : 5.000e-01


         0         1         2         3           
         0123456789012345678901234567890123456789  
        ******************************************
       *                                          *
   0  *  ........................................  *
   1  *  ........................................  *
   2  *  ..........................++++++2222....  *
   3  *  ................................+++234..  *
   4  *  .............................+++++++2378  *
   5  *  .............................+++++234444  *
   6  *  .........................++.++++332+....  *
   7  *  ......+................+..++222+........  *
   8  *  ......+...............++++2++...........  *
   9  *  .....++.........+..+++22+...............  *
  10  *  .....++......+..+++22+..................  *
  11  *  .....2++......+++2+.....................  *
  12  *  .....2+..+.+++22+.......................  *
  13  *  ....+2++++++22+.........................  *
  14  *  ....22+++222............................  *
  15  *  ....322232+.............................  *
  16  *  ....52242...............................  *
  17  *  ...2433.....+...........................  *
  18  *  ...454..................................  *
  19  *  ...75......+............................  *
  20  *  ...B+.....+.............................  *
  21  *  ..45++...++.............................  *
  22  *  ..62++..+++.............................  *
  23  *  ..63++.++2..............................  *
  24  *  ..53++++2+..............................  *
  25  *  ..252+++3...............................  *
  26  *  ...53223+...............................  *
  27  *  ...+6323................................  *
  28  *  ....2653................................  *
  29  *  .....3F.................................  *
       *                                          *
        ******************************************

ENTRIES  :      50000   Z MIN    :          0
TOTAL C. :   6.26e+03   Z STEP   :         10
NEQUIVAL :   3.34e+04   Z SCALE  : .+23456789ABCDE

             0 |          0 |          0
    -----------|------------|-----------
             0 |   6.26e+03 |          0
    -----------|------------|-----------
             0 |          0 |          0

TYPE     : Histo2D
TITLE    : Variable bin Histo2D
X:  BINS :     9    -und-]0.000e+00(--]1.000e+00(--]2.000e+00(--]4.000e+00(
                       --]8.000e+00(--]1.000e+01(--]1.100e+01(
                       --]2.000e+01(--]3.000e+01(--]1.000e+02(-ovr-
Y:  BINS :     9    -und-]0.000e+00(--]1.000e+00(--]2.000e+00(--]4.000e+00(
                       --]8.000e+00(--]1.000e+01(--]1.100e+01(
                       --]2.000e+01(--]3.000e+01(--]1.000e+02(-ovr-

         012345678  
        ***********
       *           *
   0  *  .........  *
   1  *  .........  *
   2  *  .........  *
   3  *  ......222  *
   4  *  ......22+  *
   5  *  ......+++  *
   6  *  ++253+FEB  *
   7  *  ..+3+.876  *
   8  *  .........  *
       *           *
        ***********

ENTRIES  :      50000   Z MIN    :          3
TOTAL C. :      5e+04   Z STEP   :        345
NEQUIVAL :      5e+04   Z SCALE  : .+23456789ABCDE

             0 |          0 |          0
    -----------|------------|-----------
      8.72e+03 |   4.07e+04 |          0
    -----------|------------|-----------
            87 |        448 |          0
</PRE>


<H3><A NAME="Histogram-operations">Histogram operations</A></H3>

<P>To combine histograms using arithmetic operations one must satisfy
a few basic rules, which are explained below. In case one of the
conditions is violated, a run-time error will occur, the program will
abort, and display a diagnostic message on standard output.  In future
versions exceptions will be implemented to handle such run-time
errors.</P>

<H4>Any arithmetic operations between two histograms</H4>

<P>The partitions used by both histograms must either be the same
physical object (see <A HREF="#Copying-histograms"><EM>Copying
histograms</EM></A> for information how one partition can be shared
between many histograms) or must have the same structure
(<EM>structural identity</EM> between histograms), i.e.,
<UL>
<LI>the same number of elementary partitions;</LI>
<LI>corresponding elementary partitions must have the same number of bins;</LI>
<LI>corresponding bins in elementary partitions must be of the same size
and location.</LI>
</UL>

<H4>Division of two histograms</H4>

<P>
In the case of normal division of two histograms, the denominator
should contain no bins with zero contents.  For binomial division, the
denominator should have no bins which have zero error. Finally, when
dividing a histogram by a real number, it is evident that this number
should be different from zero.</P>

<H3><A NAME="Copying-histograms">Copying histograms</A></H3>

<P>It is forbidden to use the equal operator <TT>=</TT> or to use the
<EM>copy constructor</EM> to copy histograms. In the case of
<EM>transient</EM> objects histograms should be passed by reference,
for persistent objects by means of a <TT>HepRef</TT> handle. It is
possible, however, to obtain identical copies of a histogram using the
<TT>clone</TT> and <TT>cloneNull</TT> methods. The advantage of this
latter approach is that all copies of a histogram share one, physical
partition object. From this point of view all copies of a histogram
are <EM>structurally identical</EM> although they remain different physical
objects with different contents.</P>

<P>Any number of histograms can share one partition. To achieve
this:</P>

<UL>
<LI>use the <TT>clone</TT> (or <TT>cloneNull</TT>) method (see
the <TT>Histogram</TT> class description for more details)
<PRE>
         HepRef(Histo1D) x = new(myDB) Histo1D(...);
         HepRef(Histo1D) y = x.clone();
</PRE></LI>
<LI>explicitly reuse a partition 
    (not available for <TT>Histo1D</TT> and <TT>Histo2D</TT>)
<PRE>
  HepRef(Partition) <EM>part</EM> = new(myDB) Partition();
         ...
  HepRef(DataHistogram) x = new(myDB) DataHistogram(...,<EM>part</EM>);
  HepRef(DataHistogram) y = new(myDB) DataHistogram(...,<EM>part)</EM>;
</PRE></LI>
</UL>


<H3>Example of histogram copy and operations</H3>

<P>Let us consider the following code, which shows how we cloned
histogram <TT>xhist</TT> into <TT>x2hist</TT>, then filled the
<TT>xhist</TT> with a uniform random number, and <TT>x2hist</TT> with
two Gaussians.  We next add the two histograms together into
<TT>x2hist</TT> and divide each bin by the mean number in each bin in
<TT>xhist</TT> (2500.). We use the histogram printing facilities to
show the effect of these operations, getting at the same time the
statistics associated with each histogram.</P>

<PRE>
/* copyHistos.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;iostream.h&gt;
#include "CLHEP/Random/Randomize.h"

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    const int Nbin = 10;

    HepDatabaseRef  myDb = db("MyDB"); //open the database

    HepRef(Histo1D) xhist = new(myDb) Histo1D(" Random Numbers ",40,0.0,20.0);

    HepRef(Histo1D) x2hist = xhist-&gt;clone(); // Clone histogram

/* -----Start of histogram manipulation-------------------------------- */

    // Fill histograms with random number 

    for(int i = 1;i &lt;= 100000;i++)
    {
      double x  = RandFlat::shoot(20.);       // fnum  ]0,20[
      double n1 = RandGauss::shoot(5.,1.6);   // (mean=5, stDev=1.6)
      double n2 = RandGauss::shoot(15.2,0.7); // (mean=15.2, stDev=.7)
      xhist-&gt;fill(x,1.);
      x2hist-&gt;fill(n1,1.);
      x2hist-&gt;fill(n2,0.5);
    }

    cout &lt;&lt; "Graphical Histogram Printout" &lt;&lt; endl;

    HistPrintout p(cout);

    p.print(*xhist); cout &lt;&lt; endl; p.print(*x2hist); 

    // Add x2hist to xhist, then divide by 2500 

    x2hist-&gt;add(*xhist);
    x2hist-&gt;div(2500.);      

    cout &lt;&lt; endl 
         &lt;&lt; "Graphical Histogram Printout of xhist2 after operations"
         &lt;&lt; endl;

    p.print(*x2hist); 

/*  -----End of histogram manipulation--------------------------------- */

    commit();     // commit transaction
    return 0;
  }
};  // end of class definition

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call it's run method
}
</PRE>
!!TEX!!\index{histo1d@{\texttt{Histo1D}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histo1d@{\texttt{Histo1D}}}%
!!TEX!!\index{fill@{\texttt{fill}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!fill@{\texttt{fill}}}%
!!TEX!!\index{clone@{\texttt{clone}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!clone@{\texttt{clone}}}%
!!TEX!!\index{add@{\texttt{add}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!add@{\texttt{add}}}%
!!TEX!!\index{div@{\texttt{div}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!div@{\texttt{div}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%
!!TEX!!\index{randflat@{\texttt{RandFlat}} method (CLHEP)}%
!!TEX!!\index{CLHEP!methods!randflat@{\texttt{RandFlat}}}%
!!TEX!!\index{randgauss@{\texttt{RandGauss}} method (CLHEP)}%
!!TEX!!\index{CLHEP!methods!randgauss@{\texttt{RandGauss}}}%

<P>Note that we had to include a reference to the CLHEP classes via the
include file <TT>CLHEP/Random/Randomize.h</TT>, and that we also have
to include the path of the CLHEP directory where these include files
are kept, as well, when building the executable, we have to specify
where the CLHEP libraries are. In this example we use the
<TT>shoot</TT> methods of two of the random number generators of
CLHEP, namely <TT>RandFlat</TT> (uniform distribution), and
<TT>RandGauss</TT> (Gaussian distribution). The output generated 
by the code shown is below.</P>

<PRE>

Graphical Histogram Printout
TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN NUMBER : 40
BIN WIDTH  : 0.5

                           2.33e+03                        2.59e+03 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.511e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e-01   1     2.491e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   2     2.434e+03|XXXXXXXXXXXXXXXXXXXXX
 1.500e+00   3     2.537e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   4     2.510e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.500e+00   5     2.485e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   6     2.448e+03|XXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     2.547e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     2.542e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     2.565e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    2.532e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    2.328e+03|
 6.000e+00   12    2.543e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    2.534e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    2.529e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.500e+00   15    2.535e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.000e+00   16    2.508e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 8.500e+00   17    2.504e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.000e+00   18    2.473e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 9.500e+00   19    2.457e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+01   20    2.585e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.050e+01   21    2.524e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.100e+01   22    2.473e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.150e+01   23    2.490e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.200e+01   24    2.425e+03|XXXXXXXXXXXXXXXXXXX
 1.250e+01   25    2.500e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.300e+01   26    2.576e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.350e+01   27    2.448e+03|XXXXXXXXXXXXXXXXXXXXXXX
 1.400e+01   28    2.483e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    2.581e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    2.447e+03|XXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    2.555e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    2.585e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.650e+01   33    2.431e+03|XXXXXXXXXXXXXXXXXXXX
 1.700e+01   34    2.480e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.750e+01   35    2.549e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   36    2.429e+03|XXXXXXXXXXXXXXXXXXXX
 1.850e+01   37    2.494e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   38    2.541e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.950e+01   39    2.391e+03|XXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :     100000 TOTAL C. :  1.000e+05 NEQUIVAL :  1.000e+05
 MEAN F.T.:  9.991e+00 MEAN B.C.:  9.991e+00 UNDERFLOW:  0.000e+00
 RMS F.T. :  5.766e+00 RMS B.C. :  5.764e+00 OVERFLOW :  0.000e+00

TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN NUMBER : 40
BIN WIDTH  : 5.000e-01

                           0.00e+00                        1.40e+04 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     1.330e+02|
 5.000e-01   1     3.590e+02|X
 1.000e+00   2     8.710e+02|XXX
 1.500e+00   3     1.676e+03|XXXXXX
 2.000e+00   4     2.812e+03|XXXXXXXXXX
 2.500e+00   5     4.732e+03|XXXXXXXXXXXXXXXXX
 3.000e+00   6     6.835e+03|XXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     9.271e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     1.117e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     1.214e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    1.237e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    1.106e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   12    9.104e+03|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    6.935e+03|XXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    4.599e+03|XXXXXXXXXXXXXXXX
 7.500e+00   15    2.897e+03|XXXXXXXXXX
 8.000e+00   16    1.532e+03|XXXXX
 8.500e+00   17    8.560e+02|XXX
 9.000e+00   18    3.230e+02|X
 9.500e+00   19    1.440e+02|
 1.000e+01   20    5.700e+01|
 1.050e+01   21    2.000e+01|
 1.100e+01   22    5.000e+00|
 1.150e+01   23    2.000e+00|
 1.200e+01   24    1.500e+00|
 1.250e+01   25    4.650e+01|
 1.300e+01   26    3.340e+02|X
 1.350e+01   27    1.751e+03|XXXXXX
 1.400e+01   28    5.794e+03|XXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    1.140e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    1.403e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    1.039e+04|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    4.743e+03|XXXXXXXXXXXXXXXXX
 1.650e+01   33    1.270e+03|XXXX
 1.700e+01   34    2.105e+02|
 1.750e+01   35    2.300e+01|
 1.800e+01   36    2.000e+00|
 1.850e+01   37    0.000e+00|
 1.900e+01   38    0.000e+00|
 1.950e+01   39    0.000e+00|
                          X |
                            V
 ENTRIES  :     200000 TOTAL C. :  1.500e+05 NEQUIVAL :  1.800e+05
 MEAN F.T.:  8.394e+00 MEAN B.C.:  8.394e+00 UNDERFLOW:  9.100e+01
 RMS F.T. :  5.001e+00 RMS B.C. :  4.998e+00 OVERFLOW :  0.000e+00

Graphical Histogram Printout of xhist2 after operations
TYPE       : Histo1D
TITLE      :  Random Numbers 
BIN NUMBER : 40
BIN WIDTH  : 5.000e-01

                           9.56e-01                        6.59e+00 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     1.058e+00|
 5.000e-01   1     1.140e+00|X
 1.000e+00   2     1.322e+00|XXX
 1.500e+00   3     1.685e+00|XXXXXX
 2.000e+00   4     2.129e+00|XXXXXXXXXX
 2.500e+00   5     2.887e+00|XXXXXXXXXXXXXXXXX
 3.000e+00   6     3.713e+00|XXXXXXXXXXXXXXXXXXXXXXXX
 3.500e+00   7     4.727e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   8     5.486e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 4.500e+00   9     5.882e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+00   10    5.960e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.500e+00   11    5.357e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+00   12    4.659e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.500e+00   13    3.788e+00|XXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+00   14    2.851e+00|XXXXXXXXXXXXXXXXX
 7.500e+00   15    2.173e+00|XXXXXXXXXXX
 8.000e+00   16    1.616e+00|XXXXX
 8.500e+00   17    1.344e+00|XXX
 9.000e+00   18    1.118e+00|X
 9.500e+00   19    1.040e+00|
 1.000e+01   20    1.057e+00|
 1.050e+01   21    1.018e+00|
 1.100e+01   22    9.912e-01|
 1.150e+01   23    9.968e-01|
 1.200e+01   24    9.706e-01|
 1.250e+01   25    1.019e+00|
 1.300e+01   26    1.164e+00|X
 1.350e+01   27    1.680e+00|XXXXXX
 1.400e+01   28    3.311e+00|XXXXXXXXXXXXXXXXXXXXX
 1.450e+01   29    5.593e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.500e+01   30    6.590e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.550e+01   31    5.179e+00|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.600e+01   32    2.931e+00|XXXXXXXXXXXXXXXXX
 1.650e+01   33    1.480e+00|XXXX
 1.700e+01   34    1.076e+00|X
 1.750e+01   35    1.029e+00|
 1.800e+01   36    9.724e-01|
 1.850e+01   37    9.976e-01|
 1.900e+01   38    1.016e+00|
 1.950e+01   39    9.564e-01|
                          X |
                            V
 ENTRIES  :     200000 TOTAL C. :  1.500e+05 NEQUIVAL :  1.800e+05
 MEAN F.T.:  8.394e+00 MEAN B.C.:  6.022e-03 UNDERFLOW:  3.640e-02
 RMS F.T. :  5.001e+00 RMS B.C. :  2.713e-01 OVERFLOW :  0.000e+00
</PRE>

<H3><A NAME="Stream-IO">Stream input/output</A></H3>

<P>In parallel to persistent storage provided with &OBJ;,
there is the possibility to use C++ based Standard Stream IO for
histograms. In particular, this feature lets you save histograms to a
file and retrieve them back. There exist two specialised
<EM>stream</EM> classes: 
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#HistInputStream">
!!HTML!!<EM>HistInputStream</EM></A> and
!!TEX!!<EM>HistInputStream</EM> and
!!TEX!!\index{histinputstream@{\texttt{HistInputStream}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histinputstream@{\texttt{HistInputStream}}}%
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/histoo/classref.html#HistOutputStream">
!!HTML!!<EM>HistOutputStream</EM></A>.
!!TEX!!<EM>HistOutputStream</EM>.
!!TEX!!\index{histoutputstream@{\texttt{HistOutputStream}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histoutputstream@{\texttt{HistOutputStream}}}%
Let us look how to use them.</P>

<P>
After getting an database handle <TT>myDB</TT> in the usual way, let
us assume that we have created two histograms which are referenced by
handles <TT>hist1</TT> and <TT>hist2</TT>. We decide to save them in
the file <TT>simple_test.txt</TT>.
</P>

<PRE>
  HepRef(Histogram) hist1 = new(myDB) Histo1D("test",10,0.0,20.0);
  HepRef(Histo1D) hist2 = new(myDB) Histo1D("test",20,-10.0,10.0);
</PRE>

<P>
First, we have to create an <TT>HistOutputStream</TT>
!!TEX!!\index{histoutputstream@{\texttt{HistOutputStream}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histoutputstream@{\texttt{HistOutputStream}}}%
object, which is to open our file <TT>simple_test.txt</TT> in output
mode, so that we can save the histograms using the class instance
<TT>hos</TT> in the code below.  Note that by enclosing everything
inside a compound statement, which is exited by the closing brace, the
output file is automatically closed (since <TT>hos</TT> is going out
of scope).
</P>

<PRE>
 {
     HistOutputStream hos("simple_test.txt");

   /* We save histograms in 'hos' */

     if( !hos.write(*hist1) ) error();
     if( !hos.write(*hist2) ) error();
 }
</PRE>

<P>
Next, when we want to retrieve histograms from the file
<TT>simple_test.txt</TT>, we should first create an <TT>HistInputStream</TT>
!!TEX!!\index{histinputstream@{\texttt{HistInputStream}} class (HistOOgram)}%
!!TEX!!\index{HistOOgram!classes!histinputstream@{\texttt{HistInputStream}}}%
object. This opens the file <TT>simple_test.txt</TT> in input mode.
The histograms will be written into &OBJ;'s persistent storage
using the database whose handle was obtained before.
</P>

<PRE>
 {
    HistInputStream his("simple_test.txt");

    HepRef(Histogram) hist3 = his.read_new();
    HepRef(Histogram) hist4 = his.read_new();

    if( !hist3 || !hist4 ) error();
 }
</PRE>

<!--
<P>In the previous examples Histogram Stream objects are creating and
destroy file streams (ifstream,ofstream) automatically. However, in 
some cases we may want to use already existing streams, which in general 
do not need to be file streams. Let us look at an example:</P>

<PRE>
  fstream *my_sp = new fstream("simple_test.txt",ios::in|ios::out);

  HistInputStream his(*my_sp,myDB);
  HistOutputStream hos(*my_sp,myDB);

  /* now both Histogram Streams use the same C++ stream for input/output

     ...

  /* you can use any kind of stream, even 'cout' */

  ostrstream my_memory_stream(buffer);
  HistOutputStream hos2(my_memory_stream);

  HistOutputStream hos3(cout);

  delete my_sp;
</PRE>

<P>The last line above is needed since it is our responsibility to 
destroy streams we created. Therefore, in this case we must explicitly
delete <TT>my_sp</TT>, because it is a dynamic object, 
while we need to do nothing for <TT>my_memory_stream</TT>, which
is an automatic object and will thus be deleted automatically.
Similarly, <TT>cout</TT> is a global object and
is automatically deleted when the program terminates.</P>
-->

<P>
We now are ready to look at a complete example. To simplify the code
we will either read 1D histograms from an &OBJ; database (the
generalisation to other histogram kinds is trivial) and save in a text
file, or alternatively, read all histograms stored in a text file
and save them into an &OBJ; database.
</P>

<PRE>
/* ioHistos.cpp */
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"
#include &lt;fstream.h&gt;
#include &lt;iostream.h&gt;
#include &lt;ctype.h&gt;

class createHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
public:
  // this application implements just one method: run the 
  int run()
  {
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    char opt;

    cout &lt;&lt; endl &lt;&lt; "db to file (D) or File -&gt; db (F)?" &lt;&lt; " &gt; ";
    cin  &gt;&gt; opt;
    if (opt!='D'&amp;&amp;opt!='F') return 0;

    char dbname[255];

    cout &lt;&lt; endl &lt;&lt; "Please type database name "        &lt;&lt; " &gt; ";
    cin  &gt;&gt; dbname;

    HepDatabaseRef  myDb = db(dbname); //create or open db "HistoDB"
    HistInputStream::oo_clustering_dir = myDb;

    char fname[255];

    cout &lt;&lt; endl &lt;&lt; "Please type filename "             &lt;&lt; " &gt; ";
    cin  &gt;&gt; fname;

    cout &lt;&lt; endl &lt;&lt; "Federated DB boot: " &lt;&lt; getenv("OO_FD_BOOT");
    cout &lt;&lt; endl &lt;&lt; "Database name    : " &lt;&lt; dbname;
    cout &lt;&lt; endl &lt;&lt; "Filename         : " &lt;&lt; fname;
    cout &lt;&lt; endl;

    HistPrintout printfile(cout);

    switch(opt)
    {
      case 'D' : // save histograms from database to file
      {
        HistOutputStream hos(fname);
        ooItr(Histo1D) histI;    // declare iterator over 1D histograms
        
        if( histI.scan(myDb) != oocSuccess ) cerr &lt;&lt; "Iterator::scan failed";
          else
            while(histI.next())  // iterate over 1D histograms in db
            {
              HepRef(Histo1D) hist = histI;
              printfile.print(*hist);
              if(hos.write(*hist))
              { 
   	      cout &lt;&lt; endl &lt;&lt; "Success - histogram " &lt;&lt; hist-&gt;get_name() 
                           &lt;&lt; " written on file "    &lt;&lt; endl;
              }
            else	  
                cout &lt;&lt; "Saving Error!";
            }                    // end of while, end of if
        break;                   // break out of case 
      }                          // end fo case 'D'
      case 'F' :                 // save histograms from file to database
      { 
        HistInputStream  his(fname);
        HepRef(Histogram) hist;
        while (1)                // loop "forever"
        {
          hist = his.read_new();  
          cout &lt;&lt; endl;
          if(hist == 0) break;       // no more histograms or read error on file
            else
            {
              cout &lt;&lt; "Success - histogram " &lt;&lt; hist-&gt;get_name() 
                   &lt;&lt; " read from file "     &lt;&lt; endl &lt;&lt; endl;
              printfile.print(*hist);
            }                    // end of if 
        }                        // end of while
        break;                   // break out of case 
      }                          // end of case 'F'
    }                            // end fo switch
/*  -----End of histogram manipulation--------------------------------- */
    
    commit();                    // commit this transaction
    return 0;
  }
  
};  // end of class definition

int main()
{
  createHistoApp myApp;  // create an application object
  return myApp.run();    // call its run method
}
</PRE>
<P>
The above program has two modes of operation, namely <TT>D</TT> to
save all one-dimensional histograms read in an &OBJ; database into a
text file, and <TT>F</TT> to do the reverse, namely, read all
histograms saved in a text file and save commit them to an &OBJ;
database. The user is first asked to choose the mode, and is then
invited to provide the names of the database and the text file.
</P>

<P>Below we show the first step, where we save all
one-dimensional histograms from the database <TT>HistoDB</TT> to the
text file <TT>histo1d.txt</TT>. We in fact used the single histogram
saved in the
!!TEX!!example in Section~\ref{HIST1DEXA} on page \pageref{HIST1DEXA}.
!!HTML!!<A HREF="#HIST1DEXA">example here</A>.
We print the histogram to compare it with the one we will read back
afterwards from the text file.</P>
<PRE>
db to file (D) or File -> db (F)?
 > <EM>D</EM>
Please type database name 
 > <EM>HistoDB</EM>
Please type filename 
 > <EM>histo1d.txt</EM>

Federated DB boot: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Database name    : HistoDB
Filename         : histo1d.txt
TYPE       : Histo1D
TITLE      : Test_Histo1D
BIN NUMBER : 20
BIN WIDTH  : 1
                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  2.162e+06 NEQUIVAL :  2.961e+04
 MEAN F.T.:  9.498e+00 MEAN B.C.:  7.618e+00 UNDERFLOW:  2.574e+05
 RMS F.T. :  8.368e+00 RMS B.C. :  6.936e+00 OVERFLOW :  2.573e+05

Success - histogram Test_Histo1D written on file 
</PRE>

<P>
Now that we saved the 1D histogram on the text file
<TT>histo1d.txt</TT> we want to read it back and save it
into another database <TT>MyDB</TT>. We therefore rerun the
same program, specifying this time the <TT>F</TT> option. 
</P>

<PRE>
db to file (D) or File -> db (F)?
 > <EM>F</EM>
Please type database name 
 > <EM>MyDB</EM>
Please type filename 
 > <EM>histo1d.txt</EM>

Federated DB boot: /afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Database name    : HistoDB
Filename         : histo1d.txt

Success - histogram Test_Histo1D read from file 
TYPE       : Histo1D
TITLE      : Test_Histo1D
BIN NUMBER : 20
BIN WIDTH  : 1
                           7.39e+03                        2.12e+05 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.120e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.347e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.029e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     7.558e+04|XXXXXXXXXXXXXXXXX
 5.000e+00   5     5.285e+04|XXXXXXXXXXX
 6.000e+00   6     3.466e+04|XXXXXX
 7.000e+00   7     2.103e+04|XXX
 8.000e+00   8     1.193e+04|X
 9.000e+00   9     7.387e+03|
 1.000e+01   10    7.387e+03|
 1.100e+01   11    1.193e+04|X
 1.200e+01   12    2.103e+04|XXX
 1.300e+01   13    3.466e+04|XXXXXX
 1.400e+01   14    5.285e+04|XXXXXXXXXXX
 1.500e+01   15    7.554e+04|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.028e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.346e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    1.710e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.119e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                          X |
                            V
 ENTRIES  :      50000 TOTAL C. :  2.162e+06 NEQUIVAL :  2.961e+04
 MEAN F.T.:  9.498e+00 MEAN B.C.:  7.618e+00 UNDERFLOW:  2.574e+05
 RMS F.T. :  8.368e+00 RMS B.C. :  6.936e+00 OVERFLOW :  2.573e+05
</PRE>

<P>
From the printout of the histogram we see that we retrieved the
histogram from the text file without problems.
</P>

<H3>Reading back and deleting histograms from an &OBJ;</H3>

<P>
Histograms produced in a C++ program are automatically stored in the
current federated database and the programmer can specify exactly in
which database or container the object will be created. If the user
knows where the histograms were created, reading them back is pretty
simple by taking advantage of &OBJ;'s scan methods. The purpose of the
scan method is to iterate over all objects of a given class in a
well-defined scope. The scope defines the extent of the search. It can
include the whole federated database, a particular database, or a
specific container (of course larger scopes imply a longer search).
</P>
<P>The <TT>readHistogram</TT> example below shows you how to retrieve
a specific histogram by specifying its title and the name of the
container where it is stored. The program consists of three parts. Its
first part creates three histograms with different titles in the same
container and fills them with a different contents. The second part
opens a new transaction, scans the container for all histograms of the
given type, and compares the histogram title to select only the second
histogram, which is finally printed on the output stream. The third
part removes the objects created in part one from the database. It
shows how the scan method can be used to remove objects of a given
class from the chosen scope.
</P>

<P>
It is important to realize that histograms are written, read back, and
deleted in separate transactions. This means that the three parts of
the code shown can be run as independent programs.
</P>

<H4>Example code</H4>
<PRE>
#include "histograms.h"
#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;
#include "HepODBMS/clustering/HepDbApplication.h"

class readHistoApp : public HepDbApplication {
  // Application inherits session control from HepDbApplication
private :
  HepDatabaseRef  histoDb;
  HepContainerRef histoCont;
protected:
  void create() {
    const int noOfBins=20;
    histoDb = db("HistoDB"); //create or reuse a db 
    histoCont = container("HistoCont"); //create or reuse a container
    // Create three histograms with different names
    cout &lt;&lt; "Create histogram no. 1" &lt;&lt; endl;
    HepRef(Histo1D) h1 = new(histoCont) Histo1D("Histo 1",noOfBins,0.0,20.0);
    cout &lt;&lt; "Create histogram no. 2" &lt;&lt; endl;
    HepRef(Histo1D) h2 = new(histoCont) Histo1D("Histo 2",noOfBins,0.0,20.0);
    cout &lt;&lt; "Create histogram no. 3" &lt;&lt; endl;
    HepRef(Histo1D) h3 = new(histoCont) Histo1D("Histo 3",noOfBins,0.0,20.0);
    // Histos are filled with different weights
    for( int i = 0; i &lt; 50000; i++) {   
      double x = (i % 22) - 1;          
      h1-&gt;fill(x,(x-9.5)*(x-9.5)+3);
      h2-&gt;fill(x,(x-9.5)*(x-9.5)+30);
      h3-&gt;fill(x,(x-9.5)*(x-9.5)+300);      
    }
  }

  // Read back an histogram from the database
  void read() {
    // Declare an iterator over 1D histograms
    ooItr(Histo1D)  histo1D_itr;
    // Retrieve by name the Database &amp; the Container
    histoDb = db("HistoDB"); 
    histoCont = container("HistoCont"); 
    // Apply the iterator over our container
    histo1D_itr.scan(histoCont);
    for(int i = 1;histo1D_itr.next();i++){ 
      // Just look for histogram no. 2
      if (strcmp(histo1D_itr-&gt;get_name(),"Histo 2") == 0) {
	// Print it
	cout &lt;&lt; histo1D_itr-&gt;get_name() &lt;&lt; " found!" &lt;&lt; endl &lt;&lt; endl;
	HistPrintout p(cout);
	p.print(*histo1D_itr);    
	cout &lt;&lt; endl;
      }
    }
  }

  void cleanup() {
    // Declare an iterator over 1D histograms
    ooItr(Histo1D)  histo1D_itr;
    // Retrieve by name the Database &amp; the Container
    histoDb = db("HistoDB"); 
    histoCont = container("HistoCont"); 
    // Apply the iterator over our container
    histo1D_itr.scan(histoCont);
    for(int i = 1;histo1D_itr.next();i++){ 
      HepRef(Histo1D) h;
      histo1D_itr-&gt;ooThis( h );
      cout &lt;&lt; "Delete histogram no. " &lt;&lt; i &lt;&lt; endl;
      ooDelete( h );
    }
  }
</PRE>

<P>Transaction management and histogram creation have already been
explained in previous sections, so the interesting part of the code
corresponds to the <TT>read</TT> and <TT>cleanup</TT> methods. Both
methods declare an iterator over objects of type <TT>Histo1D</TT>,
locate the container, and apply the iterator over the container.
</P>

<PRE>
    // Declare an iterator over 1D histograms
    ooItr(Histo1D)  histo1D_itr;
    // Retrieve by name the Database &amp; the Container
    histoDb = db("HistoDB"); 
    histoCont = container("HistoCont"); 
    // Apply the iterator over our container
    histo1D_itr.scan(histoCont);
    for(int i = 1;histo1D_itr.next();i++){ 
    ... 
    }
</PRE>
<P>An iterator over 2D histograms is declared as follows.</P>
<PRE>
    // Declare an iterator over 2D histograms
    ooItr(Histo2D) histo2D_itr;
</PRE>
<P>An iterator over a whole database rather than over single
 container should use the database handle.</P>
<PRE>
     // Apply the iterator over our Database
     histo1D_itr.scan(histoDb);
</PRE>
<P>The output of running the program is shown below.</P>
<PRE>
Create histogram no. 1
Create histogram no. 2
Create histogram no. 3
Histo 2 found!

TYPE       : Histo1D
TITLE      : Histo 2
BIN NUMBER : 20
BIN WIDTH  : 1

                           6.88e+04                        2.73e+05 Y
X POSITION   BIN       VALUE|---------------------------------------------------&gt;
 0.000e+00   0     2.733e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.000e+00   1     2.324e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 2.000e+00   2     1.960e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3.000e+00   3     1.642e+05|XXXXXXXXXXXXXXXXXXXXXXX
 4.000e+00   4     1.369e+05|XXXXXXXXXXXXXXXXX
 5.000e+00   5     1.142e+05|XXXXXXXXXXX
 6.000e+00   6     9.603e+04|XXXXXX
 7.000e+00   7     8.240e+04|XXX
 8.000e+00   8     7.330e+04|X
 9.000e+00   9     6.876e+04|
 1.000e+01   10    6.876e+04|
 1.100e+01   11    7.330e+04|X
 1.200e+01   12    8.240e+04|XXX
 1.300e+01   13    9.603e+04|XXXXXX
 1.400e+01   14    1.142e+05|XXXXXXXXXXX
 1.500e+01   15    1.369e+05|XXXXXXXXXXXXXXXX
 1.600e+01   16    1.642e+05|XXXXXXXXXXXXXXXXXXXXXXX
 1.700e+01   17    1.960e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.800e+01   18    2.323e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 1.900e+01   19    2.732e+05|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                         X |
                           V
 ENTRIES  :      50000 TOTAL C. :  2.875e+06 NEQUIVAL :  3.728e+04
 MEAN F.T.:  9.499e+00 MEAN B.C.:  9.999e+00 UNDERFLOW:  3.188e+05
 RMS F.T. :  6.865e+00 RMS B.C. :  6.865e+00 OVERFLOW :  3.186e+05

Delete histogram no. 1
Delete histogram no. 2
Delete histogram no. 3
</PRE>

<H2>Converting an HBOOK file into an &OBJ; database</H2>
!!TEX!!\index{HBOOK}%

<P>The program <TT>Hbook2Objy</TT>
<!--/afs/cern.ch/sw/lhcxx/specific/@sys/HEP_Explorer/3.9/bin/-->
converts histograms contained in an HBOOK file into persistent
<EM>HistOOgrams</EM> that can be saved in an &OBJ; database. Only one-
and two-dimensional histograms are converted, Ntuples are ignored. To
execute the program you should type:</P>

<PRE>
Hbook2Objy &lt;hfile> &lt;OBJ-federated-DB>
</PRE>

<P>
Starting from the histograms in the HBOOK file <TT>&lt;hfile></TT>
the program will create a new database with as name the name of the
HBOOK file <TT>&lt;hfile></TT> inside the &OBJ; database pointed at by
the environment variable <TT>OO_FD_BOOT</TT>.  If <TT>&lt;hfile></TT>
already exists, then you will be asked whether you want to overwrite 
the original file.
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
</P>

<P>It should be noted that the hierarchical (directory) structure of
the HBOOK file is not preserved. Nevertheless, since the name of each
created persistent histogram corresponds to the full path name inside
the HBOOK hierarchy, it is easy to distinguish between histograms with
the same name but coming from different HBOOK directories.  An example
of the translation of a set of HBOOK histograms is shown 
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="H2OPaw.gif"></P>
!!HTML!!<P><IMG SRC="H2OHistOOReader.gif"></P>
!!TEX!!in Figure \ref{PAW2HISTOO}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\begin{center}
!!TEX!!\includegraphics[width=.8\linewidth]{H2OPaw.eps}\\[2mm]
!!TEX!!\includegraphics[width=.8\linewidth]{H2OHistOOReader.eps}
!!TEX!!\end{center}
!!TEX!!\caption[Transforming HBOOK histograms into HistOO
!!TEX!!         histograms]{Transforming HBOOK histograms into HistOO
!!TEX!!         histograms.
!!TEX!!\index{HBOOK}%
<P>
!!TEX!!\small
At the top we see some (1D and 2D) histograms with the HBOOK Directory
Browser, and at the bottom the same histograms after conversion as
viewed from the &OBJ; database with the <EM>HistOOgramReader</EM> module.</P>
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!TEX!!}\label{PAW2HISTOO}
!!TEX!!\end{figure}
!!TEX!!\clearpage

<H2>The tag classes</H2>
!!TEX!!\index{Tag|(}%

<H3>Explaining the environment</H3>

<P>The following <TT>gmake</TT> file supposes the &OBJ; database and
IRIS Explorer path and environment variables have been set up for
the current session.</P>

<PRE>
# GNUmakefile for createTag example
# Dirk Duellmann

HEP_ODBMS_DIR=/afs/cern.ch/sw/lhcxx/specific/@sys/HepODBMS/development
include $(HEP_ODBMS_DIR)/etc/HepODBMS.mk

APPL       = createTag
SRCS       = $(APPL).cpp 
OBJS	   = $(OS)/$(APPL).o

all : $(APPL)

$(APPL): GNUmakefile
	$(C++) $(C_FLAGS) -o $(APPL) $(OBJS) $(HEP_ODBMS_LIBS) $(OBJY_LIBS) $(RWTOOL_LIBS)
</PRE>

<H3>Writing tags</H3>

<P>As explained 
!!HTML!!<A HREF="#NEWDATAMODEL">earlier</A>,
!!TEX!!earlier (see Section \ref{SNEWDATAMODEL}),
tags are a small collection of the most important physics attributes
of an event plus an association with the event in question.  Tags
!!TEX!!\index{Event association}%
provide a natural and efficient syntax for handling event data,
speeding up queries, cuts handling, etc., substantially, while at the
same time offering the possibility to easily access the original full
data. Usually, the event tags are chosen in such a way that a high
degree of selectivity can be obtained by first cutting on attributes
in the event tag, while, if needed, the association to the full event
!!TEX!!\index{Event association}%
can be exploited in order to retrieve any other information not
contained in the tag.</P>

<P>In workgroup-wide data sets, individual physicists should still be
able to have their own simpler data collection, so an easy-to-use
<EM>Generic Tag</EM> is defined as well.  Presently, both the Event Tag 
!!TEX!!\index{Tag!generic}%
and the Generic Tag have to be created inside a C++ program before using
the Interactive Analysis framework.</P>




<P>
The data types that can be stored in a tag are <tt>long</tt> and
<tt>short</tt> integers, <tt>float</tt> and <tt>double</tt> real
numbers, and an 8-bit <tt>char</tt>. These types are recognised by the
<EM>HepExplorableBrowser</EM> module
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
!!TEX!!(see Figure \ref{HEPEXPBROWSER})
which lets you browse and select explorable collections and their tags.
!!TEX!!\index{Explorable collection}%
</P>

<PRE>
/* createTag.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepExplorableGenericTags.h"
#include "HepODBMS/tagdb/HepExplorableAttribute.h"
#include &lt;math.h>

class createTagsApp : public HepTagDbApplication {
  // inherits session control from HepTagDbApplication
public:
  // this application implements just one method: 
  int run()
  {
    const long   maxEvents = 1000;
    
    Init();        // initialise the db session
    startUpdate(); // start an update transaction

    HepExplorableGenericTags genTag; // create a tag collection

    if (!genTag.createDescription("generator tag")) // start creating a new field description
      fatal("could not create new generator tag");  // print the message and stop the application

    // define fields all fields that belong to genTag
    HepExplorableAttribute&lt;long>  eventNo (genTag,"event_number");    
    
    /* particle 1*/
    HepExplorableAttribute&lt;float> et1 (genTag,"Et_part1");    
    HepExplorableAttribute&lt;float> phi1(genTag,"phi_part1");
    HepExplorableAttribute&lt;short> pid1(genTag,"pdg_part1");    
    
    /* particle 2*/
    HepExplorableAttribute&lt;float> et2 (genTag,"Et_part2");
    HepExplorableAttribute&lt;float> phi2(genTag,"phi_part2");
    HepExplorableAttribute&lt;short> pid2(genTag,"pdg_part2");        

    cout << endl;
    // Fill 1000 tags
    for (short i=0; i&lt;maxEvents; i++)
    {
      genTag.newTag();      // create a new tag (all fields have default values)

      if (! (i % 100))      cout << "\revent " << i << flush;
      
      eventNo = i;          // set the event number field
      et1 = i * 5.0;        // calculate some quantity
      et2 = sqrt(et1);      // re-use one field to define another

      phi1 =  (i * 2 * M_PI) / maxEvents; // invent some phi value
      phi2 = -phi1;                // balance the directions

      pid1 = (short) 22;           // both particles are photons 
      pid2 = (short) 22;
    }
    cout << "\r" << eventNo+1 << " events written." << endl;
    // commit this transaction
    commit();
    return 0;
  }
  
};

int main()
{
  createTagsApp myApp;  // create an application object
  return myApp.run();   // run it
}
</PRE>
!!TEX!!\index{Tag!generic}%
!!TEX!!\index{newtag@{\texttt{newtag}} method (Generic tag)}%
!!TEX!!\index{Tag!generic!newtag@{\texttt{newtag}} method}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startupdate@{\texttt{startUpdate}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startupdate@{\texttt{startUpdate}}}%

<P>When you compile and run this program then you will see the
following output on your screen.
<PRE>
> createTag 
created new ContainerGroup for class "EventTags" ClusteringHint
created new ContainerGroup for class "PersistentEventCollections" ClusteringHint
created new ContainerGroup for class "Events" ClusteringHint
created new ContainerGroup for class "generator tag" ClusteringHint

1000 events written.
</PRE>
<P>First the <TT>EventTags</TT>, <TT>PersistentEventCollections</TT>,
<TT>Events</TT>, and <TT>generator tag</TT> are entered as container
groups into the &OBJ; database. Then a Generic tag is created,
consisting of seven components, namely the <TT>event_number</TT>
(integer of type <TT>long</TT>), and two <EM>particles</EM>,
characterised each by their transverse energy and phi angle (two
reals of type <TT>float</TT>, <TT>Et_part1/2</TT> and
<TT>phi_part1/2</TT>), and an identifier (a <TT>short</TT>
integer <TT>pdg_part1/2</TT>).</P>

<P>Before reading back the tags in the next example program, we can
have a look into the database with the <TT>ootoolmgr</TT> program (see
!!TEX!!Figure \ref{OOTOOLMGRTAG}).<BR>
!!TEX!!\begin{figure}
!!TEX!!\centering\includegraphics[width=.8\linewidth]{ootoolmgrtag.eps}
!!TEX!!\caption{Using the program \texttt{ootoolmgr} to view tags in a
!!TEX!!  database}\label{OOTOOLMGRTAG}
!!TEX!!\index{ootoolmgr@{\ttfamily ootoolmgr}}
!!TEX!!\end{figure}
!!HTML!!the figure below).</P>
!!HTML!!<P><IMG SRC="./ootoolmgrtag.gif"></P>
<P>We look in the <TT>Events</TT> database, inside the <TT>generator
tag</TT> container and go to the last stored <EM>Basic Object</EM>.
Then in the bottom window we can see the contents of the seven tag
components, in particular we find the only <TT>int32</TT> component
(<TT>event_number</TT>) has indeed a value of 999. The two
<TT>int16</TT> components (<TT>pdg_part1/2</TT>) are both 22, while
the four <TT>float32</TT> components have the values
<TT>Et_part1=4995</TT>, <TT>phi_part1=6.2769</TT>, 
<TT>Et_part2=70.6753</TT> and <TT>phi_part2=-6.2769</TT>. This
general-purpose &OBJ; tool does not show the names of the variables
(for this a HEPExplorer module should be used), but one can still
understand in this simple case the contents of the object in the
database and the C++ code used to generate it.
</P>
<P>
The same three databases <TT>System</TT>, <TT>Tag</TT>, and
<TT>Events</TT> can also be seen with the <TT>oodumpcatalog</TT> tool.
!!TEX!!\index{oodumpcatalog@{\ttfamily oodumpcatalog}}\index{&OBJ;}%
</P>
<PRE>
> oodumpcatalog

Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.

FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16

DB Name   = System
DB ID     = 17
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/System.HEPEXP.DB

DB Name   = Tag
DB ID     = 20
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/Tag.HEPEXP.DB

DB Name   = Events
DB ID     = 21
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/Events.HEPEXP.DB
</PRE>

<H3>Reading tags</H3>

<P>Once we have written the tag, let us show how to read and use
it. Therefore let us look at the following example.</P>

<PRE>
/* readTag.cpp */
#include "HepODBMS/tagdb/HepTagDbApplication.h"
#include "HepODBMS/tagdb/HepExplorable.h"
#include "HepODBMS/tagdb/HepExplorableAttribute.h"
#include "histograms.h"
#include "HepODBMS/clustering/HepDbApplication.h"

class readTagsApp : public HepTagDbApplication {
  // inherits session control from HepTagDbApplication
public:
  // this application implements just one method: 
  int run()
  {
    Init();        // initialise the db session
    startRead();   // start a read transaction

    HepExplorable *genTag =
      HepExplorable::findExplorable("generator tag"); // find a tag by name

    if (!genTag)
      fatal("could not find generator tag!"); // use fatalmethod defined on HepDbApplication
        
    // define fields all fields that belong to genTag
    HepExplorableAttribute&lt;long>  eventNo (genTag,"event_number");    
    
    /* particle 1*/
    HepExplorableAttribute&lt;float> et1 (genTag,"Et_part1");    
    HepExplorableAttribute&lt;float> phi1(genTag,"phi_part1");
    HepExplorableAttribute&lt;short> pid1(genTag,"pdg_part1");    
    
    /* particle 2*/
    HepExplorableAttribute&lt;float> et2 (genTag,"Et_part2");
    HepExplorableAttribute&lt;float> phi2(genTag,"phi_part2");
    HepExplorableAttribute&lt;short> pid2(genTag,"pdg_part2");        

    HepDatabaseRef  histoDb = db("HistoDB"); // go to DB HistoDB
    HepRef(Histo1D) xhist = new(histoDb) Histo1D(" Et1 and Et2 ",8,0.0,80.0);

    // print a few tag values and histogram Et1 and Et2
    for (int rc=genTag->start(); rc != 0; rc = genTag->next())
    {
          xhist->fill(et1,1.);
          xhist->fill(et2,1.);
	  if ((eventNo<2)||(eventNo>997)) //print first and last two events
          { cout << "Event No. " << eventNo << endl
                 << "Particle 1: Et=" << et1 << " phi=" << phi1 
                                      << " pgd code= " << pid1 << endl
                 << "Particle 2: Et=" << et2 << " phi=" << phi2 
                                      << " pgd code= " << pid2 << endl;
	  }
    }
    HistPrintout p(cout);
    p.print(*xhist);

    commit();        // commit this transaction
    return 0;
  }
  
};

int main()
{
  readTagsApp myApp;   // create an application object
  return myApp.run(); // run it
}
</PRE>
!!TEX!!\index{Tag!generic}%
!!TEX!!!!TEX!!\index{fill@{\texttt{fill}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!fill@{\texttt{fill}}}%
!!TEX!!\index{print@{\texttt{print}} method (HistOOgram)}%
!!TEX!!\index{HistOOgram!methods!print@{\texttt{print}}}%
!!TEX!!\index{commit@{\texttt{commit}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!commit@{\texttt{commit}}}%
!!TEX!!\index{init@{\texttt{Init}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!init@{\texttt{Init}}}%
!!TEX!!\index{startread@{\texttt{startRead}} method (HEPODBMS)}%
!!TEX!!\index{HEPODBMS!methods!startread@{\texttt{startRead}}}%

<P>We recognise the same attribute definitions for the tag elements,
as in the <TT>createTag</TT> program, which allows us to use them in
our code in a convenient way. We then attach the <TT>HistoDB</TT>
database and declare an histogram, which we shall use via its
reference <TT>xhist</TT>. Before then loop over the generic tag
events, using the <TT>next</TT> method of the generic tag class until
the return code <TT>rc</TT> is different from zero. We print out the
parameters of the first and last two events, and enter the <TT>Et1</TT>
and <TT>Et2</TT> values of all events into the <TT>xhist</TT>
histogram. After exiting the loop, the output file for the histogram
is initialised to <TT>cout</TT>, and the histogram <TT>xhist</TT>
is printed on that output stream.</P>

<P>The output generated by the <TT>readTAG</TT> program first shows
 the
parameters of the events o, 1, 998, and 999 (the latter can be
 compared in detail with
!!HTML!!the Figure in the previous section,
!!TEX!!Figure \ref{OOTOOLMGRTAG},
showing the dump of that event in the database).
Then the histogram of <TT>Et1</TT>
and <TT>Et2</TT> is printed, and, as expected, almost half of the
contents are in the overflow bin, since the value of <TT>Et1</TT> was
five times the event number (see the code of <TT>createTag</TT>.
</P>
<PRE>
Event No. 0
Particle 1: Et=0 phi=0 pgd code= 22
Particle 2: Et=0 phi=0 pgd code= 22
Event No. 1
Particle 1: Et=5 phi=0.00628319 pgd code= 22
Particle 2: Et=2.23607 phi=-0.00628319 pgd code= 22
Event No. 998
Particle 1: Et=4990 phi=6.27062 pgd code= 22
Particle 2: Et=70.6399 phi=-6.27062 pgd code= 22
Event No. 999
Particle 1: Et=4995 phi=6.2769 pgd code= 22
Particle 2: Et=70.6753 phi=-6.2769 pgd code= 22
TYPE       : Histo1D
TITLE      :  Et1 and Et2 
BIN NUMBER : 8
BIN WIDTH  : 10

                           2.20e+01                        2.62e+02 Y
X POSITION   BIN       VALUE|--------------------------------------------------->
 0.000e+00   0     2.200e+01|
 1.000e+01   1     6.200e+01|XXXXXXXX
 2.000e+01   2     1.020e+02|XXXXXXXXXXXXXXXXX
 3.000e+01   3     1.420e+02|XXXXXXXXXXXXXXXXXXXXXXXXX
 4.000e+01   4     1.820e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 5.000e+01   5     2.220e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 6.000e+01   6     2.620e+02|XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 7.000e+01   7     2.200e+01|
                          X |
                            V
 ENTRIES  :       2000 TOTAL C. :  2.000e+03 NEQUIVAL :  2.000e+03
 MEAN F.T.:  1.272e+03 MEAN B.C.:  2.382e+01 UNDERFLOW:  0.000e+00
 RMS F.T. :  1.595e+03 RMS B.C. :  2.037e+01 OVERFLOW :  9.840e+02
</PRE>

<P>Now that we are finished with our tags, we can decide to delete
them from our federated database. Therefore, we can issue the
!!TEX!!\index{Federated database}\index{Database}%
!!TEX!!\index{&OBJ;}%
<TT>oodeletedb</TT> command. However, you should be careful not to
!!TEX!!\index{oodeletedb@{\ttfamily oodeletedb}}
delete still useful information, so it is probably good practice to
save different datasets in separate databases to provide a suffient
level of granularity. In our case we decide
the get rid of the <TT>Tag</TT>, and <TT>Events</TT> databases.
<PRE>
> <EM>oodeletedb -db Tag</EM>

Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.

Are you sure you want to delete the Database?
[Y-N]=> <EM>y</EM>

Deleted the Database "Tag" (ID = 20).

> <EM>oodeletedb -db Events -f</EM>

Objectivity/DB (TM) Delete Database Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1992, 1996. All rights reserved.

Deleted the Database "Events" (ID = 21).

> <EM>oodumpcatalog</EM>

Objectivity/DB (TM) List Database Files Utility, Version 4.0.2
Copyright (c) Objectivity, Inc 1990, 1996. All rights reserved.

FD Name   = HEPEXP
FD ID     = 30500
FD File   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP.FDDB
Boot File = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/HEPEXP
Jnl Dir   = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer
Lock Host = hpplus16

DB Name   = System
DB ID     = 17
DB Image  = hpplus16::/afs/cern.ch/user/g/goossens/HP-UX/explorer/System.HEPEXP.DB
</PRE>
<P>The first <TT>oodeletetb</TT> command specifies the <TT>Tag</TT>
database, and the program ask for confirmation. In the second
commands, where we specify the <TT>Events</TT> database, we also 
give the <TT>-f</TT> (force) switch, so that <TT>oodeletetb</TT>
deletes de database in question without further query. Finally, we
dump once more the catalog of the database, to see that, indeed,
only the <TT>System</TT> database is still present.</P>
!!TEX!!\index{oodumpcatalog@{\ttfamily oodumpcatalog}}\index{&OBJ;}%
!!TEX!!\index{oodeletedb@{\ttfamily oodeletedb}}\index{&OBJ;}%
!!TEX!!\index{Tag|)}%

<H3>Converting HBOOK Ntuples to &OBJ;</H3>

<P>
The LHC++ environment provides tools to convert existing HBOOK Ntuples
to &OBJ;. 
!!HTML!!Details are available
!!HTML!!<A HREF="http://wwwinfo.cern.ch/asd/lhc++/HepExplorer/ntkit/ntupleconv.html">
!!HTML!!here</A>.
!!TEX!!At the URL 
!!TEX!!\url{http://wwwinfo.cern.ch/asd/lhc++/HepExplorer/ntkit/ntupleconv.html}.
!!TEX!!you can find more details.

<!--filename=HEPExplorerModules.html-->
<H1><A NAME="H1HEPExplorerModules">HEPExplorer Modules</A></H1>
!!TEX!!\index{IRIS Explorer|(}%
!!TEX!!\index{HEPExplorer|(}%

<H2>Starting IRIS Explorer</H2>

<P>The environment variables needed to run the IRIS Explorer
components and get access to the relevant libraries and auxiliary
files have been setup on the central systems at CERN. Moreover, since
the HEP components use the &OBJ; database, you should have been
registered by your experiment for using that database (see the
previous chapter to find out how to handle &OBJ; database files).</P>

<P>Once your environment is set correctly, you can start up IRIS
Explorer by just typing <TT>explorer</TT>. You should then get a layout of
windows on your workstation as shown in
!!TEX!!Figure \ref{IRISEXPLORER}.<BR>
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="irisexplorer.gif"></P>
!!TEX!!\begin{figure}[h]
!!TEX!!\centering\includegraphics[width=.8\linewidth]{irisexplorer.eps}
!!TEX!!\caption{IRIS Explorer startup screen}\label{IRISEXPLORER}
!!TEX!!\end{figure}
<P>
You see three large components on your screen. First, at the left
we have the list of IRIS Explorer modules, the <EM>Librarian</EM>. 
!!TEX!!\index{Librarian@{\emph{Librarian} window}}%
!!TEX!!\index{IRIS Explorer!Librarian@{\emph{Librarian} window}}%
In fact, in the figure we chose to highlight the HEP Explorer
modules, which will be described below. It should be noted that
several tens of IRIS Explorer modules come with the basic system,
and many more can be obtained from various public archives.
</P>

<P>
The larger part of the screen is occupied by the <EM>Map Editor</EM>.
This is where the user builds or modifies maps, connects modules
together, or interacts with the various modules in the map.
!!TEX!!\index{Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
</P>

<P>
Finally, just below the <EM>Map Editor</EM> you have the <EM>Explorer
Log</EM> window, where messages coming from IRIS Explorer modules
are displayed.  
!!TEX!!\index{Explorer Log@{\emph{Explorer Log} window}}%
!!TEX!!\index{IRIS Explorer!Explorer Log@{\emph{Explorer Log} window}}%
</P>

<H3> For first time users of IRIS Explorer  </H3>
 
<P>
If this is the first time that  you are using Iris Explorer (IE), there are
several choices open to you.  You can jump straight into the examples which
follow.  Since the IE interface is intuitive, you will probably learn
your way around quite quickly.  We provide below some hints which may
nevertheless be useful for beginners.  
</P>

<P>
Either before or after your first trials, you may be interested in
some more formal Web-based guidance concerning IE.  There are two such
tutorials accessible from CERN.  One, supplied by NAG, is rather
complete and thorough, and gives you a quick tour of most
possibilities of IRIS Explorer.  It is available
!!HTML!!<a href="http://www.nag.co.uk/0/visual/IE/iecbb/Tutorial/index.html">here</A>.
!!TEX!!\index{NAG}%
!!TEX!!at the URL 
!!TEX!!\texttt{http://www.nag.co.uk/0/visual/IE/iecbb/Tutorial/index.html}
The other, supplied by the University of Leeds, provides more of an
overview, and might be more suitable for physicists. It can be found 
!!HTML!!<a href="http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html">here</A>.
!!TEX!!\index{IECOE!IRIS Explorer Centre of Excellence}
!!TEX!!at the URL
!!TEX!!\texttt{http://www.scs.leeds.ac.uk/iecoe/tutorial/main-frm.html}
</P>

<P> 
The following knowledge can be useful for beginners.  By default,
the <TT>Render</TT> (output) window has a black background.  If you
!!TEX!!\index{Background colour}\index{Colour!background}%
want to look at histogram plots, much of the (default) output will
also be black, and thus potentially invisible!  You are therefore
recommended to change the <TT>Render</TT> window background to a
colour other than black before viewing histograms. To make that
change, in the <EM>Render</EM> module you need the <TT>Viewing</TT>
!!TEX!!\index{Render@{\emph{Render} module}!menus!viewing@{\texttt{Viewing}}}%
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
menu, and <TT>Edit Background Colour</TT>, to select the background of
!!TEX!!\index{Background colour}\index{Colour!background}%
your choice.  The black background can also be changed permanently to
some other colour via the X11 resources described in
!!TEX!!\index{X11 resources}
!!TEX!!Section~\ref{SECHISTOOGRAMPLOT}.
!!HTML!!<A HREF="#SECHISTOOGRAMPLOT">this section</A>.
These resources should be put in the <TT>.Xdefaults</TT> file like any
other X11 resources. If you want to change the fill colour of the
!!TEX!!\index{Fill colour}\index{Colour!fill}%
histograms themselves, you can do that from the
<EM>HistOOgramPlot</EM> module.  As you complete each example, and no
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
longer need the the current map, you can
re-initialise your IE session via the <EM>Map Editor</EM>, by
selecting <TT>Destroy All</TT> from the <TT>Edit</TT> menu.  </P>
!!TEX!!\index{Destroy map}%
!!TEX!!\index{Map editor@{\emph{Map Editor} window}!menu!edit@{\texttt{Edit}}}%
!!TEX!!\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%

<H3>What you should know about the IRIS Explorer user interface</H3>

<P>
In this section we give some brief comments on the general rules
which you should be aware of when using the modules described in the
later sections.
</P>

<P>
Text typed in a widget is read only if you hit <TT>Return</TT>. If
you type some text in a widget without pressing the <TT>Return</TT>
key, the widget will look modified but it keeps the previous value
instead (if this is the first time you type in a widget it is quite
likely that the previous value is the empty string).
</P>

<P>
For instance, typing a C++ cut in the <TT>Match</TT> widget of
the <EM>HepMatchAndFill</EM> module without hitting
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
<TT>Return</TT>, the module will not recognize the <TT>Match</TT>
expression and will thus select all tags.
</P>

<P>
A slider widget allows you to vary a parameter between a minimum and a
maximum value using the mouse. If you prefer to use the keyboard
instead, you can directly type into the text field displaying the
current value.  The range limits can be changed in a similar way.
</P>

<P>
When you save a map after editing its modules' widgets, the values on
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
the widget are retained and will be shown again the next time when you
run the map. Be aware that a listbox is usually cleaned up, so that
you will have to select the item again.
</P>

<P>
Reference documentation on Iris Explorer is available 
online as follows.
<UL>
<LI>
!!HTML!!<a href="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/UG/CONTENTS.html">IRIS Explorer Users' Guide</A>.
!!TEX!!<EM>IRIS Explorer Users' Guide.</EM>
The basic IRIS Explorer system, scripting, and DataScribe.
!!TEX!!\index{DataScripe!Component of IRIS Explorer}%
!!TEX!!\index{IRIS Explorer!DataScribe}
!!TEX!!\index{IRIS Explorer!scripts}
!!TEX!!\index{IRIS Explorer}
!!TEX!!\newline URL: 
!!TEX!!\texttt{http://www.nag.co.uk/0/visual/IE/iecbb/DOC/UG/CONTENTS.html}
</LI>
<LI>
!!HTML!!<a href="http://www.nag.co.uk/0/visual/IE/iecbb/DOC/Index.html">IRIS Explorer Documentation</A>.
!!TEX!!<EM>IRIS Explorer Documentation.</EM>
!!TEX!!\index{NAG}%
Pointers to all of NAG's IRIS Explorer documentation.
!!TEX!!\index{IRIS Explorer}
!!TEX!!\newline URL: 
!!TEX!!\texttt{http://www.nag.co.uk/0/visual/IE/iecbb/DOC/Index.html}
</LI>
</UL>

<H3>Appearance of IRIS Explorer modules</H3>

<P>On &UNIX; systems, IRIS Explorer modules can appear in three different
ways on the Map Editor.
</P>
<UL>
<LI><EM>Minimized view</EM>: no user interface is visible.</LI>
<LI><EM>Diminutif view</EM>: a scaled-down version of the user interface is visible.</LI>
<LI><EM>Maximized view</EM>: the GUI is expanded to a full-size panel.</LI>
</UL>
<P>On &WNT; the diminutif view is not available, thus modules are either minimized
or maximized.
</P>

<H2>Storing and deleting histograms</H2>

<P>HBOOK and PAW used to deal with histograms in the
``traditional'' way:</P>
!!TEX!!\index{HBOOK}\index{Ntuple}\index{PAW}%
<UL> 
<LI>all histograms are created in memory;</LI> 
<LI>interesting histograms are explicitly saved (explicit I/O).</LI>
</UL>

<P>An ODBMS such as &OBJ; works exactly the other way round:</P>
!!TEX!!\index{ODBMS}\index{Object Database Management System}%
<UL>
<LI>all histograms are created in the database (implicit I/O);</LI>
<LI>uninteresting histograms are explicitly deleted.</LI>
</UL>

<P>There are different ways to manage the deletion of such histograms.</P>

<UL>
 <LI>In a C++ program the user can either:
  <UL>
   <LI>individually delete each histogram (using the <TT>delete</TT> method 
       or the <TT>ooDelete</TT> function);</LI>
   <LI>allocate ``temporary'' histograms in a well defined container and 
       at the end delete the whole container.</LI>
  </UL>
 </LI>
 <LI>In an IRIS Explorer map the user can either:
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
  <UL> 
   <LI>individually delete each histogram (using the
       <EM>HistOOgramDelete</EM> module);
!!TEX!!\index{HistOOgramDelete@{\emph{HistOOgramDelete} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramDelete@{\emph{HistOOgramDelete}}}%
   </LI>
   <LI>create ``temporary'' histograms in a well defined 
       container and at the end delete the whole container (using 
       the <EM>ContainerDelete</EM> module).
!!TEX!!\index{ContainerDelete@{\emph{ContainerDelete} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerDelete@{\emph{ContainerDelete}}}%
   </LI>
  </UL>
 </LI>
</UL>

<P>Modules such as <EM>HistOOgramFill</EM> (Ntuple-like analysis)
!!TEX!!\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
store their temporary histograms in a container named
<TT>HistoDump_uid</TT>, where <TT>uid</TT> stands for the user's &UNIX;
<TT>uid</TT>. The container is created in a database called <TT>UserDb</TT>,
as seen in 
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="histstore.gif"></P>
!!TEX!!Figure \ref{HISTSTORE}.%
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.6\linewidth]{histstore.eps}
!!TEX!!\caption{Storing histograms in a container}\label{HISTSTORE}
!!TEX!!\end{figure}

<P>
The cleanup of temporary histograms is managed by the <EM>HepMatchAndFill</EM>
!!TEX!!\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
and <EM>HepLoop</EM> modules. The user can either:
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
<p>
<UL>
<LI>clean up the dump container immediately;</LI>
<LI>clean it up when the module leaves;</LI>
<LI>keep the dump contents across separate IRIS Explorer sessions.</LI>
</UL>

<H2>Displaying histograms</H2>

<P>Several HEP Explorer modules have been developed to handle histograms.
In the following sections we shall explore them each in turn.</P>

<H3>The <EM>ContainerBrowser</EM> module</H3>
!!TEX!!\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%

<P>The <EM>ContainerBrowser</EM> module allows you to browse the
databases in the federated database defined by the <TT>OO_FD_BOOT</TT>
!!TEX!!\index{Federated database}\index{Database}%
environment variable.  When the module starts, the list of the data
bases available in the <TT>OO_FD_BOOT</TT> federated database appears
in the <TT>DB List</TT> scroll field. A list of all the containers
available in a given database can be obtained by click on the database
name in question the <TT>DB List</TT> field.  You can also create a
new container belonging to the chosen database by typing the new
container's name in the <TT>container</TT> text field. The output of
this module is a container which can be connected to the <EM>Histogram
Reader</EM> module. The <EM>ContainerBrowser</EM> panel is shown in 
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepex.container.gif"></P>
!!TEX!!Figure \ref{HEPEXCONTAINER}.%
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.6\linewidth]{hepex.container.eps}
!!TEX!!\caption{<EM>ContainerBrowser</EM> panel}\label{HEPEXCONTAINER}
!!TEX!!\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
!!TEX!!\end{figure}

<H3>The <A NAME="HISTOOGRAMREADER"><EM>HistOOgramReader</EM></A> module</H3>
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%

<P>The <EM>HistOOgramReader</EM> module receives a container from the
<EM>ContainerBrowser</EM> module and allows you to select a histogram
from that container.  The list of histograms appears in the
<TT>Histograms</TT> field. You can select the type of histogram should
be shown (1D, 2D or all) using the radio buttons on the right of the
<TT>Histogram</TT> list. By clicking on one of the histogram names in
that list, the selected histogram is send on the output port and can
be received by any module able to take an histogram as its input.
The <EM>HistOOgramReader</EM> panel is shown in 
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepex.reader.gif"></P>
!!TEX!!Figure \ref{HEPEXREADER}.%
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.55\linewidth]{hepex.reader.eps}
!!TEX!!\caption{<EM>HistOOgramReader</EM> panel}\label{HEPEXREADER}
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!TEX!!\end{figure}
<!--
!!TEX!!\begin{figure}[ht]
!!TEX!!\begin{minipage}{.43\linewidth}
!!TEX!!\includegraphics[width=\linewidth]{hepex.container.eps}
!!TEX!!\caption{<EM>ContainerBrowser</EM> panel}\label{HEPEXCONTAINER}
!!TEX!!\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.55\linewidth}
!!TEX!!\includegraphics[width=\linewidth]{hepex.reader.eps}
!!TEX!!\caption{<EM>HistOOgramReader</EM> panel}\label{HEPEXREADER}
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!TEX!!\end{minipage}
!!TEX!!\end{figure}
-->

<H3><A NAME="SECHISTOOGRAMPLOT">The <EM>HistOOgramPlot</EM> module</A></H3>
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

<P>This <EM>HistOOgramPlot</EM> module receives the histogram from
the <EM>HistOOgramReader</EM> module. It can also take lattices as
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
input as shown in the following example. It creates the geometry from
these data and sends them to the <EM>Render</EM> module, which shows
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
the result on screen. To save pictures as vector PostScript files, use the 
<EM>PostScript</EM> module. </P>

<P>
The <EM>HistOOgramPlot</EM> module 
!!TEX!! shown in Figure~\vref{HEPEXPLOT}
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
assumes that the background of the
Render window is white. It is possible to change this background colour
!!TEX!!\index{Background colour}\index{Colour!background}%
with the <TT>Edit Background Color</TT> option in the <TT>Viewing</TT>
!!TEX!!\index{Render@{\emph{Render} module}!menus!viewing@{\texttt{Viewing}}}%
menu or by specifying a different colour in the X11 resources, 
as follows.</P>
!!TEX!!\index{X11 resources}%
<PRE>
*SoXtExaminerViewer*BackgroundColor: white
*SoXtFlyViewer*BackgroundColor: white
*SoXtPlaneViewer*BackgroundColor: white
*SoXtWalkViewer*BackgroundColor: white
</PRE>

<P>
Various plot attributes can be changed via radio buttons or
pull-down menus. The action of the majority of the selectors is quite
obvious by just reading their names. We shall thus only say a few
words about the less trivial case of the <TT>Plot mode</TT>
selector.</P>

<H4>The <TT>Plot mode</TT> selector</H4>

<P>The default value of the <TT>Plot mode</TT> selector is <TT>Start new
plot</TT>. In this state, the last histogram or lattice entered in the
picture is deleted each time a new histogram or lattice is received by
the module. Another value for this selector is <TT>Cumulate</TT>.  In
this case each new histogram or lattice received by the module will be
drawn on the same plot. Finally, by pushing the <TT>New page</TT>
button you will start a new page, deleting all the current plots.</P>

<P>
!!HTML!!<P>The <EM>HistOOgramPlot</EM> panel is shown in 
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepex.plot.gif"></P>
!!TEX!!\begin{figure}
!!TEX!!\centering\includegraphics[width=.65\linewidth]{hepex.plot.eps}
!!TEX!!\caption{<EM>HistOOgramPlot</EM> panel}\label{HEPEXPLOT}
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
!!TEX!!\end{figure}

<H3>How to Plot a histogram</H3>

<P>When the map is ready on the <EM>Map Editor</EM>, you should first select a
!!TEX!!\index{Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
database by just clicking on its name in the <EM>ContainerBrowser</EM>
panel and then go on to select a container name. The list of
histograms is now visible in the <EM>HistOOgramReader</EM> panel. It
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
suffices to select a histogram by clicking on its name for it to be
displayed in the <TT>Render</TT> window. It can be useful to set the
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
render window background to white via the <TT>edit background color</TT>
option in the <TT>Viewing</TT> menu of the <EM>Render</EM> window.</P>
!!TEX!!\index{Render@{\emph{Render} module}!menus!viewing@{\texttt{Viewing}}}%

<P>The map and the PostScript output for a simple one-dimensional histogram are shown in 
!!HTML!!the figures below.</P>
!!HTML!!<P><IMG SRC="./hepex1map.gif"></P>
!!HTML!!<P><IMG SRC="./hepex1.gif"></P>
!!TEX!!Figures \ref{HEPEX1MAP} and \ref{HEPEX1}. 
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{hepex1map.eps}
!!TEX!!\caption{HEP Explorer histogram viewing screen}\label{HEPEX1MAP}
!!TEX!!\centering\includegraphics[width=.5\linewidth]{hepex1.eps}
!!TEX!!\caption{A histogram viewed with the HEP Explorer modules}\label{HEPEX1}
!!TEX!!\end{figure}
!!TEX!!\clearpage

<P>
It is also possible to have several zone on the same plot by assigning
a <em>HistOOgramPlot</em> module to each zone and varying the zone
coordinates value. The map and the PostScript output for two
one-dimensional histograms are shown in 

!!HTML!!the figures below.</P>
!!HTML!!<P><IMG SRC="./hepex2map.gif"></P> 
!!HTML!!<P><IMG SRC="./hepex2.gif"></P> 
!!TEX!!Figures \ref{HEPEX2MAP} and \ref{HEPEX2}.  
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.9\linewidth]{hepex2map.eps}
!!TEX!!\caption{Map used to produce a ``2 zones'' plot}\label{HEPEX2MAP}
!!TEX!!\centering\includegraphics[width=.55\linewidth]{hepex2.eps}
!!TEX!!\caption{Two histograms viewed with the HEP Explorer modules}\label{HEPEX2} 
!!TEX!!\end{figure} 
!!TEX!!\clearpage

<H3>The <EM>PostScript</EM> module</H3>

<P>
The <EM>PostScript</EM> module allows to generate vector PostScript
files from any Open Inventor geometry. This module is based on the
PlotMaster tools provided by Master Suite. With 3D geometries the
PostScript output generated by PlotMaster may be wrong therefore it is
preferable to restrict the usage of this module to 2D geometries.
</P>

<P>
!!HTML!!<P>The <EM>PostScript</EM> panel is shown in 
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepex.postscript.gif"></P>
!!TEX!!\begin{figure}[h]
!!TEX!!\centering\includegraphics[width=.45\linewidth]{hepex.postscript.eps}
!!TEX!!\caption{<EM>PostScript</EM> panel}\label{HEPEXPOSTSCRIPT}
!!TEX!!\index{PostScript@{\emph{PostScript} module}}%
!!TEX!!\index{HEPExplorer!modules!PostScript@{\emph{PostScript}}}%
!!TEX!!\end{figure}

<H3>Displaying a histogram as a Lego plot</H3>
!!TEX!!\index{Lego plot}

<P>
Lauch the <TT>histogramPlot3D</TT> map, which consists of three components:
</P>
<UL>
<LI>the <TT>SelectHisto</TT> group, containing
the <EM>ContainerBrowser</EM> and <EM>HistOOgramReader</EM> modules;
!!TEX!!\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
</LI>
<LI>the <EM>HistOOgramLego</EM> module;
!!TEX!!\index{HistOOgramLego@{\emph{HistOOgramLego} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramLego@{\emph{HistOOgramLego}}}%
</LI>
<LI>the <EM>Render</EM> module.
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
</LI>
</UL>
<P>
By clicking on the <TT>SelectHisto</TT> widgets you can select a 1D or
2D histogram that will be transformed in a Lego plot by the
<EM>HistOOgramLego</EM> module and
!!TEX!!\index{HistOOgramLego@{\emph{HistOOgramLego} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramLego@{\emph{HistOOgramLego}}}%
finally displayed by the <EM>Render</EM>. Whenever you change to
another histogram, click on the <TT>View All</TT> decoration (the small
eye-shaped icon on the right side of the <EM>Render</EM> window, sixth one from
the top) of the <EM>Render</EM> module to reset the camera position.
An example is shown
!!HTML!! below.</P>
!!HTML!!<P><IMG SRC="./lego.gif"></P>
!!TEX!!in Figure \ref{HISTOGRAMPLOT3D}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{lego.eps}
!!TEX!!\caption{HEP Explorer map to display a Lego plot}
!!TEX!! \label{HISTOGRAMPLOT3D}\index{Lego plot}
!!TEX!!\end{figure}

<H2>Deleting a histogram from a container</H2>

<P>If you want to delete a histogram from a container you should
construct the map shown 
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="./hepdelhistmap.gif"></P>
!!TEX!!in Figure \ref{HEPDELHISTMAP}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{hepdelhistmap.eps}
!!TEX!!\caption{HEP Explorer map to delete a
!!TEX!! histogram from a container}\label{HEPDELHISTMAP}
!!TEX!!\end{figure}

<P>
!!TEX!!\index{HistOOgramDelete@{\emph{HistOOgramDelete} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramDelete@{\emph{HistOOgramDelete}}}%
The various steps to connect the modules in the map are first to
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
connect the <EM>HistOOgramDelete</EM> module to the output port of the
<EM>HistOOgramReader</EM> module. Then, you can select a histogram by
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
clicking on its name in the <EM>HistOOgramReader</EM> panel's list.
The database identifier and name of the chosen histogram will appear in the
name fields of the <EM>HistOOgramDelete</EM> modules. If you are sure
you want to drop the histogram from the selected container in the
&OBJ; database, confirm your choice by clicking the <TT>Delete</TT>
button. The situation after the deletion of the histogram selected
in the previous figure is shown
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="./hepdelhistmap1.gif"></P>
!!TEX!!in Figure \ref{HEPDELHISTMAP1}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{hepdelhistmap1.eps}
!!TEX!!\caption{The <EM>HistOOgramReader</EM> after the
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!TEX!! histogram deletion}\label{HEPDELHISTMAP1}
!!TEX!!\end{figure}

<H2>Creating a new histogram</H2>
!!TEX!!\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%

<P>
When you want to create a new histogram you can use the module
<EM>HistOOgramCreate</EM>, whose panels for the one- and two
dimensional cases are shown
!!HTML!!below.</P> 
!!HTML!!<P><IMG SRC="hephistcreate1.gif"></P>
!!HTML!!<P><IMG SRC="hephistcreate2.gif"></P>
!!TEX!!in Figures \ref{HEPHISTCREATE1} and  \ref{HEPHISTCREATE2},
!!TEX!!respectively.
!!TEX!!\begin{figure}[h]
!!TEX!!\begin{minipage}{.49\linewidth}
!!TEX!!\centering\includegraphics[width=\linewidth]{hephistcreate1.eps}
!!TEX!!\caption{<EM>HistOOgramCreate</EM> panel (1D)}
!!TEX!!\label{HEPHISTCREATE1}
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.49\linewidth}
!!TEX!!\centering\includegraphics[width=\linewidth]{hephistcreate2.eps}
!!TEX!!\caption{<EM>HistOOgramCreate</EM> panel (2D)}
!!TEX!!\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
!!TEX!!\label{HEPHISTCREATE2}
!!TEX!!\end{minipage}
!!TEX!!\end{figure}

<P>
The <EM>HistOOgramCreate</EM> module lets you create a new histogram
!!TEX!!\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
inside an existing container: the input port of this module takes a
container parameter. Therefore, it has to be connected to the output
port of the <EM>ContainerBrowser</EM> module.
!!TEX!!\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
!!HTML!!The two maps below 
!!TEX!!The two maps in Figure \vref{HEPHISTCREATEMAP} 
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
correspond to the situation before and after the creation of a new
one-dimensional histogram.  The name chosen for the histogram is
<TT>New Histogram</TT>, as you can clearly see in the
<EM>HistOOgramReader</EM> panel of the map after the histogram
creation.
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!HTML!!(second figure below).</P>
!!HTML!!<P><IMG SRC="hephistcreatemap.gif"></P>
!!HTML!!<P><IMG SRC="hephistcreatemap1.gif"></P>
!!TEX!!(bottom part of Figure \ref{HEPHISTCREATEMAP}).<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\begin{center}
!!TEX!!\includegraphics[width=.7\linewidth]{hephistcreatemap.eps}\\[5mm]
!!TEX!!\includegraphics[width=.7\linewidth]{hephistcreatemap1.eps}
!!TEX!!\end{center}
!!TEX!!\caption[Map for the creation of a new histogram]%<BR>
!!TEX!!        {Map before (top) and after (bottom) creating a new histogram}
!!TEX!!         \label{HEPHISTCREATEMAP}
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!\end{figure}

<H2>Scalar transformations on histograms</H2>
!!TEX!!\index{HistOOgramFunc@{\emph{HistOOgramFunc} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramFunc@{\emph{HistOOgramFunc}}}%

<P>Scalar transformations on histograms are the task 
of the <EM>HistOOgramFunc</EM> module, whose panel is shown 
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="hephistfunc.gif"></P><P>
!!TEX!!in Figure~\ref{HEPHISTFUNC}.
In the map 
!!HTML!!below
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!(Figure~\ref{HEPHISTFUNCMAP})
you can see how you connect the output port of 
<EM>HistOOgramReader</EM> module, which sends a histogram to the
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
input port of the <EM>HistOOgramFunc</EM> module. After the
needed transformation the <EM>HistOOgramFunc</EM> module sends the
histogram further to the <EM>HistOOgramPlot</EM> module.</P>
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
!!HTML!!<P><IMG SRC="hephistfuncmap.gif"></P>
<P>An example of use of the <EM>HistOOgramFunc</EM> module is adding a
set of constants (selected on the dial of the <TT>inScalar</TT> after
first pushing the <TT>Add</TT> on the <EM>HistOOgramFunc</EM> panel)
to the same histogram (received from the <EM>HistOOgramReader</EM>
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
module) and plotting the results in <TT>cumulate</TT> mode onto the
same figure with the <EM>HistOOgramPlot</EM> module, as shown
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="hephistfuncexa.gif"></P>
!!TEX!!in Figure~\vref{HEPHISTFUNCEXA}.<BR>
!!TEX!!\begin{figure}[p]
!!TEX!!\begin{minipage}[b]{.3\linewidth}
!!TEX!!\includegraphics[height=4cm]{hephistfunc.eps}
!!TEX!!\caption{<EM>HistOOgramFunc</EM> panel}
!!TEX!!\label{HEPHISTFUNC}
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}[b]{.65\linewidth}
!!TEX!!\includegraphics[width=\linewidth]{hephistfuncmap.eps}
!!TEX!!\caption{Map structure for scalar histogram transformations}
!!TEX!!\label{HEPHISTFUNCMAP}
!!TEX!!\end{minipage}
!!TEX!!\centering
!!TEX!!\includegraphics[width=.7\linewidth]{hephistfuncexa.eps}
!!TEX!!\caption{Cumulating several histograms}
!!TEX!!\label{HEPHISTFUNCEXA}
!!TEX!!\end{figure}

<H2>Printing a histogram</H2>
!!TEX!!\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%

<P>Sometimes it can be interesting to actually <EM>print</EM> a
histogram. This is made possible by the <EM>HistOOgramPrint</EM>
module, which implements the histogram printing routines described
in Section 
<A HREF="#Printing-histograms"><EM>Printing histograms</EM></A>.
The <EM>HistOOgramPrint</EM> module takes his input from the 
!!TEX!!\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
<EM>HistOOgramReader</EM> module, as seen in the map shown
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="hepprinthistmap.gif"></P><P>
!!TEX!!in Figure~\ref{HEPPRINTHISTMAP}.<br>
Then you will see information (name, number of entries, bins, and parts) 
about the selected histogram in the text fields of the 
<EM>HistOOgramReader</EM>
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
!!HTML!!panel.</P>
!!HTML!!<P><IMG SRC="hepprinthistpanel.gif"></P><P>
!!TEX!!panel (Figure~\ref{HEPPRINTHISTPANEL}).<br>
After pushing the <TT>Print</TT> button in the
<EM>HistOOgramPrint</EM> panel, the output generated by the module is
!!TEX!!\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
written to the <EM>Explorer Log</EM>
!!TEX!!\index{Explorer Log@{\emph{Explorer Log} window}}%
!!TEX!!\index{IRIS Explorer!Explorer Log@{\emph{Explorer Log} window}}%
!!HTML!!window.</P>
!!HTML!!<P><IMG SRC="hepprinthistlog.gif"></P><P>
!!TEX!!window (Figure~\ref{HEPPRINTHISTLOG}).<br>
!!TEX!!\begin{figure}[h]
!!TEX!!\centering
!!TEX!!\includegraphics[width=.9\linewidth]{hepprinthistmap.eps}
!!TEX!!\caption{HEP Explorer map to print an histogram}
!!TEX!!\label{HEPPRINTHISTMAP}
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!\begin{minipage}{.32\linewidth}
!!TEX!!\includegraphics[width=\linewidth]{hepprinthistpanel.eps}
!!TEX!!\caption{<EM>HistOOgramPrint</EM> panel}
!!TEX!!\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
!!TEX!!\label{HEPPRINTHISTPANEL}
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.65\linewidth}
!!TEX!!\includegraphics[width=\linewidth]{hepprinthistlog.eps}
!!TEX!!\caption{<EM>HistOOgramPrint</EM> output}
!!TEX!!\index{HistOOgramPrint@{\emph{HistOOgramPrint} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPrint@{\emph{HistOOgramPrint}}}%
!!TEX!!\label{HEPPRINTHISTLOG}
!!TEX!!\end{minipage}
!!TEX!!\end{figure}

!!TEX!!\clearpage

<H2>Turning a histogram into a lattice</H2>
!!TEX!!\index{HistOOgram2Lat@{\emph{HistOOgram2Lat} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgram2Lat@{\emph{HistOOgram2Lat}}}%

<P>To benefit fully from the many Iris Explorer modules which have
been developed in many different laboratories, research centres,
etc. worldwide, it is advantageous to provide a conversion tool to
translate the HEP-specific data types (i.e., histograms) into IRIS Explorer
generic data types (i.e., lattices).
The module <EM>HistOOgram2Lat</EM> performs such a conversion.
The corresponding <EM>HistOOgram2Lat</EM> panel is shown
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="hephist2lat.gif"></P><P>
!!TEX!!in Figure \ref{HEPHIST2LAT}.<BR>
To show how this module is used let us have a look at the map
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="hephistlatmap.gif"></P><P>
!!TEX!!in Figure \ref{HEPHISTLATMAP}.<BR>
!!TEX!!\begin{figure}[h]
!!TEX!!\centering\includegraphics[width=.65\linewidth]{hephist2lat.eps}
!!TEX!!\caption{<EM>HistOOgram2Lat</EM> panel}\label{HEPHIST2LAT}
!!TEX!!\centering\includegraphics[width=.85\linewidth]{hephistlatmap.eps}
!!TEX!!\caption{Map of Histogram to lattice transformation}
!!TEX!!\label{HEPHISTLATMAP}
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!\end{figure}
We see that the <EM>HistOOgram2Lat</EM> module takes an histogram as
input and generates a lattice as output. The latter output stream can
be fed into any of a series of standard modules which consume
lattices. In particular, in the example map shown we decided to
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
visualise a histOOgram with the standard <EM>NAGgraph</EM> module.</P>
!!TEX!!\index{NAG}%
!!TEX!!\index{naggraph@{\texttt{NAGgraph}}}

!!TEX!!\clearpage
<H2><A NAME="MINUIT-GenDescription">Description of the IRIS Explorer
     <EM>DataFit</EM> Module</A></H2>
!!TEX!!\index{dataFit@{\emph{DataFit} module}}%
!!TEX!!\index{HEPExplorer!modules!DataFit@{\emph{DataFit}}}%
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR>

<P>This module fits a mathematical model or a given user function to
data presented at its input ports. The underlying minimisation engine
is based on Minuit. The incoming data can be one- or two-dimensional
and can be presented as a lattice (any type, any coordinate type) or a
persistent histogram characterised by its &OBJ; object identifier. The
module always retains the data coming from the most recently updated
port.</P>

<P>After the data have been received, the module allows you to:</P>

<UL>
<LI>give an expression for a mathematical model to use in the fit;</LI>
<LI>specify a filename containing a full user-defined function;</LI>
<LI>restrict the zone of interest of the data to fit;</LI>
<LI>import, export and control the parameters to be optimised;</LI>
<LI>launch the fit and retrieve the fitted parameters;</LI>
<LI>analyse the error matrix via calls to dedicated Minuit procedures.</LI>
</UL>
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR>

<H3><A NAME="MINUIT-Using">Using the <EM>DataFit</EM> module: a simple
example</A></H3>
!!TEX!!\label{SMINUIT-Using}

<P>The layout of the <EM>DataFit</EM> panel is shown
!!TEX!!in Figure~\ref{HEPFITFITPANEL}.<BR>
!!HTML!!below</P>
!!HTML!!<P><IMG SRC="hepfit.fitpanel.gif"></P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.7\linewidth]{hepfit.fitpanel.eps}
!!TEX!!\caption{Layout of the \emph{DataFit} panel}
!!TEX!!           \label{HEPFITFITPANEL}.
!!TEX!!\end{figure}

<P>On the fitting module's panel you can either specify as input the
object ID of the (one- or two-dimensional) persistent histOOgram to be
fitted.  The center of each bin will be taken as reference for the
fit. Alternatively, you can use an IRIS Explorer lattice as input,
where for each lattice point two data values should be provided, first
the data and then the error value, in order to compute an accurate
chisquare. If there is only one data value per node, then a
non-weighted least mean square will be calculated.</P>

<P>The panel offers further various dials, sliders, input boxes, etc.,
to communicate with the fitting module. Each parameter in the fit is
identified by its name. A text input widget allows you to type in the
symbolic form of the model expression for the fit.  Available symbols
are: for one-dimensional fits: <TT>g</TT> or <TT>G</TT> for
<EM>Gaussian</EM>, <TT>e</TT> or <TT>E</TT> for <EM>Exponential</EM>,
and <TT>pN</TT> or <TT>PN</TT> (where <TT>N</TT> is a number) for a
<EM>Polynomial</EM> of degree <TT>N</TT>. For two-dimensional fits
only the Gaussian option (<TT>g</TT> or <TT>G</TT>) is available.
For instance one could write</P>
<PRE>
 g+p3, g+G-e,
</PRE>

<P>The module will generate the code for the function, compile it and
put it in a sharable library that will be be loaded dynamically. The
generated function will be a function of one or two variables
according to the dimension of the incoming data. If necessary, the
code for the function can be edited before compilation, or, more
generally, you can use your own function for fitting. This latter
possibility is facilitated by using the <TT>UserFunction</TT>
pull-down menu, which can generate a skeleton to ease editing. Once
are finished, and want want to fit with your own source code, you can
try to compile it. The module will then link it as a sharable library
and load it dynamically to update the function to minimize. Although
it can take some time, it is straightforward and does not request any
special intervention from the user, except, of course, if the
compilation fails.</P>

<P>For the fit itself there is the <TT>Fit</TT> menu, which lets you
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!fit@{\texttt{Fit}}}%
launch fits with Minuit's <TT>MIGRAD</TT>, <TT>MINIMIZE</TT>,
<TT>SIMPLEX</TT>, and <TT>IMPROVE</TT> procedures (see the Minuit
documentation for details). The covariance matrix of the fit is
available via the <TT>Show</TT> menu, while a more detailed
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!show@{\texttt{Show}}}%
<TT>HESSE</TT> and <TT>MINOS</TT> error analysis can is initiated via
the <TT>Errors</TT> menu.
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!errors@{\texttt{Errors}}}%
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR>

<H3><A NAME="MINUIT-parametersetting">Setting the right parameters</A></H3>

<P>Sometimes there is a lack of coherency between the model you try to
fit and the current set of parameters. as the module does not erase
the previous set of parameters each time you change the model, you
must be careful to specify sensible starting values yourself.  If you
are using a combination of the <EM>standard</EM> functions, you can
set a default starting value by using the <TT>Set Default from
Model</TT> command from the <TT>Parameters</TT> menu. This will parse
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
the model expression and generate a set of parameters with appropriate
names, default values and behaviours. Alternatively, you can use the
ASCII file that describes the set of parameters and that can be read
(and written) by the module. This is especially useful if you are
using your own fit function. The format of the file is very easy to
understand. Don't forget to specify in the header the number of
parameters for the fit. As it can sometimes be rather tedious to
adjust the starting values via the user interface, even for the
standard functions, you will find very quickly that the same method
can also be advantageous in this case and that the ASCII file provides
you with an efficient and fast way to achieve a good initialisation,
whereas the GUI allows you to <EM>move around and play</EM> to
visually investigate the effect of parameter changes.in real-time.</P>

<H3>Using the fitting module</H3>

<P>
In this section we shall go through the various steps needed to fit
and then plot a simple one-dimensional histogram retrieved from an
&OBJ; database. The modules concerned can be found on the map
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
shown in
!!TEX!!Figure \ref{HEPFITMAP}.<BR>
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepfitmap.gif"></P>
!!TEX!!\begin{figure}
!!TEX!!\centering\includegraphics[width=.7\linewidth]{hepfitmap.eps}
!!TEX!!\caption{The IRIS Explorer map for fitting and plotting histograms}
!!TEX!!           \label{HEPFITMAP}
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!\end{figure}

<P>Most modules present in the Iris Explorer map needed to fit and
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
plot histograms, have already been described before.</P>
Therefore we only turn our attention towards the 
<EM>DataFit</EM> module itself.

<P>The <EM>DataFit</EM> module receives a histogram from the
<EM>HistOOgramReader</EM> and performs a fit on it. The output of the
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
module is a lattice that is fed into a <EM>HistOOgramPlot</EM> lattice input.
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
</P>

<P>When the map is ready on the <EM>Map Editor</EM>, you can click on histogram
!!TEX!!\index{Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
in the <EM>HistOOgramReader</EM>. At that point it is possible to
adjust various attributes and the effect of these changes will be
visible immediately in the <EM>Render</EM> window.</P>
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%

<P>You are now ready to start a simple fit. Indeed, while sending the
data to the <EM>HistOOgramPlot</EM> module, they was also sent to the
<EM>DataFit</EM> module. Suppose we want to fit the histogram to a
Gaussian distribution. In this case it is enough to type <TT>G</TT> in
the <TT>ModelExpression</TT> text field (lower left hand corner) of
the <EM>DataFit</EM> panel. After typing a carriage return, C++ source
code corresponding to the definition of a Gaussian parameter fit is
generated, compiled and loaded.</P>
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%

<P>
To have an acceptable set of starting values for the fit, it is
possible to adjust the fitting parameters visually. First in the
<TT>Parameters</TT> menu select <TT>Set default from model</TT>.  This
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
fills the <TT>Parameters list</TT> with <TT>MAX1</TT>, <TT>Mean1</TT>
and <TT>StdDev1</TT>, corresponding to the three Gaussian
parameters. By clicking on one of them you can modify its value by
using the dials on the right of the <TT>Parameters list</TT>. It is
also possible to adjust the fitting interval with the slider below the
same <TT>Parameters list</TT>. If the <TT>Histogram/Lattice</TT>
button of the <TT>HistOOgramPlot</TT> module is toggled to
<TT>Lattice</TT>, you will get the curve corresponding to the actual
parameter values displayed in the <TT>Render</TT> window, as shown in
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
!!TEX!!Figure \ref{HEPFITEXA1}.<BR>
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepfitexa1.gif"></P>

<P>When you are satisfied with the initial values for the parameters,
you can select the <TT>Set into Minuit</TT> option in the
<TT>Parameters</TT> menu and then choose the fitting method (for
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
example <TT>MIGRAD</TT>) in the <TT>Fit</TT> menu to perform the
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!fit@{\texttt{Fit}}}%
fit. The result is immediately visualised as shown in
!!TEX!!Figure \ref{HEPFITEXA2}.<BR>
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR>
!!HTML!!the figure below.</P>
!!HTML!!<P><IMG SRC="hepfitexa2.gif"></P>
!!TEX!!\begin{sidewaysfigure}
!!TEX!!\begin{minipage}{.48\textheight}
!!TEX!!\centering\includegraphics[width=.9\linewidth]{hepfitexa1.eps}
!!TEX!!\caption{Curve the initial values before the fit}
!!TEX!!           \label{HEPFITEXA1}.
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.48\textheight}
!!TEX!!\centering\includegraphics[width=.9\linewidth]{hepfitexa2.eps}
!!TEX!!\caption{Curve for the final values after the fit}
!!TEX!!           \label{HEPFITEXA2}.
!!TEX!!\end{minipage}
!!TEX!!\end{sidewaysfigure}

<H3><A NAME="MINUIT-HowSetFitFunction">A more complex example:
     using your own fit function</A></H3>

<P>As sometimes the predefined functions are not sufficient for your
needs, you will have to write and use your own model function. The
present section will guide you through the various steps you have to
take.</p>

<OL>
<LI>
Specify the name of the C-file which want the module to use in the
<TT>Source Input Filename</TT> text widget.  If this file already
exists go to step 5 since steps 2 to 4 below explain how to create a
new file. Note, however, that the contents of an already existing file
will be overwritten with its new definition.
</LI>
<LI>
Specify the number of parameters your model will use in the <TT>Nb of
parameters</TT> text widget. This is not so important; if you do not
know exactly your number of parameters, just give an
approximation.
</LI>
<LI>
Choose <TT>Generate Skeleton</TT> from the <TT>UserFunction</TT>
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!UserFunction@{\texttt{UserFunction}}}%
menu. This should create the file containing a skeleton implementation
for your fit function in the directory
<TT>$EXPLORERUSERHOME/fitting/lib</TT>.
</LI>
<LI>
Edit the file and write your function. You can always have a look at
the file <TT>Minuit_fit_function</TT> in the same directory.  If your
model contains some of the standard functions you can try to construct
a formula using these standard functions which is close in form to
your model expression, then choose <TT>Write model to User File</TT>
from the <TT>UserFunction</TT> menu. This replaces steps 2 and 3 and
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!UserFunction@{\texttt{UserFunction}}}%
can let you gain some time. Below we show an example of such a model
function.
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%
</LI>
<LI>
Choose <TT>Compile User Function</TT> from the <TT>UserFunction</TT>
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!UserFunction@{\texttt{UserFunction}}}%
menu. This should replace the old model by your new one.
</LI>
<LI>
Define the parameters via the option <TT>Open Parameters file</TT> in
the <TT>Parameters</TT> menu. If the file exist, the fields <TT>Par
Filename Input</TT> and <TT>Parameter List</TT> at the top of the
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
<EM>DataFit</EM> panel will be updated. If the file does not exist you
should create it. The simplest procedure is to start from a parameter
file created form a standard model via the option <TT>Save to Parameters
file</TT> in the <TT>Parameters</TT> menu.
!!TEX!!\index{datafit@{\emph{DataFit} module}!menus!parameters@{\texttt{Parameters}}}%
</LI>
</OL>

<P>From here on the fitting procedure proceeds as in the case of a
standard expression (as explained 
!!HTML!!<A HREF="#MINUIT-Using">here</A>)
!!TEX!!in Section \ref{SMINUIT-Using})%
</P>

<H4>Example of a fit function</H4>

<P>Below we show the example of a fit function which was automatically
generated by the <EM>DataFit</EM> module (in this case a second order
polynomial characterised by three parameters, the coefficients of the
terms). This source code can be edited as needed to implement the
desired function.</P>

<PRE>
/**********************************************************************/
/*                                                                    */
/*   Here is defined the function the user wants to fit against his   */
/*   data                                                             */
/*   The call of this function is fixed                               */
/*      Arguments :                                                   */
/*          ndim : number of arguments the function needs             */
/*          coor : the coordinate of the point where the function is  */
/*                 computed                                           */
/*          nparam : nb of parameters the fit function depends on     */
/*          param   : set of parameters values                        */
/*                                                                    */
/*   This file may be automatically generated by the module           */
/*   DataFit or edited by the user                                    */
/*                                                                    */
/**********************************************************************/

#include &lt;values.h>
#include &lt;math.h>

double fit_function(int ndim, float *coor, int nparam, double *param)

{
	double result;
	double X;

	X=(double)(*coor);

	result =
	(param[0] +
	(param[1]*X) + 
	(param[2]*pow(X, 2.0))) ; 

	return (result);
}

 /*  Summary of the meaning of the parameters 
	  param[0] : c, constant value of polynom #1
	  param[1] : b, coefficient #1 of polynom #1
	  param[2] : a, coefficient #2 of polynom #1
 */ 
</PRE>

<P>The <EM>DataFit</EM> module uses a parameter file, which contains
the values and other information for the parameters used in the fit.
The parameter file corresponding to the function described above is
shown below.</P>
<PRE>
 Parameter Tables for MINUIT/EXPLORER Modules 
 Number of Defined Parameter 3 
  
 Parameter # 1 
     Name c
     Value 50000
     Old Value 1 
     Lower Limit 0 
     Upper Limit 100000 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 2 
     Name b
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
 Parameter # 3 
     Name a
     Value 1 
     Old Value 1 
     Lower Limit 0 
     Upper Limit 10 
     Step Size 0.0005 
     Scale Factor 1 
     Free, Fixed or within bounds  0 
</PRE>
!!TEX!!\index{Minuit}\index{Minimisation!Minuit}%<BR>


<H2><A NAME="HEPExplorerexplorable">Interactive analysis in IRIS
Explorer</A></H2>
!!TEX!!\label{SHEPExplorerexplorable}%

<H3>Introduction</H3>


<P>HEP Interactive Analysis in IRIS Explorer is implemented by a set
of HEPExplorer Modules.  Generally speaking, the current set of
Modules allows you to extract data from an &OBJ; data store and
put them in a HistOOgram, using cuts on the data set expressed in C++
syntax. In particular modules implement the following 
!!HTML!!functions:
!!TEX!!functions (see Figure~\vref{FIAM}):
</P>

<UL>
<LI>select an explorable collection;
!!TEX!!\index{Explorable collection}%
</LI>
<LI>define a set of cuts over the collection;</LI>
<LI>define the input streams for the HistOOgram you will produce;</LI>
<LI>automatically generate and compile C++ code that implements the cuts;</LI>
<LI>fill the histogram with data retrieved from the collection.</LI>
</UL>

<P>Apart from accessing the data in the tag, users can invoke C++
functions that implement common physics or access the experiment
specific event object (by traversing the association between a tag and
!!TEX!!\index{Event association}%
its related event). User-defined functions can be used whenever a C++
expression is allowed.</P>

<P>The modules can be grouped in an IRIS Explorer map to avoid redefining
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
every time the user's analysis setup and such a map can be executed in
a <EM>batch</EM> fashion using IRIS Explorer's script language.</P>


<H4>The <EM>HepExplorableBrowser</EM> module</H4>
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%

<P>The <EM>HepExplorableBrowser</EM> module lets you browse and select
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
explorable collections. In the <TT>Explorable List</TT> text field you
!!TEX!!\index{Explorable collection}%
can select a tag, whose identifier will appear in the
<TT>Selected</TT> field. Then the <TT>Field List</TT> will show you
the various fields of the tag, and you can select one and pass it
on to the <EM>HepMatchAndFill</EM> module. The
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
<EM>HepExplorableBrowser</EM> panel is shown
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="HepExplorableBrowser.gif"></P>
!!TEX!!in Figure \ref{HEPEXPBROWSER}.
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering
!!TEX!!\includegraphics[width=.6\linewidth]{HepExplorableBrowser.eps}
!!TEX!!\caption{<EM>HepExplorableBrowser</EM>}
!!TEX!!\label{HEPEXPBROWSER}
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
!!TEX!!\end{figure}<BR>

<H4>The <EM>HepMatchAndFill</EM> module</H4>
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

<P>
This new module offers the same features as the three former modules 
<EM>HepExplorableSelector</EM>, <EM>LibMaker</EM> and <EM>HistOOgramFill</EM>, 
!!TEX!!\index{LibMaker@{\emph{LibMaker} module}}%
!!TEX!!\index{HEPExplorer!modules!LibMaker@{\emph{LibMaker}}}%
!!TEX!!\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
and is equivalent to PAW's <TT>NT/PLOT</TT>, <TT>NT/PROJECT</TT>
commands. 
!!TEX!!\index{PAW}\index{Ntuple}\index{Project Ntuple (PAW)}%
Basically it:
</P>
<UL>
<LI>
	allows users to define specific cuts (<TT>Match</TT> field),
	values and weights for filling histograms (<TT>X, Y</TT> and 
	<TT>W</TT> fields).
</LI>
<LI>
	automatically generates C++ code to fill histograms according to the 
	information above, compiles this code and executes it.
</LI>
</UL>
<P>
As for the <EM>HepLoop</EM> module, histograms are created in a default dump 
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
container if none is specified on the input port. When leaving the module,
users can have these histograms erased automatically (default behavior) or
left as is (just click on the <TT>Keep Dump</TT> radio button); users can also
erase them at any time by clicking on the <TT>Erase Now</TT> button.
</P>
<P>The <EM>HepMatchAndFill</EM> panel is shown
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="HepMatchAndFill1.gif"></P>
!!TEX!!in Figure \ref{HEPMATCHANDFILL}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering
!!TEX!!\includegraphics[width=.8\linewidth]{HepMatchAndFill1.eps}
!!TEX!!\caption{<EM>HepMatchAndFill</EM> panel}
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
!!TEX!!\label{HEPMATCHANDFILL}
!!TEX!!\end{figure}<BR>


<H4>The <EM>HepLoop</EM> module</H4>
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%

<P>
This module is equivalent to the <TT>PAW NT/LOOP</TT>
command and offers a framework to
!!TEX!!\index{PAW}\index{Ntuple}\index{Loop over Ntuple (PAW)}%
scan an explorable collection, apply a certain cut/match to the collection
!!TEX!!\index{Explorable collection}%
(or to each of its items) and execute a particular action each time this 
match succeeds. The action may for instance be the filling of histograms.
</P>
<P>
Most of the code (both header file and source file) is automatically generated:
users only have to provide/write the relevant part of code for the match/cut 
or action to be taken for instance.  As with <EM>HepMatchAndFill</EM> symbolic
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
constants are supported and may be passed to the code without no extra 
compilation overhead.
</P>
<P>
Once the entire code meets the user's requirements, <EM>HepLoop</EM> makes it 
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
possible to generate files and Makefile for a standalone version corresponding 
to the current customized code and setup. The standalone application may then 
be executed outside of Iris Explorer like any other applications.
</P>
<P>The <EM>HepLoop</EM> panel is shown
!!HTML!!below.</P>
!!HTML!!<P><IMG SRC="HepLoop1.gif"></P>
!!TEX!!in Figure \ref{HEPLOOP}.<BR>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering
!!TEX!!\includegraphics[width=.8\linewidth]{HepLoop1.eps}
!!TEX!!\caption{<EM>HepLoop</EM> panel}
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
!!TEX!!\label{HEPLOOP}
!!TEX!!\end{figure}

<H3>The <EM>explorablePlot</EM> map</H3>
!!TEX!!\index{explorableplot@{\emph{explorablePlot} map}}%
!!TEX!!\index{HEPExplorer!modules!explorableplot@{\emph{explorablePlot}}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%

<P>
The <EM>explorablePlot</EM> map is an example of how to use HEP-Explorer 
modules; it produces HistOOgrams out of an explorable collection.
!!TEX!!\index{Explorable collection}%
You can think of this map as a <EM>NT/PL replacement</EM>.
!!TEX!!\index{PAW}\index{Ntuple}\index{Plot Ntuple (PAW)}%
</P>
<P>
The map has three modules: <EM>HepExplorableBrowser</EM>,
<EM>HepMatchAndFill</EM>, and <EM>HistOOgramPlot</EM>.
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
</P>

<UL>
<LI>
<EM>HepExplorableBrowser</EM>'s output port <TT>Explorable</TT> is
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
connected to <EM>HepMatchAndFill</EM>'s input port <TT>Explorable</TT>;
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</LI>

<LI>
<EM>HepMatchAndFill</EM>'s output port <TT>output Histo</TT> is connected to
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
<EM>HistOOgramPlot</EM>'s input port <TT>inHisto</TT>;
</LI>

<LI>
<EM>HistOOgramPlot</EM>'s output port <TT>OutputGeometry</TT> is
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
connected to <EM>Render</EM>'s input port <TT>Geometry</TT>.
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
</LI>
</UL>

<P>
The details of the <EM>explorablePlot</EM> map can be seen
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!\index{explorableplot@{\emph{explorablePlot} map}}%
!!TEX!!\index{HEPExplorer!modules!explorableplot@{\emph{explorablePlot}}}%
!!HTML!!below.</P> 
!!HTML!!<P><IMG SRC="hepexplorablemap.gif"></P>
!!TEX!!in Figure \ref{HEPEXPLORABLEMAP}).<BR>
!!TEX!!\begin{figure}[ht]<BR>
!!TEX!!\centering\includegraphics[width=.8\linewidth]{hepexplorablemap.eps}<BR>
!!TEX!!\caption{The <EM>explorablePlot</EM> map}<BR>
!!TEX!!\index{explorableplot@{\emph{explorablePlot} map}}%
!!TEX!!\index{HEPExplorer!modules!explorableplot@{\emph{explorablePlot}}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
!!TEX!!\label{HEPEXPLORABLEMAP}<BR>
!!TEX!!\end{figure}<BR>

<P>If you want to produce a HistOOgram you should do the following.</P>

<OL>
<LI>Select an explorable collection using the
!!TEX!!\index{Explorable collection}%
<EM>HepExplorableBrowser</EM> module.  The selected item is passed
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
over to the <EM>HepMatchAndFill</EM> module.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</LI>
<LI>Define your cuts on the explorable collection by typing a C++ expression
!!TEX!!\index{Explorable collection}%
in the <TT>Match</TT> field of the <EM>HepMatchAndFill</EM> module.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</LI>
<LI>Define what you want to put in your HistOOgram as C++ expressions
in the <TT>X</TT>, <TT>Y </TT>and <TT>W</TT> fields of the
<EM>HepMatchAndFill</EM> module.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</LI>
<LI>Click on the <TT>Execute</TT> button of the
<EM>HepMatchAndFill</EM> module to 
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
generate the C++ code, compile it, if need be, and then execute it.
</LI>
<LI>
The <EM>HistOOgramPlot</EM> module transforms the histogram data into
a graphics scene which is displayed by the <EM>Render</EM> module.
!!TEX!!\index{HistOOgramPlot@{\emph{HistOOgramPlot} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramPlot@{\emph{HistOOgramPlot}}}%
!!TEX!!\index{Render@{\emph{Render} module}}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
</LI>
</OL>

<H3> Getting the most of <EM>HepMatchAndFill</EM></H3>
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

<P>
<EM>HepMatchAndFill</EM> provides many other useful features including the
following.
</P>
<UL>
<LI>
The use of symbolic constants can avoid code recompilation overhead;
</LI>
<LI>
a customized pre-booked histogram can be specified instead of the
default one;
</LI>
<LI>
users can add extra C++ source files or includes files to define more
complex cuts or histogram variables;
</LI>
<LI>
users can directly access event data from an explorable collection.
!!TEX!!\index{Explorable collection}%
</LI>
</UL>
<P>
Notice the use of the <EM>HistoryBox</EM> module to keep a history of the cuts 
!!TEX!!\index{HistoryBox@{\emph{HistoryBox} module}}%
!!TEX!!\index{HEPExplorer!modules!HistoryBox@{\emph{HistoryBox}}}%
expressions, for instance.
</P>

<H4> Using symbolic constants in <EM>HepMatchAndFill</EM></H4>
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%

<P>
Symbolic constants can be specified in the <TT>Match</TT>, <TT>X</TT>,
<TT>Y</TT> and <TT>W</TT> fields instead of actual numerical values.
The main advantage with this approach, apart from having simpler and
clearer expressions, is that whenever users want to modify the
numerical values of these symbolic constants to fit their needs, the
C++ generated code is neither regenerated nor recompiled: the
compilation overhead is thus eliminated.
</P>

<P>Such symbolic constants are defined in the <TT>Constants</TT> field
and obey the C++ numerical constants assignment syntax: <TT>name =
value</TT>.  For instance, the following expression defines two symbolic
constants (the last semi-colon is optional):
</P>
<PRE>
	PART_MIN = 45500; X_OFFSET = 36.462;
</PRE>
<P>
Note that currently there is a limitation on the definition of
symbolic constants, namely <B>the order of the definitions in the
<TT>Constants</TT> field is significant. The order cannot be changed
unless the code is re-generated, otherwise consistency is not assured.
</B>
</P>

<H4>Specifying a pre-booked histogram</H4>
<P>
By default <EM>HepMatchAndFill</EM> fills a histogram booked on the fly 
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
in a dump container. The min and max values of the default 
histogram are sampled from the data, while the number of bins is 100 for 
1D histograms and 40 by 40 for 2D histograms.
<BR>
If a valid histogram is connected to the optional histogram input port 
(<TT>Input Histo</TT>), then this histogram is used instead of the 
default one.
Typically users can look up a histogram (via <EM>HistOOgramReader</EM>) or
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
create a new one (thanks to <EM>HistOOgramCreate</EM>) and pass it to
!!TEX!!\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
<EM>HepMatchAndFill</EM>, when they want to fill their customized histogram.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</P>
<P>
!!HTML!!The following panel 
!!TEX!!The panel in Figure~\ref{HEPMATCHANDFILL4}
shows how the <TT>Customized_Histo</TT> 
HistOOgram (created by <EM>HistOOgramCreate </EM>) can be specified and 
!!TEX!!\index{HistOOgramCreate@{\emph{HistOOgramCreate} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramCreate@{\emph{HistOOgramCreate}}}%
connected to the input port <TT>Input Histo</TT> of <EM>HepMatchAndFill</EM>.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</P>
!!HTML!!<P><IMG SRC="HepMatchAndFill4.gif"></P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.6\linewidth]{HepMatchAndFill4.eps}
!!TEX!!\caption{Handling histograms with the <EM>HepMatchAndFill</EM> module}
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
!!TEX!!\label{HEPMATCHANDFILL4} 
!!TEX!!\end{figure}


<H4>Invoking user defined methods and code</H4>

<P>
When a cut becomes rather long and complex, users might find it useful
to be able to call a customized function that implements the tricky
cut.  If the routine is short enough, the easiest way to proceed is to
define it in a header file and specify the filename in the <TT>Include
Files</TT> widget.  However, If the code of the function becomes
larger, it might be better pratice to declare the routine in a header
file and implement it in a separate source file. In this case the
header filename (<TT>.h</TT>) and source filename (<TT>.cpp</TT>)
should be specified using the <TT>Include Files</TT>, and 
<TT>Source Files</TT> widgets, respectively.
</P>
<P>
You can specify extra compilation and linking options as follows:
</P>
<UL>
<LI>
the <TT>Build Options</TT> field lets you add extra <TT>includes</TT>
or <TT>define</TT> directives;
</LI>
<LI>
the <TT>Libraries</TT> field lets you add extra libraries.
</LI>
</UL>
<P>
!!HTML!!The next two panels
!!TEX!!The two panels of Figure~\ref{HEPMATCHANDFILLCUT}
show how to use a customized cut function 
(<TT>my_cut</TT>) and the files (<TT>my_cut.h</TT> and <TT>my_cut.cpp</TT>)
that are specified in the relevant widgets of the
<EM>HepMatchAndFill</EM> module.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</P>
!!HTML!!<P><IMG SRC="HepMatchAndFill2.gif"></P>
!!HTML!!<P><IMG SRC="my_cut.gif"></P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\begin{tabular}{@{}cc@{}}
!!TEX!!\includegraphics[height=6cm]{HepMatchAndFill2.eps} &amp;;;
!!TEX!!\includegraphics[height=6cm]{mycut.eps}
!!TEX!!\end{tabular}
!!TEX!!\index{Cut function}
!!TEX!!\caption{Specifying a customized cut function with
!!TEX!!<EM>HepMatchAndFill</EM>}
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
!!TEX!!\label{HEPMATCHANDFILLCUT}<BR>
!!TEX!!\end{figure}<BR>

<H4>Accessing event data from an Explorable collection</H4>
!!TEX!!\index{Explorable collection}%

<P>
HEP-Explorer modules for interactive analysis allow you to easily
manipulate tag fields to define cuts, or to collect information in a
HistOOgram. As mentioned before, no knowledge of the specific object
model is required as long as you deal with attributes defined in the
tag. However, when you need to cross the association between a tag and
its related event in order to retrieve more information, the
HEP-Explorer modules have to get access to the object model.
</P>

<P>
Information about the object model is communicated to <EM>HepMatchAndFill</EM>
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
by specifying the following:
</P>

<UL>
<LI>
the header file (<TT>Include Files</TT> field) that contains the 
declaration of your tag and the related event;
</LI>
<LI>
the name of the concrete tag (<TT>Concrete Tag</TT> field) to be
used, i.e., the name of the class implementing the tag;
</LI>
<LI>
the shared library (<TT>Libraries</TT> field) which contains the 
code to access tag/event methods and attributes.
</LI>
</UL>

<P>
!!HTML!!The following figure 
!!TEX!!Figure~\ref{HEPMATCHANDFILL3}
shows an example using the <TT>AtlasProdTag</TT> concrete tag. Its
declaration is in the header file <TT>AtlasProd.h</TT> and its associated
library has been specified in the <TT>Libraries</TT> field.
</P>
!!HTML!!<P><IMG SRC="HepMatchAndFill3.gif"></P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=.8\linewidth]{HepMatchAndFill3.eps} 
!!TEX!!\caption{Example of accessing event data  
!!TEX!!         from an Explorable collection}
!!TEX!!\label{HEPMATCHANDFILL3} 
!!TEX!!\index{Explorable collection}%
!!TEX!!\end{figure}

<P>
The <TT>theTag</TT> object is then ready for use, should you want to
access the concrete tag. You may ask for a reference to an event using
the <TT>getEvent()</TT> method. With this reference you can then
access each of the attributes as you would do in a normal C++ program
(in the <TT>AtlasProd</TT> example the attribute is named
<TT>NgTrack</TT> and corresponds to the number of tracks in the
event).
</P>

<P>
Note that your shared library should be placed in a directory included in 
the shared library path (see 
<A HREF="#TROUBLESHAREDLIBRARIES">Shared libraries</A>
for more details).
</P>

<H3> The <EM>HepLoopMap</EM> map</H3>
!!TEX!!\index{heploopmap@{\emph{HepLoopMap} map}}%
!!TEX!!\index{HEPExplorer!modulesheploopmap@{\emph{HepLoopMap}}}%

<P>
This map shows an example of how to use the <EM>HepLoop</EM> module with
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
other HEP-Explorer modules to perform a custom interactive analysis.
</P>

<P>
The  <EM>HepLoopMap</EM> map
!!TEX!!shown in Figure~\ref{HEPLOOPMAP}
!!TEX!!\index{heploopmap@{\emph{HepLoopMap} map}}%
!!TEX!!\index{HEPExplorer!modulesheploopmap@{\emph{HepLoopMap}}}%
consist of four modules:
</P>
<UL>
<LI>
<EM>HepExplorableBrowser</EM>.
!!TEX!!\index{HepExplorableBrowser@{\emph{HepExplorableBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!HepExplorableBrowser@{\emph{HepExplorableBrowser}}}%
This module provides an explorable collection to be looped over.
!!TEX!!\index{Explorable collection}%
</LI>
<LI>
<EM>HepLoop</EM>.
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
This module scans the collection, checks for elements that
match a specific user-defined cut and performs the relevant
user-defined action.
</LI>
<LI>
<EM>ContainerBrowser</EM>.
!!TEX!!\index{ContainerBrowser@{\emph{ContainerBrowser} module}}%
!!TEX!!\index{HEPExplorer!modules!ContainerBrowser@{\emph{ContainerBrowser}}}%
Most of the time users want to fill HistOOgrams. By default, such
HistOOgrams are created in a dump container. However, users can also
specify their own container (obtained via <EM>ContainerBrowser</EM>
for instance) by connecting it to the optional input port <TT>Container</TT>.
</LI>
<LI>
<EM>HistOOgramReader</EM>.
!!TEX!!\index{HistOOgramReader@{\emph{HistOOgramReader} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramReader@{\emph{HistOOgramReader}}}%
The <EM>HepLoop</EM> module
provides on its output port the container (the default one
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
or one specified by the user) where all histograms have been created.
It is then possible to display these histograms conveniently by connecting 
this output port (<TT>Out Container</TT>) to <EM>HistOOgramReader</EM>.
</LI>
</UL>

!!HTML!!<P>
!!HTML!!The following panel shows the <EM>HepLoopMap</EM> map.
!!HTML!!</P>
!!HTML!!<P><IMG SRC="HepLoopMap.gif"></P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\includegraphics[width=1.\linewidth]{HepLoopMap.eps} 
!!TEX!!\caption{The <EM>HepLoopMap</EM> map}
!!TEX!!\label{HEPLOOPMAP} 
!!TEX!!\index{heploopmap@{\emph{HepLoopMap} map}}%
!!TEX!!\index{HEPExplorer!modulesheploopmap@{\emph{HepLoopMap}}}%
!!TEX!!\end{figure}

<H3> Getting the most of <EM>HepLoop</EM></H3>

<P>
<EM>HepLoop</EM> provides various features that offer better control over
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
the generated and customized code.
</P>
<UL>
<LI>
Using symbolic constants can avoid recompilation overhead as explained
when discussing how to get the most of <EM>HepMatchAndFill</EM>.
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
</LI>
<LI>
Users can specify the actual number of events to be processed when fitting
the cut expression. By default (when nothing is entered in the text field
<TT>Number of Events</TT>) the full collection is scanned.
</LI>
<LI>
As with <EM>HepMatchAndFill</EM>, extra files or extra compilation
!!TEX!!\index{HepMatchAndFill@{\emph{HepMatchAndFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HepMatchAndFill@{\emph{HepMatchAndFill}}}%
options can be added.
</LI>
</UL>

<P>
When clicking on the <TT>Prototype</TT> button, <EM>HepLoop</EM> generates
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
two skeleton files: a header (extension <TT>.h</TT>) and a source
(extension <TT>.cpp</TT>) file. The basename is specified in
the <TT>Filename</TT> field. The header file contains the main class
declaration and the source file the implementation of its methods. Those
parts of the methods that users may want to alter by introducing
customized code are bracketed with comments, as shown below.
</P>
<PRE>
// *** BEGIN USER CODE ***
   <EM>user-modifiable code </EM>
// *** END USER CODE   ***
</PRE>
<P>
Both header and source files contain some hints to assist the user,
e.g., on how to declare and use histograms.
</P>

!!HTML!!<P>The following two panels show an example of a header and part of
!!HTML!!a source file that were automatically generated.</P>
!!HTML!!<P><IMG SRC="GeneratedCodeH.gif"</P>
!!HTML!!<P><IMG SRC="GeneratedCodeCPP.gif"</P>
!!TEX!!<P>Figure~\ref{GENERATEDCODE} shows two panels with an example 
!!TEX!!of a header (left) and part of a source file (right)
!!TEX!!that were automatically generated.</P>
!!TEX!!\begin{figure}[ht]
!!TEX!!\centering\begin{tabular}{@{}cc@{}}
!!TEX!!\includegraphics[height=9cm]{GeneratedCodeH.eps} &amp;;;
!!TEX!!\includegraphics[height=9cm]{GeneratedCodeCPP.eps}
!!TEX!!\end{tabular}
!!TEX!!\caption{Example of skeleton files generated by <EM>{HepLoop}</EM>}
!!TEX!!\label{GENERATEDCODE}<BR>
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
!!TEX!!\end{figure}<BR>
<P>
The principal idea behind <EM>HepLoop</EM> and its generated
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}% 
skeleton code is to scan (loop over) an explorable collection, 
!!TEX!!\index{Explorable collection}% 
apply a user-defined cut while trying to match each of its items,
then, when a match is successful, execute a given action.  Note that
customized actions can also be performed once before the start of the
loop (<TT>preExecute</TT> method) and once after the loop terminates
(<TT>postExecute</TT>).
</P>

<P>
The main methods users might want to customize include:
</P>
<UL>
<LI>
<TT>match</TT>: define in this method the specific cut/match that is applied
to each item of the explorable collection. <TT>match</TT> should return 0
!!TEX!!\index{Explorable collection}%
when the cut was unsuccessful, a non-zero value otherwise.
</LI>
<LI>
<TT>action</TT>: this method is executed whenever the match/cut succeeds.
Typically users might want to fill histograms in this method.
</LI>
<LI>
<TT>preExecute</TT>: this method is executed once before scanning
an Explorable collection. Typically, this is where you would perform
!!TEX!!\index{Explorable collection}%
initializations or assign resources.
</LI>
<LI>
<TT>postExecute</TT>: this method is executed once after scanning an
Explorable collection. Typically, this is where you would release the
resources that were assigned in <TT>preExecute</TT>.
</LI>
</UL>
!!HTML!!<P>The following panels show some implementations of these methods:</P>
!!HTML!!<P><IMG SRC="CustomizedGeneratedCode1.gif"></P>
!!HTML!!<P><IMG SRC="CustomizedGeneratedCode2.gif"></P>
!!HTML!!<P>The HistOOgrams used in the previous methods are declared 
!!HTML!!in the generated header file in the following way:</P>
!!HTML!!<P><IMG SRC="CustomizedGeneratedCode3.gif"></P>
!!TEX!!<P>Figures~\ref{CUSTOMIZEDGENERATEDCODE1} and
!!TEX!!\ref{CUSTOMIZEDGENERATEDCODE2} show an implementation of 
!!TEX!!some of the methods described above, while
!!TEX!!Figure~\ref{CUSTOMIZEDGENERATEDCODE3} is the header file
!!TEX!!containing their declaration.
!!TEX!!\begin{sidewaysfigure}
!!TEX!!\begin{minipage}{.32\textheight}
!!TEX!!\centering
!!TEX!!\includegraphics[width=.95\linewidth]{CustomizedGeneratedCode1.eps}
!!TEX!!\caption{Customized code: the <TT>match</TT> and
!!TEX!!<TT>preExecute</TT> methods}\label{CUSTOMIZEDGENERATEDCODE1}.
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.32\textheight}
!!TEX!!\centering
!!TEX!!\includegraphics[width=.95\linewidth]{CustomizedGeneratedCode2.eps}
!!TEX!!\caption{Customized code: the <TT>action</TT> method}
!!TEX!!\label{CUSTOMIZEDGENERATEDCODE2}.
!!TEX!!\end{minipage}\hfill
!!TEX!!\begin{minipage}{.32\textheight}
!!TEX!!\centering
!!TEX!!\includegraphics[width=.95\linewidth]{CustomizedGeneratedCode3.eps}
!!TEX!!\caption{Header file used with <EM>HepLoop</EM> customized code
!!TEX!!examples}\label{CUSTOMIZEDGENERATEDCODE3}.
!!TEX!!\end{minipage}
!!TEX!!\end{sidewaysfigure}

<H3>The standalone version of <EM>HepLoop</EM></H3>

<P>
Once the code generated by <EM>HepLoop</EM> has been modified and customized,
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
it is possible to build a standalone version of the code, i.e., a
version of <EM>HepLoop</EM> that can execute the customized code outside
of Iris Explorer.
</P>
<P>
In order to prepare such a standalone versin, users should 
click on the <TT>Generate Makefile</TT> button. Then <EM>HepLoop</EM>
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
generates:
<UL>
<LI>
a makefile (<TT>GNUmakefile</TT>) that registers the current setup
of the module (compilation options, include files, source files, etc.);
</LI>
<LI>
the <TT>main_HepLoop.cpp</TT> file that can run the customized code,
which was prepared and tested previously.
</LI>
</UL>
<P>
Then a standalone version can be build by just typing the command:
</P>
<PRE>
      <TT>gmake</TT>
</PRE>
<P>
This will compile the customized code together with the file
<TT>main_HepLoop.cpp</TT> (and other C++ code, as needed) using and
environmental setup that was defined in <EM>HepLoop</EM>. 
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
The generated application is called <TT>main_HepLoop</TT>, which
can be executed by typing its name:
</P>
<PRE>
      <TT>main_HepLoop</TT>
</PRE>
<P>
This has the same effect as clicking on the <TT>Execute</TT> button of
<EM>HepLoop</EM> inside Iris Explorer.
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
</P>

<P>
The standalone version of <EM>HepLoop</EM> accepts two optional arguments:
!!TEX!!\index{HepLoop@{\emph{HepLoop} module}}%
!!TEX!!\index{HEPExplorer!modules!HepLoop@{\emph{HepLoop}}}%
</P>
<OL>
<LI>
The constants to be passed to the customized code. It is a string
(inside quotes) that has the same format as the one of the
<TT>Constants</TT> field in <EM>HepLoop</EM>.  e.g.,
<TT>PART_MIN=45500; X_OFFSET 36.642;</TT>,  where the last semi-colon
is optional. Constants must be specified in the same order as
they were in the <TT>Constants</TT> field and their number must also
correspond; no consistency is assured when these requirements are not
fulfilled.
</LI>
<LI>
The number of actual events to be processed.
</LI>
</OL>
<P>
As an example, the following command line executes the customized code
specifying two constants and looping will process a total of 65000
event.
</P>
<PRE>
      main_HepLoop "PART_MIN=3455; X_OFFSET=24.78" 65000
</PRE>

<H2>Troubleshooting</H2>
!!TEX!!\index{IRIS Explorer!troubleshooting}\index{Troubleshooting}

<H3>The text in the menus of the <EM>Render</EM> module is difficult
to read</H3>

<P>
Sometimes the text strings in the menus and subpanels of the
<EM>Render</EM> module are difficult to read since the actual
!!TEX!!\index{Render@{\emph{Render} module}!menus}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
message text is not properly initialized
(strings of the type <TT>ivxxx</TT> are displayed).
</P>

<P>
To define the relevant text strings to be displayed, 
the corresponding resources must be defined. These resources
allow you to customize the menus in question. For instance, you can
change the language and disable some of the menu items.
</P>

<P>
The <TT>app-defaults/Inventor</TT> directory 
contains the default resource file for
all standard viewers. System administrators should copy this file into
the directory <TT>/usr/lib/X11/app-defaults</TT>.
!!TEX!!\index{X11 resources}%
For instance, a specific language is chosen as follows.
!!TEX!!\index{Open Inventor!resources}%
</P>
<PRE>
  ln -s Inventor.english Inventor
</PRE>
<P>
One should also include the <TT>$OIVHOME/app-defaults</TT> directory
in the <TT>XAPPLRESDIR</TT> path variable.
</P>
<P>
If you already have a resource file then you can also merge 
the resource file <TT>$OIVHOME/app-defaults/Inventor.xxx</TT>
with yours (see the manual page of <TT>xrdb</TT>).
</P>

<H3>What to do if a map does not react at all?</H3>
!!TEX!!\index{Map}\index{IRIS Explorer!map}%

<P>IRIS Explorer maps obey the dataflow rule:</P>

<OL>
<LI>a module fires when one of its inputs changes;</LI>
<LI>the module can then change its outputs;</LI>
<LI>if another module's input is connected to the changed output,
then that module will fire as well (according to rule 1).</LI>
</OL>

<P>You can check if a module is firing by verifying that its colour
turns yellow.  If the module does not fire then check the
following.</P>

<UL>
<LI>
All mandatory inputs are connected. For instance, if you do
not connect <EM>HistOOgramFill</EM>'s <TT>LibraryName</TT> input to
!!TEX!!\index{HistOOgramFill@{\emph{HistOOgramFill} module}}%
!!TEX!!\index{HEPExplorer!modules!HistOOgramFill@{\emph{HistOOgramFill}}}%
the corresponding <EM>LibMaker</EM>'s output, the module will never
!!TEX!!\index{LibMaker@{\emph{LibMaker} module}}%
!!TEX!!\index{HEPExplorer!modules!LibMaker@{\emph{LibMaker}}}%
activate.
</LI>
<LI>
All mandatory fields have been properly defined: a meaningful value
is typed and the Return key is pressed on the text fields, an item is selected
on the Listboxes.
</LI>
<LI>
There are no &OBJ; locks pending (just exit from IRIS Explorer and
use the &OBJ; <TT>oocleanup</TT> utility).
!!TEX!!\index{oocleanup@{\ttfamily oocleanup}}
</LI>
<LI>
All modules are enabled (enabled modules have black titles on the
<EM>Map Editor</EM>, while disabled modules have grey title).  Be
!!TEX!!\index{Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
aware that when a module crashes, IRIS Explorer will ask you whether
you want to replace the module with another instance. If you answer
positively, the newly loaded module will be disabled by default.  In
order to enable or disable a module you should click with the right
mouse button on the module's name in the <EM>Map Editor</EM> window.
!!TEX!!\index{Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{IRIS Explorer!Map editor@{\emph{Map Editor} window}}%
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
</LI>
</UL>

<H3><A NAME="TROUBLEEXCEED">The <EM>Render</EM> module dies when using Exceed</a></h3>
!!TEX!!\index{Exceed}\index{X Window}\index{PC}%

<p>
Exceed is the recommended X Window package on PCs at CERN.  If the
<EM>Render</EM> module dies immediately, try modifying the
configuration of your PC to use only 256 colours (from the <tt>Control
Panel</tt> window, select <tt>Display</tt> and then
<tt>Appearance</tt>).
!!TEX!!\index{Render@{\emph{Render} module}!dies}%
!!TEX!!\index{IRIS Explorer!modules!Render@{\emph{Render}}}%
</p>

<H3><A NAME="TROUBLESHAREDLIBRARIES">Shared libraries</A></H3>
!!TEX!!\index{Shared library}%

<P>
If you use HEPExplorer modules using shared libraries, e.g., to access
event data, it can happen that the module does not find a shared
library.  Although the details of shared library management differ
amongst &UNIX; flavours, the generic approach is to define a shared
library path environment variable containing the list of directories
that have to be to searched when looking for a shared library.  You
should check that the shared library you want to use is located in one
of these directories. If it is located in a different directory
you can use a simple workaround by creating a
symbolic link to your library in the <TT>$EXPLORERUSERHOME/fitting/lib</TT>
directory, which is always included in the shared library path, e.g.,
<PRE>
> cd $EXPLORERUSERHOME/fitting/lib
> ln -s /afs/cern.ch/myproject/HP-UX/atlasprod/libAtlasSpy.sl libAtlasSpy.sl
</PRE>
<P>Now your library has a symbolic link in one directory that is always
searched for.</P>
<P>
Note that in the example above we used the HP extension <TT>.sl</TT>
for shared library names; on other computer platforms a different
file extension might be required.
</P>

<H3><A NAME="TROUBLEARENA">Shared memory</A></H3>
!!TEX!!\index{Shared memory}%

<P>
If when running running Iris Explorer you get a message saying that
the disk where the shared memory <EM>arena</EM> resides is not large
!!TEX!!\index{Arena}% enough, check the space available in
<TT>/usr/tmp</TT> (the location where IRIS Explorer by default creates
its arena). If it is too small you should enlarge it or change the
directory where the arena is created by specifying another
<EM><TT>tempdir</TT></EM> either in the system-wide
<TT>Explorer.config</TT> file or in your personal <TT>.explorerrc</TT>
!!TEX!!\index{IRIS Explorer!customization!explorerrc@{\texttt{.explorerrc}}}%
!!TEX!!\index{explorerrc@{\texttt{.explorerrc}}!IRIS
!!TEX!! Explorer customization file}
file, e.g., by specifying a different directory
(see IRIS ExplorerUser's Guide, 
!!HTML!!<A HREF="http://www.nag.co.uk:80/visual/IE/iecbb/DOC/UG/appa.html">appendix A</A>).
!!TEX!!Appendix A at the URL 
!!TEX!!\url{http://www.nag.co.uk:80/visual/IE/iecbb/DOC/UG/appa.html}).
</P>
<PRE>
! Set the directory where the arena and pipes go
set tempdir /usr/tmp/explorer
</PRE>

<H3><A NAME="TROUBLEHPUX">Writing to <TT>cout</TT> on HPUX 10.20</A></H3>

<P>
On HPUX 10.20 there are problems with writing to <TT>cout</TT>
when the library <TT>libcx.a</TT> (via the option <TT>-lcx</TT>)
is included when building an Iris Explorer module. It is therefore
advisable to use <TT>printf</TT> rather than the C++ construct
<TT>cout &lt;&lt;</TT> to print program variables to the output stream.
</P>

<H3>Unexpected error message at Render's startup on HP machines</H3>

<p>
On HP systems when starting up the Renderer the following error
message can be printed.
</p>
<pre>
Render: TGS hostid open failed for '/dev/seah0':Permission denied
</pre>
<p>
The message is just a warning and it is due to the presence of a
non-Ethernet card on the system (typically a FDDI card).  Users can
safely ignore this message.
</p>

!!TEX!!\index{HEPExplorer|)}\index{IRIS Explorer|)}

<!--filename=NonHEPIEModules.html-->
<H1><A NAME="H1NonHEPIEModules">Overview of non-HEP-specific IRIS Explorer modules</A></H1>

!!HTML!!<P><IMG SRC="twodfit_map.gif"></P>
!!HTML!!<P>Fit 2D histogram with <EM>DataFit</EM> module</P>
!!TEX!!\begin{figure}[!h]
!!TEX!!\begin{center}
!!TEX!!\centering\includegraphics[width=.9\linewidth]{twodfit_map.eps}
!!TEX!!\end{center}
!!TEX!!\caption{Fit 2D histogram with <EM>DataFit</EM> module}
!!TEX!!\label{TWODFITMAP}
!!TEX!!\small
<P>
This application allows the user to read in a 2D histogram and fit it
using the <EM>DataFit</EM> module which is an interface to Minuit.
The <EM>DataFit</EM> module outputs a lattice which is then re-scaled
by <EM>Rescale2D</EM>.  The <EM>Lego+surface</EM> module group
generates a lego plot for the original histogram and a smooth surface
representing the fit function.
</P>
!!TEX!!\bigskip\index{Lego plot}
!!HTML!!<P><IMG SRC="lego+surface.gif"></P>
!!HTML!!<P>User Interface for the <EM>Lego+Surface</EM> module group</P>
!!TEX!!\begin{center}
!!TEX!!\includegraphics[width=.7\linewidth]{lego+surface.eps}
!!TEX!!\end{center}
!!TEX!!\caption{User Interface for the <EM>Lego+Surface</EM> module group}
!!TEX!!\small
<P>
The GUI for the <EM>Lego+Surface</EM> module group 
!!TEX!!(see the map in Figure \ref{TWODFITMAP})
!!TEX!!\index{Map}\index{IRIS Explorer!map}%
is split into two halves. The left-hand side is related to the surface
normally used to visualise the fit function. The right-hand side
relates to the lego plot used to visualise the histogram contents.
</P>
!!TEX!!\index{Lego plot}
!!TEX!!\end{figure}

!!HTML!!<P><IMG SRC="TwoDAxes.gif"></P>
!!HTML!!<P>User Interface for the <EM>TwoDAxes</EM> module group</P>
!!TEX!!\begin{figure}[p]
!!TEX!!\begin{center}
!!TEX!!\includegraphics[width=.7\linewidth]{TwoDAxes.eps}
!!TEX!!\end{center}
!!TEX!!\caption{User Interface for the <EM>TwoDAxes</EM> module group}
!!TEX!!\small
<P>
The module group produces 3D axis geometry from 2D histograms. Widgets
are fairly self explanatory.
</P>
!!TEX!!\end{figure}

!!HTML!!<P><IMG SRC="twoDfit_render.gif"></P>
!!HTML!!<P>Result of a Gaussian fit to (part of) a 2D histogram</P>
!!TEX!!\begin{figure}[p]
!!TEX!!\centering\includegraphics[width=\linewidth]{twoDfit_render.eps}
!!TEX!!\caption{Result of a Gaussian fit to (part of) a 2D histogram}
!!TEX!!\end{figure}

!!TEX!!\chapter*{Short description of \emph{HEPExplorer} modules and maps}
!!TEX!!\addcontentsline{toc}{chapter}{Short description of 
!!TEX!!\emph{HEPExplorer} modules and maps}
<!--filename=Modulesdescription.html-->
!!HTML!!<H1><A NAME="H1ModulesDescription">Overview of <em>HEPExplorer</em> modules</A></H1>
<DL>
<DT><EM>ContainerBrowser</EM></DT>
<DD>Browse the databases in the federated database.</DD>
<DT><EM>ContainerDelete</EM></DT>
<DD>Delete a container.</DD>
<DT><EM>DataFit</EM></DT>
<DD>Fit a mathematical model or a given user function to
    data presented at the input ports.</DD>
<DT><EM>explorablePlot</EM></DT>
<DD>A map of HEP-Explorer modules producing HistOOgrams from
  an explorable collection.</DD>
<DT><EM>HepExplorableBrowser</EM></DT>
<DD>Browse and select explorable collections.</DD>
<DT><EM>HepLoop</EM></DT>
<DD>Scan an explorable collection, apply a certain cut/match to 
the collection (or to each of its items) and execute a 
particular action if a match occurs (equivalent to PAW's <TT>NT/LOOP</TT>).
</DD>
<DT><EM>HepMatchAndFill</EM></DT>
<DD>Define specific cuts, values and weights for filling histograms,
then automatically generate C++ code to fill those histograms
according to the specified information, compile and execute it.
</DD>
<DT><EM>HistOOgram2Lat</EM></DT>
<DD>
Convert a HistOOgram into an Iris Explorer lattice.
</DD>
<DT><EM>HistOOgramCreate</EM></DT>
<DD>
Create a new 1D or 2D histogram
inside an existing container.
</DD>
<DT><EM>HistOOgramDelete</EM></DT>
<DD>Delete an individual histogram.</DD>
<DT><EM>HistOOgramFill</EM></DT>
<DD>Store a histogram in a container.</DD>
<DT><EM>HistOOgramFunc</EM></DT>
<DD>Perform scalar transformation on a histogram.</DD>
<DT><EM>HistOOgramLego</EM></DT>
<DD>Transform a histogram into a Lego plot.</DD>
<DT><EM>HistOOgramPlot</EM></DT>
<DD>Plot a histogram according to various user-defined attributes.</DD>
<DT><EM>HistOOgramPrint</EM></DT>
<DD>Print a histogram (&agrave; la HBOOK).</DD>
<DT><EM>HistOOgramReader</EM></DT>
<DD>Select a histogram  in a container from a list.
</DD>
<DT><EM>HistoryBox</EM></DT>
<DD>Keep the history of the cut expressions.</DD>
<DT><EM>PostScript</EM></DT>
<DD>Generate a vector PostScript file from an Open Inventor geometry.</DD>
<DT><EM>HepLoopMap</EM></DT>
<DD>A map using the <EM>HepLoop</EM> module with
other HEP-Explorer modules to perform a custom interactive analysis.
</DD>
</DL>

!!TEX!!\chapter*{Glossary}
!!TEX!!\addcontentsline{toc}{chapter}{Glossary}
<!--filename=Glossary.html-->
!!HTML!!<H1><A NAME="H1Glossary">Glossary</A></H1>

<DL>
<DT>AMS</DT>
<DD>Advanced Multi-threaded Server (&OBJ;).
!!TEX!!\index{AMS}%
!!TEX!!\index{Advanced Multi-threaded Server}%
</DD>
<DT>AFS</DT>
<DD>Andrew (distributed) Filesystem.
!!TEX!!\index{AFS}%
!!TEX!!\index{Andrew Filesystem}%
</DD>
<DT>CORBA</DT>
<DD>Common Object Request Broker Architecture, from the OMG.
!!TEX!!\index{CORBA}\index{OMG}%
!!TEX!!\index{Common Object Request Broker Architecture}%
</DD>
<DT>HPSS</DT>
<DD>High Performance Storage System. A high-end mass storage
system developed by a consortium consisting of end-user sites
and commercial companies.
!!TEX!!\index{HPSS}%
!!TEX!!\index{High Performance Storage System}%
</DD>
<DT>NFS</DT>
<DD>Network Filesystem, developed by Sun.
!!TEX!!\index{NFS}%
!!TEX!!\index{Network Filesystem}%
</DD>
<DT>&OBJ;</DT>
<DD>Vendor of an ODBMS. Chosen at CERN in the framework of RD45.
!!TEX!!\index{&OBJ;}%
</DD>
<DT>ODBMS</DT>
<DD>Object Database Management System.
!!TEX!!\index{ODBMS}\index{Object Database Management System}%
</DD>
<DT>ODL</DT>
<DD>Object Definition Language. Specification language defining the
interface to object types conforming to the ODMG Object Model.
!!TEX!!\index{ODL}%
!!TEX!!\index{Object Definition Language}%
</DD>
<DT>ODMG</DT>
<DD>Object Database Management Group. Develops standards for ODBMSes,
e.g., in the area of scalability, heterogeneity, WAN support
(distribution, replication, caching, recovery, etc.), and schema
evolution.
!!TEX!!\index{ODMG}\index{Object Database Management Group}%
</DD>
<DT>OMG</DT>
<DD>Object Management Group.
Consortium of over 400 members from the software, hardware, and large
end-user communities, whose goal is to standardise and promote object
technology in all forms, in particular by proposing specific standards
which should increase portability of customer software across ODBMS
products.
!!TEX!!\index{OMG}%
!!TEX!!\index{Object Management Group}%
</DD>
<DT>ORB</DT>
<DD>Object Request Broker
!!TEX!!\index{ORB}%
!!TEX!!\index{Object Request Broker}%
</DD>
<DT>RD44 Project</DT>
<DD>Object-Oriented Toolkit for Simulation in HEP.
!!TEX!!\index{RD44 Project}
</DD>
<DT>RD45 Project</DT>
<DD>Research and Development project to investigate object persistency
for HEP.
!!TEX!!\index{RD45 Project}
</DD>
</DL>
</body>
</html>

