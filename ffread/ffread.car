C FFREAD   3.13/04   950227 09:10 CERN Program Library     I302 FFREAD
C          FREE FORMAT INPUT PACKAGE.
C          R.BRUN,R.HAGELBERG,M.HANSROUL,I.IVANCHENKO,J-C.LASSALLE,
C          G.MISURI,J.VORBRUEGGEN
C
+PATCH,*FFREAD.
+USE, SFFREAD,IF=-TEST.
+USE, TFFREAD,IF= TEST.
+USE, FFCDES.
+USE, FFFREAD.
+PATCH,*FFEXAM.
+USE, TFFREAD,FFCDES.
+USE, FFFREAD.
+PATCH,FFFREAD.
+USE,IBM     ,IF=IBMMVS ,IBMVM.
+USE,UNIX    ,IF=ALLIANT,APOLLO ,CONVEX  ,IBMAIX ,NECSX  ,UNISYS.
+USE,UNIX    ,IF=DECS   ,HPUX   ,IBMRT   ,SGI    ,SUN    .
+USE,UNIX    ,IF=AMIGAUX,CDCUX  ,GOULD   ,IPSC   ,MACMPW ,MACAUX ,MIPS.
+USE,UNIX    ,IF=MSDOS  ,IBMUX  ,NEXT    ,LINUX  ,WINNT.
+USE,VAX     ,IF=VAXVMS ,VAXULX .
+USE,SINGLE  ,IF=CDC    ,CRAY   .
+USE,DOUBLE  ,IF=IBM    ,VAX    ,NORD.
+USE,DOUBLE  ,IF=UNIX,IF=-SINGLE.
+USE,QMIBMXA ,IF=IBM.
+USE,SAVE    ,IF=UNIX.
+USE,UPLOW   ,IF=-CDC.
+USE,EBCDIC  ,IF= IBM.
+USE,TABS    ,IF= VAX, DECS.
+USE,LUNF77  ,IF=-VAX, IF=-CDC, IF=-DECS.
+PATCH,DFFREAD,T=DATA.
+DECK,INFORM.  General information
C FFREAD   0.00      000000 00.00 CERN Program Library     I302 FFREAD
C          FREE FORMAT INPUT PACKAGE.
C          R.BRUN,R.HAGELBERG,M.HANSROUL,I.IVANCHENKO,J-C.LASSALLE,
C          G.MISURI,J.VORBRUEGGEN
C
+DECK,IGUIDE.  Installation Guide
+DECK,UGUIDE.  User Guide
+DECK,V31303. Version 3.13/03   940207 11.00
C
C- New patches/flags
C     WINNT
C
+DECK,V314. Version 3.14   920918 18.30
C
C- New patches/flags
C     NEXT
C
+DECK,V313. Version 3.13   920719 16.00
C
C- New patches/flags
C     IPSC, MSDOS
C
+DECK,V312. Version 3.12   911217 12.00
C
C- Routine changes:
C  > P=SFFREAD ,D=FFGO     : Change for compatibility with f90-NAG
C  > P=SFFREAD ,D=FFKEY    : Change for compatibility with f90-NAG
C
+DECK,V311. Version 3.11   910723 13.00
C
C- New patches/flags
C     AMIGAUX, CDCUX, IBMPC, IBMUX, NECSX
C
C- Routine changes:
C  > P=FFFREAD             : Replace B32 flag by DOUBLE
C  > P=SFFREAD ,D=FFGO     : Comment out reading of RECFM=V input files
C
+DECK,V310. Version 3.10   910408  7.00
C
C- New patches/flags
C     SFFREAD: Source patch
C     FFFREAD: Flags  patch
C     DFFREAD: Documentation patch (originally in P=HISTORY + P=INFORM)
C              segmenting version updates in decks
C     HPUX   : For HP/UX
C     MIPS   : For MIPS machine
C
C- Routine changes:
C  > P=SFFREAD ,D=FFGO     : Enable reading of RECFM=V input files
C  > P=TFFREAD ,D=FUREAD   : Move DATA statement before SAVE
C
+DECK,V309. Version 3.09   900212 16.30
C
C- Patch/flag changes:
C  > TEST      : add in *FFREAD
C
+DECK,V308. Version 3.08   891110
C
C- Bug corrected in the handling of the '*' as a comment
C- Introduce pilot patch *FFREAD, flags UNIX, ULTRIX
C
+DECK,V307. Version 3.07   890709
C
C- New routine FFRSET to set user reading routine
C- New routine FFUSET to set user action routine
C- <0 units used with READ card to read from user routine set by FFRSET
C
+DECK,V306. Version 3.06   881219
C
C- Missing sequence CFREAD added in FFCARD
C- * added as a comment as well as C
C
+DECK,V305. Version 3.05   880711
C
C- Patchy flag for VAX ULTRIX introduced.
C- PATCH TEST removed, see the INSTALL PAM file
C
+DECK,V304. Version 3.04   880328
C
C- Maximum number of chars printed by FFREAD changed from 132 to 116
C
+DECK,V303. Version 3.03   870817
C
C- Correct STOP statement in FFCARD for better FORTRAN 77 compatibility
C
+DECK,V302. Version 3.02   861203
C
C- Correct bug in FFCARD which caused incorrect handling of
C  E-format input with exponents greater than 1 digit.
C
+DECK,V301. Version 3.01   861019
C
C- Correct bugs in FFREAD, FFGO
C- Remove restriction on data cards - '3*   5' is now legal
C- Introduce possibility to define length of input line in the
C  range 72 to 132 characters (FFINIT, FFGET, FFSET, FFGO)
C- Optimization for VAX in FFGO
C
+DECK,V300. Version 3.00   860417
C
C- Complete rewrite to allow an arbitrary length of user
C  keys in the range of 4 to 32.
C  It is now possible to do nested reads.
C  A new type of key 'LOGI' for FFKEY.
C  FORTRAN-77 version only.
C
+DECK,V20X. Version 2.0x
C         2.03  (851120)
C             Bug corrected in routine FFGOR
C
C         2.02  (850912)
C             CHARACTER VARIABLES  ALLOWED IN CALLS TO FFREAD ROUTINES
C             PROTECTION WHEN TYPING LOWER CASE LETTERS
C
C         2.01  (850309)
C             NORD50 VERSION INTRODUCED
C
C         2.00  (831024)
C             NEW ROUTINES INTRODUCED
C             FFINIT,FFSET,FFGET,FFGO
C             (SEE FFREAD 2.00 DOCUMENTATION)
C
+PATCH, FFCDES.
+KEEP,  FFMACH, IF=DOUBLE.
      PARAMETER (NCHWD  =   4,
     *           NBITCH =   8,
     *           NBITWD =  32,
     *           IQANIL = -77)
+KEEP,  FFMACH, IF=SINGLE, IF=-CDC.
      PARAMETER (NCHWD  =   8,
     *           NBITCH =   8,
     *           NBITWD =  64,
     *           IQANIL = -77)
+KEEP,  FFMACH, IF=CDC.
      PARAMETER (NCHWD  =  10,
     *           NBITCH =   6,
     *           NBITWD =  60,
     *           IQANIL = -77)
+KEEP,  FFMACH, IF=UNIVAC.
      PARAMETER (NCHWD  =   4,
     *           NBITCH =   9,
     *           NBITWD =  36,
     *           IQANIL = -77)
+KEEP,  FFMACH, T=APPEND.
C
C     NCHWD  - # of characters per word
C     NBITCH - # of bits per character
C     NBITWD - # of bits per word
C     IQANIL - # weard address for the user routine
C
+KEEP,  FFLUNS, IF=CDC.
      PARAMETER (LUNDIN = L"INPUT" ,
     *           LUNDUT = L"OUTPUT",
     *           LUNMAX =        99)
+KEEP,  FFLUNS, IF=LUNF77.
      PARAMETER (LUNDIN =   5,
     *           LUNDUT =   6,
     *           LUNMAX =  99)
+KEEP,  FFLUNS, IF=VAX, DECS.
      PARAMETER (LUNDIN =   5,
     *           LUNDUT =   6,
     *           LUNMAX = 119)
+KEEP,  FFLUNS, T=APPEND.
C
C     LUNDIN - default input  LUN
C     LUNDUT - default output LUN
C     LUNMAX - maximum LUN allowed
C
+KEEP,  FFPARM.
      PARAMETER (NCHKYD =   4,
     *           NCHMAX =  32,
     *           LENMIN =  72,
     *           LENDEF =  80,
     *           LENMAX = 132,
     *           LSTACK =  20,
     *           NCSIZE = 500,
     *           NKYOVH =   3,
     *           NOVERH =  23 + LSTACK)
C
C     NCHKYD - default key size in characters
C     NCHMAX - maximum key size in characters
C     LENMIN - minimum significant length of data card
C     LENDEF - default significant length of data card
C     LENMAX - maximum significant length of data card
C     LSTACK - size of input LUN stack
C     NCSIZE - default size of IWORDS
C     NKYOVH - overhead per key in words (in addition to NWDKEY)
C     NOVERH - words in common CFREAD before IWORDS
C
C     NB: If NCHMAX or LSTACK are changed, also modify the length of
C         the variable BLANK in FFGO to be MAX(LSTACK+2, NCHMAX-6).
C
+KEEP,  CFREADSV
      SAVE /CFREAD/
+KEEP,  CFREAD.
+CDE,   FFPARM.
      COMMON /CFREAD/  NWORDS, NCHKEY, NWDKEY, NKEYS,  MAXKEY,
     *                 NOFLEN, NOFTYP, NOFKEY,
     *                 LINPUT, LUNIN,  LUNOUT,
     *                 ISTACK, LUNS(LSTACK),
     *                 IFFOPT(8), KEYOPT(3),
     *                 IWORDS(NCSIZE)
+SEQ, CFREADSV, IF=SAVE
      PARAMETER (NOFLOC = 0)
C
C     Common CFREAD contains all information FFREAD knows about.
C     The variables contain the following:
C
C     NWORDS - # of words available in array IWORDS for key storage
C
C     NCHKEY - # of characters per key - default is four
C     NWDKEY - # of words per key
C     NKEYS  - # of keys currently defined
C     MAXKEY - maximum # of keys IWORDS will hold, considering NCHKEY and NWORDS
C
C    (NOFLOC)- offset for storage of addresses in IWORDS
C              (This is declared a parameter, as it is implicitly 0.)
C     NOFLEN - ditto for array lengths
C     NOFTYP - ditto for type field
C     NOFKEY - ditto for keys
C
C     LINPUT - # of significant characters on data card
C     LUNIN  - unit number for reading
C     LUNOUT - unit number for output
C
C     IFFOPT - character options for FFGET/FFSET
C     KEYOPT - character options for FFKEY
C
C     ISTACK - stack pointer into LUNS()
C     LUNS() - stack for reading from files
C
C     IWORDS - storage for keys, value locations, their length, and their type.
C
+KEEP,  FFCHARSV
      SAVE /FFCHAR/
+KEEP,  FFCHAR
      COMMON /FFCHAR/ BUFFER
      CHARACTER*(LENMAX) BUFFER
+SEQ, FFCHARSV, IF=SAVE
C
C     FFCHAR is a character string which contains the input data card
C
+KEEP,  FFCOMMSV
      SAVE /FFCOMM/
+KEEP,  FFCOMM
      PARAMETER (NFJUMP=99)
      COMMON /FFCOMM/ FFFLAG, KUJUMP, KFJUMP(NFJUMP)
+SEQ, FFCOMMSV, IF=SAVE
C
C     FFFLAG gives the number of errors that occured during reading of
C     the data cards.
C
+PATCH,SFFREAD.
+DECK,  FFCARD.
+SELF, IF=MACMPW.
!!S SEG_FFCARD
+SELF.
      SUBROUTINE FFCARD (BUFFER, KURIN, ISYMB, KUROUT, LENGTH, IVALUE)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine scans the string given in BUFFER for
C              tokens. These are integer or floating point numbers
C              or alphanumeric symbols.
C
C      DUMMY ARGUMENTS:
C
C              BUFFER - passed length character string containing
C                       line to be parsed.
C              KURIN  - position in BUFFER to start scan
C              ISYMB  - type of token found. Values are:
C                        1 - text (IVALUE undefined)
C                        2 - a special character (IVALUE undefined)
C                        3 - an integer number
C                        4 - a floating point number
C                        5 - a logical value - allowed are:
C                              T, TRUE,    and ON  for .TRUE.
C                              F, FALS(E), and OFF for .FALSE.
C                        6 - no token found up to end of string.
C                            In this case, the other output
C                            parameters are undefined.
C              KUROUT - position in BUFFER token starts
C              LENGTH - length of token found
C              IVALUE - value associated with token if ISYMB = 3, 4, 5
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C      SIDE EFFECTS:
C
C              NONE
C
+SEQ,CFREAD.
      CHARACTER BUFFER*(*)
 
      CHARACTER*(*) ALPHA, DIGITS, SPECAL
      PARAMETER (SPECAL = '*''=$()"/')
      PARAMETER (DIGITS = '1234567890')
+SELF,  IF= UPLOW.
      PARAMETER (ALPHA =
     * 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')
 
      CHARACTER CHECK*5
+SELF,  IF=-UPLOW.
      PARAMETER (ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')
+SELF.
 
      LOGICAL LVALU
      EQUIVALENCE (IVALU, RVALU, LVALU)
C
C----------------- Beginning of executable statements -------------------------
C
C        Reset some variables to default values
C
      ISYMB  = 0
      IVALU  = 0
      IEXP   = 0
      ISGNVA = 1
      ISGNEX = 1
      MANTIS = 0
      MANLEN = 0
 
      ICUR   = KURIN - 1
      IMAX   = LEN (BUFFER)
C
C        Loop over all characters remaining
C
 100  ICUR   = ICUR + 1
      IF (ICUR .GT. IMAX) GO TO 200
      GO TO (1, 11, 201, 31, 41), ISYMB + 1
      GO TO 201
C
C        We have no idea what to expect - so throw blanks etc. away
C
   1  IF (BUFFER(ICUR:ICUR) .EQ. ' '
+SELF,  IF=TABS.
     *  .OR. ICHAR (BUFFER(ICUR:ICUR)) .EQ. 9
+SELF.
     *  ) GO TO 100
C
C        Check for a digit or decimal point
C
+SELF,  IF=-VAX.
      ITMP1 = INDEX (DIGITS, BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
      ITMP1 = LIB$LOCC (BUFFER(ICUR:ICUR), DIGITS)
+SELF.
 
      IF (ITMP1 .NE. 0) THEN
          ISYMB  = 3
          KUROUT = ICUR
          LENGTH = 1
          IF (ITMP1 .NE. 10) IVALU = ITMP1
          GO TO 100
      END IF
 
      IF (BUFFER(ICUR:ICUR) .EQ. '.') THEN
          ISYMB  = 4
          KUROUT = ICUR
          LENGTH = 1
          IFIELD = 1
          GO TO 100
      END IF
C
C        Check for unary + or -
C
      IF (BUFFER(ICUR:ICUR) .EQ. '-') THEN
          ISGNVA = -1
          KUROUT = ICUR
          LENGTH = 1
          ISYMB  =  3
          GO TO 100
      END IF
 
      IF (BUFFER(ICUR:ICUR) .EQ. '+') THEN
          ISYMB  =  3
          KUROUT = ICUR
          LENGTH = 1
          GO TO 100
      END IF
C
C        Check for text and special characters
C
+SELF,  IF=-VAX.
      ITMP2 = INDEX (ALPHA,  BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
      ITMP2 = LIB$LOCC (BUFFER(ICUR:ICUR), ALPHA)
+SELF.
      IF (ITMP2 .NE. 0) GO TO 10
 
+SELF,  IF=-VAX.
      ITMP2 = INDEX (SPECAL, BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
      ITMP2 = LIB$LOCC (BUFFER(ICUR:ICUR), SPECAL)
+SELF.
      IF (ITMP2 .NE. 0) GO TO 20
C
C        Whatever this might be - we'll ignore it
C
      GO TO 100
C
C        Start up a text
C
  10  ISYMB  = 1
      KUROUT = ICUR
      LENGTH = 1
      GO TO 100
C
C        Continue with text.
C        If we find something else, check for logical constants.
C
+SELF,  IF=-VAX.
  11    ITMP3 = INDEX (ALPHA,  BUFFER(ICUR:ICUR))
      IF (ITMP3 .EQ. 0)
     *  ITMP3 = INDEX (DIGITS, BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
  11    ITMP3 = LIB$LOCC (BUFFER(ICUR:ICUR), ALPHA)
      IF (ITMP3 .EQ. 0)
     *  ITMP3 = LIB$LOCC (BUFFER(ICUR:ICUR), DIGITS)
+SELF.
 
      IF (ITMP3 .NE. 0) THEN
          LENGTH = LENGTH + 1
          GO TO 100
      END IF
 
      GO TO 210
C
C
C        Special character - that's easy
C
  20  ISYMB  = 2
      KUROUT = ICUR
      LENGTH = 1
      RETURN
C
C        Digit of integer; if decimal point, switch to real
C
+SELF,  IF=-VAX.
  31  ITMP4 = INDEX (DIGITS, BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
  31  ITMP4 = LIB$LOCC (BUFFER(ICUR:ICUR), DIGITS)
+SELF.
 
      IF (ITMP4 .NE. 0) THEN
          LENGTH = LENGTH + 1
          IVALU  = IVALU * 10
          IF (ITMP4 .NE. 10) IVALU = IVALU + ITMP4
          GO TO 100
      END IF
 
      IF (BUFFER(ICUR:ICUR) .EQ. '.') THEN
          ISYMB  = 4
          LENGTH = LENGTH + 1
          IFIELD = 1
          GO TO 100
      END IF
 
+SELF,  IF= UPLOW.
      IF (   BUFFER(ICUR:ICUR) .EQ. 'E'
     *  .OR. BUFFER(ICUR:ICUR) .EQ. 'e') THEN
          CALL FFUPCA (BUFFER, ICUR, 1)
+SELF,  IF=-UPLOW.
      IF (   BUFFER(ICUR:ICUR) .EQ. 'E') THEN
+SELF.
          ISYMB  = 4
          LENGTH = LENGTH + 1
          IFIELD = 2
          GO TO 100
      END IF
 
      GO TO 230
C
C        Real number: dispatch on current field
C
  41  GO TO (46, 47, 48), IFIELD
C
C        Scanning fractional part - expect digit, 'E', or end
C
+SELF,  IF=-VAX.
  46  ITMP5 = INDEX (DIGITS, BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
  46  ITMP5 = LIB$LOCC (BUFFER(ICUR:ICUR), DIGITS)
+SELF.
 
      IF (ITMP5 .NE. 0) THEN
          LENGTH = LENGTH + 1
          MANLEN = MANLEN + 1
          MANTIS = MANTIS * 10
          IF (ITMP5 .NE. 10) MANTIS = MANTIS + ITMP5
          GO TO 100
      END IF
 
+SELF,  IF= UPLOW.
      IF (   BUFFER(ICUR:ICUR) .EQ. 'E'
     *  .OR. BUFFER(ICUR:ICUR) .EQ. 'e') THEN
          CALL FFUPCA (BUFFER, ICUR, 1)
+SELF,  IF=-UPLOW.
      IF (   BUFFER(ICUR:ICUR) .EQ. 'E') THEN
+SELF.
          LENGTH = LENGTH + 1
          IFIELD = 2
          GO TO 100
      END IF
 
      GO TO 240
C
C        Last item was 'E'. Check for exponent sign
C
  47  IFIELD = 3
 
      IF (BUFFER(ICUR:ICUR) .EQ. '-') THEN
          ISGNEX = -1
          LENGTH = LENGTH + 1
          GO TO 100
      END IF
 
      IF (BUFFER(ICUR:ICUR) .EQ. '+') THEN
          LENGTH = LENGTH + 1
          GO TO 100
      END IF
C
C        Scanning exponent field
C
+SELF,  IF=-VAX.
  48  ITMP6 = INDEX (DIGITS, BUFFER(ICUR:ICUR))
+SELF,  IF= VAX.
  48  ITMP6 = LIB$LOCC (BUFFER(ICUR:ICUR), DIGITS)
+SELF.
 
      IF (ITMP6 .NE. 0) THEN
          LENGTH = LENGTH + 1
          IFIELD = 3
          IEXP   = IEXP * 10
          IF (ITMP6 .NE. 10) IEXP = IEXP + ITMP6
          GO TO 100
      END IF
 
      GO TO 240
C
C        We get here when the string is exhausted.
C        If ISYMB = 0, no token found.
C        If not, finish current token.
C
 200  IF (ISYMB .EQ. 0) THEN
          ISYMB  = 6
          RETURN
      END IF
 
      GO TO (210, 201, 230, 240), ISYMB
 
 201  WRITE(LUNOUT,'('' FFCARD INTERNAL CODING ERROR'')')
      STOP
C
C        For text, check whether it's a logical constant
C
 210  IF (LENGTH .GT. 5) RETURN
+SELF,  IF= UPLOW.
      CHECK(1:LENGTH) = BUFFER(KUROUT:KUROUT+LENGTH-1)
      CALL FFUPCA (CHECK, 1, LENGTH)
+SELF.
      GO TO (211, 212, 213, 214, 215), LENGTH
      GO TO 201
 
+SELF,  IF= UPLOW.
 211  IF (CHECK(1:1)  .EQ. 'T') GO TO 221
      IF (CHECK(1:1)  .EQ. 'F') GO TO 222
+SELF,  IF=-UPLOW.
 211  IF (BUFFER(KUROUT:KUROUT) .EQ. 'T') GO TO 221
      IF (BUFFER(KUROUT:KUROUT) .EQ. 'F') GO TO 222
+SELF.
      RETURN
 
+SELF,  IF= UPLOW.
 212  IF (CHECK(1:2)  .EQ. 'ON') GO TO 221
+SELF,  IF=-UPLOW.
 212  IF (BUFFER(KUROUT:KUROUT+1) .EQ. 'ON') GO TO 221
+SELF.
      RETURN
 
+SELF,  IF= UPLOW.
 213  IF (CHECK(1:3)  .EQ. 'OFF') GO TO 222
+SELF,  IF=-UPLOW.
 213  IF (BUFFER(KUROUT:KUROUT+2) .EQ. 'OFF') GO TO 222
+SELF.
      RETURN
 
+SELF,  IF= UPLOW.
 214  IF (CHECK(1:4)  .EQ. 'TRUE') GO TO 221
      IF (CHECK(1:4)  .EQ. 'FALS') GO TO 222
+SELF,  IF=-UPLOW.
 214  IF (BUFFER(KUROUT:KUROUT+3) .EQ. 'TRUE') GO TO 221
      IF (BUFFER(KUROUT:KUROUT+3) .EQ. 'FALS') GO TO 222
+SELF.
      RETURN
 
+SELF,  IF= UPLOW.
 215  IF (CHECK(1:5)  .EQ. 'FALSE') GO TO 222
+SELF,  IF=-UPLOW.
 215  IF (BUFFER(KUROUT:KUROUT+4) .EQ. 'FALSE') GO TO 222
+SELF.
      RETURN
C
C        Termination processing for logical constants
C
 221  LVALU  = .TRUE.
      GO TO 223
 
 222  LVALU  = .FALSE.
 
 223  ISYMB  = 5
+SELF,  IF= UPLOW.
      BUFFER(KUROUT:KUROUT+LENGTH-1) = CHECK(1:LENGTH)
+SELF.
      IVALUE = IVALU
      RETURN
C
C        Termination processing for integers
C
 230  IVALUE = IVALU * ISGNVA
      RETURN
C
C        Termination processing for floating point
C
 240  RVALU  = REAL(IVALU)
 
      IF (MANLEN .NE. 0 .AND. MANTIS .NE. 0) THEN
          RVALU  = RVALU + REAL(MANTIS) * 10.**(-MANLEN)
      END IF
 
      IF (ISGNVA .LT. 0) RVALU  = - RVALU
      IF (IEXP   .NE. 0) RVALU  =   RVALU * 10.**(IEXP*ISGNEX)
 
      IVALUE = IVALU
      RETURN
 
      END
+DECK,  FFFIND.
      INTEGER FUNCTION FFFIND (NEWSTR)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This function searches all keys in common CFREAD
C              for a match with the key in NEWSTR.
C
C      DUMMY ARGUMENTS:
C
C              NEWSTR contains the character string to compare the keys with.
C
C      IMPLICIT INPUTS:
C
C              The key list in common CFREAD. Comparison is made up
C              to the length specified by NCHKEY.
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C       FUNCTION VALUE:
C
C              If the key in NEWSTR is found in the list, the index
C              is returned. If the key is not found, the negative index
C              of the key value which would follow this key is returned.
C              This is used for insertion of keys.
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,   FFMACH.
+CDE,   CFREAD.
      CHARACTER NEWSTR*(*)
      CHARACTER COMPAR*(NCHMAX), OLDSTR*(NCHMAX)
C
C        Loop over all keys to find given one.
C        In case of no keys, the loop isn't executed and
C        the statement after the loop is correct.
C
      COMPAR(1:NCHKEY) = NEWSTR
      DO 1 I = 1, NKEYS
          CALL UHTOC (IWORDS(NOFKEY+I*NWDKEY), NCHWD, OLDSTR, NCHKEY)
          IF (LGT (COMPAR(1:NCHKEY), OLDSTR(1:NCHKEY)) ) GO TO 1
          IF (LLT (COMPAR(1:NCHKEY), OLDSTR(1:NCHKEY)) ) GO TO 2
C
C        Found a match - return its index
C
          FFFIND = I
          RETURN
C
C        Step to next key
C
   1  CONTINUE
C
C        No match, this key comes after the last known key
C
      FFFIND = - (NKEYS+1)
      RETURN
C
C        No match, return index of next higher key for insertion
C
   2  FFFIND = - I
      RETURN
 
      END
+DECK,  FFGET.
      SUBROUTINE FFGET (CHOPT, IVALUE)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine returns certain internal parameters of FFREAD.
C
C      DUMMY ARGUMENTS:
C
C              CHOPT  - character string specifying which item is requested.
C                       Possible values are:
C                       LENG - # of significant characters on data card
C                       LINP - LUN for input
C                       LOUT - LUN for output
C                       NBIT - # of bits per word        -
C                       NCHW - # of characters per word   ) machine constants
C                       NBCH - # of bits per character   -
C                       NCHK - # of characters per key
C              IVALUE - integer value corresponding to requested item
C
C      IMPLICIT INPUTS:
C
C              For CHOPT = LENG, LINP, LOUT, or NCHK, the corresponding
C              values from common CFREAD.
C              The other values are machine-dependant constants.
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   CFREAD.
      CHARACTER CHOPT*(*)
C
C----------------- Beginning of executable statements -------------------------
C
C        Check option and dispatch on it
C
      CALL UCTOH (CHOPT, NCHOPT, NCHWD, MIN (LEN (CHOPT), 4) )
      IOPT = IUCOMP (NCHOPT, IFFOPT(2), 7)
      GO TO (1, 2, 3, 4, 5, 6, 7), IOPT
C
C        Unknown option
C
      WRITE (UNIT=LUNOUT, FMT=1001) NCHOPT
      RETURN
 
   1  IVALUE = LINPUT
      RETURN
 
   2  IVALUE = LUNIN
      RETURN
 
   3  IVALUE = LUNOUT
      RETURN
 
   4  IVALUE = NBITWD
      RETURN
 
   5  IVALUE = NCHWD
      RETURN
 
   6  IVALUE = NBITCH
      RETURN
 
   7  IVALUE = NCHKEY
      RETURN
 
1001  FORMAT
     * (' FFGET  --- UNRECOGNIZED OPTION ''', A4, ''' - TRY AGAIN')
 
      END
+DECK,  FFGO.
      SUBROUTINE FFGO
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine actually reads input from the specified
C              unit(s), interprets the data cards, and modifies the
C              corresponding variables.
C
C      DUMMY ARGUMENTS:
C
C              NONE
C
C      IMPLICIT INPUTS:
C
C              The common CFREAD contains the keys the user has defined.
C              Keywords LIST, NOLIST, READ, WRITE, END, STOP, KEYS, HOLL,
C              and C have predefined actions.
C
C      IMPLICIT OUTPUTS:
C
C              The variables given in the key definition are modified
C              as indicated on the data cards.
C
C      SIDE EFFECTS:
C
C              If the predefined command READ is given, an indirect input
C              file is opened and reading continues from this file.
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   CFREAD.
+CDE,   FFCOMM.
+CDE,   FFCHAR.
      INTEGER FFFIND
 
      CHARACTER REST*(NCHWD-1), TXTSEP*1
 
      CHARACTER OUTBUF*116
 
      CHARACTER ERRHDR*48
      PARAMETER (ERRHDR =
     * ' -------------------- DATA CARD ERROR -----     ')
 
      CHARACTER BLANK*26
      INTEGER IBUF((NCHMAX+NCHWD-1)/NCHWD)
+SELF,  IF=UPLOW.
 
      CHARACTER CHECK*5
+SELF.
 
      LOGICAL STRING, CALUSR, LISKEY, TITLE, LIST, STOP, SHIFT
 
      PARAMETER (IBFLEN = LENMAX/2)
      INTEGER LENBUF(IBFLEN), LOCBUF(IBFLEN)
      INTEGER IVALUS(IBFLEN)
      REAL    RVALUS(IBFLEN)
      EQUIVALENCE (IVALUS(1), RVALUS(1)), (IVALUE, RVALUE)
 
      PARAMETER (NSYSKY = 10)
      CHARACTER SYSKEY(NSYSKY)*6
      INTEGER LKYMIN(NSYSKY), LKYMAX(NSYSKY)
C
C        The fact that for END and STOP their index is their correct
C        length plus one is used at labels 150 and 907.
C        The index of system keys 2 to 4 is used at label 900.
C
      DATA SYSKEY / 'C     ', 'LIST  ', 'READ  ',
     *              'END   ', 'STOP  ', 'NOLIST',
     *              'WRITE ', 'HOLL  ', 'KEYS  ',
     *              '*     '/
      DATA LKYMIN / 1, 4, 4, 3, 4, 4, 4, 4, 4, 1 /,
     *     LKYMAX / 2, 4, 4, 3, 4, 6, 5, 4, 4, 2 /
 
      DATA BLANK / ' ' /
C
C----------------- Beginning of executable statements -------------------------
C
C        Check that we have at least one key
C
      IF (NKEYS .LE. 0) THEN
          WRITE (UNIT=LUNOUT, FMT=1011)
          RETURN
      END IF
C
C        Initialize some variables
C        LINPUT is copied to a local variable to aid compiler optimization.
C
      LIST   = .FALSE.
      TITLE  = .FALSE.
      LISKEY = .FALSE.
      STRING = .FALSE.
      STOP   = .FALSE.
      CALUSR = .FALSE.
      KURKEY = 0
      FFFLAG = 0.
      TXTSEP = ''''
      IBFSIZ = LINPUT
C
C        Reset variables and read in a data card
C
   1  KURSOR = 1
      IERROR = 0
      ICOUNT = 0
      SHIFT  = .FALSE.
 
      IF (LUNIN.LT.0) THEN
        CALL JUMPST(KFJUMP(-LUNIN))
        CALL JUMPX1(IBFSIZ)
      ELSE
CSELF,IF= IBMVM.
C       READ (UNIT=LUNIN, NUM=NBYT, IOSTAT=IOS) BUFFER(1:IBFSIZ)
C       IF(IOS.LT.0) GOTO 80
C       BUFFER(NBYT+1:IBFSIZ)=' '
CSELF,IF=-IBMVM.
        READ (UNIT=LUNIN, FMT=2001, END=80) BUFFER(1:IBFSIZ)
CSELF.
      END IF
      IF (STRING) GO TO 150
C
C        Parse first item.
C
      CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *             KURSOR, LENGTH, IVALUE)
C
C        A blank card will be ignored.
C
      IF (ISYMB .EQ. 6) GO TO 900
C
C        If first non-blank character of card is '*',
C        it can't be a continuation card. In this case,
C        get the key, if this is not a comment
C
      IF (ISYMB .EQ. 2 .AND. BUFFER(KURSOR:KURSOR) .EQ. '*') THEN
          IF(BUFFER(KURSOR+1:KURSOR+1) .NE. ' ') THEN
            KURSOR = KURSOR + 1
            SHIFT  = .TRUE.
            CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *                      KURSOR, LENGTH, IVALUE)
          END IF
      ELSE
C
C        If it seems to be a continuation card, we must have a current key
C
         IF (ISYMB .NE. 1) THEN
             IF (KURKEY .NE. 0 .AND. .NOT. SHIFT) THEN
                 GO TO 121
             ELSE
                 IF (SHIFT) THEN
                     SHIFT  = .FALSE.
                     IERROR =  5
                 ELSE
                     IERROR = 10
                 END IF
                 GO TO 900
             END IF
         END IF
      END IF
C
C        It's a symbol - convert it to uppercase if necessary.
C
C        Check for a system key.
C        The comparison in the loop below ensures that a system key
C        is compared with the token:
C         -  at least for its minimum length
C         -  at most  for its maximum length
C         -  at most  for the user-defined key length.
C
+SELF,  IF=UPLOW.
      CALL FFUPCA (BUFFER, KURSOR, LENGTH)
 
+SELF.
      DO 2 IKEY = 1, NSYSKY
          IF (LENGTH .GE. LKYMIN(IKEY)) THEN
              ITMP = MIN(LENGTH, NCHKEY)
              IF (LKYMAX(IKEY) .GE. LENGTH) THEN
                  IF (BUFFER(KURSOR:KURSOR+ITMP-1) .EQ.
     *                SYSKEY(IKEY)(1:ITMP)) GO TO 3
              ELSE IF (ITMP .NE. LENGTH) THEN
                  IF (BUFFER(KURSOR:KURSOR+LKYMAX(IKEY)-1) .EQ.
     *                SYSKEY(IKEY)) GO TO 3
              END IF
          END IF
   2  CONTINUE
 
      GO TO 100
C
C        We have found a system key.
C        If it is 'C' or a '*', ignore this card completely.
C        Otherwise, dispatch after calling FFUSER
C        for last key if necessary.
C
   3  IF (IKEY .EQ. 1 .OR. IKEY .EQ. 10) GO TO 900
 
      KURSOR = KURSOR + LENGTH
 
   4  IF (CALUSR) THEN
        CALL JUMPST(KUJUMP)
        CALL JUMPX1(IWORDS(NOFKEY+KURKEY*NWDKEY))
      END IF
      CALUSR = .FALSE.
      KURKEY = 0
      GO TO (10, 20, 30, 40, 50, 20, 60, 70), IKEY - 1
C
C        'LIST' - turn on listing, give title if not yet done
C
  10  LIST   = .TRUE.
 
      IF (.NOT. TITLE) THEN
          WRITE (UNIT=LUNOUT, FMT=2104)
          TITLE = .TRUE.
      END IF
 
      GO TO 90
C
C        'READ' or 'WRITE' - change input/output LUNs.
C        For 'READ', a stack is used.
C
C        Get LUN, check it's an integer and in the correct range.
C
  20  CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *             KURSOR, LENGTH, IVALUE)
 
      IF (ISYMB .NE. 3) THEN
          IERROR = 2
          GO TO 90
      END IF
 
      IF(IKEY.EQ.3) THEN
        LUNMIN = -NFJUMP
      ELSE
        LUNMIN = 0
      END IF
 
      IF (IVALUE .LT. LUNMIN .OR. IVALUE .GT. LUNMAX) THEN
          IERROR = 3
          GO TO 90
      END IF
C
C        Now store value; for 'READ', check for space on stack
C
      IF (IKEY .EQ. 3) THEN
C
C        In case of user reading routine, check if address
C        initialized
C
          IF(IVALUE.LT.0) THEN
              IF(KFJUMP(-IVALUE).EQ.IQANIL) THEN
                  IERROR = 11
                  GO TO 90
              END IF
          END IF
 
          IF (ISTACK .LT. LSTACK) THEN
              ISTACK = ISTACK + 1
              LUNS(ISTACK) = LUNIN
              LUNIN = IVALUE
          ELSE
              IERROR = 4
          END IF
      ELSE
          LUNOUT = IVALUE
      END IF
 
      GO TO 90
C
C        'END' - if indirect file, pop stack, else same as 'STOP'
C
  30  IF (ISTACK .GT. 0) THEN
  35      LUNIN = LUNS(ISTACK)
          ISTACK = ISTACK - 1
          IF(LUNIN.LT.0) THEN
              IF(KFJUMP(-LUNIN).EQ.IQANIL) THEN
                  IERROR = 11
                  GO TO 35
              END IF
          END IF
          GO TO 90
      END IF
C
C        'STOP', or 'END' on primary input
C
  40  STOP   = .TRUE.
      GO TO 90
C
C        'NOLIST' - turn off listing
C
  50  LIST   = .FALSE.
      GO TO 90
C
C        'HOLL' - change text seperator, must be a special character
C
  60  CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *             KURSOR, LENGTH, IVALUE)
 
      IF (ISYMB .EQ. 2) THEN
          IF (BUFFER(KURSOR:KURSOR) .EQ. '*'  .OR.
     *        BUFFER(KURSOR:KURSOR) .EQ. '=') THEN
              IERROR = 1
          ELSE
              TXTSEP = BUFFER(KURSOR:KURSOR)
          END IF
      ELSE
          IERROR = 1
      END IF
 
      GO TO 90
C
C        'KEYS' - give listing of all keys at end of reading
C
  70  LISKEY = .TRUE.
      GO TO 90
C
C        End-of-file on input: give error if reading string.
C        Then treat same as 'END'.
C
  80  IF (STRING) THEN
          STRING = .FALSE.
          IERROR = 7
      END IF
 
      IKEY   = 4
      BUFFER = 'END'
      GO TO 4
C
C        Check whether user wants to be called for this key.
C        That's it for a system key.
C
  90  IF (SHIFT) THEN
          CALL UCTOH  (SYSKEY(IKEY)//BLANK, IBUF, NCHWD, NCHKEY)
          CALL JUMPST(KUJUMP)
CF90     Pass explicitely the dimensionality to bypass argument checking
          CALL JUMPX1(IBUF(1))
      END IF
 
      GO TO 900
C
C        We might have a user key here.
C
 100  ITMP0 = FFFIND (BUFFER(KURSOR:KURSOR+LENGTH-1))
      IF (ITMP0 .GT. 0) GO TO 101
C
C        This is an unknown command. Ignore it with error message.
C
      IERROR = 8
      GO TO 900
C
C        New key, wind up old one and reset variables
C
 101  IF (CALUSR) THEN
        CALL JUMPST(KUJUMP)
        CALL JUMPX1(IWORDS(NOFKEY+KURKEY*NWDKEY))
      END IF
      CALUSR = SHIFT
      KURKEY = ITMP0
      LOC    = 1
C
C        Update cursor. Only action if item was text or special character
C
 110  KURSOR = KURSOR + LENGTH
C
C        Loop here over all items on the card
C
 120  CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *             KURSOR, LENGTH, IVALUE)
 
      IF (ISYMB .EQ. 1) GO TO 110
 121  IF (ISYMB .EQ. 2) GO TO 130
      IF (ISYMB .EQ. 6) GO TO 600
 
      KURSOR         = KURSOR + LENGTH
      ICOUNT         = ICOUNT + 1
      LENBUF(ICOUNT) = 1
      LOCBUF(ICOUNT) = LOC
 
      GO TO (200, 300, 400), ISYMB - 2
C
C        Special character. If it's the text seperator,
C        start storing a text. Otherwise, consider it
C        part of a comment and ignore it.
C
 130  IF (BUFFER(KURSOR:KURSOR) .NE. TXTSEP) GO TO 110
C
C        Check whether we're reading a logical key -
C        strings are not allowed in this case.
C
 131  IF (IWORDS(NOFTYP+KURKEY) .EQ. 3) THEN
          IERROR = 6
          GO TO 900
      END IF
C
C        Take everything up to next seperator
C
      KURSOR = KURSOR + 1
      IF (KURSOR .GT. IBFSIZ) GO TO 132
+SELF,  IF=-VAX.
      LSTRNG = INDEX (BUFFER(KURSOR:IBFSIZ), TXTSEP)
+SELF,  IF= VAX.
      LSTRNG = LIB$LOCC (TXTSEP, BUFFER(KURSOR:IBFSIZ))
+SELF.
      IF (LSTRNG .NE. 0) GO TO 140
C
C        Text overflows to next card
C        Do necessary housekeeping.
C
 132  STRING  = .TRUE.
      LSTRNG  = IBFSIZ - KURSOR + 1
 
      IF (LSTRNG .EQ. 0) THEN
          LREST = 0
          GO TO 600
      END IF
 
      LREST = LSTRNG - (LSTRNG / NCHWD) * NCHWD
 
      IF (LREST .NE. 0) THEN
          REST   = BUFFER(IBFSIZ-LREST+1:IBFSIZ)
          LSTRNG = LSTRNG - LREST
      END IF
 
      GO TO 141
C
C        We have a text item. Store it - empty string is a no-op.
C
 140  LSTRNG = LSTRNG - 1
 
      IF (LSTRNG .EQ. 0) THEN
          KURSOR = KURSOR + 1
          GO TO 120
      END IF
 
 141  ICOUNT = ICOUNT + 1
      CALL UCTOH (BUFFER(KURSOR:KURSOR+LSTRNG-1),
     *            IVALUS(ICOUNT), NCHWD, LSTRNG)
      ITMP1 = (LSTRNG + NCHWD - 1) / NCHWD - 1
 
      DO 142 ITMP2 = ICOUNT, ICOUNT + ITMP1
          LENBUF(ITMP2) = 1
          LOCBUF(ITMP2) = LOC
          LOC           = LOC + 1
 142  CONTINUE
 
      ICOUNT = ICOUNT + ITMP1
C
C        If the string wasn't terminated, we're already done with this card.
C        Else, update cursor and continue parsing.
C
      IF (STRING) GO TO 600
      KURSOR = KURSOR + LSTRNG + 1
      GO TO 500
C
C        A string has been continued.
C        Check whether first item is END or STOP.
C
 150  IKEY = 0
+SELF,  IF=UPLOW.
      CHECK = BUFFER(1:5)
      CALL FFUPCA (CHECK, 1, 5)
      IF (CHECK(1:4) .EQ. 'END ' ) IKEY = 4
      IF (CHECK(1:5) .EQ. 'STOP ') IKEY = 5
+SELF,  IF=-UPLOW.
      IF (BUFFER(1:4) .EQ. 'END ' ) IKEY = 4
      IF (BUFFER(1:5) .EQ. 'STOP ') IKEY = 5
+SELF.
      IF (IKEY .NE. 0) THEN
          IERROR = 7
+SELF,  IF=UPLOW.
          BUFFER(1:IKEY) = CHECK(1:IKEY)
+SELF.
          STRING = .FALSE.
          GO TO 4
      END IF
C
C        Try to find the end of it and deal with leftovers.
C
+SELF,  IF=-VAX.
      LSTRNG = INDEX (BUFFER(1:IBFSIZ), TXTSEP)
+SELF,  IF= VAX.
      LSTRNG = LIB$LOCC (TXTSEP, BUFFER(1:IBFSIZ))
+SELF.
 
      IF (LREST .EQ. 0 .AND. LSTRNG .EQ. 1) THEN
          KURSOR = 2
          STRING = .FALSE.
          GO TO 120
      END IF
 
      ICOUNT         = 1
      LENBUF(ICOUNT) = 1
      LOCBUF(ICOUNT) = LOC
      LOC            = LOC + 1
 
      IF (LREST+LSTRNG .LE. NCHWD) THEN
          CALL UCTOH (REST(1:LREST)//BUFFER(1:LSTRNG),
     *                IVALUS(ICOUNT), NCHWD, LREST+LSTRNG)
          KURSOR = LSTRNG + 1
          GO TO 500
      END IF
 
      CALL UCTOH (REST(1:LREST)//BUFFER(1:NCHWD-LREST),
     *            IVALUS(ICOUNT), NCHWD, NCHWD)
C
C        Now set up to copy the rest of the card.
C
      KURSOR = NCHWD - LREST + 1
 
      IF (LSTRNG .NE. 0) THEN
          LSTRNG = LSTRNG - KURSOR
          STRING = .FALSE.
      ELSE
          LSTRNG = IBFSIZ - KURSOR
      END IF
 
      GO TO 141
C
C        Found an integer item.
C        Check whether it's an address or repeat count.
C
 200  CALL FFSKIP (BUFFER(1:IBFSIZ), KURSOR)
      IF (KURSOR .GT. IBFSIZ)                   GO TO 230
      IF (      BUFFER(KURSOR:KURSOR) .EQ. '*') GO TO 220
      IF (.NOT. BUFFER(KURSOR:KURSOR) .EQ. '=') GO TO 230
C
C        This is an address. Validate it and get next field.
C        Next field may be integer, real, logical, or string.
C
      IF (IVALUE .LE. 0 .OR. IVALUE .GT. IWORDS(NOFLEN+KURKEY)) THEN
          LOC    = IVALUE + 1
          IERROR = 9
          GO TO 900
      END IF
 
      LOCBUF(ICOUNT) = IVALUE
      LOC            = IVALUE
      KURSOR         = KURSOR + 1
      CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *             KURSOR, LENGTH, IVALUE)
 
      IF (ISYMB .EQ. 1 .OR. ISYMB .EQ. 6) THEN
          IERROR = 5
          GO TO 900
      END IF
 
      IF (ISYMB  .EQ. 2) THEN
          IF (BUFFER(KURSOR:KURSOR) .EQ. TXTSEP) THEN
              GO TO 131
          ELSE
              IERROR = 5
              GO TO 900
          END IF
      END IF
 
      KURSOR = KURSOR + LENGTH
      GO TO (300, 400), ISYMB - 3
C
C         Another integer. Check for a repeat count.
C
      CALL FFSKIP (BUFFER(1:IBFSIZ), KURSOR)
      IF (KURSOR .GT. IBFSIZ)             GO TO 230
      IF (BUFFER(KURSOR:KURSOR) .NE. '*') GO TO 230
C
C        This is a repeat count. Check it is positive and get next field.
C        Strings are not allowed to have repeat counts.
C
 220  IF (IVALUE .LE. 0) THEN
          IERROR = 5
          GO TO 900
      END IF
 
      LENBUF(ICOUNT) = IVALUE
      KURSOR         = KURSOR + 1
      CALL FFCARD (BUFFER(1:IBFSIZ), KURSOR, ISYMB,
     *             KURSOR, LENGTH, IVALUE)
 
      IF (ISYMB .LT. 3 .OR. ISYMB .EQ. 6) THEN
          IERROR = 5
          GO TO 900
      END IF
 
      KURSOR = KURSOR + LENGTH
      GO TO (300, 400), ISYMB - 3
C
C        Integer value. Check type and convert if necessary.
C
 230  GO TO (240, 240, 250, 260), IWORDS(NOFTYP+KURKEY)+1
 
 240  IVALUS(ICOUNT) = IVALUE
      GO TO 500
 
 250  RVALUS(ICOUNT) = REAL(IVALUE)
      GO TO 500
 
 260  IERROR = 6
      GO TO 900
C
C        Floating point value. Check type and convert if necessary.
C
 300  GO TO (320, 310, 320, 330), IWORDS(NOFTYP+KURKEY)+1
 
 310  IVALUS(ICOUNT) = INT(RVALUE)
      GO TO 500
 
 320  RVALUS(ICOUNT) = RVALUE
      GO TO 500
 
 330  IERROR = 6
      GO TO 900
C
C        Logical value. Error if for floating point key.
C
 400  IF (IWORDS(NOFTYP+KURKEY) .NE. 2) THEN
          IVALUS(ICOUNT) = IVALUE
      ELSE
          IERROR = 6
          GO TO 900
      END IF
C
C        Correct location counter before we parse next item.
C        At the same time, check that we haven't exceeded
C        the allowed address range.
C
 500  LOC    = LOCBUF(ICOUNT) + LENBUF(ICOUNT)
 
      IF (LOC-1 .GT. IWORDS(NOFLEN+KURKEY)) THEN
          IERROR = 9
          GO TO 900
      END IF
 
      IF (KURSOR .LE. IBFSIZ) GO TO 120
C
C        End of card - now actually store the values.
C
C        If no value given, store 1, 1.0, and .TRUE., respectively,
C        depending on type of key, into current location.
C
C        This only differs from element 1 if the only item
C        on this card is the end of a continued text.
C
 600  IF (ICOUNT .NE. 0) THEN
          NOFF1 = IWORDS(NOFLOC+KURKEY)
          DO 601 ITMP5 = 1, ICOUNT
              NOFF2 = NOFF1 + LOCBUF(ITMP5) - 1
              DO 602 ITMP6 = 0, LENBUF(ITMP5) - 1
                  IWORDS(NOFF2+ITMP6) = IVALUS(ITMP5)
 602          CONTINUE
 601      CONTINUE
      ELSE
          ITMP7 = IWORDS(NOFLOC+KURKEY) + LOC - 1
          GO TO (611, 612, 613), IWORDS(NOFTYP+KURKEY)
 
 611          IWORDS(ITMP7) = 1
              GO TO 900
 
 612          RVALUS(1)   = 1.
              CALL UCOPY2 (RVALUS(1), IWORDS(ITMP7), 1)
              GO TO 900
 
CF90  The call to UCOPY2 was confusing the compiler
 613          CALL UCOPY  (.TRUE., IWORDS(ITMP7), 1)
              GO TO 900
      END IF
C
C        Here we print the data card and any error messages,
C        if so required. Indent data cards according to 'READ'
C        nesting level.
C
 900  IF (LIST) THEN
          IF (IKEY .EQ. 3) THEN
              ITMP8 = ISTACK + 1
          ELSE IF ((IKEY .EQ. 4 .OR. IKEY .EQ. 5) .AND. .NOT. STOP) THEN
              ITMP8 = ISTACK + 3
          ELSE
              ITMP8 = ISTACK + 2
          END IF
          IF (SHIFT) ITMP8 = ITMP8 - 1
 
          WRITE (UNIT=LUNOUT, FMT=2105) BLANK(1:ITMP8)//BUFFER(1:IBFSIZ)
 
          IF (IERROR .NE. 0) THEN
              FFFLAG = FFFLAG + 1.
              GO TO (901, 902, 903, 904, 905,
     *               906, 907, 908, 909, 910, 915), IERROR
          END IF
 
      END IF
C
C     Check for end of input
C
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 901  WRITE (UNIT=LUNOUT, FMT=1001) ERRHDR
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 902  WRITE (UNIT=LUNOUT, FMT=1002) ERRHDR
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 903  WRITE (UNIT=LUNOUT, FMT=1003)  ERRHDR, IVALUE
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 904  WRITE (UNIT=LUNOUT, FMT=1004)  ERRHDR, IVALUE
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 905  WRITE (UNIT=LUNOUT, FMT=1005) ERRHDR
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 906  WRITE (UNIT=LUNOUT, FMT=1006) ERRHDR
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 907  WRITE (UNIT=LUNOUT, FMT=1007) ERRHDR, SYSKEY(IKEY)(1:IKEY-1)
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 908  WRITE (UNIT=LUNOUT, FMT=1008) ERRHDR
      IF (.NOT. STOP) GO TO 1
      GO TO  920
 
 909  WRITE (UNIT=LUNOUT, FMT=1009) ERRHDR, LOC-1
      IF (.NOT. STOP) GO TO 1
      GO TO 920
 
 910  WRITE (UNIT=LUNOUT, FMT=1010) ERRHDR
      IF (.NOT. STOP) GO TO 1
C
 915  WRITE (UNIT=LUNOUT, FMT=1012) ERRHDR, LUNIN
      IF (.NOT. STOP) GO TO 1
C
C        End of reading.
C        List keys if required
C
 920  IF (LISKEY) THEN
          WRITE (UNIT=LUNOUT, FMT=2101)
          MAXPOS = LEN (OUTBUF) - NCHKEY + 1
          OUTBUF = ' FFREAD KEYWORDS'
          IPOS   = 29
 
          DO 921 ITMP9 = 1, NSYSKY
              OUTBUF(IPOS:IPOS+NCHKEY-1) = SYSKEY(ITMP9)
              IPOS = IPOS + NCHKEY + 1
              IF (IPOS .GT. MAXPOS) THEN
                  WRITE (UNIT=LUNOUT, FMT=2103) OUTBUF
                  OUTBUF = ' '
                  IPOS = 29
              END IF
 921      CONTINUE
          IF (IPOS .NE. 29) WRITE (UNIT=LUNOUT, FMT=2103) OUTBUF
 
          WRITE (UNIT=LUNOUT, FMT=2102)
          OUTBUF = ' USER   KEYWORDS'
          IPOS   = 29
 
          DO 922 ITMP9 = 1, NKEYS
              CALL UHTOC (IWORDS(NOFKEY+ITMP9*NWDKEY), NCHWD,
     *                    OUTBUF(IPOS:IPOS+NCHKEY-1), NCHKEY)
              IPOS = IPOS + NCHKEY + 1
              IF (IPOS .GT. MAXPOS) THEN
                  WRITE (UNIT=LUNOUT, FMT=2103) OUTBUF
                  OUTBUF = ' '
                  IPOS = 29
              END IF
 922      CONTINUE
          IF (IPOS .NE. 29) WRITE (UNIT=LUNOUT, FMT=2103) OUTBUF
 
      END IF
C
C        All done !
C
      RETURN
C
C        FORMATs for all error messages.
C
1001  FORMAT (A,
     * 'KEY ''HOLL'' MUST BE FOLLOWED BY SPECIAL CHARACTER ',
     * 'NEITHER * NOR =')
1002  FORMAT (A,
     * 'KEY ''READ''/''WRITE'' MUST BE FOLLOWED BY AN INTEGER')
1003  FORMAT (A,
     * 'LUN', I12, ' FOR ''READ''/''WRITE'' OUT OF RANGE')
1004  FORMAT (A,
     * 'CAN''T READ FROM UNIT ', I3, ' BECAUSE OF STACK OVERFLOW')
1005  FORMAT (A,
     * 'SYNTAX ERROR')
1006  FORMAT (A,
     * 'TYPE MISMATCH OF KEY DECLARATION AND VALUE')
1007  FORMAT (A,
     * 'SECOND DELIMITER NOT FOUND. SCAN TERMINATED BY ''', A, '''')
1008  FORMAT (A,
     * 'COMMAND NOT FOUND IN DICTIONARY')
1009  FORMAT (A,
     * 'ADDRESS', I12, ' OUT OF RANGE')
1010  FORMAT (A,
     * 'DECK CANNOT START BY A CONTINUATION CARD')
1011  FORMAT
     * (' FFGO  --- NO KEYS ARE CURRENTLY DEFINED.'/
     *  '           YOU MUST BE JOKING!')
1012  FORMAT(A,
     *' FFGO  --- UNSET USER READ ROUTINE - UNIT ',I3,' SKIPPED.')
C
C        FORMAT for input.
C
2001  FORMAT (A)
C
C        FORMATs for output.
C
2101  FORMAT (/)
2102  FORMAT ( )
2103  FORMAT (' ', A)
2104  FORMAT ('1           USER''S DIRECTIVES TO RUN THIS JOB'/
     *        '            ----------------------------------'//)
2105  FORMAT (' ***** DATA CARD CONTENT   ', A)
 
      END
+DECK,  FFINIT.
      SUBROUTINE FFINIT (NW)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine intializes the FFREAD package.
C              If any keys had been previously specified,
C              they are erased with all associated information.
C
C      DUMMY ARGUMENTS:
C
C              NW specifies the number of words allocated by the
C              user in common CFREAD. This can be used to increase
C              the number of available keys.
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              The common CFREAD is initialized with default information.
C
C      SIDE EFFECTS:
C
C              Any information set up by previous calls to FFREAD routines
C              is destroyed. Users of FFREAD (which calls FFINIT with
C              NW=0) can call FFINIT(NW) before calling FFREAD.
C
      EXTERNAL FFUSER
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   CFREAD.
+CDE,   FFCOMM.
C
C--- Define initial value for NWORDS (so FFREAD users can call FFINIT)
      DATA NWINIT/ NCSIZE/
C----------------- Beginning of executable statements -------------------------
C
C        Initialize default unit numbers and input file stack
C
      LINPUT = LENDEF
      LUNIN  = LUNDIN
      LUNOUT = LUNDUT
      ISTACK = 0
C
C        Initialize jump addresses
C
      CALL VFILL(KFJUMP,NFJUMP,IQANIL)
      CALL FFUSET(FFUSER)
C
C        Default key size and associated values
C
      NCHKEY = NCHKYD
      NKEYS  = 0
      NWDKEY = (NCHKEY+NCHWD-1) / NCHWD
C
C        Set size of common, check for at least one key possible if NW not 0
C
      IF (NW .EQ. 0) THEN
          NWORDS = NWINIT
      ELSE
          IF (NW .GE. NOVERH+NWDKEY+NKYOVH) THEN
              NWORDS = NW - NOVERH
          ELSE
              WRITE (UNIT=LUNOUT, FMT=1001) NW
              NWORDS = NCSIZE
          END IF
C        Remember NWORDS in NWINIT for later FFINIT(0) call by FFREAD
          NWINIT= NWORDS
      END IF
 
      MAXKEY = NWORDS / (NWDKEY + NKYOVH)
C
C        Calculate offsets into IWORDS for different arrays
C
      NOFLEN = MAXKEY   -      1 + 1
      NOFTYP = MAXKEY*2 -      1 + 1
      NOFKEY = MAXKEY*3 - NWDKEY + 1
C
C        Initialize character options for FFGET, FFKEY, and FFSET.
C
      CALL UCTOH ('SIZE', IFFOPT(1), NCHWD, 4)
      CALL UCTOH ('LENG', IFFOPT(2), NCHWD, 4)
      CALL UCTOH ('LINP', IFFOPT(3), NCHWD, 4)
      CALL UCTOH ('LOUT', IFFOPT(4), NCHWD, 4)
      CALL UCTOH ('NBIT', IFFOPT(5), NCHWD, 4)
      CALL UCTOH ('NCHW', IFFOPT(6), NCHWD, 4)
      CALL UCTOH ('NBCH', IFFOPT(7), NCHWD, 4)
      CALL UCTOH ('NCHK', IFFOPT(8), NCHWD, 4)
 
      CALL UCTOH ('INTE', KEYOPT(1), NCHWD, 4)
      CALL UCTOH ('REAL', KEYOPT(2), NCHWD, 4)
      CALL UCTOH ('LOGI', KEYOPT(3), NCHWD, 4)
C
C        Reset error counter
C
      FFFLAG = 0.
      RETURN
 
1001  FORMAT
     * (' FFINIT --- INVALID PARAMETER NW =', I12,
     *  ' - DEFAULT ASSUMED')
 
      END
+DECK,  FFKEY.
      SUBROUTINE FFKEY (KEY, ADRESS, LENGTH, CHTYPE)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine accepts the definition of a user key
C              for later use by FFGO.
C
C      DUMMY ARGUMENTS:
C
C              KEY    - character string containing the key to use
C              ADRESS - variable/array to store values to
C              LENGTH - number of values associated with this key
C              CHTYPE - character string containing either INTE, REAL,
C                       or LOGI to signify ADRESS contains integer,
C                       floating point, or logical data, respectively.
C
C      IMPLICIT INPUTS:
C
C              The currently defined keys are checked for unambiguity
C              of the new key. If no more keys can be defined, an error
C              message is issued.
C
C      IMPLICIT OUTPUTS:
C
C              CFREAD is updated to include the new information.
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   CFREAD.
      CHARACTER KEY*(*), CHTYPE*(*)
CF90  Declare ADRESS as integer to avoid consistency checking by LOCF
      INTEGER   ADRESS(1)
      INTEGER FFFIND
 
      CHARACTER KEYSTR*(NCHMAX)
C
C----------------- Beginning of executable statements -------------------------
C
C        Get key string into local variable, possibly truncating it
C
      KEYSTR(1:NCHKEY) = KEY
C
C        Check whether enough space for a new key
C
      IF (NKEYS .LT. MAXKEY) THEN
C
C        Check key for ambiguity (convert to upper case if necesssary).
C        This also gives us the place to insert it.
C
+SELF,  IF=UPLOW.
          CALL FFUPCA (KEYSTR, 1, NCHKEY)
+SELF.
          IPOINT = FFFIND (KEYSTR)
 
          IF (IPOINT .GT. 0) THEN
              WRITE (UNIT=LUNOUT, FMT=1001) KEYSTR(1:NCHKEY)
              RETURN
          END IF
C
C        Check length is positive
C
          IF (LENGTH .LE. 0) THEN
              WRITE (UNIT=LUNOUT, FMT=1002) KEYSTR(1:NCHKEY)
              RETURN
          END IF
C
C        Find which type of key it is
C
          CALL UCTOH (CHTYPE, NTYPE, NCHWD, MIN (LEN (CHTYPE), 4) )
          ITYPE = IUCOMP (NTYPE, KEYOPT, 3)
C
C        Count this key and make room for it if necessary
C
          NKEYS  = NKEYS + 1
          IPOINT = - IPOINT
          ITEMP  =   NOFKEY + IPOINT*NWDKEY
 
          IF (IPOINT .NE. NKEYS) THEN
              CALL UCOPY2 (IWORDS(NOFLOC+IPOINT  ),
     *                     IWORDS(NOFLOC+IPOINT+1), NKEYS-IPOINT)
              CALL UCOPY2 (IWORDS(NOFLEN+IPOINT  ),
     *                     IWORDS(NOFLEN+IPOINT+1), NKEYS-IPOINT)
              CALL UCOPY2 (IWORDS(NOFTYP+IPOINT  ),
     *                     IWORDS(NOFTYP+IPOINT+1), NKEYS-IPOINT)
              CALL UCOPY2 (IWORDS(ITEMP),
     *                     IWORDS(ITEMP+NWDKEY), NWDKEY*(NKEYS-IPOINT))
          END IF
C
C        Now fill in data as appropriate
C
          IWORDS(NOFLOC+IPOINT) = LOCF(ADRESS) - LOCF(IWORDS) + 1
          IWORDS(NOFLEN+IPOINT) = LENGTH
          IWORDS(NOFTYP+IPOINT) = ITYPE
          CALL UCTOH  (KEYSTR, IWORDS(ITEMP), NCHWD, NCHKEY)
      ELSE
C
C        Not enough room for this key, sorry.
C
          WRITE (UNIT=LUNOUT, FMT=1003) KEYSTR(1:NCHKEY)
      END IF
      RETURN
 
1001  FORMAT
     * (' FFKEY  --- REPEATED DEFINITION OF ''', A, ''' - CALL IGNORED')
1002  FORMAT
     * (' FFKEY  --- INVALID LENGTH FOR ''', A, ''' - TRY AGAIN')
1003  FORMAT
     * (' FFKEY  --- NO SPACE TO DEFINE ''', A, ''' - CALL IGNORED')
 
      END
+DECK,  FFREAD.
      SUBROUTINE FFREAD (NKEY, KEY, LOCVAR, LENVAR)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This is the old-fashioned form of using FFREAD and is
C              only supplied for backward compatibility.
C
C              If NKEY is set to 0, it is used to modify the values for
C              the default input/output LUNs.
C
C              If NKEY is negative, it will return them.
C
C              If NKEY is positive, it specifies the number of keys
C              in KEY. The keys will be set up and FFGO called to do
C              the work.
C
C      DUMMY ARGUMENTS:
C
C              NKEY   - number of keys. Different actions depending on
C                       sign of NKEYS are described above.
C              KEY    - array containing user's keys, one per machine word,
C                       with NCHKYD (four) significant characters.
C              LOCVAR - locations of variables/arrays to change as returned
C                       by LOCF.
C              LENVAR - length of array at location given in LOCVAR.
C
C      IMPLICIT INPUTS:
C
C              The data cards entered by the user.
C
C      IMPLICIT OUTPUTS:
C
C              The data cards read modify appropriate locations in memory.
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   CFREAD.
      INTEGER KEY(1), LOCVAR(1), LENVAR(1)
 
      CHARACTER KEYSTR*(NCHKYD)
 
      INTEGER LFFIN, LFFOUT
      DATA LFFIN / LUNDIN /, LFFOUT / LUNDUT /
C
C----------------- Beginning of executable statements -------------------------
C
C        NKEY < 0: Return values of input/output LUNs
C
      IF (NKEY .LT. 0) THEN
          LOCVAR(1) = LFFIN
          LENVAR(1) = LFFOUT
          RETURN
      END IF
C
C        NKEY = 0: Set values of input/output LUNs
C
      IF (NKEY .EQ. 0) THEN
          IF (LOCVAR(1) .NE. 0) LFFIN  = LOCVAR(1)
          IF (LENVAR(1) .NE. 0) LFFOUT = LENVAR(1)
          RETURN
      END IF
C
C        Here for the real work. First, initialize.
C
      CALL FFINIT (0)
      IF (LFFIN  .NE. LUNDIN) CALL FFSET ('LINP', LFFIN)
      IF (LFFOUT .NE. LUNDUT) CALL FFSET ('LOUT', LFFOUT)
C
C        Extract the keys and call FFKEY for each.
C
      DO 1 I = 1, NKEY
          CALL UHTOC (KEY(I), NCHKYD, KEYSTR, NCHKYD)
          IADRES = LOCVAR(I) - LOCF(IWORDS) + 1
          CALL FFKEY (KEYSTR, IWORDS(IADRES), LENVAR(I), 'NONE')
    1 CONTINUE
C
C        Now let FFGO do the rest.
C
      CALL FFGO
      RETURN
 
      END
+DECK,  FFRSET.
      SUBROUTINE FFRSET (LUNSUB, FFRSUB)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routines stores the address of FFRSUB (to be
C              declared EXTERNAL in the calling program). When a
C              data card READ is encountered, if the number of the
C              logical unit is -LUNSUB, then this routine will be
C              used to input the next data card.
C
C      DUMMY ARGUMENTS:
C
C              LUNSUB - absolute value of the negative logical unit
C                       associated with this subroutine. Must be:
C                             0 < LUNSUB < NFJUMP
C              FFRSUB - routine to be called when reading is directed
C                       to unit -LUNSUB via a READ data cards. This
C                       routine has the following calling sequence:
C
C                         SUBROUTINE FFRSUB(IBUSIZ)
C
C                         Where:
C
C                         IBUSIZ   - Length of the character string
C                                    to be returned with the data card,
C                                    blank padded.
C
C                         the string may be accessed using the common FFCHAR:
C
C                         COMMON / FFCHAR / STRING
C                         CHARACTER*132 STRING
C
C
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              The appropriate value in common CFREAD is changed.
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   FFCOMM.
+CDE,   CFREAD.
C
C----------------- Beginning of executable statements -------------------------
C
C        Check if logical unit within range
C
      IF(LUNSUB.LE.0.OR.LUNSUB.GT.NFJUMP) THEN
        WRITE (UNIT=LUNOUT, FMT=1001) LUNSUB
        GO TO 999
      END IF
      KFJUMP(LUNSUB) = JUMPAD(FFRSUB)
 
 999  CONTINUE
 
1001  FORMAT
     * (' FFRSET --- INVALID VALUE', I12,
     *  ' FOR LUNSUB - ADDRESS NOT STORED')
      END
+DECK,  FFSET.
      SUBROUTINE FFSET (CHOPT, IVALUE)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This sets some values which are optional within FFREAD.
C
C      DUMMY ARGUMENTS:
C
C              CHOPT  - Character argument specifying which item to change.
C                       Valid are:
C                         LENG - set # of significant characters on data cards
C                         LINP - change input  LUN
C                         LOUT - change output LUN
C                         SIZE - set key size in number of characters.
C                                This must be at least 4 and cannot be
C                                greater than NCHMAX.
C                       The last option, SIZE, can only be specified
C                       after a call to FFINIT and before the first
C                       call to FFKEY/FFGO.
C              IVALUE - Value of the desired argument
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              The appropriate value in common CFREAD is changed.
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,   FFMACH.
+CDE,   FFLUNS.
+CDE,   FFCOMM.
+CDE,   CFREAD.
      CHARACTER CHOPT*(*)
C
C----------------- Beginning of executable statements -------------------------
C
C        Check option and dispatch on it
C
      CALL UCTOH (CHOPT, NCHOPT, NCHWD, MIN (LEN (CHOPT), 4) )
      IOPT = IUCOMP (NCHOPT, IFFOPT, 4)
      GO TO (1, 2, 3, 4), IOPT
 
      WRITE (UNIT=LUNOUT, FMT=1005) NCHOPT
      RETURN
 
   1  IF (NKEYS .EQ. 0) THEN
          IF (     IVALUE .GE.       4
     *       .AND. IVALUE .LE.  NCHMAX
     *       .AND. IVALUE .LT. (NWORDS-NKYOVH)*NCHWD) THEN
              NCHKEY = IVALUE
              NWDKEY = (NCHKEY+NCHWD-1) / NCHWD
              MAXKEY = NWORDS / (NWDKEY + NKYOVH)
              NOFLEN = MAXKEY   -      1 + 1
              NOFTYP = MAXKEY*2 -      1 + 1
              NOFKEY = MAXKEY*3 - NWDKEY + 1
          ELSE
              WRITE (UNIT=LUNOUT, FMT=1001) IVALUE
          END IF
      ELSE
          WRITE (UNIT=LUNOUT, FMT=1002)
      END IF
      RETURN
 
   2  IF (IVALUE .GE. LENMIN .AND. IVALUE .LE. LENMAX) THEN
          LINPUT = IVALUE
      ELSE
          WRITE (UNIT=LUNOUT, FMT=1003) IVALUE
      END IF
      RETURN
 
   3  IF (IVALUE .GE. -NFJUMP .AND. IVALUE .LE. LUNMAX) THEN
          LUNIN  = IVALUE
      ELSE
          WRITE (UNIT=LUNOUT, FMT=1004) IVALUE, 'INPUT'
      END IF
      RETURN
 
   4  IF (IVALUE .GE. 0 .AND. IVALUE .LE. LUNMAX) THEN
          LUNOUT = IVALUE
      ELSE
          WRITE (UNIT=LUNOUT, FMT=1004) IVALUE, 'OUTPUT'
      END IF
      RETURN
 
1001  FORMAT
     * (' FFSET  --- INVALID VALUE', I12,
     *  ' FOR KEY SIZE - NOT CHANGED')
1002  FORMAT
     * (' FFSET  --- INVALID STATE FOR OPTION ''SIZE'' - IGNORED')
1003  FORMAT
     * (' FFSET  --- INVALID VALUE', I12,
     *  ' FOR CARD LENGTH - NOT CHANGED')
1004  FORMAT
     * (' FFSET  --- INVALID LUN', I12,
     *  ' FOR ', A, ' - NOT CHANGED')
1005  FORMAT
     * (' FFSET  --- UNRECOGNIZED OPTION ''', A4, ''' - TRY AGAIN')
 
      END
+DECK,  FFSKIP.
      SUBROUTINE FFSKIP (BUFFER, KURSOR)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine skips over blanks in BUFFER, starting
C              at position KURSOR. The position of the first non-blank
C              character is returned in KURSOR; if none is found, KURSOR
C              will equal LEN (BUFFER) + 1.
C
C      DUMMY ARGUMENTS:
C
C              BUFFER - passed length character string
C              KURSOR - input:  starting position
C                       output: position of first non-blank character
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C      SIDE EFFECTS:
C
C              NONE
C
      CHARACTER BUFFER*(*)
C
C----------------- Beginning of executable statements -------------------------
C
C
C        Loop over all characters remaining
C
      DO 1 I = KURSOR, LEN(BUFFER)
          IF (BUFFER(I:I) .NE. ' '
+SELF,  IF=TABS.
     *       .AND. ICHAR (BUFFER(I:I)) .NE. 9
+SELF.
     *       ) GO TO 2
1     CONTINUE
 
2     KURSOR = I
 
      END
+DECK,  FFUPCA, IF=UPLOW.
      SUBROUTINE FFUPCA (STRING, IPOS, LENGTH)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine will convert all characters in
C              STRING(IPOS:IPOS+LENGTH-1) to upper case.
C
C      DUMMY ARGUMENTS:
C
C              STRING - passed length character string to be converted
C                       to upper case (done in place)
C              IPOS   - starting position
C              LENGTH - number of characters to convert
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C      SIDE EFFECTS:
C
C              NONE
C
+SELF,  IF=-EBCDIC.
      PARAMETER (IDIFF = -32)
+SELF,  IF= EBCDIC.
      PARAMETER (IDIFF =  64)
+SELF.
      CHARACTER STRING*(*)
C
C----------------- Beginning of executable statements -------------------------
C
C        Loop over characters and substitute if lower case
C
      DO 1 I = IPOS, IPOS + LENGTH - 1
          J = ICHAR (STRING(I:I))
          IF (J .GE. ICHAR ('a') .AND. J .LE. ICHAR ('z'))
     *        STRING(I:I) = CHAR (J + IDIFF)
1     CONTINUE
 
      END
+DECK,  FFUSER.
      SUBROUTINE FFUSER (KEY)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This is a dummy user routine which does nothing.
C
C      DUMMY ARGUMENTS:
C
C              KEY - This is an array containing the current key
C                    stored in hollerith, blank padded to the
C                    defined length of a key.
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C      SIDE EFFECTS:
C
C              NONE
C
      INTEGER KEY(1)
 
      END
+DECK,  FFUSET
      SUBROUTINE FFUSET(FUSUB)
C
C      FUNCTIONAL DESCRIPTION:
C
C              This routine stores the address of the user
C              routine which should be called when a key
C              is preceded by an *. This routine can be
C              called at any time to redefine the address
C              of the user routine, but AFTER FFINIT. If
C              this routine is not called, the default
C              routine FFUSER will be used
C
C      DUMMY ARGUMENTS:
C
C              FUSUB - routine to be called (to be declared
C                      EXTERNAL in the caling program)
C
C      IMPLICIT INPUTS:
C
C              NONE
C
C      IMPLICIT OUTPUTS:
C
C              NONE
C
C      SIDE EFFECTS:
C
C              NONE
C
+CDE,  FFCOMM.
+CDE,  FFMACH.
C
      KUJUMP = JUMPAD(FUSUB)
C
      END
+PATCH,TFFREAD.
+DECK,  MAIN.
+SELF,  IF=CDC.
      PROGRAM FFTEST(INPUT,OUTPUT)
+SELF,  IF=-CDC.
      PROGRAM FFTEST
+SELF.
 
      INTEGER I, J(10)
      REAL    X, Y(10)
      LOGICAL A, B(10)
      CHARACTER*4 TEXT
      EXTERNAL FUREAD, FUSTAR
C
C----------------- Beginning of executable statements -------------------------
C
      I = 0
      X = 0.
      A = .FALSE.
 
      DO 10 K = 1, 10
          J(K) = 0
          Y(K) = 0.
          B(K) = .FALSE.
  10  CONTINUE
 
      CALL FFINIT (0)
 
      CALL FFSET ('SIZE', 6)
 
      CALL FFRSET( 10, FUREAD)
 
      CALL FFKEY ('INTVAR',   I,  1, 'INTEGER')
      CALL FFKEY ('INTARRAY', J, 10, 'INTEGER')
 
      CALL FFKEY ('REALVAR',   X,  1, 'REAL')
      CALL FFKEY ('REALARRAY', Y, 10, 'REAL')
 
      CALL FFKEY ('LOGVAR',   A,  1, 'LOGICAL')
      CALL FFKEY ('LOGARRAY', B, 10, 'LOGICAL')
 
      CALL FFGO
 
      WRITE (*, *)
 
      WRITE (*, *) ' INTEGER VARIABLE:', I
      WRITE (*, *) ' INTEGER ARRAY:   ', (J(K), K = 1, 5)
      WRITE (*, *) '                  ', (J(K), K = 6,10)
      WRITE (*, *)
 
      WRITE (*, *) ' LOGICAL VARIABLE:', A
      WRITE (*, *) ' LOGICAL ARRAY:   ', (B(K), K = 1, 5)
      WRITE (*, *) '                  ', (B(K), K = 6,10)
      WRITE (*, *)
 
      CALL UHTOC (X, 4, TEXT, 4)
      WRITE (*, *) ' TEXT (REALVAR):  ''', TEXT, ''''
      WRITE (*, *) ' REAL    ARRAY:   ', (Y(K), K = 1, 4)
      WRITE (*, *) '                  ', (Y(K), K = 5, 8)
      WRITE (*, *) '                  ', (Y(K), K = 9,10)
 
      END
+DECK,  FFUSER.
      SUBROUTINE FFUSER (KEY)
 
      DIMENSION KEY(1)
      CHARACTER*6 KEYSTR
C
C----------------- Beginning of executable statements -------------------------
C
      CALL FFGET ('NCHW', NCHW)
      CALL UHTOC(KEY, NCHW, KEYSTR, 6)
 
      WRITE (*, *) ' STANDARD FFUSER CALLED WITH KEY ''', KEYSTR, ''''
      WRITE (*, *)
 
      END
+DECK,  FUSTAR.
      SUBROUTINE FUSTAR (KEY)
 
      DIMENSION KEY(1)
      CHARACTER*6 KEYSTR
C
C----------------- Beginning of executable statements -------------------------
C
      CALL FFGET ('NCHW', NCHW)
      CALL UHTOC(KEY, NCHW, KEYSTR, 6)
 
      WRITE (*, *)
     +    ' USER ACTION ROUTINE CALLED WITH KEY ''', KEYSTR, ''''
      WRITE (*, *)
 
      END
+DECK,  FUREAD.
      SUBROUTINE FUREAD (IBFSIZ)
 
      COMMON / FFCHAR / STRING
      CHARACTER*132 STRING
      EXTERNAL FUSTAR
C
C----------------- Beginning of executable statements -------------------------
C
      DATA ITIME /0/
+SELF,IF=SAVE.
      SAVE ITIME
+SELF
      ITIME = ITIME + 1
      WRITE(*,*) 'User reading routine called'
      IF(ITIME.EQ.1) THEN
        WRITE(STRING(1:IBFSIZ),'(''*INTARRAY 7=-77'')')
      ELSE IF(ITIME.EQ.2) THEN
        CALL FFUSET(FUSTAR)
        WRITE(STRING(1:IBFSIZ),'(''REALARRAY 7=-77.'')')
      ELSE IF(ITIME.EQ.3) THEN
        WRITE(STRING(1:IBFSIZ),'(''*LOGARRAY 7=OFF'')')
      ELSE IF(ITIME.EQ.4) THEN
        WRITE(STRING(1:IBFSIZ),'(''END'')')
      END IF
      END
+DECK,  FFDATA, T=DATA.
LIST
INTVAR 127
INTARRAY 3=5.7 2*12 (THIS IS A COMMENT) 10=1 1=2*4
C YOU CAN PUT ANYTHING ON A CARD LIKE THIS - IT IS IGNORED COMPLETELY
* THIS ALSO IS A COMMENT CARD - IT IS IGNORED AS WELL
 
LOGVAR 1 (THIS PRODCUES AN ERROR!)
LOGVAR 2=TRUE (THIS ONE ALSO)
 
READ -300
(THIS SHOULD GIVE AN ERROR !)
 
*LOGVAR FALSE
LOGARRA ON OFF T F TRUE FALS FALSE 9=2*TRUE
 
CBLABLA (THIS IS AN UNKNOWN COMMAND AND PRODUCES AN ERROR)
 
REALVAR                                         'TEXT'
*REALARRAY 1 -1 1. -1.456
           3.76E-2  1 =5.7 6=-6.2E03 8=3*.9995 (THIS IS A CONTINUATION CARD)
READ -10
STOP
