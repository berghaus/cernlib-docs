\section{Kinetic model algorithm.}

 The kinetic algorithm can be considered as a step by step
updating of a particle vector:
\begin{enumerate}
\item Create a vector of particles: assign initial
particle types, their coordinates and momenta etc. Assign initial value
for time evolution parameter;
\item  For choosen time evolution parameter step find pairs of particles
(according to a collision criterion), which are assumed to collide and
particles (according to their life times), which are assumed to decay; 
\item  Perform particle collisions and particle decays. Collisions and
decays convert incoming particles  into outgoing particles. During this
step one should update also particle coordinates and momenta (particle 
propagation); 
\item Starting from (2) perform the next step.
\end{enumerate}

At any evolution parameter step one needs a possibility to interupt
"updating" process.
Thus at
 each evolution time step  for the system consisting
from $n$ particles we are looking for the particles, which will decay
according to their lifetimes and the pairs $(i,j)$, where $i\neq j$ and
$i,j = 1,2,...,n$, of particles, which will collide according to the
choosen collision criterion. The collision pairs are ordered
chronologically using their collision times.  This algorithm is very
simple and general enough but it is CPU time consuming if $n$ is large, 
e. g. during
nucleus-nucleus collision at high energy, because at each time step we
need to perform $n(n-1)/2 \sim n^2$ computations. 
 
If we neglect by field interaction and keep only particle collisions and 
decays (the cascade option), when
particles move along straight trajectories, after each collision we
only have to look for the collisions between new produced particles and
the existing particles. We also do not need to use fixed time step. We 
need to "shift" system on time between events of collisions or decays.
 Then the number of computations at given time 
will be $n_{new}n$, where $n_{new}$ is the number of produced particles
during the former time step. It should be noted that in this case we 
have to maintain
 the list of
potential particle collision or decay events.
Using "cascade" algorithm describing evolution of system we have the criterion 
to stop calculation process: the list of potential particle collision or 
decay events is empty.
