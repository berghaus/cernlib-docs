\documentstyle{report}
\newcommand{\DEFMENU}[2]{
  \ifcase#1 \chapter{#2}
  \or \section{#2}
  \or \subsection{#2}
  \else \subsubsection{#2}
  \fi
}
\newcommand{\DEFCMD}[4]{
  \subsubsection{#3 #4\label{#1}\index{#3}\index{#2/#3}}}
\newcommand{\BEGARG}{
  \begin{tabular}{llll}}
\newcommand{\DEFARG}[4]{
  {\tt #1}&{\tt #3}&{\em #2}&{\tt #4}\\}
\newcommand{\ENDARG}{\end{tabular}\par}
\newcommand{\BEGTEXT}{\par}
\newcommand{\ENDTEXT}{}
\begin{document}

\DEFMENU{0}{KUIP}
\BEGTEXT
Command Processor commands.
\ENDTEXT

\DEFCMD{K0HELP}{/KUIP}{HELP}{[ item ]}
\BEGARG
\DEFARG{ITEM}{Command name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Give the help of a command.
If a command is supplied as parameter ITEM, its full explanation is given:
syntax (as given by the command USAGE), explanation of the functionality,
list of parameters with their attributes (prompt, type, default, range, etc.).
'HELP /' gives the help for all commands.

If HELP is entered without parameters, the dialogue style is switched
to 'AN', guiding the user in traversing the tree command structure.

'HELP -EDIT' (or just 'HELP -E') switch the help in the edit mode.
This mode is currently implemented on IBM/VM-CMS and Apollo:
instead of writing the help text on the terminal output,
it is written into a temporary file and the editor is invoked,
XEDIT on IBM/VM-CMS or a new pad window on the Apollo
(see also command SET\_SHOW/HOST\_EDITOR).
'HELP -NOEDIT' (or just 'HELP -N' or 'HELP -') switch the help in
the standard mode.
\ENDTEXT

\DEFCMD{K0USAGE}{/KUIP}{USAGE}{[ cmnd ]}
\BEGARG
\DEFARG{CMND}{Command name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Give the syntax of a command.
If CMND='/' the syntax of all commands is given.
\ENDTEXT

\DEFCMD{K0MANUAL}{/KUIP}{MANUAL}{[ item outfil docsys ]}
\BEGARG
\DEFARG{ITEM}{Command name or help (key)word}{C}{D=' ' }
\DEFARG{OUTFIL}{Output file name}{C}{D=' ' }
\DEFARG{DOCSYS}{Text formatting system}{C}{D=' ' R=' ,SGML,TEX,LATEX' }
\ENDARG
\BEGTEXT
Write on a file the text formatted help of a command.
If OUTFIL=' ' the text is written to the terminal.
It works like the command HELP ITEM, plus a text formatting option:
if DOCSYS is not a blank the output is formatted according to the selected
documentation and text formatting system (ex. SGML, TEX, LATEX, etc.).
Example:
\begin{verbatim}
 MANUAL / FILE.DOC SGML
\end{verbatim}
will produce a file named FILE.DOC
containing the SGML input to be processed
by SGML in order to have the documentation of all the available commands.
\ENDTEXT

\DEFCMD{K0LISTHE}{/KUIP}{LISTHELP}{[ lstnam ]}
\BEGARG
\DEFARG{LSTNAM}{List name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Help for lists.
If a list is specified, display its attributes (D='dynamic', S='static',
T='temporary', P='permanent') and a description of the list and its use.
Otherwise display the names of all of the known lists.
'LISTHELP /' gives help for all lists.
\ENDTEXT

\DEFCMD{K0EDIT}{/KUIP}{EDIT}{fname }
\BEGARG
\DEFARG{FNAME}{File name}{C}{}
\ENDARG
\BEGTEXT
Invoke the default host editor.
The file FNAME.KUMAC (the extension KUMAC is taken automatically
unless FNAME contains already a dot) is given to the editor and,
if it does not exist, a new file is created with this name.
Use the command SET\_SHOW/HOST\_EDITOR to change the default editor.
\ENDTEXT

\DEFCMD{K0LAST}{/KUIP}{LAST}{[ n fname ]}
\BEGARG
\DEFARG{N}{N last commands to be saved}{I}{D=-1 }
\DEFARG{FNAME}{File name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Perform various operations with the history file.

If FNAME is not specified, the current history file is assumed by default
(the startup history file name is LAST.KUMAC).
To change the history file the command LAST 0 NEWFNAME must be entered.

If N=-1 (default case) the default host editor is called
to edit the current history file, containing all the commands of the session.

If N=0 the history file FNAME is rewound and set as the current one
(the command LAST 0 FNAME itself is not recorded).

If N>0 the last N commands of the session are saved in the
current history file.

See also the command SET\_SHOW/RECORDING.
\ENDTEXT

\DEFCMD{K0MESSAG}{/KUIP}{MESSAGE}{[ string ]}
\BEGARG
\DEFARG{STRING}{Message string}{C}{D=' ' }
\ENDARG
\BEGTEXT
Write a message string on the terminal.
A useful command inside a macro.
Several message strings can be given in the same command line,
each of them separated by one or more spaces
(the usual parameter separator);
therefore multiple blanks will be dropped
and only one will be kept.
If multiple blanks have not to be dropped,
the string must be surrounded by single quotes.
\ENDTEXT

\DEFCMD{K0SHELL}{/KUIP}{SHELL}{[ cmd ]}
\BEGARG
\DEFARG{CMD}{Shell command}{C}{D=' ' }
\ENDARG
\BEGTEXT
Execute a command of the host operating system.
To execute just one command enter SHELL COMMAND;
otherwise enter just SHELL and wait for the system prompt.
After the last command enter RETURN (the full word, not just <CR>)
to go back to the application.
\ENDTEXT

\DEFCMD{K0WAIT}{/KUIP}{WAIT}{[ string sec ]}
\BEGARG
\DEFARG{STRING}{Message string}{C}{D=' ' }
\DEFARG{SEC}{Number of seconds}{R}{D=0 }
\ENDARG
\BEGTEXT
Make a pause (e.g. inside a macro).
Wait a given number of seconds (if SEC.GT.0)
or just until <CR> is entered (if SEC.LE.0).
A message string is also written on the terminal before waiting.
\ENDTEXT

\DEFCMD{K0UNITS}{/KUIP}{UNITS}{}
\BEGTEXT
List all Input/Output logical units currently open.
The files attached to them are also shown.
\ENDTEXT

\DEFCMD{K0EXIT}{/KUIP}{EXIT}{}
\BEGTEXT
End of the interactive session.
\ENDTEXT

\DEFCMD{K0QUIT}{/KUIP}{QUIT}{}
\BEGTEXT
End of the interactive session.
\ENDTEXT

\DEFCMD{K0FUNCTI}{/KUIP}{FUNCTIONS}{}
\BEGTEXT
KUIP System Functions.
The function name (and arguments) is literally replaced,
at run-time, by its current value.
At present, the following functions are available:
\begin{verbatim}
 $DATE  .......................  Current date in format DD/MM/YY
 $TIME  .......................  Current time in format HH.MM.SS
 $CPTIME  .....................  CP time elapsed since last call (in sec)
 $RTIME  ......................  Real time elapsed since last call (in sec)
 $VDIM(VNAME,IDIM)  ...........  Physical length of vector VNAME
                                 on dimension IDIM (1..3)
 $VLEN(VNAME,IDIM)  ...........  As above, but for the logical length
                                 (i.e. stripping trailing zeroes)
 $NUMVEC  .....................  Current number of vectors
 $VEXIST(VNAME)  ..............  Index of vector VNAME
                                 (1..$NUMVEC or 0 if VNAME does not exist)
 $SUBSTRING(STRING,IX,NCH)  ...  STRING(IX:IX+NCH-1)
 $UPPER(STRING)  ..............  STRING changed to upper case
 $LOWER(STRING)  ..............  STRING changed to lower case
 $LEN(STRING)  ................  Length of STRING, stripping
                                 leading/trailing blanks and single quotes
 $SIGMA(SIGMA_Expression)  ....  Result of SIGMA_Expression, computed by SIGMA
 $ARGS  .......................  Command line at program invocation
 $KEYNUM  .....................  Address of latest clicked key in style GP
 $KEYVAL  .....................  Value of latest clicked key in style GP
 $LAST  .......................  Latest command line executed
 $ANUM  .......................  Number of aliases
 $ANAM(I)  ....................  Name of I-th alias
 $AVAL(I)  ....................  Value of I-th alias
 $STYLE  ......................  Current style as defined by SET/STYLE
\end{verbatim}
\ENDTEXT


\DEFMENU{1}{ALIAS}
\BEGTEXT
Operations with aliases.
Aliases are defined to provide shortcut abbreviations for the input line or
some part of it. An alias name can be any string of characters
(excepted the single quote and the blank) and whenever encountered
in an input line it will be literally replaced by its value (another string
of characters).
Alias substitution does not apply in quoted strings.
Aliases need separators to be recognized in the input line, namely:
\begin{verbatim}
 blank  /  ,  =  :  .  %  '  (  )
\end{verbatim}
To juxtaposition aliases, a double slash can be used as concatenation sign.
Be careful not defining aliases recursively.
\ENDTEXT

\DEFCMD{KACREATE}{/KUIP/ALIAS}{CREATE}{aname string [ chopt ]}
\BEGARG
\DEFARG{ANAME}{Alias name}{C}{}
\DEFARG{STRING}{Equivalent string}{C}{}
\DEFARG{CHOPT}{Option}{C}{D=' ' R=' ,C' }
\ENDARG
\BEGTEXT
Create an alias named ANAME corresponding to STRING.
Also switch ON the alias translation, i.e. ALIAS/TRANSLATION ON.
If CHOPT='C' then the alias is a command alias, i.e. an alias that
will only be translated when it is the first token on a command line.
Example:
\begin{verbatim}
 Alias/Create GG Graph/Struct/Scratch
 Alias/Create FF File1/Name1/Name2
 GG FF/ID
\end{verbatim}
is equivalent to
\begin{verbatim}
 Graph/Struct/Scratch File1/Name1/Name2/ID
\end{verbatim}

\begin{verbatim}
 Alias/Create LS DIR C
\end{verbatim}
is equivalent to
\begin{verbatim}
 DIR
\end{verbatim}
only when LS is the first token on a command line. In the following case
LS will not be translated
\begin{verbatim}
 SHELL LS
\end{verbatim}
\ENDTEXT

\DEFCMD{KALIST}{/KUIP/ALIAS}{LIST}{}
\BEGARG
\ENDARG
\BEGTEXT
List all aliases (name, equivalent string).
\ENDTEXT

\DEFCMD{KADELETE}{/KUIP/ALIAS}{DELETE}{alist }
\BEGARG
\DEFARG{ALIST}{Alias list}{C}{}
\ENDARG
\BEGTEXT
Delete the definition of aliases in the list ALIST.
The aliases are separated in the list by a comma and
imbedded blanks are not allowed.
If ALIST='*' then delete all aliases
and the alias translation is switched OFF
(i.e.: ALIAS/TRANSLATION OFF is executed).
\ENDTEXT

\DEFCMD{KATRANSL}{/KUIP/ALIAS}{TRANSLATION}{[ option ]}
\BEGARG
\DEFARG{OPTION}{Option}{C}{D='ON' R='ON,OFF,?' }
\ENDARG
\BEGTEXT
Switch ON/OFF the alias translation.
If OFF, alias definitions are not used in parsing the command lines.
It is automatically switched ON when an alias is created.
If OPTION='?' the current value is shown.
The startup value is OFF.
\ENDTEXT


\DEFMENU{1}{SET\_SHOW}
\BEGTEXT
Set or show various KUIP parameters and options.
\ENDTEXT

\DEFCMD{KSSTYLE}{/KUIP/SET\_SHOW}{STYLE}{[ option sgylen sgsize sgyspa sgbord wktype ]}
\BEGARG
\DEFARG{OPTION}{Option}{C}{D='?' R='?,C,AN,AL,G,GW,GS,GP' }
\DEFARG{SGYLEN}{max Y LENgth of each menu item box}{R}{D=0.025 R=0.005:0.25 }
\DEFARG{SGSIZE}{space available for the application}{R}{D=0.8 R=0:0.9 }
\DEFARG{SGYSPA}{max Y length of space between menus}{R}{D=0.02 R=-0.5:0.5 }
\DEFARG{SGBORD}{X or Y border for menus}{R}{D=0.015 R=0:0.25 }
\DEFARG{WKTYPE}{Graphics workstation type}{I}{D=0 }
\ENDARG
\BEGTEXT
Set the user dialogue style (or working mode).
If OPTION='?' the current style is shown.
The startup value is C (command mode).
Currently available options are:
\begin{verbatim}
 C   for Command
 AN  for general Alpha menu (with Numbers)
 AL  for general Alpha menu (with Letters)
 G   for Graphics menu (with hardware character fonts)
 GW  for Graphics menu (with shadowed Width effect)
 GS  for Graphics menu (with Software character fonts)
 GP  for Graphics menu (with Panel keys only, i.e. no command tree menu)'
\end{verbatim}

When using OPTION='G' (or 'GW', 'GS', 'GP') the 4 parameters following
the style can be defined to control the geometrical layout
of the menus on the screen, and the the fifth one to set the graphics
workstation type (without being prompted afterwards, if case of HIGZ
was not inizialized).
\ENDTEXT

\DEFCMD{KSPANEL}{/KUIP/SET\_SHOW}{PANEL}{line [ gkey ]}
\BEGARG
\DEFARG{LINE}{Line number}{R}{D=0 }
\DEFARG{GKEY}{Graphics key value(s)}{C}{D=' ' }
\ENDARG
\BEGTEXT
Set up the panel of graphics keys (used by STYLE GP).

Examples:
\begin{verbatim}
 PANEL  0                        | reset the panel
 PANEL  2 A/L QUIT V/L           | initialize line 2 with 3 graphics keys,
                                   respectively A/L, QUIT, V/L
 PANEL  2 A/L ' '  V/L ' ' ' '   | initialize line 2 with 5 graphics keys,
                                   and fill 1st and 3rd keys
 PANEL  2.04 MESSAGE             | initialize 4th key of 2nd line to MESSAGE
 PANEL  2.04                     | clear 4th key of 2nd line
 PANEL -2.08                     | initialize line 2 with 8 graphics keys
 PANEL -6.16                     | initialize line 6 with 16 graphics keys
\end{verbatim}
Note that the key number on the right of the decimal point must
always be defined with two digits.

Keys ending with a minus sign make an additional request of keyboard input;
the complete command line will be the key text, with a blank at the place
of the minus, concatenated with the additional keyboard input. Example:
\begin{verbatim}
 PANEL 1.03 'VEC/PRI-'        | entering VAB will execute VEC/PRI VAB.
\end{verbatim}
Keys ending with a double minus sign behave as above but no blank is put
at the place of the double minus. Example:
\begin{verbatim}
 PANEL 1.03 'VEC/PRI V--'     | entering AB will execute VEC/PRI VAB
\end{verbatim}
The dollar sign inside a key is replaced by additional keyboard input. Example:
\begin{verbatim}
 PANEL 1.03 'VEC/PRI V($)'    | entering 11:20 will execute VEC/PRI V(11:20)
\end{verbatim}
Maximum values for the key layout are:
1 panel, 10 lines/panel, 30 keys/line, 32 characters/key
\ENDTEXT

\DEFCMD{KSCOMMAN}{/KUIP/SET\_SHOW}{COMMAND}{[ chpath ]}
\BEGARG
\DEFARG{CHPATH}{Path name for command line}{C}{D=' ' }
\ENDARG
\BEGTEXT
Set a filter for the parsing of command lines.
If it has been called, it means that whenever a command line is entered,
if and only if it is not an existing command (not just ambiguous),
it is inserted into the CHPATH string, with \$n (n=1..9) being replaced
by the n-th token of the command (tokens are separated by spaces),
or \$* being replaced by the whole command line. Examples:
\begin{verbatim}
 COMMAND 'V/CR $*(10)'
 AA                     =>   V/CR AA(10)
 BB                     =>   V/CR BB(10)
 V/LIST                 =>   V/LIST
\end{verbatim}

\begin{verbatim}
 COMMAND 'VECTOR/PLOT $1 555 $2'
 AA E                   =>   VECTOR/PLOT AA 555 E
 BB                     =>   VECTOR/PLOT BB 555
\end{verbatim}

\begin{verbatim}
 COMMAND                =>   shows its current value
 COMMAND *              =>   reset (equivalent to COMMAND $*)
\end{verbatim}
Note that COMMAND and subsequent command lines can be used inside macros,
excepted when producing macro statements (like EXEC, IF, GOTO, etc.).
For example, the above examples would work also inside macros, while
COMMAND 'EXEC \$*' or COMMAND 'GOTO \$1' will not.

The same remark applies also to the command DEFAULT -Auto,
which is in fact equivalent to COMMAND 'EXEC \$*'

The COMMAND logic is superseded by the DEFAULT -A (or -AR) logic.
\ENDTEXT

\DEFCMD{KSAPPLIC}{/KUIP/SET\_SHOW}{APPLICATION}{[ path cmdex ]}
\BEGARG
\DEFARG{PATH}{Application name}{C}{D=' ' }
\DEFARG{CMDEX}{Exit command}{C}{D='EXIT' }
\ENDARG
\BEGTEXT
Set the application name.
This means that all input lines will be concatenated to the string PATH
(until the command specified by the parameter CMDEX is executed,
which resets the application to the null string). The value of CMDEX
may be specified if the default value EXIT has to be changed
(i.e. because already used by the application).
APPLICATION can also be inserted in a macro: in this case at least
4 characters must be specified (i.e. APPL).
\ENDTEXT

\DEFCMD{KSROOT}{/KUIP/SET\_SHOW}{ROOT}{[ path ]}
\BEGARG
\DEFARG{PATH}{Root directory}{C}{D='/' }
\ENDARG
\BEGTEXT
Set the root for searching commands.
If PATH='?' the current root is shown.
This allows to access commands regardless of possible
ambiguities with different menus.
Commands are first searched starting from the current root:
if a command is found it is executed.
Only if a command is not found a second pass of search is done,
starting now from the top root of the command tree (i.e. '/').
\ENDTEXT

\DEFCMD{KSTIMING}{/KUIP/SET\_SHOW}{TIMING}{[ option ]}
\BEGARG
\DEFARG{OPTION}{Option}{C}{D='ON' R='ON,OFF,ALL' }
\ENDARG
\BEGTEXT
Set ON/OFF/ALL the timing of commands.
If ON, the real time and the CPU time for the latest
executed command (or macro) are presented.
If ALL, the time is shown for each command being executed within a macro.
The startup value is OFF.
\ENDTEXT

\DEFCMD{KSPROMPT}{/KUIP/SET\_SHOW}{PROMPT}{[ option ]}
\BEGARG
\DEFARG{OPTION}{Prompt string}{C}{D=' ' }
\ENDARG
\BEGTEXT
Set the prompt string for the command mode dialogue.
If OPTION is blank the current prompt is left unchanged.
\ENDTEXT

\DEFCMD{KSBREAK}{/KUIP/SET\_SHOW}{BREAK}{[ option ]}
\BEGARG
\DEFARG{OPTION}{Option}{C}{D='ON' R='ON,OFF,TB,?' }
\ENDARG
\BEGTEXT
Set ON/OFF the break handling.
If OPTION='?' the current value is shown.
The startup value is ON.

Hitting the keyboard interrupt (CTRL/C on VAX or CTRL/Q on the Apollo)
under break ON condition, the current command or macro execution
will be interrupted and the user will get again the application prompt.

BREAK TB switch ON the traceback of the routines called, with their
line numbers, when an error occurs. This allows the detection of
the routines which provoked the error.
\ENDTEXT

\DEFCMD{KSCOLUMN}{/KUIP/SET\_SHOW}{COLUMNS}{[ ncol ]}
\BEGARG
\DEFARG{NCOL}{Number of columns for terminal output}{I}{D=80 R=0:132 }
\ENDARG
\BEGTEXT
Set the maximum number of columns for terminal output.
If NCOL=0 the current number of columns is shown.
The startup value is 80.
\ENDTEXT

\DEFCMD{KSRECORD}{/KUIP/SET\_SHOW}{RECORDING}{[ nrec ]}
\BEGARG
\DEFARG{NREC}{Rate for recording on history file}{I}{D=25 R=0:25 }
\ENDARG
\BEGTEXT
Set the recording rate for the history file.
Every NREC commands of the session the current history file is updated.
If NREC=0 the history is not kept at all (i.e. the file is not written).
See also the command LAST.
\ENDTEXT

\DEFCMD{KSHOST_E}{/KUIP/SET\_SHOW}{HOST\_EDITOR}{[ option top left width height dxpad dypad npads ]}
\BEGARG
\DEFARG{OPTION}{Name of default host editor}{C}{D='?' R='?,EDT,TPU,DM,VI,WINDOW,PAD' }
\DEFARG{TOP}{Top position of the edit window}{I}{D=20 }
\DEFARG{LEFT}{Left position of the edit window}{I}{D=20 }
\DEFARG{WIDTH}{Width of the edit window}{I}{D=0 }
\DEFARG{HEIGHT}{Height of the edit window}{I}{D=0 }
\DEFARG{DXPAD}{X offset for help PAD windows}{I}{D=30 R=0: }
\DEFARG{DYPAD}{Y offset for help PAD windows}{I}{D=20 R=0: }
\DEFARG{NPADS}{Maximum number of shifted pads}{I}{D=4 R=1: }
\ENDARG
\BEGTEXT
Set the default host editor (only for VAX/VMS, Apollo and Unix).
If OPTION='?' the current host editor is shown.
The EDIT command will invoke this editor.
The startup value is EDIT/EDT (VAX/VMS), dm (Apollo) or the value
assigned to the EDITOR environment variable (Unix).

On the Apollo, if OPTION='WINDOW' or 'PAD' and some parameters are
following, they will be used as edit window positions (in pixel units).
If no parameters are following (i.e. typing just HOST WINDOW or HOST PAD)
they will be asked graphically on a dummy window.
OPTION='WINDOW' is used to specify window pad parameters used by
commands like EDIT, LAST, etc., while OPTION='PAD' is used to specify help
pad parameters used by the command HELP in EDIT mode.

This command is not meaningful on IBM/VM-CMS where it is always XEDIT.
\ENDTEXT

\DEFCMD{KSHOST_S}{/KUIP/SET\_SHOW}{HOST\_SHELL}{[ option ]}
\BEGARG
\DEFARG{OPTION}{Name of default host shell}{C}{D='?' R='sh,csh,ksh,/com/sh' }
\ENDARG
\BEGTEXT
Set the default host shell (only for Apollo and Unix machines).
If OPTION='?' the current host shell is shown.
The SHELL command will invoke this shell.
The startup value is the value assigned to the SHELL environment variable.
\ENDTEXT

\DEFCMD{KSVISIBI}{/KUIP/SET\_SHOW}{VISIBILITY}{cmd [ chopt1 chopt2 ]}
\BEGARG
\DEFARG{CMD}{Command name}{C}{D=' ' }
\DEFARG{CHOPT1}{?, OFF, ON}{C}{D='?' R='?,OFF,ON' }
\DEFARG{CHOPT2}{?, CLEAR, KEEP}{C}{D='?' R='?,CLEAR,KEEP' }
\ENDARG
\BEGTEXT
Set or show the visibility attributes of a command.

If CHOPT1='OFF':
\begin{verbatim}
 - the command it is not executable anymore
 - STYLE G draws a shadowed box on the command
 - HELP may be still requested on the command
\end{verbatim}
The startup value is ON.

CHOPT2 allows the user to customize the 'Style Motif':
\begin{verbatim}
 - if CHOPT2='KEEP' the parameters window is not cleared upon execution
\end{verbatim}
The startup value is CLEAR.
\ENDTEXT

\DEFCMD{KSMODE}{/KUIP/SET\_SHOW}{MODE}{mode }
\BEGARG
\DEFARG{MODE}{KUIP Mode}{C}{D='M' R='M,A' }
\ENDARG
\BEGTEXT
Set or Show KUIP mode for Command Area.
\ENDTEXT


\DEFMENU{0}{MACRO}
\BEGTEXT
Macro Processor commands.
\ENDTEXT

\DEFCMD{M0EXEC}{/MACRO}{EXEC}{mname }
\BEGARG
\DEFARG{MNAME}{Macro name}{C}{}
\ENDARG
\BEGTEXT
Execute the command lines contained in the macro MNAME.
As a file can contain several macros, the character '\#' is
used to select a particular macro inside a file as explained below.

If MNAME does not contain the character '\#', the file MNAME.KUMAC
is searched and the first macro is executed (it may be an unnamed
macro if a MACRO statement is not found as first command line in the file).

If MNAME is of the form FILE\#MACRO, the file named FILE.KUMAC is searched
and the macro named MACRO is executed.

Examples:
\begin{verbatim}
 EXEC ABC   to exec first (or unnamed) macro of file ABC.KUMAC
 EXEC ABC#M to exec macro M of file ABC.KUMAC
\end{verbatim}
\ENDTEXT

\DEFCMD{M0LIST}{/MACRO}{LIST}{[ mname ]}
\BEGARG
\DEFARG{MNAME}{Macro name restrictions}{C}{D=' ' }
\ENDARG
\BEGTEXT
List all macros on disk.
Macros are files with the extension KUMAC.
MNAME may be specified to restrict the list to the macros
containing such a string in the first part of their name,
for example MACRO/LIST ABC will list all macros starting with ABC.
\ENDTEXT

\DEFCMD{M0TRACE}{/MACRO}{TRACE}{[ option level prompt ]}
\BEGARG
\DEFARG{OPTION}{Option}{C}{D='ON' R='ON,OFF' }
\DEFARG{LEVEL}{Level}{C}{D=' ' R=' ,TEST,WAIT,FULL' }
\DEFARG{PROMPT}{Prompt string}{C}{D=' ' }
\ENDARG
\BEGTEXT
Set ON/OFF the trace of commands during macro execution.
If TRACE='ON' the command being executed is written
on the terminal, after the prompt defined in the parameter PROMPT.
If LEVEL='TEST' the command is only echoed but not executed.
If LEVEL='WAIT' the command WAIT is automatically inserted
after the execution of each command.
If LEVEL='FULL' all the names of macros and labels are printed
at the end of macro interpretation.
If PROMPT=' ' (default) the prompt written is replaced by a number of '>'
equal to the current prompt length. At the end of the macro execution
the prompt is switched back to the original one.
The startup values are OPTION='OFF' and LEVEL=' '.
\ENDTEXT

\DEFCMD{M0DEFAUL}{/MACRO}{DEFAULTS}{[ chpath ]}
\BEGARG
\DEFARG{CHPATH}{Path name for macro files}{C}{D=' ' }
\ENDARG
\BEGTEXT
Set or show various MACRO attributes.

Entered without parameters, it show the current "extra path"
to the 'default working directory',
as well as all macro parameters (name, default value)
relative to the latest EXEC command entered.

If CHPATH is supplied, set its value representing the "extra path".
The "extra path" is a string (e.g. the name of a disk directory) which
is added in front of the macro file names, whenever they are used in
the commands EDIT, EXEC and MACRO/LIST.
The extra path is ignored if a dash sign '-' is put in front of
the file name.
If CHPATH='*', the extra path is reset and the host computer's
current working directory is used.
Example:
\begin{verbatim}
     DEFAULT 'DISK$DL:[PAW]'
     MACRO/LIST              | list macros in DISK$DL:[PAW]
     EXEC FUNCTION           | executes DISK$DL:[PAW]FUNCTION.KUMAC
     EXEC -MYMACRO           | executes MYMACRO.KUMAC
     EXEC PALETTE            | executes DISK$DL:[PAW]PALETTE.KUMAC
     DEFAULT *
     EXEC PALETTE            | executes PALETTE.KUMAC
\end{verbatim}
In addition to what described above, the command DEFAULTS may be used to
control whether commands and/or macros are searched (and in which order):
\begin{verbatim}
     DEFAULT -Command
     CMD                     | CMD is executed (error if not found)
     DEFAULT -Auto
     CMD                     | try CMD first; if not found, try EXEC CMD
     DEFAULT -AutoReverse
     CMD                     | try EXEC CMD first; if not found, try CMD
\end{verbatim}
The lower case letters following the minus sign are optional.
The startup value (also re-set by DEFAULT *) is DEFAULT -C

The DEFAULT -A (or -AR) logic supersedes the COMMAND logic.

Important note:

Inside macros the DEFAULT -A (or -AR) logic is not active:
DEFAULT -C is always assumed.
\ENDTEXT

\DEFCMD{M0RECURS}{/MACRO}{RECURSION}{[ option ]}
\BEGARG
\DEFARG{OPTION}{Option}{C}{D='ON' R='ON,OFF' }
\ENDARG
\BEGTEXT
Set ON/OFF the option to execute macros recursively.
The startup value is OFF.
\ENDTEXT


\DEFMENU{0}{VECTOR}
\BEGTEXT
Vector Processor commands.
Vectors are equivalent to FORTRAN 77 arrays and they use
the same notation except when omitting indexes (see last line below).
Up to 3 dimensions are supported. Examples:
\begin{verbatim}
 Vec(20) (mono-dimensional with 20 elements)
\end{verbatim}
may be addressed by:
\begin{verbatim}
 Vec          for all elements
 Vec(13)      for element 13-th
 Vec(12:)     for elements 12-th to last
 Vec(:10)     for elements first to 10-th
 Vec(5:8)     for elements 5-th to 8-th
\end{verbatim}

\begin{verbatim}
 Vec(3,100) (bi-dimensional with 3 columns by 100 rows):
\end{verbatim}
may be addressed by:
\begin{verbatim}
 Vec(2,5:8)   for elements 5-th to 8-th in 2-nd column
 Vec(2:3,5:8) for elements 5-th to 8-th in 2-nd to 3-rd columns
 Vec(2,5)     for element 5-th in 2-nd column
 Vec(:,3)     for all elements in 3-rd row
 Vec(2)       for all elements in 2-nd column (SPECIAL CASE)
\end{verbatim}
The latest line shows the special (and non-standard with FORTRAN 77)
notation such that missing indexes are substituted to the right.

An 'invisible' vector called '?', mono-dimensional and of length 100,
is always present. Is is used for communicating between user arrays
and KUIP vectors, being equivalenced with the real array VECTOR(100)
in the labelled common block /KCWORK/.
\ENDTEXT

\DEFCMD{V0CREATE}{/VECTOR}{CREATE}{vname [ type ]}
\BEGARG
\DEFARG{VNAME}{Vector name(length)}{C}{}
\DEFARG{TYPE}{Vector type}{C}{D='R' R='R,I' }
\ENDARG
\BEGTEXT
Create a vector named VNAME (elements are set to zero).
The dimensions are taken from the name,
for example VEC(20), VEC(3,100), VEC(2,2,10).
Up to 3 dimensions are supported. Dimensions which are not specified
are taken to 1, for example VEC(10) ---> VEC(10,1,1) and VEC ---> VEC(1,1,1).
The vector may be of type Real or Integer.
A vector is filled at the same time if parameters are given
after the TYPE:
\begin{verbatim}
 VEC/CREATE V(10) R 1 2 3 4 5 66 77 88 99 111
 VEC/CREATE W(20) R 1 2 3
\end{verbatim}
In the last example only the first three elements are filled.
Vector elements may be changed later with the command VECTOR/INPUT.

If many equal values have to be entered consecutively, one can specify just
one value and precede it by a repetition factor and an asterisk. Example:
\begin{verbatim}
 VEC/CREATE Z(20) R 5*1 2 4*3   --->   VEC/CREATE Z(20) R 1 1 1 1 1 2 3 3 3 3
\end{verbatim}
Enter HELP VECTOR for more information on vector addressing.
\ENDTEXT

\DEFCMD{V0LIST}{/VECTOR}{LIST}{}
\BEGTEXT
List all vectors (name, dimensions, type).
\ENDTEXT

\DEFCMD{V0DELETE}{/VECTOR}{DELETE}{vlist }
\BEGARG
\DEFARG{VLIST}{Vector list}{C}{D=' ' }
\ENDARG
\BEGTEXT
Delete from memory all vectors in the list VLIST.
The vectors are separated in the list by a comma and imbedded blanks
are not allowed. An asterisk at the end of VLIST acts as string placeholder:
\begin{verbatim}
 VEC/DEL AB*          --->  deletes all vectors starting by AB
 VEC/DEL *            --->  deletes all vectors
\end{verbatim}
\ENDTEXT

\DEFCMD{V0COPY}{/VECTOR}{COPY}{vnam1 vnam2 }
\BEGARG
\DEFARG{VNAM1}{Source vector name}{C}{}
\DEFARG{VNAM2}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
Copy a vector into another one.
Mixed vector type copy is supported (e.g. Integer ---> Real and viceversa).
If VNAM2 does not exist it is created with the required dimensions,
not necessarily the same as the source vector if a sub-range was specified.
For example, if A is a 3 x 100 vector and B does not exist,
COPY A(2,11:60) B will create B as a 50 elements mono-dimensional vector;
a special (and non-standard with FORTRAN 77) notation is used such that,
still using the above vectors, COPY A(2,1:100) B and COPY A(2) B have the
same effect.

Note that VECTOR/COPY does not allow a range for the destination vector
not specifying consecutive elements (i.e. along the first dimension):
\begin{verbatim}
 VEC/COPY V(5)      W(3,4)     | O.K.
 VEC/COPY V1(2:3,5) V2(4:5,9)  | O.K.
 VEC/COPY V1(5,2:3) V2(4:5,9)  | O.K.
 VEC/COPY V1(3,3:4) V2(4,4:5)  | NOT allowed
 VEC/COPY V1(2:3,5) V2(2,4:5)  | NOT allowed
\end{verbatim}
Enter HELP VECTOR for more information on vector addressing.
\ENDTEXT

\DEFCMD{V0INPUT}{/VECTOR}{INPUT}{vname }
\BEGARG
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Enter values into a vector from the terminal.
Example:
\begin{verbatim}
 VEC/INPUT V(6:10) 1.1 2.22 3.333 4.4444 5.55555
\end{verbatim}
If many equal values have to be entered consecutively, one can specify just
one value and precede it by a repetition factor and an asterisk. Example:
\begin{verbatim}
 VEC/INPUT V 5*1 2 4*3   --->   VEC/INPUT V 1 1 1 1 1 2 3 3 3 3
\end{verbatim}
Enter HELP VECTOR for more information on vector addressing.
\ENDTEXT

\DEFCMD{V0PRINT}{/VECTOR}{PRINT}{vname }
\BEGARG
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Write to the terminal the content of a vector.
Enter HELP VECTOR for more information on vector addressing.
\ENDTEXT

\DEFCMD{V0READ}{/VECTOR}{READ}{vlist fname [ format opt match ]}
\BEGARG
\DEFARG{VLIST}{Vector list}{C}{}
\DEFARG{FNAME}{File name}{C}{D=' ' }
\DEFARG{FORMAT}{Format}{C}{D=' ' }
\DEFARG{OPT}{Options}{C}{D='OC' R='OC,O, ,C' }
\DEFARG{MATCH}{Matching pattern}{C}{D=' ' }
\ENDARG
\BEGTEXT
Enter values into vector(s) from a file.
A format can be specified, e.g. FORMAT='F10.5,2X,F10.5',
or the free format is used if FORMAT is not supplied.

If vector(s) are not existing they will be created
of the size as read from the file.

Vectors in the list VLIST are separated by a comma and
imbedded blanks are not allowed. If subscripts are present
in vector names, the smallest one is taken.

OPT is used to select between the following options:
\begin{verbatim}
 'OC'   file is Opened, read and then Closed (default case)
 'O'    file is Opened and then read (left open for further reading)
 ' '    file is read (already open, left so for further reading)
 'C'    file is read and then Closed (already open)
\end{verbatim}
If the character 'Z' is present in OPT, the vector elements equal to zero
after reading are set to the latest non-zero element value
(for example reading 1 2 3 0 0 4 0 5 will give 1 2 3 3 3 4 4 5).

MATCH is used to specify a pattern string, restricting
the vector filling only to the records in the file which
verify the pattern. Example of patterns:
\begin{verbatim}
  /string/      match a string (starting in column 1)
 -/string/      do not match a string (starting in column 1)
  /string/(n)   match a string, starting in column n
  /string/(*)   match a string, starting at any column
\end{verbatim}
Enter HELP VECTOR for more information on vector addressing.
\ENDTEXT

\DEFCMD{V0WRITE}{/VECTOR}{WRITE}{vlist [ fname format chopt ]}
\BEGARG
\DEFARG{VLIST}{Vector list}{C}{}
\DEFARG{FNAME}{File name}{C}{D=' ' }
\DEFARG{FORMAT}{Format}{C}{D='5(1X,G13.7)' }
\DEFARG{CHOPT}{Options}{C}{D='OC' R='OC,O, ,C' }
\ENDARG
\BEGTEXT
Write to a file the content of vector(s).
If FNAME=' ' the content is written to the terminal.
A format can be specified, e.g. FORMAT='F10.5,2X,F10.5',
or the default one is used if FORMAT is not supplied.

Vectors in the list VLIST are separated by a comma and
imbedded blanks are not allowed. If subscripts are present
in vector names, the smallest one is taken.

CHOPT is used to select between the following options:
\begin{verbatim}
 'OC'   file is Opened, written and then Closed (default case)
 'O'    file is Opened and then written (left open for further writing)
 ' '    file is written (already open, left so for further writing)
 'C'    file is written and then Closed (already open)
\end{verbatim}
Enter HELP VECTOR for more information on vector addressing.
\ENDTEXT

\DEFCMD{V0DRAW}{/VECTOR}{DRAW}{vname [ id chopt ]}
\BEGARG
\DEFARG{VNAME}{Vector name}{C}{}
\DEFARG{ID}{Histogram Identifier}{C}{D='12345' }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,C,S,+,B,L,P,*' }
\ENDARG
\BEGTEXT
Draw vector VNAME interpreting it as a histogram.
Optionally save the contents in histogram ID.
CHOPT may be a combination of the following characters:
\begin{verbatim}
 'C' Draw a smooth curve.
 'S' Superimpose plot on top of existing picture.
 '+' Add contents of ID to last plotted histogram.
 'B' Select Bar chart format.
 'L' Connect channels contents by a line.
 'P' Draw the current polymarker at each channel.
 '*' Draw a * at each channel.
\end{verbatim}
\ENDTEXT

\DEFCMD{V0HFILL}{/VECTOR}{HFILL}{vname id }
\BEGARG
\DEFARG{VNAME}{Vector name}{C}{}
\DEFARG{ID}{Histogram Identifier}{C}{}
\ENDARG
\BEGTEXT
Fill the existing histogram ID with vector VNAME.
Note that the command VECTOR/PLOT can automatically book, fill and plot
the contents of a vector.
\ENDTEXT

\DEFCMD{V0PLOT}{/VECTOR}{PLOT}{vname [ id chopt ]}
\BEGARG
\DEFARG{VNAME}{Vector name}{C}{}
\DEFARG{ID}{Histogram Identifier}{C}{D='12345' }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,C,S,+,B,L,P,*' }
\ENDARG
\BEGTEXT
Each element of VNAME is used to fill an histogram
which is automatically booked with 100 channels and then plotted.
If VNAME has the form VNAME1\%VNAME2 then a scatter-plot of vector VNAME1
versus VNAME2 is plotted. If ID is given different of 12345, then
a 2-Dim histogram is created with 40 bins by 40 bins and filled.
One can use the command VECTOR/HFILL to fill an already existing
histogram.
CHOPT may be a combination of the following characters:
\begin{verbatim}
 'C' Draw a smooth curve.
 'S' Superimpose plot on top of existing picture.
 '+' Add contents of ID to last plotted histogram.
 'B' Select Bar chart format.
 'L' Connect channels contents by a line.
 'P' Draw the current polymarker at each channel.
 '*' Draw a * at each channel.
\end{verbatim}
\ENDTEXT

\DEFCMD{V0FIT}{/VECTOR}{FIT}{x y ey func [ chopt np par step pmin pmax errpar ]}
\BEGARG
\DEFARG{X}{Vector of X coordinates}{C}{}
\DEFARG{Y}{Vector of Y coordinates}{C}{}
\DEFARG{EY}{Vector of errors on Y}{C}{D='?' }
\DEFARG{FUNC}{Function name}{C}{}
\DEFARG{CHOPT}{Character options}{C}{D=' ' R=' ,0,N,Q,V,B,D,W,M' }
\DEFARG{NP}{Number of parameters}{I}{D=0 R=0:20 }
\DEFARG{PAR}{Vector of parameters}{C}{}
\DEFARG{STEP}{Vector of steps size}{C}{}
\DEFARG{PMIN}{Vector of lower bounds}{C}{}
\DEFARG{PMAX}{Vector of upper bounds}{C}{}
\DEFARG{ERRPAR}{Vector of errors on parameters}{C}{}
\ENDARG
\BEGTEXT
Fit a user defined function
to the points defined by the two vectors X and Y and the vector
of associated errors EY.
See command Histo/Fit for explanation of parameters.
Note that if option 'W' is specified or EY='?' (default),
the array EY is ignored. Option 'L' is not available.
\ENDTEXT


\DEFMENU{1}{OPERATIONS}
\BEGTEXT
Simple arithmetic operations between vectors.
In all the operations only the minimum vector length is considered,
i.e. an operation between a vector A of dimension 10 and a vector B
of dimension 5 will involve the first 5 elements in both vectors.
If the destination vector does not exist,
it is created with the same length as the source vector.
\ENDTEXT

\DEFCMD{VOVBIAS}{/VECTOR/OPERATIONS}{VBIAS}{vnam1 bias vnam2 }
\BEGARG
\DEFARG{VNAM1}{Source vector name}{C}{}
\DEFARG{BIAS}{Bias value}{R}{}
\DEFARG{VNAM2}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
VNAM2(I) = BIAS     + VNAM1(I)
\ENDTEXT

\DEFCMD{VOVSCALE}{/VECTOR/OPERATIONS}{VSCALE}{vnam1 scale vnam2 }
\BEGARG
\DEFARG{VNAM1}{Source vector name}{C}{}
\DEFARG{SCALE}{Scale factor}{R}{}
\DEFARG{VNAM2}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
VNAM2(I) = SCALE    * VNAM1(I)
\ENDTEXT

\DEFCMD{VOVADD}{/VECTOR/OPERATIONS}{VADD}{vnam1 vnam2 vnam3 }
\BEGARG
\DEFARG{VNAM1}{First source vector name}{C}{}
\DEFARG{VNAM2}{Second source vector name}{C}{}
\DEFARG{VNAM3}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
VNAM3(I) = VNAM1(I) + VNAM2(I)
\ENDTEXT

\DEFCMD{VOVMULTI}{/VECTOR/OPERATIONS}{VMULTIPLY}{vnam1 vnam2 vnam3 }
\BEGARG
\DEFARG{VNAM1}{First source vector name}{C}{}
\DEFARG{VNAM2}{Second source vector name}{C}{}
\DEFARG{VNAM3}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
VNAM3(I) = VNAM1(I) * VNAM2(I)
\ENDTEXT

\DEFCMD{VOVSUBTR}{/VECTOR/OPERATIONS}{VSUBTRACT}{vnam1 vnam2 vnam3 }
\BEGARG
\DEFARG{VNAM1}{First source vector name}{C}{}
\DEFARG{VNAM2}{Second source vector name}{C}{}
\DEFARG{VNAM3}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
VNAM3(I) = VNAM1(I) - VNAM2(I)
\ENDTEXT

\DEFCMD{VOVDIVID}{/VECTOR/OPERATIONS}{VDIVIDE}{vnam1 vnam2 vnam3 }
\BEGARG
\DEFARG{VNAM1}{First source vector name}{C}{}
\DEFARG{VNAM2}{Second source vector name}{C}{}
\DEFARG{VNAM3}{Destination vector name}{C}{}
\ENDARG
\BEGTEXT
VNAM3(I) = VNAM1(I) / VNAM2(I)     ( or 0 if VNAM2(I)=0 )
\ENDTEXT


\DEFMENU{0}{HISTOGRAM}
\BEGTEXT
Manipulation of histograms, Ntuples.
Interface to the HBOOK package.
\ENDTEXT

\DEFCMD{H0FILE}{/HISTOGRAM}{FILE}{lun fname [ lrecl chopt ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{LRECL}{Record length in words}{I}{D=1024 }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,N,U' }
\ENDARG
\BEGTEXT
Open an HBOOK direct access file.
\begin{verbatim}
 For CHOPT=' ', existing file is opened (read mode only).
 For CHOPT='N', a new file is opened.
 For CHOPT='U', existing file is opened to be modified.
\end{verbatim}
\ENDTEXT

\DEFCMD{H0LIST}{/HISTOGRAM}{LIST}{[ chopt ]}
\BEGARG
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,I' }
\ENDARG
\BEGTEXT
List histograms and Ntuples in the current directory.
If CHOPT='I' a verbose format is used (HINDEX).
\ENDTEXT

\DEFCMD{H0DELETE}{/HISTOGRAM}{DELETE}{id }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\ENDARG
\BEGTEXT
Delete histogram/Ntuple ID in Current Directory (memory).
If ID=0 delete all histograms and Ntuples.
To delete histograms in disk files use command HIO/HSCRATCH.
\ENDTEXT

\DEFCMD{H0PLOT}{/HISTOGRAM}{PLOT}{[ id chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,C,S,+,-,B,L,P,*,K,U,E,A' }
\ENDARG
\BEGTEXT
Plot a single histogram or a 2-Dim projection.
Each plotted histogram will start
either a new picture or a new zone in the current picture.
A channel range may be specified for 1-Dim and 2-Dim histograms.
Ex: Histo/plot 10(25:64) or Histo/plot 20(4:18,5:10).
CHOPT may be a combination of the following characters:
\begin{verbatim}
 'C'     Draw a smooth curve.
 'S'     Superimpose plot on top of existing picture.
 '+'     Add contents of ID to last plotted histogram.
 '-'     Substract contents of ID to last plotted histogram.
 '+-'    Draw the delta with the last plotted histogram.
 'B'     Select Bar chart format.
 'L'     Connect channels contents by a line.
 'P'     Draw the current polymarker at each channel or cell.
 '*'     Draw a * at each channel.
 'K'     Must be given if option 'U' is given later.
 'U'     Update channels modified since last call.
 'E'     Draw error bars and current marker.
 'A'     Axis labels and tick marks are not drawn.
 'BOX'   Draw 2-Dim with proportional boxes.
 'COL'   Draw 2-Dim with a color table.
 'Z'     Used with COL or SURF, it draws the color map.
 'SURF'  Draw as a surface plot (angles are set via the command angle).
 'SURF1' Draw as a surface with color levels
 'SURF2' Same as SURF1 but without cell lines.
 'SURF3' Same as SURF but with the contour plot (in color) on top.
 'SURF4' Draw as a surface with Gouraud shading.
 'LEGO'  Draw as a lego plot (angles are set via the command angle).
 'LEGO1' Draw lego plot with light simulation.
 'LEGO2' Draw lego plot with color levels.
 'CONT'  Draw 2-Dim as a contour plot (15 levels).
 'TEXT'  Draw 2-Dim as a table.
 'CHAR'  Draw 2-Dim with characters (a la HBOOK).
 'HIST'  Draw only histogram (no errors or associated function).
 'FUNC'  Draw only the associated function (not the histogram).
\end{verbatim}
1 Dim histograms could be plotted with option LEGO or SURF. In this
case the angles are THETA=1 and PHI=-1.
When option 'E' is used, the marker type can be changed with SMK,
the marker size with SET KSIZ, the marker color with SPMCI.
To plot projection X of ID type
\begin{verbatim}
   HI/PLOT ID.PROX
\end{verbatim}
To plot band 1 in Y of ID type
\begin{verbatim}
   HI/PLOT ID.BANY.1
\end{verbatim}
To plot slice 3 in Y of ID type
\begin{verbatim}
   HI/PLOT ID.SLIY.3
\end{verbatim}
\ENDTEXT

\DEFCMD{H0ZOOM}{/HISTOGRAM}{ZOOM}{[ id chopt icmin icmax ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,C,S,+,B,L,P,*' }
\DEFARG{ICMIN}{First channel}{I}{D=1 }
\DEFARG{ICMAX}{Last channel}{I}{D=9999 }
\ENDARG
\BEGTEXT
Plot a single histogram between channels ICMIN and ICMAX.
Each plotted histogram will start
either a new picture or a new zone in the current picture.
If no parameters are given to the command, then the system waits
for two points using the graphics cursor. To quit ZOOM, click
the right button of the mouse or CRTL/E.
CHOPT may be a combination of the following characters:
\begin{verbatim}
 'C' Draw a smooth curve.
 'S' Superimpose plot on top of existing picture.
 '+' Add contents of ID to last plotted histogram.
 'B' Select Bar chart format.
 'L' Connect channels contents by a line.
 'P' Draw the current polymarker at each channel.
 '*' Draw a * at each channel.
\end{verbatim}
\ENDTEXT

\DEFCMD{H0MANY_P}{/HISTOGRAM}{MANY\_PLOTS}{idlist }
\BEGARG
\DEFARG{IDLIST}{List of histogram Identifiers}{C}{}
\ENDARG
\BEGTEXT
Plot one or several histograms into the same plot.
Plotted histograms are superimposed on the same zone
of the picture.
\ENDTEXT

\DEFCMD{H0PROJEC}{/HISTOGRAM}{PROJECT}{id }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\ENDARG
\BEGTEXT
Fill all booked projections of a 2-Dim histogram.
Filling is done using the 2-D contents of ID.
\ENDTEXT

\DEFCMD{H0COPY}{/HISTOGRAM}{COPY}{id1 id2 [ title ]}
\BEGARG
\DEFARG{ID1}{First histogram Identifier}{C}{}
\DEFARG{ID2}{Second histogram Identifier}{C}{}
\DEFARG{TITLE}{New title}{C}{D=' ' }
\ENDARG
\BEGTEXT
Copy a histogram (not Ntuple) onto another one.
Bin definition, contents, errors, etc. are preserved.
If TITLE is not given, ID2 has the same title as ID1.
\ENDTEXT

\DEFCMD{H0FIT}{/HISTOGRAM}{FIT}{id func [ chopt np par step pmin pmax errpar ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{FUNC}{Function name}{C}{D=' ' }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,0,N,Q,V,B,L,D,W,M,E' }
\DEFARG{NP}{Number of parameters}{I}{D=0 R=0:34 }
\DEFARG{PAR}{Vector of parameters}{C}{}
\DEFARG{STEP}{Vector of steps size}{C}{}
\DEFARG{PMIN}{Vector of lower bounds}{C}{}
\DEFARG{PMAX}{Vector of upper bounds}{C}{}
\DEFARG{ERRPAR}{Vector of errors on parameters}{C}{}
\ENDARG
\BEGTEXT
Fit a user defined (and parameter dependent) function
to a histogram ID (1-Dim or 2-Dim) in the specified range.
FUNC may be:
\begin{verbatim}
 A- The name of a file which contains the user defined
    function to be minimized. Function name and file name
    must be the same. For example file FUNC.FOR is:
      FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram
      COMMON/PAWPAR/PAR(2)
      FUNC=PAR(1)*X +PAR(2)*EXP(-X)
      END
     Ex: His/fit 10 func.for ! 5 par
\end{verbatim}

\begin{verbatim}
 B- One of the following keywords (1-Dim only):
    G : to fit Func=par(1)*exp(-0.5*((x-par(2))/par(3))**2)
    E : to fit Func=exp(par(1)+par(2)*x)
    Pn: to fit Func=par(1)+par(2)*x+par(3)*x**2......+par(n+1)*x**n
     Ex: His/fit 10 g
\end{verbatim}

\begin{verbatim}
 C- A combination of the keywords in B with the 2 operators + or *.
    Ex: His/Fit 10 p4+g ! 8 par
        His/Fit 10 p2*g+g ! 9 par
      Note that in this case, the order of parameters in PAR must
      correspond to the order of the basic functions.
      For example, in the first case above, par(1:5) apply to
      the polynomial of degree 4 and par(6:8) to the gaussian while
      in the second case par(1:3) apply to the polynomial of degree 2,
      par(4:6) to the first gaussian and par(7:9) to the second gaussian..
      Blanks are not allowed in the expression.
\end{verbatim}
For cases A and C, before the execution of this command, the vector PAR
must be filled (via Vector/Input) with the initial values.
For case B, if NP is set to 0, then the initial values of PAR
will be calculated automatically.
After the fit, the vector PAR contains the new values
of parameters. If the vector ERRPAR is given, it will contain
the errors on the fitted parameters.
A bin range may be specified with ID.
\begin{verbatim}
  Ex. Histo/Fit 10(25:56).
\end{verbatim}
CHOPT : Possible options '0NQVBLDWM' + HPLOT options
\begin{verbatim}
   '0'  Do not plot the result of the fit. By default the fitted
        function is drawn unless the option 'N' below is specified.
   'N'  Do not store the result of the fit bin by bin with the histogram.
        By default the function is calculated at the middle of each bin
        and the fit results stored with the histogram data structure.
   'Q'  Quiet mode. No print
   'V'  Verbose mode. Results after each iteration are printed
        By default only final results are printed.
   'B'  Some or all parameters are bounded. The vectors STEP,PMIN,PMAX
        must be specified.
        Default is: All parameters vary freely.
   'L'  Use Log Likelihood.
        Default is chisquare method.
   'D'  The user is assumed to compute derivatives analytically
        using the routine HDERIV.
        By default, derivatives are computed numerically.
   'W'  Sets weights equal to 1. Default weights taken from
        the square root of the contents or from HPAKE/HBARX (PUT/ERRORS).
   'M'  The interactive Minuit is invoked.
   'E'  Performs a better Error evaluation (MIGRAD + HESSE + MINOS).
\end{verbatim}
\ENDTEXT


\DEFMENU{1}{2D\_PLOT}
\BEGTEXT
Plotting of 2-Dim histograms in various formats.
\ENDTEXT

\DEFCMD{H2LEGO}{/HISTOGRAM/2D\_PLOT}{LEGO}{[ id theta phi chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{THETA}{Angle THETA in degrees}{R}{D=30. }
\DEFARG{PHI}{Angle PHI in degrees}{R}{D=30. }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,1,2' }
\ENDARG
\BEGTEXT
Draw a lego plot from 2-Dim or 1-Dim histograms.
By default (CHOPT=' ') a hidden line algorithm is used.
CHOPT='1' A hidden surface algorithm is used. The colour of the lego
\begin{verbatim}
          is given by SET HCOL CI where CI is a colour index. For the
          top and the sides of the lego the same hue is used but with
          a different light.
\end{verbatim}
CHOPT='2' A hidden surface algorithm is used. The colour of each bar
\begin{verbatim}
          changes according to the value of Z. It is possible to change
          the set of colours used with SET HCOL c.L where L define a palette
          of colours given by the command ATT/PALETTE.
\end{verbatim}
It is also possible to produce stacked lego plots. A stacked lego plot
consists of a superimposition of several histograms, whose identifiers are
given in the command LEGO separated by the character "+".

\begin{verbatim}
    PAW > LEGO ID1+ID2+ID3    | Maximum number of ID's is 10. The colours of
                                each IDn is given by the command ATT/PALETTE
\end{verbatim}
Examples:

\begin{verbatim}
    PAW > SET HCOL 2          | The colour the histogram is 2 (red)
    PAW > LEGO 20             | Display a lego with lines
    PAW > LEGO 20 ! ! 1       | Display a lego with different lights
    PAW > LEGO 20 ! ! 2       | Display a lego with colours
\end{verbatim}

\begin{verbatim}
    PAW > PALETTE  1 3 2 3 4  | Create the palette number 1 with 3 elements: 2,3
    PAW > SET HCOL 0.1        | The subsequent stack lego plots will use list 1
    PAW > LEGO 10+20+30       | Plot a stack of lego plots with lines
    PAW > LEGO 10+20+30 ! ! 1 | Plot a stack of lego plots with light
\end{verbatim}

Notes: - The commands OPTION BAR, SET BARW and SET BARO act on lego plots
\begin{verbatim}
       - The options 1 and 2 must be used only on selective erase
         devices.
\end{verbatim}
\ENDTEXT

\DEFCMD{H2SURFAC}{/HISTOGRAM/2D\_PLOT}{SURFACE}{[ id theta phi chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{THETA}{Angle THETA in degrees}{R}{D=30. }
\DEFARG{PHI}{Angle PHI in degrees}{R}{D=30. }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,1,2,3,4' }
\ENDARG
\BEGTEXT
Draw a surface plot from 2-Dim or 1-Dim histograms.
By default (CHOPT=' ') a hidden line algorithm is used.
CHOPT='1' A hidden surface algorithm is used and each cell is filled
\begin{verbatim}
          with a colour corresponding to the Z value (or grey scale
          with PostScript). It is possible to change the set of colours
          used with SET HCOL ic.L where L define a palette of colours
          given by the command ATT/PALETTE.
\end{verbatim}
CHOPT='2' Is similar to option '1' except that the cell lines
\begin{verbatim}
          are not drawn. This is very useful to draw contour
          plots with colours if THETA=90 and PHI=0.
\end{verbatim}
CHOPT='3' A surface is drawn with a contour plot in color on top. The
\begin{verbatim}
          contour plot is drawn with the colors defined with the command
          PALETTE.
\end{verbatim}
CHOPT='4' A surface is drawn with Gouraud shading.
With this command it is possible to draw color contour plots:
\begin{verbatim}
    PAW > ATT/PAL 1 3 2 3 4   | Define the palette 1 with 3 elements
    PAW > SET HCOL 0.1        | Set the list 1 as colours for histograms
    PAW > SET NDVZ 4          | Set the number of Z divisions to 4
    PAW > SURF id 90 0 2      | Draw the contour
\end{verbatim}

Note: - The options 1 to 4 must be used only on selective erase devices.
\ENDTEXT

\DEFCMD{H2CONTOU}{/HISTOGRAM/2D\_PLOT}{CONTOUR}{[ id nlevel chopt param ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{NLEVEL}{Number of contour lines}{I}{D=10 }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,0,1,2,S' }
\DEFARG{PARAM}{Vector of contour levels}{C}{}
\ENDARG
\BEGTEXT
Draw a contour plot from a 2-Dim histogram.
CHOPT may be a combination of the following characters:
\begin{verbatim}
 '0' use colour to distinguish contours.
 '1' use line style to distinguish contours.
 '2' line style and colour are the same for all contours.
 '3' The contour is drawn with filled colour levels. The
     levels are equidistant. The color indices are taken
     in the current palette (defined with the command PALETTE).
     If the number of levels (NLEVEL) is greater than the number
     of entries in the current palette, the palette is explore
     again from the beginning in order to reach NLEVEL.
 'S' Superimpose plot on top of existing picture.
\end{verbatim}
If PARAM is not given, contour levels are equidistant.
If given, the vector PARAM may contain up to 50 values.
\ENDTEXT


\DEFMENU{1}{CREATE}
\BEGTEXT
Creation ("booking") of HBOOK objects in memory.
\ENDTEXT

\DEFCMD{HC1DHIST}{/HISTOGRAM/CREATE}{1DHISTO}{id title ncx xmin xmax [ valmax ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{TITLE}{Histogram title}{C}{D=' ' }
\DEFARG{NCX}{Number of channels}{I}{D=100 }
\DEFARG{XMIN}{Low edge}{R}{D=0. }
\DEFARG{XMAX}{Upper edge}{R}{D=100. }
\DEFARG{VALMAX}{Maximum bin content}{R}{D=0. }
\ENDARG
\BEGTEXT
Create a one dimensional histogram.
The contents are set to zero.
If VALMAX=0, then a full word is allocated per channel, else VALMAX
is used as the maximum bin content allowing several channels to be
stored into the same machine word.
\ENDTEXT

\DEFCMD{HCPROFIL}{/HISTOGRAM/CREATE}{PROFILE}{id title ncx xmin xmax ymin ymax [ chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{TITLE}{Histogram title}{C}{D=' ' }
\DEFARG{NCX}{Number of channels}{I}{D=100 }
\DEFARG{XMIN}{Low edge in X}{R}{D=0. }
\DEFARG{XMAX}{Upper edge in X}{R}{D=100. }
\DEFARG{YMIN}{Low edge in Y}{R}{D=-1.E30 }
\DEFARG{YMAX}{Upper edge in Y}{R}{D=1.E30 }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,S' }
\ENDARG
\BEGTEXT
Create a profile histogram.
Profile histograms
accumulate statistical quantities of a variable y
in bins of a variable x.
The contents are set to zero.
\ENDTEXT

\DEFCMD{HCBINS}{/HISTOGRAM/CREATE}{BINS}{id title ncx xbins [ valmax ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{TITLE}{Histogram title}{C}{D=' ' }
\DEFARG{NCX}{Number of channels}{I}{D=100 }
\DEFARG{XBINS}{Vector of NCX+1 low-edges}{C}{}
\DEFARG{VALMAX}{Maximum bin content}{R}{D=0. }
\ENDARG
\BEGTEXT
Create a histogram with variable size bins.
The low-edge of each bin is given in vector XBINS (NCX+1) values.
The contents are set to zero. See 1DHISTO for VALMAX.
\ENDTEXT

\DEFCMD{HC2DHIST}{/HISTOGRAM/CREATE}{2DHISTO}{id title ncx xmin xmax ncy ymin ymax [ valmax ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{TITLE}{Histogram title}{C}{D=' ' }
\DEFARG{NCX}{Number of channels in X}{I}{D=40 }
\DEFARG{XMIN}{Low edge in X}{R}{D=0. }
\DEFARG{XMAX}{Upper edge in X}{R}{D=40. }
\DEFARG{NCY}{Number of channels in Y}{I}{D=40 }
\DEFARG{YMIN}{Low edge in Y}{R}{D=0. }
\DEFARG{YMAX}{Upper edge in Y}{R}{D=40. }
\DEFARG{VALMAX}{Maximum bin content}{R}{D=0. }
\ENDARG
\BEGTEXT
Create a two dimensional histogram.
The contents are set to zero. See 1DHISTO for VALMAX.
\ENDTEXT

\DEFCMD{HCPROX}{/HISTOGRAM/CREATE}{PROX}{id }
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\ENDARG
\BEGTEXT
Create the projection onto the x axis.
The projection is not filled until the Histo/Project command is executed.
\ENDTEXT

\DEFCMD{HCPROY}{/HISTOGRAM/CREATE}{PROY}{id }
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\ENDARG
\BEGTEXT
Create the projection onto the y axis.
The projection may be filled with Histo/Project.
\ENDTEXT

\DEFCMD{HCSLIX}{/HISTOGRAM/CREATE}{SLIX}{id nslices }
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\DEFARG{NSLICES}{Number of slices}{I}{}
\ENDARG
\BEGTEXT
Create projections onto the x axis, in y-slices.
The projection may be filled with Histo/Project.
\ENDTEXT

\DEFCMD{HCSLIY}{/HISTOGRAM/CREATE}{SLIY}{id nslices }
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\DEFARG{NSLICES}{Number of slices}{I}{}
\ENDARG
\BEGTEXT
Create projections onto the y axis, in x-slices.
The projection may be filled with Histo/Project.
\ENDTEXT

\DEFCMD{HCBANX}{/HISTOGRAM/CREATE}{BANX}{id ymin ymax }
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\DEFARG{YMIN}{Low edge in Y}{R}{}
\DEFARG{YMAX}{Upper edge in Y}{R}{}
\ENDARG
\BEGTEXT
Create a projection onto the x axis, in a band of y.
The projection may be filled with Histo/Project.
\ENDTEXT

\DEFCMD{HCBANY}{/HISTOGRAM/CREATE}{BANY}{id xmin xmax }
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\DEFARG{XMIN}{Low edge in X}{R}{}
\DEFARG{XMAX}{Upper edge in X}{R}{}
\ENDARG
\BEGTEXT
Create a projection onto the y axis, in a band of x.
The projection may be filled with Histo/Project.
\ENDTEXT

\DEFCMD{HCTITLE_}{/HISTOGRAM/CREATE}{TITLE\_GLOBAL}{[ chtitl chopt ]}
\BEGARG
\DEFARG{CHTITL}{Global title}{C}{D=' ' }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,U' }
\ENDARG
\BEGTEXT
Set the global title.
The global title is plotted at the top of each picture
if the CHOPT=' '. If CHOPT='U' and if the option 'UTIT' is on,
a user title is plotted at the bottom of each histogram.
The size and the Y position of the global title may be changed
by the commands SET GSIZ and SET YGTI respectively. The size and
the Y position of the user title may be changed by the commands
SET TSIZ and SET YHTI respectively.
\ENDTEXT


\DEFMENU{1}{HIO}
\BEGTEXT
Input/Output operations of histograms.
\ENDTEXT

\DEFCMD{HHHRIN}{/HISTOGRAM/HIO}{HRIN}{id [ icycle iofset ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{ICYCLE}{Cycle number}{I}{D=999 }
\DEFARG{IOFSET}{Offset}{I}{D=0 }
\ENDARG
\BEGTEXT
Read histogram/Ntuple ID from the current directory
on direct access file to memory.
An identical histogram is created but with an ID equal to that
of the original histogram plus the offset IOFSET.
Identifier may be '0' or '*' (for all histograms).
If ICYCLE > 1000 and ID=0 read all histograms in all subdirectories as well.
If IOFSET = 99999 then the contents of histogram ID on the disk file
are added to the current histogram in memory if it exists. For example
to add all histograms from FILE1 and FILE2 in memory, the sequence
of commands can be:
\begin{verbatim}
 PAW > Histo/File 1 FILE1
 PAW > Hrin 0
 PAW > Histo/File 2 FILE2
 PAW > Hrin 0 ! 99999
\end{verbatim}
\ENDTEXT

\DEFCMD{HHHROUT}{/HISTOGRAM/HIO}{HROUT}{id [ chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,T' }
\ENDARG
\BEGTEXT
Write histo/Ntuple ID from memory to current directory.
Identifier may be '0' or '*' (for all histograms).
If CHOPT='T' writes all histograms in subdirectories as well.
\ENDTEXT

\DEFCMD{HHHSCRAT}{/HISTOGRAM/HIO}{HSCRATCH}{id }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\ENDARG
\BEGTEXT
Delete histogram ID in Current Directory on disk.
If ID='0' or '*' delete all histograms.
To delete histograms in memory use command HISTO/DELETE.
\ENDTEXT

\DEFCMD{HHHFETCH}{/HISTOGRAM/HIO}{HFETCH}{id fname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{FNAME}{File name}{C}{}
\ENDARG
\BEGTEXT
Fetch histogram ID from file FNAME.
FNAME has been created by the old version of HBOOK3 (Unformatted).
\ENDTEXT

\DEFCMD{HHHREAD}{/HISTOGRAM/HIO}{HREAD}{id fname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{FNAME}{File name}{C}{}
\ENDARG
\BEGTEXT
Read histogram ID from file FNAME.
FNAME has been created by the old version of HBOOK3 (Formatted).
\ENDTEXT

\DEFCMD{HHPRINT}{/HISTOGRAM/HIO}{PRINT}{id [ chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,S' }
\ENDARG
\BEGTEXT
Print histograms (line-printer format) on screen.
The command OUTPUT\_LP may be used to change the output file.
If CHOPT='S', then only statistics (Number of entries, mean, RMS,
underflow, overflow) are printed.
\ENDTEXT

\DEFCMD{HHDUMP}{/HISTOGRAM/HIO}{DUMP}{id }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\ENDARG
\BEGTEXT
Dump the histogram ZEBRA data structure on the terminal.
\ENDTEXT

\DEFCMD{HHOUTPUT}{/HISTOGRAM/HIO}{OUTPUT\_LP}{[ lun fname ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{D=6 }
\DEFARG{FNAME}{File name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Change the HBOOK "line printer" file name.
If FNAME=' ' then OUTPUT is appended to an already opened file on unit LUN.
If LUN is negative, the file is closed and subsequent output
is directed to unit 6.
\ENDTEXT

\DEFCMD{HHGLOBAL}{/HISTOGRAM/HIO}{GLOBAL\_SECT}{gname }
\BEGARG
\DEFARG{GNAME}{Global section name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Map the global section GNAME (VAX only).
The current directory is changed to //GNAME.
\ENDTEXT

\DEFCMD{HHGRESET}{/HISTOGRAM/HIO}{GRESET}{id }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\ENDARG
\BEGTEXT
Reset histogram ID in the global section.
\ENDTEXT


\DEFMENU{1}{OPERATIONS}
\BEGTEXT
Histogram operations and comparisons.
\ENDTEXT

\DEFCMD{HOADD}{/HISTOGRAM/OPERATIONS}{ADD}{id1 id2 id3 [ c1 c2 ]}
\BEGARG
\DEFARG{ID1}{First histogram Identifier}{C}{}
\DEFARG{ID2}{Second histogram Identifier}{C}{}
\DEFARG{ID3}{Result histogram Identifier}{C}{}
\DEFARG{C1}{Scale factor for ID1}{R}{D=1. }
\DEFARG{C2}{Scale factor for ID2}{R}{D=1. }
\ENDARG
\BEGTEXT
Add histograms: ID3 = C1*ID1 + C2*ID2.
Applicable to 1-Dim and 2-Dim histograms.
See command HRIN to add histograms with same IDS
from different files.
\ENDTEXT

\DEFCMD{HOSUBTRA}{/HISTOGRAM/OPERATIONS}{SUBTRACT}{id1 id2 id3 [ c1 c2 ]}
\BEGARG
\DEFARG{ID1}{First histogram Identifier}{C}{}
\DEFARG{ID2}{Second histogram Identifier}{C}{}
\DEFARG{ID3}{Result histogram Identifier}{C}{}
\DEFARG{C1}{Scale factor for ID1}{R}{D=1. }
\DEFARG{C2}{Scale factor for ID2}{R}{D=1. }
\ENDARG
\BEGTEXT
Subtract histograms: ID3 = C1*ID1 - C2*ID2.
Applicable to 1-Dim and 2-Dim histograms.
\ENDTEXT

\DEFCMD{HOMULTIP}{/HISTOGRAM/OPERATIONS}{MULTIPLY}{id1 id2 id3 [ c1 c2 ]}
\BEGARG
\DEFARG{ID1}{First histogram Identifier}{C}{}
\DEFARG{ID2}{Second histogram Identifier}{C}{}
\DEFARG{ID3}{Result histogram Identifier}{C}{}
\DEFARG{C1}{Scale factor for ID1}{R}{D=1. }
\DEFARG{C2}{Scale factor for ID2}{R}{D=1. }
\ENDARG
\BEGTEXT
Multiply histogram contents: ID3 = C1*ID1 * C2*ID2.
Applicable to 1-Dim and 2-Dim histograms.
\ENDTEXT

\DEFCMD{HODIVIDE}{/HISTOGRAM/OPERATIONS}{DIVIDE}{id1 id2 id3 [ c1 c2 ]}
\BEGARG
\DEFARG{ID1}{First histogram Identifier}{C}{}
\DEFARG{ID2}{Second histogram Identifier}{C}{}
\DEFARG{ID3}{Result histogram Identifier}{C}{}
\DEFARG{C1}{Scale factor for ID1}{R}{D=1. }
\DEFARG{C2}{Scale factor for ID2}{R}{D=1. }
\ENDARG
\BEGTEXT
Divide histograms: ID3 = C1*ID1 / C2*ID2.
Applicable to 1-Dim and 2-Dim histograms.
\ENDTEXT

\DEFCMD{HORESET}{/HISTOGRAM/OPERATIONS}{RESET}{id [ title ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{TITLE}{New title}{C}{D=' ' }
\ENDARG
\BEGTEXT
Reset contents and errors of an histogram.
Bin definition is not modified.
\ENDTEXT

\DEFCMD{HODIFF}{/HISTOGRAM/OPERATIONS}{DIFF}{id1 id2 [ chopt ]}
\BEGARG
\DEFARG{ID1}{First Histogram Identifier}{C}{}
\DEFARG{ID2}{Second Histogram Identifier}{C}{}
\DEFARG{CHOPT}{Options}{C}{D='D' R='D,N, ,O,U,L,R,B,T' }
\ENDARG
\BEGTEXT
Test of compatibility for two 1-Dim histograms ID1 and ID2.
A probability PROB is calculated as a number between zero and one,
where PROB near
one indicates very similar histograms, and PROB near zero
means that it is very unlikely that the two arose from the same
parent distribution.
For two histograms sampled randomly from the same distribution,
PROB will be (approximately) uniformly distributed between 0 and 1.
See discussion in HBOOK manual under "HDIFF- Statistical Considerations".
By default (if no options are selected with CHOPT)
the comparison is done only
on the shape of the two histograms, without consideration of
the difference in numbers of events, and ignoring all
underflow and overflow bins.
The string CHOPT allows specification of the following options:
\begin{verbatim}
  N Include also comparison of the relative normalization of the
    two histograms, in addition to comparing the shapes.
    PROB is then a combined confidence level taking account
    of absolute contents.
  D Debug printout, produces a blank line and two lines of
    information at each call, including the ID numbers, the number
    of events in each histogram, the PROB value, and the maximum
    Kolmogorov distance between the two histograms.
    For 2-Dim histograms, there are two Kolmogorov distances
    (see below). If 'N' is specified, there is a third line of
    output giving the PROB for shape alone, and for normalization.
  O Overflow, requests that overflow bins be taken into account.
  U Underflow, requests that underflow bins be taken into account.
\end{verbatim}
\ENDTEXT

\DEFCMD{HOSMOOTH}{/HISTOGRAM/OPERATIONS}{SMOOTH}{id [ isel ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{ISEL}{Option flag }{I}{D=2 }
\ENDARG
\BEGTEXT
Smooth histogram ID using the 353QH algorithm.
\begin{verbatim}
 ISEL = 0,1 replace original histogram by smoothed.
      = 2   superimpose result of smoothing as a function when editing.
\end{verbatim}
\ENDTEXT

\DEFCMD{HOSPLINE}{/HISTOGRAM/OPERATIONS}{SPLINE}{id [ isel knotx kx ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{ISEL}{Option flag}{I}{D=2 }
\DEFARG{KNOTX}{Number of knots}{I}{D=10 }
\DEFARG{KX}{Degree of the spline}{I}{D=3 }
\ENDARG
\BEGTEXT
Smooth 1-Dim or 2-Dim histogram ID using B-splines.
If ID is a 1-Dim histogram then:
\begin{verbatim}
 ISEL = 0,1 replace original histogram by smoothed.
      = 2   superimpose as a function when editing.
\end{verbatim}
If ID is a 2-Dim histogram then original contents are replaced.
\ENDTEXT

\DEFCMD{HOPARAM}{/HISTOGRAM/OPERATIONS}{PARAM}{id [ isel r2min maxpow ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{ISEL}{Control word}{I}{D=11 }
\DEFARG{R2MIN}{Min correlation coefficient}{R}{D=1. }
\DEFARG{MAXPOW}{Max degree of polynomials}{I}{D=5 R=1:20 }
\ENDARG
\BEGTEXT
Perform a regression on contents of the 1-Dim histogram ID.
Find the best parameterization in terms of elementary functions
(regressors). See HBOOK guide HPARAM.
Control word ISEL=1000*T +100*W +10*S +P
\begin{verbatim}
 S = 1 resulting parametric fit superimposed on histogram
     0 no superposition
 P = 0 minimal output: the residual sum of squares is printed
     1 normal output: in addition, the problem characteristics and
       options are printed; also the standard deviations and
       confidence intervals of the coefficients.
     2 extensive output: the results of each iteration are printed
       with the normal output.
 W = 0 weights on histogram contents are already defined via HBARX
       or HPAKE. If not they are taken to be equal to the
       square-root of the contents.
     1 weights are equal to 1.
 T = 0 monomials will be selected as the elementary functions
     1 Chebyshev polynomials with a definition region: [-1,1]
     2 Legendre polynomials with a definition region: [-1,1]
     3 shifted Chebyshev polynomials with a definition region: [0,1]
     4 Laguerre polynomials with a definition region: [0,+infinite]
     5 Hermite polynomials with a definition region: [-inf,+inf]
\end{verbatim}
The FORTRAN code of the parameterization is written onto the file
FPARAM.DAT.
\ENDTEXT

\DEFCMD{HOHSETPR}{/HISTOGRAM/OPERATIONS}{HSETPR}{param value }
\BEGARG
\DEFARG{PARAM}{Parameter name}{C}{D='FEPS' }
\DEFARG{VALUE}{Parameter value}{R}{D=0.001 }
\ENDARG
\BEGTEXT
Set various parameters for command PARAM.
\ENDTEXT


\DEFMENU{1}{GET\_VECT}
\BEGTEXT
Fill a vector from values stored in HBOOK objects.
\ENDTEXT

\DEFCMD{HGCONTEN}{/HISTOGRAM/GET\_VECT}{CONTENTS}{id vname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Get contents of histogram ID into vector VNAME.
\ENDTEXT

\DEFCMD{HGERRORS}{/HISTOGRAM/GET\_VECT}{ERRORS}{id vname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Get errors of histogram ID into vector VNAME.
\ENDTEXT

\DEFCMD{HGFUNCTI}{/HISTOGRAM/GET\_VECT}{FUNCTION}{id vname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Get function associated to histogram ID into vector VNAME.
\ENDTEXT

\DEFCMD{HGABSCIS}{/HISTOGRAM/GET\_VECT}{ABSCISSA}{id vname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Get values of center of bins abscissa into vector VNAME.
\ENDTEXT

\DEFCMD{HGREBIN}{/HISTOGRAM/GET\_VECT}{REBIN}{id x y ex ey [ n ifirst ilast ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{X}{Name of vector X}{C}{}
\DEFARG{Y}{Name of vector Y}{C}{}
\DEFARG{EX}{Name of vector EX}{C}{}
\DEFARG{EY}{Name of vector EY}{C}{}
\DEFARG{N}{Number of elements to fill}{I}{D=100 }
\DEFARG{IFIRST}{First bin}{I}{D=1 }
\DEFARG{ILAST}{Last bin}{I}{D=100 }
\ENDARG
\BEGTEXT
Get contents and errors into vectors, grouping bins.
Bin width and centers are also extracted.
Allow to combine 2, 3 or more bins into one.
\begin{verbatim}
   E.g.:  REBIN 110 X Y EX EY 25 11 85
           will group by 3 channels 11 to 85  and return
           new abscissa, contents and errors.
           Errors in X are equal to 1.5*BINWIDTH.
   N.B.:
          REBIN ID X Y EX EY  is a convenient way to return in
          one call abscissa, contents and errors for 1-Dim histogram.
          In this case the errors in X are equal to 0.5*BINWIDTH.
\end{verbatim}
\ENDTEXT


\DEFMENU{1}{PUT\_VECT}
\BEGTEXT
Replace histogram contents with values in a vector.
\ENDTEXT

\DEFCMD{HPCONTEN}{/HISTOGRAM/PUT\_VECT}{CONTENTS}{id vname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Replace contents of histogram with values of vector VNAME.
\ENDTEXT

\DEFCMD{HPERRORS}{/HISTOGRAM/PUT\_VECT}{ERRORS}{id vname }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VNAME}{Vector name}{C}{}
\ENDARG
\BEGTEXT
Replace errors of histogram with values of vector VNAME.
\ENDTEXT


\DEFMENU{1}{SET}
\BEGTEXT
Set histogram attributes.
\ENDTEXT

\DEFCMD{HSMAXIMU}{/HISTOGRAM/SET}{MAXIMUM}{id vmax }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VMAX}{Maximum value}{R}{}
\ENDARG
\BEGTEXT
Set the maximum value on the Y axis.
To select again an automatic scale, just set VMAX less then
the minimum.
\ENDTEXT

\DEFCMD{HSMINIMU}{/HISTOGRAM/SET}{MINIMUM}{id vmin }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{VMIN}{Minimum value}{R}{}
\ENDARG
\BEGTEXT
Set the minimum value on the Y axis.
To select again an automatic scale, just set VMIN greater then
the maximum.
\ENDTEXT

\DEFCMD{HSNORMAL}{/HISTOGRAM/SET}{NORMALIZE\_FACTOR}{id [ xnorm ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{XNORM}{Normalization factor}{R}{D=1 }
\ENDARG
\BEGTEXT
Set the contents/errors normalization factor.
Only valid for histograms (1-Dim).
(does not change contents, only presentation).
\ENDTEXT

\DEFCMD{HSSCALE_}{/HISTOGRAM/SET}{SCALE\_FACTOR\_2D}{id [ xscale ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{XSCALE}{Scale factor}{R}{D=0 }
\ENDARG
\BEGTEXT
Set the scale factor for histograms (2-Dim).
\ENDTEXT

\DEFCMD{HSIDOPT}{/HISTOGRAM/SET}{IDOPT}{id option }
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{OPTION}{Options}{C}{}
\ENDARG
\BEGTEXT
Set options for histogram ID. (* means default).
\begin{verbatim}
 SETD* Set all options to the default values
 SHOW  Print all the options currently set
 BLAC  1 Dim histogram printed with X characters
 CONT* 1 Dim histogram is printed with the contour option
 STAR  1 Dim histogram is printed with a * at the Y value
 SCAT* Print a 2 Dim histogram as a scatter-plot
 TABL  Print a 2 Dim histogram as a table
 PROS* Plot errors as the Spread of each bin in Y for
       profile histograms
 PROE  Plot errors as the mean of each bin in Y for
       profile histograms
 STAT  Mean value and RMS computed at filling time
 NSTA* Mean value and RMS computed from bin contents only
 ERRO  Errors bars printed as SQRT(contents)
 NERR* Do not print print error bars
 INTE  Print the values of integrated contents bin by bin
 NINT* Do not print integrated contents
 LOGY  1 Dim histogram is printed in Log scale in Y
 LINY* 1 Dim histogram is printed in linear scale in Y
 PCHA* Print channel numbers
 NPCH  Do not print channel numbers
 PCON* Print bin contents
 NPCO  Do not print bin contents
 PLOW* Print values of low edge of the bins
 NPLO  Do not print the low edge
 PERR  Print the values of the errors for each bin
 NPER* Do not print the values of the errors
 PFUN  Print the values of the associated function bin by bin
 NPFU* Do not print the values of the associated function
 PHIS* Print the histogram profile
 NPHI  Do not print the histogram profile
 PSTA* Print the values of statistics (entries,mean,RMS,etc.)
 NPST  Do not print values of statistics
 ROTA  Print histogram rotated by 90 degrees
 NROT* Print histogram vertically
 1EVL  Force an integer value for the steps in the Y axis
 AEVL* Steps for the Y axis are automatically computed
 2PAG  Histogram is printed over two pages
 1PAG* Histogram is printed in one single page
 AUTO* Automatic scaling
\end{verbatim}
\ENDTEXT


\DEFMENU{0}{FUNCTION}
\BEGTEXT
Operations with Functions. Creation and plotting.
\ENDTEXT

\DEFCMD{F0FUN1}{/FUNCTION}{FUN1}{id ufunc ncx xmin xmax [ chopt ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{UFUNC}{Name of the function}{C}{}
\DEFARG{NCX}{Number of channels}{I}{D=100 R=1: }
\DEFARG{XMIN}{Low edge}{R}{D=0. }
\DEFARG{XMAX}{Upper edge}{R}{D=100. }
\DEFARG{CHOPT}{Options}{C}{D='P' }
\ENDARG
\BEGTEXT
Create a one dimensional histogram and fill the bins with the
values of a (single-valued) function.
The function UFUNC may be given in two ways:

-An expression of the variable x in case of a simple function.
\begin{verbatim}
 Ex: FUN1  10 sin(x)/x  100 0 10
\end{verbatim}
-UFUNC is the name of a COMIS function in a text file with the
name UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).

If CHOPT='P' the function is drawn.
\ENDTEXT

\DEFCMD{F0FUN2}{/FUNCTION}{FUN2}{id ufunc ncx xmin xmax ncy ymin ymax [ chopt ]}
\BEGARG
\DEFARG{ID}{Histogram (2-Dim) Identifier}{C}{}
\DEFARG{UFUNC}{Name of the function}{C}{}
\DEFARG{NCX}{Number of channels in X}{I}{D=40 R=1: }
\DEFARG{XMIN}{Low edge in X}{R}{D=0. }
\DEFARG{XMAX}{Upper edge in X}{R}{D=40. }
\DEFARG{NCY}{Number of channels in Y}{I}{D=40 R=1: }
\DEFARG{YMIN}{Low edge in Y}{R}{D=0. }
\DEFARG{YMAX}{Upper edge in Y}{R}{D=40. }
\DEFARG{CHOPT}{Options}{C}{D='S' R='S, ,L,C' }
\ENDARG
\BEGTEXT
Create a two dimensional histogram and fill
the bins with the values of a (two-valued) function.
The function UFUNC may be given in two ways:

-An expression of the variables x and y in case of a simple function.
\begin{verbatim}
 Ex: FUN2  10 abs(sin(x**2+y**2)) 40 -2 2 40 -2 2 C
\end{verbatim}
-UFUNC is the name of a COMIS function in a text file with the
name UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).

If CHOPT='S' the function is drawn as a surface.
If CHOPT='L' the function is drawn as a lego plot.
If CHOPT='C' the function is drawn as a contour plot.
\ENDTEXT

\DEFCMD{F0DRAW}{/FUNCTION}{DRAW}{ufunc [ chopt ]}
\BEGARG
\DEFARG{UFUNC}{Name of function}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ' }
\ENDARG
\BEGTEXT
Draw the function UFUNC
in the current ranges specified by the command:
RANGE XLOW XUP YLOW YUP ZLOW ZUP and with THETHA and PHI angles specified
by the command ANGLE THETA PHI. The number of points to evaluate the function
between XLOW, XUP YLOW, YUP, and ZLOW, ZUP can be changed by the command
POINTS NPX NPY NPZ.

The function UFUNC may be given in two ways:
- As an expression of the variables X, Y, Z in the case of a simple function.
\begin{verbatim}
  Ex:
  PAW >  FUN/DRAW X*Y*Z         | equivalent to :
  PAW >  FUN/DRAW X*Y*Z=0
  PAW >  FUN/DRAW X**2+Y**2+Z**2=1
  PAW >  FUN/DRAW X**2+Y**2=1-Z**2
\end{verbatim}
- As a COMIS function in a text file with the name UFUNC.FTN or UFUNC.FOR
or UFUNC FORTRAN (Apollo, VAX, IBM).
\begin{verbatim}
  Ex:
  The file FTEST.FOR contains:
\end{verbatim}

\begin{verbatim}
  FUNCTION FTEST(X,Y,Z)
  IF(X.LE.0..AND.Y.LE.0.)THEN
    FTEST=(X+0.5)**2+(Y+0.5)**2+(Z+0.5)**2-0.2
  ELSE
    FTEST=(X-0.5)**2+(Y-0.5)**2+(Z-0.5)**2-0.1
  ENDIF
  END
\end{verbatim}

\begin{verbatim}
  PAW > RANGE -1 1 -1 1 -1 1  | Define the range as a cube between -1 1 in the 3
                                directions
  PAW > POINTS 20 20 20       | FUN/DRAW will use 20 points in the 3 directions
  PAW > FUN/DRAW FTEST.FOR    | Draw 2 spheres centered on (-0.5,-0.5,-0.5)
                                and (0.5,0.5,0.5) with the radius SQRT(0.2)
                                and SQRT(0.1)
\end{verbatim}
\ENDTEXT

\DEFCMD{F0PLOT}{/FUNCTION}{PLOT}{ufunc xlow xup [ chopt ]}
\BEGARG
\DEFARG{UFUNC}{Name of function}{C}{}
\DEFARG{XLOW}{Lower limit}{R}{}
\DEFARG{XUP}{Upper limit}{R}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,C,S,+,L,P,*' }
\ENDARG
\BEGTEXT
Plot single-valued function UFUNC between XLOW and XUP.
The function UFUNC may be given in two ways:

-An expression of the variable x in case of a simple function.
\begin{verbatim}
 Ex: FUN/PLOT   sin(x)/x  0 10
\end{verbatim}
-UFUNC is the name of a COMIS function in a text file with the
name UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).
For example, if the file FTEST.FOR contains:
\begin{verbatim}
      FUNCTION FTEST(X)
      FTEST=SIN(X)*EXP(-0.1*X)
      END
\end{verbatim}
Then, FUN/PLOT FTEST.FOR 0 10, will interpret the Fortran
code in the file FTEST.FOR and draw the function for x
between 0 and 10.

The number of points to evaluate the function between XLOW and XUP
can be changed by the command /FUN/POINTS. Only 1-Dim functions
are supported. For 2-Dim use FUN2.
CHOPT may be a combination of the following characters:
\begin{verbatim}
 'C' Draw a smooth curve (default if CHOPT not specified)
 'S' Superimpose plot on top of existing picture.
 '+' Add contents of ID to last plotted histogram.
 'L' Connect channel contents by a line.
 'P' Draw the current polymarker at each channel.
 '*' Draw a * at each channel.
\end{verbatim}
\ENDTEXT

\DEFCMD{F0POINTS}{/FUNCTION}{POINTS}{[ npx npy npz ]}
\BEGARG
\DEFARG{NPX}{Number of points on X axis}{I}{D=20 R=2:1000 }
\DEFARG{NPY}{Number of points on Y axis}{I}{D=20 R=2:1000 }
\DEFARG{NPZ}{Number of points on Z axis}{I}{D=20 R=2:1000 }
\ENDARG
\BEGTEXT
Change the number of points to be used by FUN/DRAW
and FUN/PLOT. Note that the default for NPX is 20 for 3-Dim plots
(FUN/DRAW) but it is 100 for 1-Dim plots (FUN/PLOT).
\ENDTEXT

\DEFCMD{F0RANGE}{/FUNCTION}{RANGE}{[ xlow xup ylow yup zlow zup ]}
\BEGARG
\DEFARG{XLOW}{X Lower limit}{R}{D=-1. }
\DEFARG{XUP}{X Upper limit}{R}{D=1. }
\DEFARG{YLOW}{Y Lower limit}{R}{D=-1. }
\DEFARG{YUP}{Y Upper limit}{R}{D=1 }
\DEFARG{ZLOW}{Z Lower limit}{R}{D=-1. }
\DEFARG{ZUP}{Z Upper limit}{R}{D=1. }
\ENDARG
\BEGTEXT
Change the range used by FUN/DRAW.
\ENDTEXT

\DEFCMD{F0ANGLE}{/FUNCTION}{ANGLE}{[ theta phi ]}
\BEGARG
\DEFARG{THETA}{Angle THETA in degrees}{R}{D=30. }
\DEFARG{PHI}{Angle PHI in degrees}{R}{D=30. }
\ENDARG
\BEGTEXT
Change the angle used by FUN/DRAW and HISTO/PLOT.
\ENDTEXT


\DEFMENU{0}{NTUPLE}
\BEGTEXT
Ntuple creation and related operations.
\ENDTEXT

\DEFCMD{N0CREATE}{/NTUPLE}{CREATE}{idn title nvar chrzpa nprime varlist }
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\DEFARG{TITLE}{Ntuple title}{C}{D=' ' }
\DEFARG{NVAR}{Number of variables}{I}{D=1 R=1:512 }
\DEFARG{CHRZPA}{RZ path}{C}{D=' ' }
\DEFARG{NPRIME}{Primary allocation}{I}{D=1000 }
\DEFARG{VARLIST}{Names of the NVAR variables}{C}{}
\ENDARG
\BEGTEXT
Create an Ntuple.
The Ntuple may be created either purely in memory or possibly
using an automatic overflow to an RZ file.
Memory allocation works in the following way.
If CHRZPA = '  ', then a bank of NPRIME
words is created. When the space in this bank is exhausted at filling time,
a new linear structure of length NPRIME is created and this process will be
repeated should the structure become exhausted.
If CHRZPA contains the top directory name of an already existing RZ file (as
declared with HISTO/FILE), then a bank of length NPRIME is also created,
but at filling time, this bank is moved to the RZ file when full, and
then it is overwritten by any new entries.
The Ntuple can be filled by calling HFN from an interactively
defined subroutine called by the command NTUPLE/LOOP or by NTUPLE/READ.
The number of variables per data point is given in the parameter NVAR.
\ENDTEXT

\DEFCMD{N0LIST}{/NTUPLE}{LIST}{}
\BEGTEXT
List all Ntuples in the Current Directory.
Note that the command HISTO/LIST lists all histograms and Ntuples
in the Current Directory.
\ENDTEXT

\DEFCMD{N0PRINT}{/NTUPLE}{PRINT}{idn }
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\ENDARG
\BEGTEXT
Print a summary about Ntuple IDN.
Number of entries, variables names and limits are listed.
\ENDTEXT

\DEFCMD{N0SCAN}{/NTUPLE}{SCAN}{idn [ chfunc nevent ifirst nvars varlis ]}
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\DEFARG{CHFUNC}{User cut function}{C}{D='0' }
\DEFARG{NEVENT}{Number of events}{I}{D=999999 }
\DEFARG{IFIRST}{First event}{I}{D=1 }
\DEFARG{NVARS}{Number of variables to scan}{I}{D=8 R=0:8 }
\DEFARG{VARLIS}{Names of the NVARS variables to scan}{C}{}
\ENDARG
\BEGTEXT
Scan the entries of an Ntuple subject to user cuts.
Scan the variables for NEVENT events starting at IFIRST, requiring that
the events satisfy cut CHFUNC. Up to 8 variables may be scanned,
the default is to scan the first 8 variables.
VARLIS may contain a list of the original variables or/and expressions
of the original variables.
For example, if IDN=30 has the 3 variables X,Y,Z, one can do:
\begin{verbatim}
 PAW > scan 30
 PAW > scan 30 z>10
 PAW > scan 30 z>10 ! ! 5 z abs(x) y+z x func.for
       where func.for is a COMIS function returning an expression
       of the original variables. This function func.for may be
       generated automatically by the PAW command:
 PAW > uwfunc 30 func.for
\end{verbatim}
\ENDTEXT

\DEFCMD{N0LOOP}{/NTUPLE}{LOOP}{idn uwfunc [ nevent ifirst ]}
\BEGARG
\DEFARG{IDN}{Identifier of Ntuple}{C}{}
\DEFARG{UWFUNC}{Selection function or cut number}{C}{D=' ' }
\DEFARG{NEVENT}{Number of events}{I}{D=999999 }
\DEFARG{IFIRST}{First event}{I}{D=1 }
\ENDARG
\BEGTEXT
Invoke the selection function UWFUNC for each event
starting at event IFIRST. In UWFUNC, the user can fill one or several
histograms previously booked.
The loop will be terminated if UWFUNC returns a negative value.
For more information about UWFUNC, see command NTUPLE/PLOT.
\ENDTEXT

\DEFCMD{N0MERGE}{/NTUPLE}{MERGE}{idn1 idn2 [ uwfunc nevent ifirst ]}
\BEGARG
\DEFARG{IDN1}{Identifier of first Ntuple}{C}{}
\DEFARG{IDN2}{Identifier of second Ntuple}{C}{}
\DEFARG{UWFUNC}{Selection function or cut number}{C}{D=' ' }
\DEFARG{NEVENT}{Number of events}{I}{D=999999 }
\DEFARG{IFIRST}{First event}{I}{D=1 }
\ENDARG
\BEGTEXT
Merge two Ntuples.
Invoke the selection function UWFUNC for each of the NEVENT events
starting at event IFIRST of Ntuple IDN1.
Suppose you have 4 files containing Ntuple ID=10 and you want to merge
the 4 files into the file 4, the sequence is:
\begin{verbatim}
 PAW >Histo/file 1 file1
 PAW >Histo/file 2 file2
 PAW >Histo/file 3 file3
 PAW >Histo/file 4 file4 1024 U
 PAW >Ntuple/Merge //lun1/10 //lun4/10
 PAW >Ntuple/Merge //lun2/10 //lun4/10
 PAW >Ntuple/Merge //lun3/10 //lun4/10
 PAW >Ntuple/plot 10.x .........
\end{verbatim}
Only the events with UWFUNC>0 are appended to IDN2. IDN2 may be empty.
Note that the Ntuple variables may be redefined inside UWFUNC.
For more information about UWFUNC, see command NTUPLE/PLOT.
\ENDTEXT

\DEFCMD{N0PROJEC}{/NTUPLE}{PROJECT}{idh idn [ uwfunc nevent ifirst ]}
\BEGARG
\DEFARG{IDH}{Identifier of histogram to fill}{C}{}
\DEFARG{IDN}{Identifier of Ntuple}{C}{}
\DEFARG{UWFUNC}{Selection function or cut number}{C}{D=' ' }
\DEFARG{NEVENT}{Number of events}{I}{D=999999 }
\DEFARG{IFIRST}{First event}{I}{D=1 }
\ENDARG
\BEGTEXT
Project an Ntuple onto a 1-Dim or 2-Dim histogram,
possibly using a selection function or predefined cuts.
IDN may be given as IDN or IDN.X , IDN.Y\%X , IDN.1, IDN.2\%1.
Y\%X means variable Y of Ntuple IDN versus variable X.
For more information about UWFUNC, see command NTUPLE/PLOT.
The histogram IDH is not reset before filling. This allows
several PROJECTs from different Ntuples.
\ENDTEXT

\DEFCMD{N0READ}{/NTUPLE}{READ}{idn fname [ format chopt nevent ]}
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{FORMAT}{Format}{C}{D='*' }
\DEFARG{CHOPT}{Options}{C}{D=' ' }
\DEFARG{NEVENT}{Number of events}{I}{D=1000000 }
\ENDARG
\BEGTEXT
Read Ntuple values from the alphanumeric file FNAME with
the format specifications in FORMAT.
Before executing this command, the Ntuple IDN must have been
created with the command Ntuple/Create.
\ENDTEXT

\DEFCMD{N0PLOT}{/NTUPLE}{PLOT}{idn [ uwfunc nevent ifirst nupd option ]}
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\DEFARG{UWFUNC}{Selection function}{C}{D='0' }
\DEFARG{NEVENT}{Number of events}{I}{D=999999 }
\DEFARG{IFIRST}{First event}{I}{D=1 }
\DEFARG{NUPD}{Frequency to update histogram}{I}{D=1000000 }
\DEFARG{OPTION}{Options}{C}{D=' ' R=' ,C,S,+,B,L,P,*,U,E,A' }
\ENDARG
\BEGTEXT
Project and plot an Ntuple as a (1-Dim or 2-Dim) histogram
with automatic binning (ID=1000000),
possibly using a selection algorithm.
See parameter CHOPT in command HISTO/PLOT for explanation of OPTION.
\begin{verbatim}
 IDN may be given as IDN
                     IDN.X
                     IDN.Y%X
                     IDN.1
                     IDN.2%1
                     IDN.expression1
                     IDN.expression1%expression2
\end{verbatim}
Y\%X means a scatter-plot Y(I) versus X(I) where I is the event number.
2\%1 means a scatter-plot variable 2 versus variable 1.
In this example, X and Y are the names of the variables 1 and 2
respectively.
Expression 1 is any numerical expression of the Ntuple variables.
It may include a call to a COMIS function.
\begin{verbatim}
 UWFUNC may have the following forms:
 1- UWFUNC='0' or missing (only IDN given). No selection is applied.
 2- UWFUNC is a CUT or combination of valid CUTS created by the
    command NTUPLE/CUTS. Ex:
           UWFUNC=1            means use cut number 1
           UWFUNC=1.AND.2
           UWFUNC=.NOT.(1.AND.2)
           UWFUNC=(1.OR.2).AND.3
 3- UWFUNC is a FORTRAN expression
    Ex:    X>3.14.AND.(Y<Z+3.15)
 4- UWFUNC is a variable name or an arithmetic expression
    Ex:   NT/PLOT 30.X Y  weight of each event is variable Y
          NT/PLOT 30.X X**2+Y**2
 5- UWFUNC is the name of a selection function in a text file with
    the name UWFUNC.FTN, UWFUNC.FOR, UWFUNC FORTRAN (Apollo, VAX, IBM).
\end{verbatim}
The command UWFUNC may be used to generate automatically this function.
For example if IDN=30 is an Ntuple with 3 variables
per event and 10000 events, then
\begin{verbatim}
    NTUPLE/PLOT 30.X SELECT.FOR
\end{verbatim}
will process the 10000 events of the Ntuple IDN=30. For each event,
the function SELECT is called. It returns the weight of the event.
Example:
\begin{verbatim}
    FUNCTION SELECT(X)
    DIMENSION X(3)
    IF(X(1)**1+X(2)**2.LT.1.5)THEN
       SELECT=0.
    ELSE
       SELECT=1.
    ENDIF
    END
\end{verbatim}
The file SELECT.FOR (VAX), SELECT.FTN (Apollo) or
SELECT FORTRAN (IBM) can be edited from PAW using the command EDIT.
Note that if the suffix (.FTN, .FORTRAN or .FOR) is omitted, then COMIS
will start from the precompiled version in memory and not from the file.
Results of a selection can be saved in a MASK (See NTUPLE/MASK).
\begin{verbatim}
 Ex: NT/PLOT 30.X Z<0.4>>MNAME(4)
     means mark bit 4 in mask MNAME for all events satisfying
     the condition Z<0.4
\end{verbatim}
A MASK may also be given as input to a selection expression.
\begin{verbatim}
 Ex:  NT/PLOT 30.X MNAME(4).and.Z<0.4
      means all events satisfying bit 4 of MNAME AND Z<0.4
\end{verbatim}
It is possible to plot expressions of the original variables.

\begin{verbatim}
 Ex 1:  NT/PLOT 30.SIN(X)%SQRT(Y**2+Z**2)  Z<0.4
     plots a scatter-plot of variable U versus V for all events
     satisfying the condition Z<0.4. U and V are defined as being
     U=SIN(X)  and V=SQRT(X**2+Y**2)
\end{verbatim}

\begin{verbatim}
 Ex 2:  NT/PLOT 30.FUNC.FTN(X)%(SIN(Y)+3.)  Z<0.2.and.TEST.FTN>6
     plots a scatter-plot of variable U versus V for all events
     satisfying the condition (Z<0.2 and the result of the COMIS
     function TEST.FTN >6). U and V are defined as being
     U=Result of the COMIS function FUNC.FTN,  V=SIN(Y)+3.
\end{verbatim}
The default identifier of the histogram  being filled is IDF=1000000.
At the next invokation of this command, it will be overwritten.
If either NEVENT or IFIRST or NUPD are negative, then the identifier
of the histogram being filled will be taken as IDF=-NEVENT or
IDF=-IFIRST or IDF=-NUPD. IDF may have been created with H/CREATE.
Before filling IDF, the contents of IDF are reset if IDF already
exists. Use NTUPLE/PROJECT to cumulate several passes into IDF.
Note that IDF not equal to 1000000 is a convenient way to force user
binning. This option must be used when options '+', 'U', 'S' are
specified in OPTION.
Every NUPD events, the current status of the  histogram is displayed.
\ENDTEXT

\DEFCMD{N0CUTS}{/NTUPLE}{CUTS}{icut [ option fname ]}
\BEGARG
\DEFARG{ICUT}{Cut number}{I}{R=0:100 }
\DEFARG{OPTION}{Options}{C}{D='P' R='P,G, ,S,-,R,W,D' }
\DEFARG{FNAME}{File name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Define cut number ICUT for an Ntuple.
This cut can then be used
in subsequent commands NTUPLE/PLOT, PROJECT.
\begin{verbatim}
  OPTION='G' define a new cut ICUT using graphics input on the latest
             1-Dim or 2-Dim projection of the Ntuple.
             For a 1-Dim projection, give 2 points cutmin,cutmax.
             For a 2-Dim projection, give up to 20 points to delimit
             the selected area. The polygon will automatically
             be closed by PAW.
  OPTION='P' Print definition of cut number ICUT.
         'S' same as P
         '-' Reset cut ICUT
         'R' read definition of cut ICUT from file FNAME.
         'W' write definition of cut ICUT on file FNAME (text file).
         'D' Draw cut contour.
  OPTION='expression'  Ex:   0.4<X<0.8.and.Y<SQRT(X)
\end{verbatim}
Note that ICUT=0 means all cuts except for 'G' option.
When option G is selected, graphical cuts are only operational
for plots of the original Ntuple variables, not for expressions
of these variables.
\ENDTEXT

\DEFCMD{N0CSELEC}{/NTUPLE}{CSELECT}{[ chopt csize ]}
\BEGARG
\DEFARG{CHOPT}{Options}{C}{D='N' R='N, ,R,B,C' }
\DEFARG{CSIZE}{Comment size}{R}{D=0.28 }
\ENDARG
\BEGTEXT
To write selection mechanism as a comment on the picture.
If option N is given, then all subsequent NTUPLE/PLOT commands
will print the selection mechanism with the options specified in CHOPT.
By default, the comment is drawn left justified above the top zone line.
The options are :
\begin{verbatim}
  'R' comment is right adjusted to the current zone
  'C' comment is centered to the current zone
  'B' comment is drawn below the top zone line
\end{verbatim}
Example:
\begin{verbatim}
 CSEL          All coming NT/PLOT commands will draw a comment
               of size CSIZE=0.28cm Left justified.
 CSEL NRB 0.4  All coming NT/PLOT commands will draw a comment
               of size 0.4 cm Right justified Below the top line.
 CSEL  CB      Draw previous selection mechanism Centered Below
               the top zone line.
\end{verbatim}
\ENDTEXT

\DEFCMD{N0MASK}{/NTUPLE}{MASK}{mname [ chopt number ]}
\BEGARG
\DEFARG{MNAME}{Mask name}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,U,N,P,C,R' }
\DEFARG{NUMBER}{Bit number}{I}{D=0 }
\ENDARG
\BEGTEXT
Perform Operations with masks.
A mask is a direct-access file with the name MNAME.MASK.
It must contain as many 32 bit words as there are events
in the associated Ntuple.
Masks are interesting when only a few events of a Ntuple are selected
with a time consuming selection algorithm. For example if the command:
\begin{verbatim}
   NT/PLOT 30.X  Z<0.4.AND.SELECT.FTN>>MNAME(6)
\end{verbatim}
then for all events in Ntuple 30 satisfying the condition above,
the bit 6 in the corresponding mask words will be set. One can then use
the mask as selection mechanism. Example:
\begin{verbatim}
   NT/PLOT 30.X MNAME(6)
\end{verbatim}
will produce the same results than the NT/PLOT command above, but
will be much faster if only a small fraction of all the events
is selected.
MASKS are automatically saved across PAW sessions on files.
\begin{verbatim}
 CHOPT=' ' Existing mask on file MNAME.MASK is attached for READ only.
 CHOPT='U' Existing mask on file MNAME.MASK is attached for UPDATE.
 CHOPT='N' A new mask on file MNAME.MASK is created for NUMBER events.
 CHOPT='P' The comments for all active bits is printed.
 CHOPT='C' Mask is closed.
 CHOPT='R' Reset bit number NUMBER.If NUMBER=99, resets all bits.
\end{verbatim}
Example:
\begin{verbatim}
   MASK  TEST N 10000
      creates a new mask on file TEST.MASK with enough words to
      process a Ntuple with 10000 events
   MASK  TEST UP
      opens an existing mask for update and
      prints the active selection bits with explanation
\end{verbatim}
\ENDTEXT

\DEFCMD{N0UWFUNC}{/NTUPLE}{UWFUNC}{idn fname [ chopt ]}
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,E,P,T' }
\ENDARG
\BEGTEXT
To generate the FORTRAN skeleton of a selection function.
Example:
If Ntuple ID=30 has variable names [X,Y,Z,ETOT,EMISS,etc] then:

NTUPLE/UWFUNC 30 SELECT.FOR   will generate the file SELECT.FOR with:
\begin{verbatim}
      FUNCTION SELECT(XDUMMY)
      COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc
      SELECT=1.
      END
\end{verbatim}
Then using the command EDIT one can modify this file which could then
look something like (IDNEVT is the event number):
\begin{verbatim}
      FUNCTION SELECT(XDUMMY)
      COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc
      IF(X**2+Y**2.GT.Z**2.OR.ETOT.GT.20.)THEN
         SELECT=1.
      ELSE
         SELECT=0.
      ENDIF
      END
\end{verbatim}
If in a subsequent command NTUPLE/PLOT, the selection function SELECT
is used, then:
\begin{verbatim}
   If NTUPLE/PLOT 30.ETOT SELECT.FOR
      VIDN1=ETOT
   If NTUPLE/PLOT 30.SQRT(X**2+Y**2)%(ETOT-EMISS)
      VIDN1=ETOT-EMISS
      VIDN2=SQRT(X**2+Y**2)
 If CHOPT='E' then the local editor is invoked on FNAME.
         ='P' code to print events is generated.
         ='T' Names of the Ntuple variables are generated in DATA.
\end{verbatim}
\ENDTEXT

\DEFCMD{N0LINTRA}{/NTUPLE}{LINTRA}{idn [ chopt nevent ifirst nvars varlis ]}
\BEGARG
\DEFARG{IDN}{Ntuple Identifier}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,N,P' }
\DEFARG{NEVENT}{Number of events}{I}{D=999999 }
\DEFARG{IFIRST}{First event}{I}{D=1 }
\DEFARG{NVARS}{Number of the most significant variables }{I}{D=20 R=0:20 }
\DEFARG{VARLIS}{Names of the NVARS most significant variables }{C}{}
\ENDARG
\BEGTEXT
Data reduction on Ntuple.
The method used is the PRINCIPAL COMPONENTS ANALYSIS.
The Principal Components Analysis method consists in applying
a linear transformation to the original variables of a ntuple.
This transformation is described by an orthogonal matrix and
is equivalent to a rotation of the original space to a new set
of coordinates vectors, which hopefully provide easier identification
and dimensionality reduction. This matrix is real positive definite
and symmetric and has all its eigenvalues greater than zero.
Among the family of all complete orthonormal bases, the basis
formed by the eigenvectors of the covariance matrix and belonging
to the largest eigenvalues corresponds to the most significant features
for the description of the original ntuple.
Reduction of the variables for NEVENT events starting at IFIRST
The default is to take all the 20 first variables.
CHOPT : Possible options 'NP'
\begin{verbatim}
   'N'  The variables are normalized
        This option is useful in the case the ranges of variables
        are very different
   'P'  Print more results about the analysis
\end{verbatim}
This command creates a file : -> XTOXSI.FORTRAN or xtoxsi.for,xtoxsi.ftn.
This file contains a Fortran function which computes the new variables.
These new variables can be visualized in PAW with for example:
\begin{verbatim}
 PAW > Ntuple/plot id.xtoxsi.ftn(1)
 PAW > Ntuple/plot id.xtoxsi.ftn(1)%xtoxsi.ftn(3)
\end{verbatim}
\ENDTEXT


\DEFMENU{0}{GRAPHICS}
\BEGTEXT
Interface to the graphics packages HPLOT and HIGZ.
\ENDTEXT

\DEFCMD{G0SET}{/GRAPHICS}{SET}{[ chatt value ]}
\BEGARG
\DEFARG{CHATT}{Attribute name}{C}{D='SHOW' }
\DEFARG{VALUE}{Attribute value}{R}{D=0 }
\ENDARG
\BEGTEXT
Set a specific HPLOT attribute.
If CHATT='SHOW', print defaults and current values for all attributes.
If CHATT='*', restore default values for all attributes.
If VALUE=0, the attribute is set to its default value.
\ENDTEXT

\DEFCMD{G0OPTION}{/GRAPHICS}{OPTION}{[ choptn ]}
\BEGARG
\DEFARG{CHOPTN}{Option name}{C}{D='SHOW' }
\ENDARG
\BEGTEXT
Set general plotting options for HPLOT.
If CHOPTN='SHOW' print all current and default options.
If CHOPTN='*', restore all default options.
\ENDTEXT

\DEFCMD{G0METAFI}{/GRAPHICS}{METAFILE}{[ lun metafl chmeta ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{D=0 }
\DEFARG{METAFL}{Metafile ID}{I}{D=0 }
\DEFARG{CHMETA}{Metafile name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Set the metafile logical unit and metafile type.
This command controls the destination of the subsequent graphics output.
Example:
\begin{verbatim}
 LUN =-10 output only on metafile opened on unit 10;
 LUN =  0 output only on screen;
 LUN = 10 output on both screen and metafile opened on unit 10;
\end{verbatim}
Use the command FORTRAN/FILE to open a new file, FORTRAN/CLOSE to close it.
Note that PAW opens the file PAW.METAFILE on the unit 10
at initialization time.
\begin{verbatim}
 METAFL=   4 Appendix E GKS.
 METAFL=-111 HIGZ/PostScript (Portrait).
 METAFL=-112 HIGZ/PostScript (Landscape).
 METAFL=-113 HIGZ/Encapsulated PostScript.
 METAFL=-114 HIGZ/PostScript Color (Portrait).
 METAFL=-115 HIGZ/PostScript Color (Landscape).
 METAFL=-777 HIGZ/LaTex Encapsulated.
 METAFL=-778 HIGZ/LaTex.
\end{verbatim}
\ENDTEXT

\DEFCMD{G0WORKST}{/GRAPHICS}{WORKSTATION}{iwkid [ chopt iwtyp ]}
\BEGARG
\DEFARG{IWKID}{Workstation ID}{I}{D=1 }
\DEFARG{CHOPT}{Options}{C}{D='OA' }
\DEFARG{IWTYP}{Workstation type}{I}{D=1 }
\ENDARG
\BEGTEXT
To create/delete workstations or change status.
\begin{verbatim}
    CHOPT='O'  Open a new workstation
    CHOPT='C'  Close a workstation
    CHOPT='A'  Activate a workstation
    CHOPT='D'  Deactivate a workstation
    CHOPT='L'  Give the list of open workstations
    IWKID > 0  Do the action specified by CHOPT on the
               workstation identified by IWKID.
    IWKID=0    Do the action specified by CHOPT on all
               workstations.
    IWKID < 0  Do the action specified by CHOPT on the
               workstation identified by -IWKID and the
               complementary action on all the others.
\end{verbatim}
\ENDTEXT

\DEFCMD{G0SLIDE}{/GRAPHICS}{SLIDE}{}
\BEGTEXT
Invoke the SLIDE package.
\ENDTEXT


\DEFMENU{1}{MISC}
\BEGTEXT
Miscellaneous HPLOT functions.
\ENDTEXT

\DEFCMD{GMNEXT}{/GRAPHICS/MISC}{NEXT}{}
\BEGTEXT
Clear the screen.
Initialize a new HIGZ picture if option ZFL or ZFL1 has been selected.
Select the Normalization Transformation number 1 (cm).
\ENDTEXT

\DEFCMD{GMCLR}{/GRAPHICS/MISC}{CLR}{}
\BEGTEXT
Clear the screen.
\ENDTEXT

\DEFCMD{GMLOCATE}{/GRAPHICS/MISC}{LOCATE}{[ ntpri chopt ]}
\BEGARG
\DEFARG{NTPRI}{Transformation with highest priority}{I}{D=-1 }
\DEFARG{CHOPT}{Options}{C}{D='R' R='R,S,+' }
\ENDARG
\BEGTEXT
Locate points on the screen using the graphics cursor
and output coordinates on terminal. Control is returned when
the BREAK (right) mouse button is clicked (or CRTL/E) or
when 20 points are located.
The optional parameter NTPRI may be specified to locate
a point in the specific transformation number NTPRI.
NTPRI=-1 (default) means that all the histogram transformation
numbers (10, 20, etc.) have priority on transformation number 1.
\begin{verbatim}
 CHOPT='R' Request mode is used to locate the points (default)
       'S' Sample mode is used to locate the points
       'I' Integrate an histogram between 2 bins
       '+' use the tracking cross (default is cross-hair)
\end{verbatim}
\ENDTEXT

\DEFCMD{GMVLOCAT}{/GRAPHICS/MISC}{VLOCATE}{vecx vecy [ chopt ntpri ]}
\BEGARG
\DEFARG{VECX}{Vector for coordinates X}{C}{}
\DEFARG{VECY}{Vector for coordinates Y}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,L,P,*,+,-,S' }
\DEFARG{NTPRI}{Transformation with highest priority}{I}{D=-1 }
\ENDARG
\BEGTEXT
Locate a set of points using the graphics cursor.
Return corresponding coordinates in vectors X and Y.
If vectors X or Y do not exist, they are automatically created.
Control is returned when the point is outside picture limits
or when the BREAK (right) mouse button is clicked (or CRTL/E).
\begin{verbatim}
 CHOPT=' ' use the cross-hair
       '+' use the tracking cross
       '-' use the rubber line
       'L' connect points by a polyline
       'P' draw the current polymarker at each point
       '*' draw a * at each point
       'S' sample mode is used. Allows to see the coordinates of
           point before clicking
\end{verbatim}
The optional parameter NTPRI may be specified to locate
a point in the specific transformation number NTPRI (see LOCATE).
\ENDTEXT

\DEFCMD{GMHMOVE}{/GRAPHICS/MISC}{HMOVE}{}
\BEGTEXT
Change the contents of a histogram channel using the cursor.
Position the cursor to the channel to be changed, trigger graphics input,
position the cursor to the new channel value
(a rubber band box is used to visualize the change), trigger graphics input
to fix the new value.
\ENDTEXT


\DEFMENU{1}{VIEWING}
\BEGTEXT
To define Normalization transformations.
Either automatically (ZONE and SIZE) or 'by hand' (SVP, SWN and SELNT).
\ENDTEXT

\DEFCMD{GVZONE}{/GRAPHICS/VIEWING}{ZONE}{[ nx ny ifirst chopt ]}
\BEGARG
\DEFARG{NX}{Number of divisions along X}{I}{D=1 }
\DEFARG{NY}{Number of divisions along Y}{I}{D=1 }
\DEFARG{IFIRST}{First division number}{I}{D=1 }
\DEFARG{CHOPT}{Option}{C}{D=' ' R=' ,S' }
\ENDARG
\BEGTEXT
Subdivide the picture into NX by NY zones,
starting at zone IFIRST (count along X first).
If CHOPT='S', redefine zones on current picture.
\ENDTEXT

\DEFCMD{GVSIZE}{/GRAPHICS/VIEWING}{SIZE}{[ xsize ysize ]}
\BEGARG
\DEFARG{XSIZE}{Size along X}{R}{D=20. }
\DEFARG{YSIZE}{Size along Y}{R}{D=20. }
\ENDARG
\BEGTEXT
Set the size of the picture.
On the terminal, the pictures will have the ratio YSIZE/XSIZE, and,
if a metafile is produced, pictures will be YSIZE by XSIZE cm.
This command sets the parameters for the normalisation transformation
number 1 to [0-XSIZE], [0-YSIZE].
\ENDTEXT

\DEFCMD{GVSVP}{/GRAPHICS/VIEWING}{SVP}{nt x1 x2 y1 y2 }
\BEGARG
\DEFARG{NT}{Normalization transformation number}{I}{}
\DEFARG{X1}{Low X  of viewport in NDC}{R}{D=0 R=0:1 }
\DEFARG{X2}{High X of viewport in NDC}{R}{D=1 R=0:1 }
\DEFARG{Y1}{Low Y  of viewport in NDC}{R}{D=0 R=0:1 }
\DEFARG{Y2}{High Y of viewport in NDC}{R}{D=1 R=0:1 }
\ENDARG
\BEGTEXT
Set the viewport of the normalization transformation NT
in the Normalized Device Coordinates (NDC).
\ENDTEXT

\DEFCMD{GVSWN}{/GRAPHICS/VIEWING}{SWN}{nt x1 x2 y1 y2 }
\BEGARG
\DEFARG{NT}{Normalize transformation number}{I}{}
\DEFARG{X1}{Low X  of window in WC}{R}{D=0 }
\DEFARG{X2}{High X of window in WC}{R}{D=20 }
\DEFARG{Y1}{Low Y  of window in WC}{R}{D=0 }
\DEFARG{Y2}{High Y of window in WC}{R}{D=20 }
\ENDARG
\BEGTEXT
Set the window of the normalization transformation NT
in World Coordinates (WC).
\ENDTEXT

\DEFCMD{GVSELNT}{/GRAPHICS/VIEWING}{SELNT}{nt }
\BEGARG
\DEFARG{NT}{Normalization transformation number}{I}{}
\ENDARG
\BEGTEXT
Select a normalization transformation number.
\begin{verbatim}
  If ZONE 2 2 is active , then:        If ZONE 1 1 is active, then:
 +------------------------------+    +-----------------------------+
 |                              |    |                             |
 |  +----------+   +---------+  |    |  +-----------------------+  |
 |  |          |   |         |  |    |  |                       |  |
 |  |   NT=10  |   |  NT=20  |  |    |  |                       |  |
 |  |          |   |         |  |    |  |                       |  |
 |  +----------+   +---------+  |    |  |                       |  |
 |                              |    |  |         NT=10         |  |
 |  +----------+   +---------+  |    |  |                       |  |
 |  |          |   |         |  |    |  |                       |  |
 |  |   NT=30  |   |  NT=40  |  |    |  |                       |  |
 |  |          |   |         |  |    |  |                       |  |
 |  +----------+   +---------+  |    |  |                       |  |
 |                              |    |  +-----------------------+  |
 |             NT=1             |    |             NT=1            |
 +------------------------------+    +-----------------------------+
\end{verbatim}
\ENDTEXT


\DEFMENU{1}{PRIMITIVES}
\BEGTEXT
Call HIGZ drawing primitives
\ENDTEXT

\DEFCMD{GPPLINE}{/GRAPHICS/PRIMITIVES}{PLINE}{n x y }
\BEGARG
\DEFARG{N}{Number of points}{I}{}
\DEFARG{X}{Vector name for X coordinates}{C}{}
\DEFARG{Y}{Vector name for Y coordinates}{C}{}
\ENDARG
\BEGTEXT
Draw a polyline of N points X,Y
in the current Normalization transformation.
Use commands SLN, SLWSC and SPLCI (or IGSET) to change line attributes.
\ENDTEXT

\DEFCMD{GPLINE}{/GRAPHICS/PRIMITIVES}{LINE}{x1 y1 x2 y2 }
\BEGARG
\DEFARG{X1}{X first coordinate}{R}{}
\DEFARG{Y1}{Y first coordinate}{R}{}
\DEFARG{X2}{X second coordinate}{R}{}
\DEFARG{Y2}{Y second coordinate}{R}{}
\ENDARG
\BEGTEXT
Draw a line connecting points (X1,Y1) and (X2,Y2)
in the current Normalization transformation.
Use commands SLN, SLWSC and SPLCI (or IGSET) to change line attributes.
\ENDTEXT

\DEFCMD{GPFAREA}{/GRAPHICS/PRIMITIVES}{FAREA}{n x y }
\BEGARG
\DEFARG{N}{Number of points}{I}{}
\DEFARG{X}{Vector name for X coordinates}{C}{}
\DEFARG{Y}{Vector name for Y coordinates}{C}{}
\ENDARG
\BEGTEXT
Fill the area defined by the N points X,Y
in the current Normalization transformation.
Use commands SFASI, SFAIS and SFACI (or IGSET) to change fill area attributes.
\ENDTEXT

\DEFCMD{GPPMARKE}{/GRAPHICS/PRIMITIVES}{PMARKER}{n x y }
\BEGARG
\DEFARG{N}{Number of points}{I}{}
\DEFARG{X}{Vector name for X coordinates}{C}{}
\DEFARG{Y}{Vector name for Y coordinates}{C}{}
\ENDARG
\BEGTEXT
Draw polymarkers at the N points X,Y
in the current Normalization transformation.
Use commands SMK and SPMCI (or IGSET) to change polymarker attributes.
\ENDTEXT

\DEFCMD{GPBOX}{/GRAPHICS/PRIMITIVES}{BOX}{x1 x2 y1 y2 }
\BEGARG
\DEFARG{X1}{X coordinate of first corner}{R}{}
\DEFARG{X2}{X coordinate of second corner}{R}{}
\DEFARG{Y1}{Y coordinate of first corner}{R}{}
\DEFARG{Y2}{Y coordinate of second corner}{R}{}
\ENDARG
\BEGTEXT
Draw and fill a box with the current fill area attributes.
Use the current Normalization transformation.
\ENDTEXT

\DEFCMD{GPFBOX}{/GRAPHICS/PRIMITIVES}{FBOX}{x1 x2 y1 y2 x3 x4 y3 y4 }
\BEGARG
\DEFARG{X1}{X coord of 1st corner of ext box}{R}{}
\DEFARG{X2}{X coord of 2nd corner of ext box}{R}{}
\DEFARG{Y1}{Y coord of 1st corner of ext box}{R}{}
\DEFARG{Y2}{Y coord of 2nd corner of ext box}{R}{}
\DEFARG{X3}{X coord of 1st corner of int box}{R}{}
\DEFARG{X4}{X coord of 2nd corner of int box}{R}{}
\DEFARG{Y3}{Y coord of 1st corner of int box}{R}{}
\DEFARG{Y4}{Y coord of 2nd corner of int box}{R}{}
\ENDARG
\BEGTEXT
Draw and fill a frame (2 nested boxes)
with the current fill area attributes.
Use the current Normalization transformation.
\ENDTEXT

\DEFCMD{GPARROW}{/GRAPHICS/PRIMITIVES}{ARROW}{x1 x2 y1 y2 [ size ]}
\BEGARG
\DEFARG{X1}{X coordinate of start point}{R}{}
\DEFARG{X2}{X coordinate of end point}{R}{}
\DEFARG{Y1}{Y coordinate of start point}{R}{}
\DEFARG{Y2}{Y coordinate of end point}{R}{}
\DEFARG{SIZE}{Arrow size}{R}{D=0.4 }
\ENDARG
\BEGTEXT
Draw an arrow (X1,Y1) ----> (X2,Y2) if SIZE>0.
Draw an arrow (X1,Y1) <---> (X2,Y2) if SIZE<0.
Use the current Normalization transformation.
\ENDTEXT

\DEFCMD{GPAXIS}{/GRAPHICS/PRIMITIVES}{AXIS}{x0 x1 y0 y1 wmin wmax ndiv [ chopt ]}
\BEGARG
\DEFARG{X0}{X axis origin in WC}{R}{}
\DEFARG{X1}{X end axis in WC}{R}{}
\DEFARG{Y0}{Y axis origin in WC}{R}{}
\DEFARG{Y1}{Y end axis in WC}{R}{}
\DEFARG{WMIN}{Lowest value for labels}{R}{}
\DEFARG{WMAX}{Highest value for labels}{R}{}
\DEFARG{NDIV}{Number of divisions}{I}{D=510 }
\DEFARG{CHOPT}{Options}{C}{D=' ' }
\ENDARG
\BEGTEXT
Draw an axis in the current Normalization transformation.
\begin{verbatim}
        NDIV=N1 + 100*N2 + 10000*N3
        N1, N2, N3 = Number of 1st, 2nd, 3rd divisions respectively, eg:.
            NDIV=0 --> no tick marks.
            NDIV=2 --> 2 divisions, one tick mark in the middle
                     of the axis.
        CHOPT='G' : loGarithmic scale, default is linear.
        CHOPT='B' : Blank axis. Useful to superpose axis.
  Orientation of tick marks on axis: Tick marks are normally drawn
  on the positive side of the axis.However, if X0=X1, then Negative .
        CHOPT='+': tick marks are drawn on Positive side. (default)
        CHOPT='-': tick marks are drawn on the negative side.
        i.e: '+-' --> tick marks are drawn on both sides of the axis.
        CHOPT='U' : Unlabeled axis, default is labeled.
  Position of labels on axis. Labels are normally drawn on side
  opposite to tick marks.However:
        CHOPT= '='   on Equal side
  Orientation of labels on axis. Labels are normally drawn
  parallel to the axis. However if X0=X1, then Orthogonal
                                 if Y0=Y1, then Parallel
        CHOPT= 'P' : Parallel to the axis
        CHOPT= 'O' : Orthogonal to the axis (Top to Down).
        CHOPT= '0' : Orthogonal to the axis (Down to Top).
  Position of labels on tick marks. Labels are centered on
  tick marks. However , if X0=X1, then they are right adjusted.
        CHOPT='R': labels are Right adjusted on tick mark.
                     (default is centered)
        CHOPT='L': labels are Left adjusted on tick mark.
        CHOPT='C': labels are Centered on tick mark.
        CHOPT='M': In the Middle of the divisions.
  Direction of labels. Default is RIGHT
        CHOPT='Y':   Down
  Format of labels. Blank characters are stripped, and then the
  label is correctly aligned. The dot,if last character of the
  string, is also stripped, unless
        CHOPT='.'     Dot obligatory
  In the following, we have some parameters, like
  tick marks length and characters height (in percentage
  of the length of the axis).The default values are as follows:
     Primary tick marks: 3.0 %
     Secondary tick marks: 1.5 %
     Third order tick marks: .75 %
     Characters height for labels: 2%
     Characters spacing (related to height): 40%
     Labels offset: 4.0 %
  Type of labels. Labels are normally numeric . However, alphanumeric
  labels can be drawn (see command LABEL).
        CHOPT='T':   Alphanumeric labels .
  Intrinsic parameters.
        CHOPT='S': Tick marks Size
        CHOPT='H': Labels Height
        CHOPT='D': Distance labels-axis
  Axis bining optimization. By default the axis bining is optimized .
        CHOPT='N': No bining optimization
        CHOPT='I': Integer labeling
\end{verbatim}
\ENDTEXT

\DEFCMD{GPARC}{/GRAPHICS/PRIMITIVES}{ARC}{x1 y1 r1 [ r2 phimin phimax ]}
\BEGARG
\DEFARG{X1}{X coordinate of centre}{R}{}
\DEFARG{Y1}{Y coordinate of centre}{R}{}
\DEFARG{R1}{Inner radius}{R}{}
\DEFARG{R2}{Outer radius}{R}{D=-1. }
\DEFARG{PHIMIN}{Minimum angle}{R}{D=0. }
\DEFARG{PHIMAX}{Maximum angle}{R}{D=360. }
\ENDARG
\BEGTEXT
Draw an arc of circle
in the current Normalization transformation.
If R1 is not equal to R2 the area between the
two arcs of radius R1 and R2 is
filled according to the current fill area attributes.
The border is never drawn unless the interior style is hollow or
the command IGSET BORD 1 has been called.
If R1 is equal to R2 a polyline is drawn.
\ENDTEXT

\DEFCMD{GPPIE}{/GRAPHICS/PRIMITIVES}{PIE}{x0 y0 radius n values [ chopt iao ias iac ]}
\BEGARG
\DEFARG{X0}{X coordinate of centre of the pie}{R}{}
\DEFARG{Y0}{Y coordinate of centre of the pie}{R}{}
\DEFARG{RADIUS}{Radius of the pie chart}{R}{}
\DEFARG{N}{Number of values}{I}{}
\DEFARG{VALUES}{Vector name for N values}{C}{}
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,P,N,L' }
\DEFARG{IAO}{Name of vector with offsets}{C}{D=' ' }
\DEFARG{IAS}{Name of vector with styles}{C}{D=' ' }
\DEFARG{IAC}{Name of vector with colors}{C}{D=' ' }
\ENDARG
\BEGTEXT
Draw a pie chart
in the current Normalization transformation.
\begin{verbatim}
 CHOPT Character variable specifying the option:
   'P' Labels of each slice will be in percentage.
   'N' Labels of each slice will be the numeric value in VALUES.
   'L' Labels of each slice will be the text given in command LABEL.
\end{verbatim}
\ENDTEXT

\DEFCMD{GPTEXT}{/GRAPHICS/PRIMITIVES}{TEXT}{x y text size [ angle chopt ]}
\BEGARG
\DEFARG{X}{X coordinate}{R}{}
\DEFARG{Y}{Y coordinate}{R}{}
\DEFARG{TEXT}{Text to be drawn}{C}{}
\DEFARG{SIZE}{Text size}{R}{D=0.3 }
\DEFARG{ANGLE}{Comment angle}{R}{D=0 }
\DEFARG{CHOPT}{Justification option}{C}{D='L' R='L, ,C,R' }
\ENDARG
\BEGTEXT
Draw text at position X,Y in the current normalization
transformation using the software font IGTEXT.
SIZE is always given in centimeters (as defined by the command SIZE).
Boldface effects can
be obtained using the parameters PASS and CSHI of the command SET.
\begin{verbatim}
 CHOPT='L' Text is Left justified.
 CHOPT='C' Text is Centered.
 CHOPT='R' Text is Right justified.
\end{verbatim}
The text color can be changed by IGSET TXCI.
\ENDTEXT

\DEFCMD{GPITX}{/GRAPHICS/PRIMITIVES}{ITX}{x y text }
\BEGARG
\DEFARG{X}{X coordinate}{R}{}
\DEFARG{Y}{Y coordinate}{R}{}
\DEFARG{TEXT}{Text to be drawn}{C}{}
\ENDARG
\BEGTEXT
Draw text at position X,Y
in the current Normalization transformation,
using the current font parameters.
The font and the precision can be changed by IGSET TXFP.
The character size can be changed by IGSET CHHE.
The text color can be changed by IGSET TXCI.
The text orientation can be changed with IGSET TXAL.
The text angle can be changed by IGSET TANG.
\ENDTEXT

\DEFCMD{GPLABELS}{/GRAPHICS/PRIMITIVES}{LABELS}{labnum nlabs chlabs }
\BEGARG
\DEFARG{LABNUM}{Label identifier}{I}{D=1 R=1:9 }
\DEFARG{NLABS}{Number of labels}{I}{D=0 R=0:50 }
\DEFARG{CHLABS}{List of labels}{C}{D=' ' }
\ENDARG
\BEGTEXT
Define a list of labels to be used by subsequent commands
such as PIE and AXIS.
The position of the labels on the axis may be changed with SET NDVX (NDVY).
\ENDTEXT

\DEFCMD{GPPAVE}{/GRAPHICS/PRIMITIVES}{PAVE}{x1 x2 y1 y2 [ dz isbox isfram chopt ]}
\BEGARG
\DEFARG{X1}{X bottom left corner of box}{R}{}
\DEFARG{X2}{X top right corner of box}{R}{}
\DEFARG{Y1}{Y bottom left corner of box}{R}{}
\DEFARG{Y2}{Y top right corner of box}{R}{}
\DEFARG{DZ}{Box width}{R}{D=0.4 }
\DEFARG{ISBOX}{Box style}{I}{D=0 }
\DEFARG{ISFRAM}{Frame style}{I}{D=5 }
\DEFARG{CHOPT}{Option}{C}{D='TR' }
\ENDARG
\BEGTEXT
Draw a paving-block (box with 3D effect).
ISBOX (ISFRAM) may be 1000+ICOLOR where ICOLOR is the color index
of the box (frame), otherwise the style index.
If ISBOX (ISFRAM) =0, only the box contour is drawn with the current
polyline attributes.
\begin{verbatim}
 CHOPT='TR' (or just 'T') Top and Right frame are drawn (default)
 CHOPT='TL' Top and Left frame
 CHOPT='BR' (or just 'B') Bottom and Right frame
 CHOPT='BL' Bottom and Left frame
 CHOPT='L' Left frame only
 CHOPT='R' Right frame only
 CHOPT='T-' Top frame only pointing left
 CHOPT='B-' Bottom frame only pointing left
 CHOPT='S' Shadow mode
 CHOPT='K' Key mode
\end{verbatim}
\ENDTEXT

\DEFCMD{GPHIST}{/GRAPHICS/PRIMITIVES}{HIST}{n x y [ chopt ]}
\BEGARG
\DEFARG{N}{Number of values}{I}{}
\DEFARG{X}{Vector name for X coordinates}{C}{}
\DEFARG{Y}{Vector name for Y coordinates}{C}{}
\DEFARG{CHOPT}{Options}{C}{D='AHW' R='AHW,A,W,R,N,H,F,C,L,*,P,B, ' }
\ENDARG
\BEGTEXT
Draw an histogram defined by arrays X and Y.
The number of components
needed in vectors X and/or in Y may be dependent upon the value of CHOPT
(see options 'R' and 'N').
\begin{verbatim}
 CHOPT:
 'A'  X and Y axes are drawn (default).
 'H'  An histogram is drawn as a contour (default).
 'W'  The Window/Viewport parameters are automatically computed
      from the X and Y values (default).
 'R'  The histogram is Rotated, i.e. the values in X are used
      for the ordinate and the values in Y for the abscissa
      (default is the contrary).
      If option R is selected (and option 'N' is not selected),
      the user must give:
         2 values for Y (Y(1)=YMIN and Y(2)=YMAX)
         N values for X, one for each bin.
      Otherwise the user must give:
         N values for Y, one for each bin.
         2 values for X (X(1)=XMIN and X(2)=XMAX)
      If option 'N' is selected see below.
 'N'  Non equidistant bins (default is equidistant).
      The arrays X and Y must be dimensioned as follows:
      If option R is not selected (default) then give:
         (N+1) values for X (limits of bins).
         N values for Y, one for each bin.
      Otherwise give:
         (N+1) values for Y (limits of bins).
         N values for X, one for each bin.
 'F'  The area delimited by the histogram is filled according
      to the fill area interior style and the fill area style
      index or colour index.
      Contour is not drawn unless CHOPT='H' is also selected.
 'C'  A Smooth curve is drawn across points at the centre of
      each bin of the histogram.
 'L'  A straight Line is drawn across points at the centre of
      each bin of the histogram.
 '*'  A star is plotted at the center of each bin of the
      histogram.
 'P'  Idem as '*' but with the current marker.
 'B'  A Bar chart with equidistant bins is drawn as fill areas.
      (Contours are drawn). The bar origin and the bar
      width can be controlled by the routine IGSET using the
      options BARO and BARW respectively.
\end{verbatim}
To set Log scales in X and/or Y, use OPT LOGX/LOGY.
Note that when an option is specified, it is also necessary to
specify the options 'AW' or 'AHW' in order to start a new zone
or/and draw the axes.
\ENDTEXT

\DEFCMD{GPGRAPH}{/GRAPHICS/PRIMITIVES}{GRAPH}{n x y [ chopt ]}
\BEGARG
\DEFARG{N}{Number of values}{I}{}
\DEFARG{X}{Vector name for X coordinates}{C}{}
\DEFARG{Y}{Vector name for Y coordinates}{C}{}
\DEFARG{CHOPT}{Options}{C}{D='ALW' R='ALW,W,L,C,F, ,*,P,R,B' }
\ENDARG
\BEGTEXT
Draw a curve through a set of points.
\begin{verbatim}
 'A'  X and Y axes are drawn (default).
 'L'  Every point is connected with a straight line. (default)
 'W'  The Window/Viewport parameters are automatically computed
      from the X and Y values (default).
 'C'  The values in Y are plotted in the form of a smooth curve.
      A Spline approximation algorithm is used.
 'F'  A fill area is drawn. If the option 'CF' is used the contour
      of the fill area is smooth. The border of the fill area
      is drawn if the command IGSET BORD 1 has been typed. The fill
      area type may be changed via the IGSET parameters FASI and FASI
 'R'  The graph is Rotated, i.e. the values in X are used
      for the ordinate and the values in Y for the abscissa
      (default is the contrary).
 'B'  A Bar chart with equidistant bins is drawn as fill areas.
      (Contours are drawn). The bar origin and the bar
      width can be controlled by the routine IGSET using the
      options BARO and BARW respectively.
 '*'  A star is plotted at every point.
 'P'  A marker is plotted at every point,
      according to current marker type and polymarker colour index.
\end{verbatim}
To set Log scales in X and/or Y, use OPT LOGX/LOGY.
Note that when an option is specified, it is also necessary to
specify the options 'AW' or 'ALW' in order to start a new zone
or/and draw the axes.
\ENDTEXT


\DEFMENU{1}{ATTRIBUTES}
\BEGTEXT
Change HIGZ/GKS attributes.
\ENDTEXT

\DEFCMD{GASLN}{/GRAPHICS/ATTRIBUTES}{SLN}{[ iln ]}
\BEGARG
\DEFARG{ILN}{Line style}{I}{D=1 R=1: }
\ENDARG
\BEGTEXT
Set the line style.
\ENDTEXT

\DEFCMD{GASFAIS}{/GRAPHICS/ATTRIBUTES}{SFAIS}{[ ints ]}
\BEGARG
\DEFARG{INTS}{Fill area interior style}{I}{D=0 R=0:3 }
\ENDARG
\BEGTEXT
Set the fill area interior style :
\begin{verbatim}
 Hollow=0, Solid=1, Pattern=2, Hatch=3
\end{verbatim}
\ENDTEXT

\DEFCMD{GASFASI}{/GRAPHICS/ATTRIBUTES}{SFASI}{[ styli ]}
\BEGARG
\DEFARG{STYLI}{Fill area style index}{I}{D=1 }
\ENDARG
\BEGTEXT
Set the fill area style index.
\ENDTEXT

\DEFCMD{GASFACI}{/GRAPHICS/ATTRIBUTES}{SFACI}{[ ifaci ]}
\BEGARG
\DEFARG{IFACI}{Fill area color index}{I}{D=1 }
\ENDARG
\BEGTEXT
Set the fill area color index.
\ENDTEXT

\DEFCMD{GASPLCI}{/GRAPHICS/ATTRIBUTES}{SPLCI}{[ iplci ]}
\BEGARG
\DEFARG{IPLCI}{Polyline color index}{I}{D=1 }
\ENDARG
\BEGTEXT
Set the polyline color index.
\ENDTEXT

\DEFCMD{GASPMCI}{/GRAPHICS/ATTRIBUTES}{SPMCI}{[ ipmci ]}
\BEGARG
\DEFARG{IPMCI}{Polymarker color index}{I}{D=1 }
\ENDARG
\BEGTEXT
Set the polymarker color index.
\ENDTEXT

\DEFCMD{GASTXCI}{/GRAPHICS/ATTRIBUTES}{STXCI}{[ itxci ]}
\BEGARG
\DEFARG{ITXCI}{Text color index}{I}{D=1 }
\ENDARG
\BEGTEXT
Set the text color index.
\ENDTEXT

\DEFCMD{GASTXFP}{/GRAPHICS/ATTRIBUTES}{STXFP}{[ ifont iprec ]}
\BEGARG
\DEFARG{IFONT}{Font number}{I}{D=0 }
\DEFARG{IPREC}{Font precision}{I}{D=2 }
\ENDARG
\BEGTEXT
Set text font and precision.
\ENDTEXT

\DEFCMD{GASCHH}{/GRAPHICS/ATTRIBUTES}{SCHH}{[ chh ]}
\BEGARG
\DEFARG{CHH}{Character height}{R}{D=0.28 }
\ENDARG
\BEGTEXT
Set the character height.
\ENDTEXT

\DEFCMD{GASLWSC}{/GRAPHICS/ATTRIBUTES}{SLWSC}{[ lw ]}
\BEGARG
\DEFARG{LW}{Line width}{I}{D=1 R=1: }
\ENDARG
\BEGTEXT
Set the line width.
\ENDTEXT

\DEFCMD{GASMK}{/GRAPHICS/ATTRIBUTES}{SMK}{[ mkt ]}
\BEGARG
\DEFARG{MKT}{Marker type}{I}{D=1 }
\ENDARG
\BEGTEXT
Set the marker type.
\ENDTEXT

\DEFCMD{GACOLOR_}{/GRAPHICS/ATTRIBUTES}{COLOR\_TABLE}{icol [ red green blue ]}
\BEGARG
\DEFARG{ICOL}{Color Index}{I}{D=1 }
\DEFARG{RED}{Weight of red}{R}{D=0. R=0.:1. }
\DEFARG{GREEN}{Weight of green}{R}{D=0. R=0.:1. }
\DEFARG{BLUE}{Weight of blue}{R}{D=0. R=0.:1. }
\ENDARG
\BEGTEXT
Define the color ICOL.
\ENDTEXT

\DEFCMD{GAPALETT}{/GRAPHICS/ATTRIBUTES}{PALETTE}{palnb [ nel list ]}
\BEGARG
\DEFARG{PALNB}{Palette number}{I}{D=0 R=0:9 }
\DEFARG{NEL}{Number of elements in the palette}{I}{D=0 R=0:50 }
\DEFARG{LIST}{List of the palette elements}{I}{D=0 }
\ENDARG
\BEGTEXT
Define a palette of attributes.
The palette number is used in the command SET. The command
SET HCOL 0.1 defines the palette number 1 as colour indices
used by the command LEGO in case of stacked lego plots and
plotting of SURFACE with options 1 or 2, LEGO with option 2
and CONTOUR with option 3.

By default the palettes are initiliazed with 6 elements:
2,3,4,5,6,7.

If the number of elements (NEL) is equal to 0 (default), the
palette is filled automatically according to the number of
colours defined with the command IGSET NCOL. If NCOL is smaller
than 8, the palette is filled with a subset of the 8 basic
colours. If NCOL is greater than 8, the palette is filled
with colours varying continuously for blue to red. This is
called a "geographycal" palette. Note that the command
IGSET NCOL reset the colours 8 to NCOL with gray levels.

Examples:

\begin{verbatim}
    PAW > IGSET NCOL 8      | Define the number of colours
    PAW > PALETTE 1         | The palette 1 is filled with
                            | 8 elements: 0,5,7,3,6,2,4,1
    PAW > IGSET NCOL 4      | Define the number of colours
    PAW > PALETTE 1         | The palette 1 is filled with
                            | 4 elements: 0,5,7,3
    PAW > IGSET NCOL 16     | Define the number of colours
    PAW > PALETTE 1         | Fill palette 1 with 8 elements
                            | (8,9,10,11,12,13,14,15) varying
                            | continuously from blue to red
\end{verbatim}
\ENDTEXT


\DEFMENU{1}{HPLOT}
\BEGTEXT
Draw various HPLOT objects (symbols, errors, key, etc.).
\ENDTEXT

\DEFCMD{GHSYMBOL}{/GRAPHICS/HPLOT}{SYMBOLS}{x y n [ isymb ssize ]}
\BEGARG
\DEFARG{X}{Vector of X coordinates}{C}{}
\DEFARG{Y}{Vector of Y coordinates}{C}{}
\DEFARG{N}{Number of points}{I}{D=1 }
\DEFARG{ISYMB}{Symbol number}{I}{D=24 }
\DEFARG{SSIZE}{Symbol size}{R}{D=0.28 }
\ENDARG
\BEGTEXT
Draw the same symbol at several points x,y
in the current normalization transformation.
\ENDTEXT

\DEFCMD{GHERRORS}{/GRAPHICS/HPLOT}{ERRORS}{x y ex ey n [ isymb ssize ]}
\BEGARG
\DEFARG{X}{Vector of X coordinates}{C}{}
\DEFARG{Y}{Vector of Y coordinates}{C}{}
\DEFARG{EX}{Vector of X error bars}{C}{}
\DEFARG{EY}{Vector of Y error bars}{C}{}
\DEFARG{N}{Number of points}{I}{D=1 }
\DEFARG{ISYMB}{Symbol number}{I}{D=24 }
\DEFARG{SSIZE}{Symbol size}{R}{D=0.28 }
\ENDARG
\BEGTEXT
Draw a series of points using a symbol and error bars
in horizontal and vertical direction in the current
normalization transformation.
\ENDTEXT

\DEFCMD{GHKEY}{/GRAPHICS/HPLOT}{KEY}{x y [ isymb text ]}
\BEGARG
\DEFARG{X}{X coordinate of comment}{R}{}
\DEFARG{Y}{Y coordinate of comment}{R}{}
\DEFARG{ISYMB}{Symbol number}{I}{D=24 }
\DEFARG{TEXT}{Legend}{C}{D=' ' }
\ENDARG
\BEGTEXT
Draw one symbol and its explanation (legend) at a point x,y
in the current normalization transformation.
\ENDTEXT

\DEFCMD{GHTICKS}{/GRAPHICS/HPLOT}{TICKS}{[ chopt xval yval ]}
\BEGARG
\DEFARG{CHOPT}{Options}{C}{D=' ' }
\DEFARG{XVAL}{X position}{R}{D=1.E30 }
\DEFARG{YVAL}{Y position}{R}{D=1.E30 }
\ENDARG
\BEGTEXT
Draw 'cross-wires' on a picture,
optionally with tick marks and values.
Cross-wires are lines perpendicular to the X and/or Y axis.
\begin{verbatim}
 CHOPT is a string to denote which cross-wires to draw,
       and where to draw the values:
 ' '   tick marks are drawn on the edges of the picture
 'X'   cross-wire drawn perpendicular to the X-axis
 'Y'   cross-wire drawn perpendicular to the Y-axis
 'A'   value drawn Above cross-wire
 'B'   value drawn Below cross-wire
 'L'   value drawn Left of cross-wire
 'R'   value drawn Right of cross-wire
\end{verbatim}

\begin{verbatim}
 XVAL intersection on the X-axis
 YVAL intersection on the Y-axis
\end{verbatim}
The values of XVAL are always histogram coordinates.
The tick marks will be drawn on both side of the cross
wire, unless the cross-wires are requested on the boundary
of the box surrounding the histogram (i.e. at the extreme
limits of the drawn histogram). In this case tick marks will
only be drawn inside the box.
The options 'A' and 'B' (for Above and Below)
refer only to the cross-wire perpendicular to the Y axis.
In each case only one cross-wire will be drawn.
Similarly 'L' and 'R' (Left and Right) refer only
to the cross-wires perpendicular to the X-axis.
It is possible to redefine the length of tick marks on the X or Y
axis with SET XTIC or SET YTIC.
The position of the axis values may be changed
with SET XVAL or SET YVAL.
\ENDTEXT

\DEFCMD{GHATITLE}{/GRAPHICS/HPLOT}{ATITLE}{[ xtit ytit ]}
\BEGARG
\DEFARG{XTIT}{X Axis title}{C}{D=' ' }
\DEFARG{YTIT}{Y Axis title}{C}{D=' ' }
\ENDARG
\BEGTEXT
Draw axis titles on the axes of the present plot zone.
\ENDTEXT

\DEFCMD{GHGRID}{/GRAPHICS/HPLOT}{GRID}{}
\BEGTEXT
Draw a grid in cm.
\ENDTEXT

\DEFCMD{GHNULL}{/GRAPHICS/HPLOT}{NULL}{[ xmin xmax ymin ymax chopt ]}
\BEGARG
\DEFARG{XMIN}{Low range in X}{R}{D=0. }
\DEFARG{XMAX}{High range in X}{R}{D=1. }
\DEFARG{YMIN}{Low range in Y}{R}{D=0. }
\DEFARG{YMAX}{High range in Y}{R}{D=1. }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,S,A,B' }
\ENDARG
\BEGTEXT
Draw a frame box only.
If XMIN, XMAX, etc. are given, draw a frame box with the window
coordinates set to XMIN, XMAX, YMIN, YMAX. Axis labels and tick marks
are drawn by default.
If option 'S' is also specified, this command is a convenient way
to redefine the scale for the current zone.
If the option 'A' is given then axis labels and tick marks are not drawn.
The box is not drawn if the option 'B' is given.
\ENDTEXT


\DEFMENU{0}{PICTURE}
\BEGTEXT
Creation and manipulation of HIGZ pictures.
\ENDTEXT

\DEFCMD{P0FILE}{/PICTURE}{FILE}{lun fname [ lrecl chopt ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{LRECL}{Record length in words}{I}{D=1024 }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,A,N,U,AN,AU' }
\ENDARG
\BEGTEXT
Open a HIGZ direct access picture file.
\begin{verbatim}
  For CHOPT=' ', existing file is opened.
  For CHOPT='N', a new file is opened.
  For CHOPT='U', existing file is modified.
\end{verbatim}
If CHOPT='AU' or 'AN', pictures will be automatically saved
on the direct access file. This automatic saving facility
can be switched off using IGSET AURZ 0.
\ENDTEXT

\DEFCMD{P0LIST}{/PICTURE}{LIST}{}
\BEGTEXT
List all the HIGZ pictures currently stored in memory.
\ENDTEXT

\DEFCMD{P0CREATE}{/PICTURE}{CREATE}{pname }
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{}
\ENDARG
\BEGTEXT
Create a new picture, named PNAME, in memory.
Note that all commands which start a new picture (clear workstation)
automatically create pictures named PICT1, PICT2, etc.
if the command OPTION ZFL or OPTION ZFL1 has been executed.
\ENDTEXT

\DEFCMD{P0DELETE}{/PICTURE}{DELETE}{pname }
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Delete the picture PNAME from memory.
PNAME='*' means all pictures.
\ENDTEXT

\DEFCMD{P0SCRATC}{/PICTURE}{SCRATCH}{pname [ icycle ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{D=' ' }
\DEFARG{ICYCLE}{Cycle number }{I}{D=9999 }
\ENDARG
\BEGTEXT
Delete the picture PNAME from current directory on disk.
\ENDTEXT

\DEFCMD{P0PLOT}{/PICTURE}{PLOT}{[ pname ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Plot the picture PNAME.
PNAME=' ' means the current picture.
PNAME='*' means all pictures.
\ENDTEXT

\DEFCMD{P0MODIFY}{/PICTURE}{MODIFY}{[ pname chopt ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{D=' ' }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,S,A' }
\ENDARG
\BEGTEXT
Edit the picture PNAME.
PNAME=' ' means the current picture.
Various options can be selected with the graphics menu.
This command is only available on workstations.
\begin{verbatim}
 CHOPT='S' Software characters are used for the text in menus.
 CHOPT='A' the option shAdow is used.
\end{verbatim}
\ENDTEXT

\DEFCMD{P0MERGE}{/PICTURE}{MERGE}{pname [ x y scale chopt ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{}
\DEFARG{X}{X coord(NDC) where to draw PNAME}{R}{D=0 }
\DEFARG{Y}{Y coord(NDC) where to draw PNAME}{R}{D=0 }
\DEFARG{SCALE}{Scale factor}{R}{D=1. }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,D' }
\ENDARG
\BEGTEXT
Add the picture PNAME to the current picture.
\begin{verbatim}
 CHOPT='D' Picture PNAME is displayed during merging.
\end{verbatim}
\ENDTEXT

\DEFCMD{P0COPY}{/PICTURE}{COPY}{pname1 pname2 }
\BEGARG
\DEFARG{PNAME1}{Picture name}{C}{}
\DEFARG{PNAME2}{New picture name}{C}{}
\ENDARG
\BEGTEXT
Copy a picture.
\ENDTEXT

\DEFCMD{P0RENAME}{/PICTURE}{RENAME}{pname1 pname2 }
\BEGARG
\DEFARG{PNAME1}{Old picture name}{C}{}
\DEFARG{PNAME2}{New picture name}{C}{}
\ENDARG
\BEGTEXT
Rename a picture.
\ENDTEXT

\DEFCMD{P0IZOUT}{/PICTURE}{IZOUT}{[ pname ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Write the picture PNAME to a direct access picture file
(see command PICTURE/FILE).
PNAME=' ' means the current picture.
PNAME='*' means all pictures.
\ENDTEXT

\DEFCMD{P0IZIN}{/PICTURE}{IZIN}{pname [ icycle ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{}
\DEFARG{ICYCLE}{Cycle number }{I}{D=9999 }
\ENDARG
\BEGTEXT
Read picture into memory from a direct access picture file.
(see command PICTURE/FILE).
PNAME='*' means all pictures.
\ENDTEXT

\DEFCMD{P0IZPICT}{/PICTURE}{IZPICT}{pname [ chopt ]}
\BEGARG
\DEFARG{PNAME}{Picture name}{C}{}
\DEFARG{CHOPT}{Options}{C}{D='M' R='M, ,D,S,N,L,F,P,C' }
\ENDARG
\BEGTEXT
Perform various operations on a picture.
\begin{verbatim}
 CHOPT:
 'M' Make a new picture in memory with name PNAME.
     An empty structure is created in memory and becomes
     the current picture. If PNAME = ' ', the picture is
     automatically named as PICTnnn, where the starting
     value of nnn is either 0 (default), or the value assigned by
     IGSET to the parameter PICT.
 'D' Display the picture PNAME in memory.
 'S' Scratch the picture PNAME from memory. If PNAME = ' '
     the current picture is scratched.
 'N' The picture following the current picture in memory becomes
     the current picture. If the current picture is the
     last one in memory, the first picture in memory becomes
     the current picture.
 'L' Give the list of the pictures in memory,
     following the sequence of their storage in memory.
 'F' The First picture in memory becomes the current picture.
 'P' Print the picture data structure. Useful to debug programs.
 'C' Set Current picture. All calls to HIGZ graphic functions
     are stored in the current structure according to the option
     selected be IGZSET.
\end{verbatim}
PNAME=' ' means the current picture.
PNAME='*' means all pictures.
\ENDTEXT

\DEFCMD{P0SWITCH}{/PICTURE}{SWITCH}{[ chopt ]}
\BEGARG
\DEFARG{CHOPT}{Options}{C}{D='G' R='G,Z,GZ' }
\ENDARG
\BEGTEXT
Set the graphics switch to control plotting output
to terminal (G) and/or picture in memory (Z).
\begin{verbatim}
  If CHOPT='G'  Graphics output only.
  If CHOPT='Z'  graphics primitives stored in ZEBRA memory only.
  If CHOPT='GZ' both.
\end{verbatim}
\ENDTEXT

\DEFCMD{P0IGSET}{/PICTURE}{IGSET}{[ chatt value ]}
\BEGARG
\DEFARG{CHATT}{Attribute name}{C}{D='SHOW' }
\DEFARG{VALUE}{Attribute value}{R}{D=0. }
\ENDARG
\BEGTEXT
Set a HIGZ attribute.
If CHATT='SHOW' print default and current values for all attributes.
If CHATT='*' restore default values for all attributes.
If VALUE=0, the attribute is set to its default value.
\ENDTEXT


\DEFMENU{0}{ZEBRA}
\BEGTEXT
Interfaces to the ZEBRA RZ, FZ and DZ packages.
\ENDTEXT


\DEFMENU{1}{RZ}
\BEGTEXT
ZEBRA/RZ package: direct access Input/Output.
\ENDTEXT

\DEFCMD{ZRFILE}{/ZEBRA/RZ}{FILE}{lun fname [ lrecl chopt ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{LRECL}{Record length in WORDS}{I}{D=1024 }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,U' }
\ENDARG
\BEGTEXT
Open an existing direct access file.
\begin{verbatim}
 CHOPT=' ' read only mode
 CHOPT='U' update mode
\end{verbatim}
\ENDTEXT

\DEFCMD{ZRMAKE}{/ZEBRA/RZ}{MAKE}{lun fname [ lrecl nrec nwkey chform chtags ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{LRECL}{Record length in WORDS}{I}{D=1024 }
\DEFARG{NREC}{Number of records}{I}{D=1000 }
\DEFARG{NWKEY}{Number of words per Key}{I}{D=1 }
\DEFARG{CHFORM}{Key format}{C}{D='I' R='I,B,A,H' }
\DEFARG{CHTAGS}{List of Tags}{C}{D='HBOOK-ID' }
\ENDARG
\BEGTEXT
Open a new direct access file.
\ENDTEXT

\DEFCMD{ZRMDIR}{/ZEBRA/RZ}{MDIR}{chdir [ nwkey chform chtags ]}
\BEGARG
\DEFARG{CHDIR}{Directory name}{C}{}
\DEFARG{NWKEY}{Number of words per Key}{I}{D=1 }
\DEFARG{CHFORM}{CHFORM}{C}{D='I' }
\DEFARG{CHTAGS}{List of Tags}{C}{D='HBOOK-ID' }
\ENDARG
\BEGTEXT
Create a new RZ directory below the current directory.
\ENDTEXT

\DEFCMD{ZRDDIR}{/ZEBRA/RZ}{DDIR}{chdir }
\BEGARG
\DEFARG{CHDIR}{Directory name}{C}{}
\ENDARG
\BEGTEXT
Delete the directory CHDIR from the current directory.
\ENDTEXT

\DEFCMD{ZRLDIR}{/ZEBRA/RZ}{LDIR}{[ chpath chopt ]}
\BEGARG
\DEFARG{CHPATH}{Path name}{C}{D=' ' }
\DEFARG{CHOPT}{Options}{C}{D=' ' R=' ,A,T' }
\ENDARG
\BEGTEXT
List contents of a directory (memory or disk).
To list all RZ files currently opened, type 'LD //'.
Note that if the Current Directory is //PAWC, this command
uses the same format as HISTO/LIST.
\begin{verbatim}
 CHOPT='A' to list all the Ntuple extensions.
 CHOPT='T' to list a directory Tree.
\end{verbatim}
\ENDTEXT

\DEFCMD{ZRCDIR}{/ZEBRA/RZ}{CDIR}{[ chpath chopt ]}
\BEGARG
\DEFARG{CHPATH}{Path name}{C}{D=' ' }
\DEFARG{CHOPT}{Options}{C}{D=' ' }
\ENDARG
\BEGTEXT
Change the current working directory (CWD).
IF CHPATH is given make it the new CWD.
Otherwise, print the pathname of the CWD.
\begin{verbatim}
 Ex.  CD dir1         ; make DIR1 the new CWD
      CD //file1/dir2 ; make //FILE1/DIR2 the new CWD
      CD              ; print the name of the CWD
\end{verbatim}
\ENDTEXT

\DEFCMD{ZRPURGE}{/ZEBRA/RZ}{PURGE}{[ keep ]}
\BEGARG
\DEFARG{KEEP}{Number of cycles to be kept}{I}{D=1 }
\ENDARG
\BEGTEXT
Purge an RZ directory.
\ENDTEXT

\DEFCMD{ZRLOCK}{/ZEBRA/RZ}{LOCK}{[ chlock ]}
\BEGARG
\DEFARG{CHLOCK}{Lock identifier}{C}{D='RZFILE' }
\ENDARG
\BEGTEXT
Lock an RZ directory.
\ENDTEXT

\DEFCMD{ZRFREE}{/ZEBRA/RZ}{FREE}{[ chlock ]}
\BEGARG
\DEFARG{CHLOCK}{Lock identifier}{C}{D='RZFILE' }
\ENDARG
\BEGTEXT
Free an RZ directory.
\ENDTEXT

\DEFCMD{ZRSTAT}{/ZEBRA/RZ}{STAT}{chpath }
\BEGARG
\DEFARG{CHPATH}{Name of top directory}{C}{}
\ENDARG
\BEGTEXT
Print space statistics for an RZ file.
\ENDTEXT


\DEFMENU{1}{FZ}
\BEGTEXT
ZEBRA/FZ package: sequential access Input/Output.
\ENDTEXT

\DEFCMD{ZFFILE}{/ZEBRA/FZ}{FILE}{lun fname [ lrecl chopt ]}
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\DEFARG{FNAME}{File name}{C}{}
\DEFARG{LRECL}{Record length in words}{I}{D=900 }
\DEFARG{CHOPT}{Options}{C}{D='IX' R='IX,O,X,A,I,OX,IA,OA' }
\ENDARG
\BEGTEXT
Open an FZ sequential formatted or unformatted file.
\begin{verbatim}
  CHOPT = 'I' Input file.
  CHOPT = 'O' Output file
  CHOPT = 'X' binary eXchange mode.
  CHOPT = 'A' Alphanumeric exchange mode.
\end{verbatim}
\ENDTEXT

\DEFCMD{ZFTOFZ}{/ZEBRA/FZ}{TOFZ}{lun [ chopt ]}
\BEGARG
\DEFARG{LUN}{Logical unit number of FZ file}{I}{R=1:128 }
\DEFARG{CHOPT}{Options}{C}{D=' ' }
\ENDARG
\BEGTEXT
Copy the current directory tree onto an FZ file.
\ENDTEXT

\DEFCMD{ZFFRFZ}{/ZEBRA/FZ}{FRFZ}{lun [ chopt ]}
\BEGARG
\DEFARG{LUN}{Logical unit number of FZ file}{I}{R=1:128 }
\DEFARG{CHOPT}{Options}{C}{D=' ' }
\ENDARG
\BEGTEXT
Copy the FZ file into the current directory tree.
\ENDTEXT

\DEFCMD{ZFTOALPH}{/ZEBRA/FZ}{TOALPHA}{fname }
\BEGARG
\DEFARG{FNAME}{Name of the FZ text file}{C}{}
\ENDARG
\BEGTEXT
Copy the current directory tree onto a FZ file.
An alphanumeric format is used.
The file FNAME can be exchanged between different machines.
\ENDTEXT

\DEFCMD{ZFFRALPH}{/ZEBRA/FZ}{FRALPHA}{fname }
\BEGARG
\DEFARG{FNAME}{Name of the FZ text file}{C}{}
\ENDARG
\BEGTEXT
Copy the FZ alphanumeric file into the current directory.
\ENDTEXT


\DEFMENU{1}{DZ}
\BEGTEXT
ZEBRA/DZ package: debugging.
\ENDTEXT

\DEFCMD{ZDSHOW}{/ZEBRA/DZ}{SHOW}{name [ number chopt ]}
\BEGARG
\DEFARG{NAME}{Bank name}{C}{}
\DEFARG{NUMBER}{Bank number}{I}{D=1 }
\DEFARG{CHOPT}{Options}{C}{D='BSV' }
\ENDARG
\BEGTEXT
Display the contents of a bank or a data structure
identified by its NAME and NUMBER.
The output format of the data part is controlled by the internal
or external I/O characteristic.
\begin{verbatim}
 CHOPT='B' Print the bank.
 CHOPT='S' Print the bank contents from left to right Sideways
           with up to ten elements per line.
 CHOPT='V' Print the vertical (down) structure.
 CHOPT='D' Print the bank contents from top to bottom Downwards
           with five elements per line.
 CHOPT='L' Print the linear structure.
 CHOPT='Z' Print the data part of each bank in hexadecimal format
\end{verbatim}
\ENDTEXT

\DEFCMD{ZDSURV}{/ZEBRA/DZ}{SURV}{name [ number ]}
\BEGARG
\DEFARG{NAME}{Bank name}{C}{}
\DEFARG{NUMBER}{Bank number}{I}{D=1 }
\ENDARG
\BEGTEXT
Print a survey of the structure identified by NAME, NUMBER.
\ENDTEXT

\DEFCMD{ZDSNAP}{/ZEBRA/DZ}{SNAP}{[ idiv chopt ]}
\BEGARG
\DEFARG{IDIV}{Division number }{I}{D=2 R=0:24 }
\DEFARG{CHOPT}{Options}{C}{D='M' }
\ENDARG
\BEGTEXT
Snap of one or more divisions.
Provides a snapshot of one or more divisions in a ZEBRA store.
The kind of information provided is controlled by CHOPT.
\begin{verbatim}
 CHOPT='M' Print Map entry for each bank
 CHOPT='E' Extend map entry to dump all links of each bank
           (otherwise only as many links as will fit on a line)
 CHOPT='F' Full. Dump all active banks, links and data
 CHOPT='K' Kill. Dropped banks to be treated as active
           (dropped banks are not normally dumped under D or F option)
 CHOPT='L' Dump all Link areas associated with the store
 CHOPT='W' Dump the Working space, links and data
 CHOPT='Z' Dump the information in hexadecimal.
\end{verbatim}
\ENDTEXT

\DEFCMD{ZDVERIFY}{/ZEBRA/DZ}{VERIFY}{[ idiv chopt ]}
\BEGARG
\DEFARG{IDIV}{Division number }{I}{D=0 R=0:24 }
\DEFARG{CHOPT}{Options}{C}{D='CLSU' }
\ENDARG
\BEGTEXT
Check the structure of one or more ZEBRA divisions.
The verification detail depends on the settings in CHOPT.
\begin{verbatim}
 CHOPT='C' Check chaining of banks only
 CHOPT='L' Check validity of the structural links (implies 'C')
 CHOPT='S' Check the store parameters
 CHOPT='U' Check the validity of the up and origin (implies 'C')
 CHOPT='F' Errors are considered fatal and generate a call to ZFATAL
\end{verbatim}
\ENDTEXT

\DEFCMD{ZDSTORE}{/ZEBRA/DZ}{STORE}{[ ixstor ]}
\BEGARG
\DEFARG{IXSTOR}{Store number}{I}{D=0 R=0:24 }
\ENDARG
\BEGTEXT
Display the structure of the ZEBRA store IXSTOR.
Output the parameters characterizing the store, followed by a
list of all divisions and all link areas associated with the store in
question.
\ENDTEXT


\DEFMENU{0}{FORTRAN}
\BEGTEXT
Interface to COMIS, SIGMA and FORTRAN Input/Output.
\ENDTEXT

\DEFCMD{F0COMIS}{/FORTRAN}{COMIS}{}
\BEGTEXT
Invoke the COMIS FORTRAN interpreter.
COMIS allows to execute FORTRAN routines without recompiling
and relinking. It communicates
with PAW commands through vectors and functions. COMIS has its
PAW-independent command structure.
Example in command mode:
\begin{verbatim}
 PAW > Comis
 CS >    do 10 i=1,10
 MND>       x=sqrt(i)*10.
 MND>       print *,i,x
 MND> 10 continue
 MND>    END
 CS > quit
 PAW >
\end{verbatim}
COMIS code may be inserted into a macro. Example:
\begin{verbatim}
 Vector/Create Y(10) r 1 2 3 4 5 6 7 8 9 10
 *
 *  In the following COMIS code, the statement "Vector Y" declares
 *  to COMIS an existing KUIP vector. KUIP dimension is assumed.
 *  The statement "Vector X(10)" creates a new KUIP vector.
 *  (Note that SUBROUTINEs must be declared before the MAIN program)
 *  (KUIP vectors cannot be created into the MAIN program)
 *
 APPLIcation COMIS QUIT
       SUBROUTINE DEMO
       Vector Y
       Vector X(10)
       do 10 i=1,10
          XX=i
          X(i)=Y(i)*sqrt(XX)*10.
   10  CONTINUE
       END
       CALL DEMO
       END
 QUIT
 Vector/print X       | Print KUIP vector created by COMIS
\end{verbatim}
\ENDTEXT

\DEFCMD{F0CALL}{/FORTRAN}{CALL}{urout }
\BEGARG
\DEFARG{UROUT}{User routine}{C}{}
\ENDARG
\BEGTEXT
Execute the routine UROUT.
UROUT may be a routine compiled and linked with PAW.
For example : CALL HPRINT(10).
UROUT may also be the name of a file which can be edited interactively
with the command EDIT. For example if file UROUT.FOR contains:
\begin{verbatim}
     SUBROUTINE UROUT(N)
     SUM=0.
     DO 10 I=1,N
       SUM=SUM+I
  10 CONTINUE
     PRINT *,SUM
     END
\end{verbatim}
Then one can type CALL UROUT.FOR(10).  The routine UROUT may also
contains references to the library routines mentioned below.
The following routines from the CERN Program Library can be called:
\ENDTEXT

\DEFCMD{F0LOOP}{/FORTRAN}{LOOP}{ntimes urout }
\BEGARG
\DEFARG{NTIMES}{Number of calls}{I}{D=1 }
\DEFARG{UROUT}{User routine}{C}{}
\ENDARG
\BEGTEXT
The routine UROUT is called NTIMES times.
See command CALL for explanation of UROUT.
\ENDTEXT

\DEFCMD{F0FILE}{/FORTRAN}{FILE}{lun fname }
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\DEFARG{FNAME}{File name}{C}{}
\ENDARG
\BEGTEXT
Open a FORTRAN formatted text file.
\ENDTEXT

\DEFCMD{F0CLOSE}{/FORTRAN}{CLOSE}{lun }
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\ENDARG
\BEGTEXT
Close the file on unit LUN.
If the file has been opened with HISTO/FILE, PICTURE/FILE, etc, then
before closing the unit, PAW will close correctly the file with
CALL HREND or FZENDI(O), ICLWK, etc.
\ENDTEXT

\DEFCMD{F0REWIND}{/FORTRAN}{REWIND}{lun }
\BEGARG
\DEFARG{LUN}{Logical unit number}{I}{R=1:128 }
\ENDARG
\BEGTEXT
Rewind the file on unit LUN.
\ENDTEXT

\DEFCMD{F0SIGMA}{/FORTRAN}{SIGMA}{}
\BEGTEXT
Invoke the SIGMA package.
SIGMA is an array manipulation package using its own
vector-oriented language, outside the PAW command conventions.
SIGMA may be invoked in one of the three following ways:
\begin{verbatim}
 1- Using the KUIP $SIGMA function. Example:
    PAW > Vector/Create x(10) r 1 2 3 4 5 6 7 8 9 10
    PAW > Graph 10 x $sigma(sqrt(x))
\end{verbatim}

\begin{verbatim}
 2- Using the SIGMA command. Example:
    PAW > sigma x=array(10,1#10)
    PAW > sigma y=sqrt(x)
    PAW > Graph 10 x y
\end{verbatim}

\begin{verbatim}
 3- Using the APPLication command. Example:
    PAW > APPLication SIGMA
    SIGMA > x=array(10,1#10)
    SIGMA > y=sqrt(x)
    SIGMA > exit
    PAW > Graph 10 x y
\end{verbatim}
\ENDTEXT


\DEFMENU{0}{OBSOLETE}
\BEGTEXT
Obsolete commands.
\ENDTEXT


\DEFMENU{1}{HISTOGRAM}

\DEFMENU{2}{FIT}
\BEGTEXT
Fitting and smoothing (1-Dim or 2-Dim) histograms.
Results are given as histogram-associated functions,
and fit parameters printed on screen.
\ENDTEXT

\DEFCMD{OHFEXPONE}{/OBSOLETE/HISTOGRAM/FIT}{EXPONENTIAL}{id [ isel iftlow iftup ]}
\BEGARG
\DEFARG{ID}{histogram Identifier}{C}{}
\DEFARG{ISEL}{option flag }{I}{D=12 }
\DEFARG{IFTLOW}{First channel}{I}{D=1 }
\DEFARG{IFTUP}{Last channel }{I}{D=99999 }
\ENDARG
\BEGTEXT
Fit histogram ID with an exponential function between channels
IFTLOW and IFTUP.
Obsolete command. Use Command Hist/Fit instead.
Control word ISEL = 100*W+10*P+S.
\begin{verbatim}
  S=2 superimposes function to histogram
    1 no superimposing
  P=1 output from final iteration
   >1 output at iterations from 0 to (P-1), N=0,1,2,..
    0 no output
  W=1 sets weights equal to 1
    0 calculates statistical errors as
      E=SQRT(CONTENTS) unless the 1-Dim  histogram
      ID is weighted with HBARX or HPAKE
\end{verbatim}
\ENDTEXT

\DEFCMD{OHFGAUSS}{/OBSOLETE/HISTOGRAM/FIT}{GAUSS}{id [ isel iftlow iftup ]}
\BEGARG
\DEFARG{ID}{histogram Identifier}{C}{}
\DEFARG{ISEL}{option flag }{I}{D=12 }
\DEFARG{IFTLOW}{First channel}{I}{D=1 }
\DEFARG{IFTUP}{Last channel }{I}{D=99999 }
\ENDARG
\BEGTEXT
Fit histogram ID with a Gaussian between channels IFTLOW and IFTUP.
Obsolete command. Use Command Hist/Fit instead.
Control word ISEL = 100*W+10*P+S.
\begin{verbatim}
  S=2 superimposes function to histogram
    1 no superimposing
  P=1 output from final iteration
   >1 output at iterations from 0 to (P-1), N=0,1,2,..
    0 no output
  W=1 sets weights equal to 1
    0 calculates statistical errors as
      E=SQRT(CONTENTS) unless the 1-Dim  histogram
      ID is weighted with HBARX or HPAKE
\end{verbatim}
\ENDTEXT

\DEFCMD{OHFPOLYNO}{/OBSOLETE/HISTOGRAM/FIT}{POLYNOMIAL}{id ncoeff [ isel iftlow iftup ]}
\BEGARG
\DEFARG{ID}{histogram Identifier}{C}{}
\DEFARG{NCOEFF}{Number of coefficients}{I}{D=3 }
\DEFARG{ISEL}{option flag }{I}{D=12 }
\DEFARG{IFTLOW}{First channel}{I}{D=1 }
\DEFARG{IFTUP}{Last channel }{I}{D=99999 }
\ENDARG
\BEGTEXT
Fit histogram ID with a polynomial between channels IFTLOW and IFTUP.
NCOEFF is the degree of the polynomial plus one.
Obsolete command. Use Command Hist/Fit instead.
Control word ISEL = 100*W+10*P+S.
\begin{verbatim}
  S=2 superimposes function to histogram
    1 no superimposing
  P=1 output from final iteration
   >1 output at iterations from 0 to (P-1), N=0,1,2,..
    0 no output
  W=1 sets weights equal to 1
    0 calculates statistical errors as
      E=SQRT(CONTENTS) unless the 1-Dim  histogram
      ID is weighted with HBARX or HPAKE
\end{verbatim}
\ENDTEXT

\DEFCMD{OHFFUNCTI}{/OBSOLETE/HISTOGRAM/FIT}{FUNCTION}{id func np dpar [ isel iftlow iftup step pmin pmax ]}
\BEGARG
\DEFARG{ID}{Histogram Identifier}{C}{}
\DEFARG{FUNC}{Function name}{C}{}
\DEFARG{NP}{Number of parameters}{I}{}
\DEFARG{DPAR}{Vector of parameters}{C}{}
\DEFARG{ISEL}{option flag }{I}{D=12 }
\DEFARG{IFTLOW}{First channel}{I}{D=1 }
\DEFARG{IFTUP}{Last channel }{I}{D=99999 }
\DEFARG{STEP}{Vector of steps size}{C}{}
\DEFARG{PMIN}{Vector of lower bounds}{C}{}
\DEFARG{PMAX}{Vector of upper bounds}{C}{}
\ENDARG
\BEGTEXT
Obsolete command. Use Command Hist/Fit instead.
Fit a user defined (and parameter dependent) function
to a histogram ID between channels IFTLOW and IFTUP.
FUNC is the name of a file which contains the user defined
function to be minimized. For example file FUNC.FOR is:
\begin{verbatim}
      DOUBLE PRECISION FUNCTION FUNC(X)
      DOUBLE PRECISION X,DPAR
      COMMON/PAWPAR/DPAR(100)
      FUNC=DPAR(1)*X +DPAR(2)*EXP(-X)
      END
\end{verbatim}
After the fit, the vector DPAR contains the new values
of parameters.
Control word ISEL = 10000*B+100*W+10*P+S.
\begin{verbatim}
  S=2 superimposes function to histogram
    1 no superimposing
  P=1 output from final iteration
   >1 output at iterations from 0 to (P-1), N=0,1,2,..
    0 no output
  W=1 sets weights equal to 1
    0 calculates statistical errors as
      E=SQRT(CONTENTS) unless the 1-Dim  histogram
      ID is weighted with HBARX or HPAKE
  B=0 All parameters vary freely (vectors STEP,PMIN,PMAX not required)
    1 Some or all parameters are bounded
      STEP(I)=0 means parameter I is fixed to its initial value
\end{verbatim}
\ENDTEXT


\DEFMENU{0}{NETWORK}
\BEGTEXT
To access files on remote computers.
To send messages to a remote process (ZEBRA server)
\ENDTEXT

\DEFCMD{N0RLOGIN}{/NETWORK}{RLOGIN}{host }
\BEGARG
\DEFARG{HOST}{Host name}{C}{D=' ' }
\ENDARG
\BEGTEXT
Start a communication with a remote machine HOST.
Current Directory will be changed to //HOST.
\ENDTEXT

\DEFCMD{N0RSHELL}{/NETWORK}{RSHELL}{message }
\BEGARG
\DEFARG{MESSAGE}{Message to remote host}{C}{D=' ' }
\ENDARG
\BEGTEXT
Send MESSAGE to current remote host.
Note that the Current Directory must be //HOST (see RLOGIN).
Some PAW commands (Histo/Plot, Histo/List) can communicate
directly with HOST.
\ENDTEXT

\end{document}
