head	1.6;
access;
symbols;
locks
	goossens:1.6; strict;
comment	@% @;


1.6
date	96.01.23.13.44.52;	author goossens;	state Exp;
branches;
next	1.5;

1.5
date	95.02.13.20.10.13;	author goossens;	state Exp;
branches;
next	1.4;

1.4
date	95.02.13.12.22.54;	author goossens;	state Exp;
branches;
next	1.3;

1.3
date	94.06.10.11.15.40;	author goossens;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.20.59.14;	author goossens;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.36.14;	author goossens;	state Exp;
branches;
next	;


desc
@initial entry
@


1.6
log
@New version from OC
@
text
@\DEFMENU{0}{KUIP}{KUIP}
\ifMENUtext
   \par
Command Processor commands.  


\fi

\DEFCMD{K}{HELP}{KUIP}{HELP}{ [ item option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu name or keyword(s)}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Option}{ D='N'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{EDIT}{\par
The help text is written to a file and the editor is invoked,
}
\DEFOPT{NOEDIT}{\par
The help text is output on the terminal output.
}
\DEFOPT{KEYWORD}{\par
give access to all commands associated to that keyword(s).
}
\DEFOPT{E}{\par
Same as 'EDIT'.
}
\DEFOPT{N}{\par
Same as 'NOEDIT'
}
\DEFOPT{K}{\par
Same as 'KEYWORD'
}
\ENDOPT

   \par
Find help information by command name, menu name or keywords.  

   \par
If ITEM is a valid command name (and there is only one such command) then 
   full explanation on that command is provided: syntax (as given by the 
   command USAGE), functionality, list of parameters with their attributes.  
   If ITEM also corresponds to other commands associated to it with a 
   \DQUOTE{}keyword\DQUOTE{} then a \DQUOTE{}See also\DQUOTE{} message, 
   followed by the names of these commands is given.  

   \par
If ITEM is a menu (or a submenu) a dialogue is guiding the user in 
   traversing the tree command structure for getting full explanation on a 
   specific command from that tree.  

   \par
If HELP is entered without parameters, the search start from the top level 
   menu and the user is guided in traversing the complete tree command 
   structure.  

   \par
'HELP -KEYWORD' (or 'HELP -K') followed by one or more keywords causes HELP 
   to give access to all commands associated to that (list of) keyword(s).  If 
   the keyword corresponds to a valid command or (sub)menu name all 
   corresponding commands are accessible. This option is especially useful 
   when you do not know the exact name of a valid command or menu and you can 
   only describe it by its functionality (e.g. 'HELP -KEYWORD POSTSCRIPT').  

   \par
N.B. If ITEM does not correspond to any valid command or menu name then the 
   option `-KEYWORD' is automatically invoked.  

   \par
'HELP -EDIT' (or just 'CHELP -E') switches to edit mode: instead of writing 
   the help text to the terminal output, it is written into a temporary file 
   and the pager or editor defined by the command HOST\_PAGER is invoked.  (On 
   Unix workstations the pager can be defined to display the help text 
   asynchrously in a separated window.) 'CHELP -NOEDIT' (or just 'CHELP -N') 
   switches back to standard mode.  The startup value is system dependent.  

\ENDCMD

\DEFCMD{K}{CHELP}{KUIP}{CHELP}{ [ item option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu path}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{View mode}{ D='N'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{EDIT}{\par
The help text is written to a file and the editor is invoked,
}
\DEFOPT{E}{\par
Same as 'EDIT'.
}
\DEFOPT{NOEDIT}{\par
The help text is output on the terminal output.
}
\DEFOPT{N}{\par
Same as 'NOEDIT'
}
\ENDOPT

   \par
Find help information only on valid command name or menu path.  

   \par
A more general help facility, associated to keywords, is given by the 
   command HELP.  

   \par
If ITEM is a command its full explanation is given:  syntax (as given by 
   the command USAGE), functionality, list of parameters with their attributes 
   (prompt, type, default, range, etc.).  If ITEM='/' the help for all 
   commands is given.  

   \par
If CHELP is entered without parameters or ITEM is a submenu, the dialogue 
   style is switched to 'AN', guiding the user in traversing the tree command 
   structure.  

   \par
'CHELP -EDIT' (or just 'CHELP -E') switches to edit mode:  instead of 
   writing the help text to the terminal output, it is written into a 
   temporary file and the pager or editor defined by the command HOST\_PAGER 
   is invoked.  (On Unix workstations the pager can be defined to display the 
   help text asynchrously in a separated window.) 'CHELP -NOEDIT' (or just 
   'CHELP -N') switches back to standard mode.  The startup value is system 
   dependent.  

\ENDCMD

\DEFCMD{K}{USAGE}{KUIP}{USAGE}{ item}

\BEGARG
\DEFARG{ITEM}{C}{Command name}{}
\ENDARG

   \par
Give the syntax of a command.  If ITEM='/' the syntax of all commands is 
   given.  

\ENDCMD

\DEFCMD{K}{MANUAL}{KUIP}{MANUAL}{ item [ output option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu path}{}
\DEFARG{OUTPUT}{C}{Output file name}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Text formatting system}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{\par
plain text : plain text format
}
\DEFOPT{LATEX}{\par
LaTeX format (encapsulated)
}
\DEFOPT{TEX}{\par
LaTeX format (without header)
}
\ENDOPT

   \par
Write on a file the text formatted help of a command.  If ITEM is a menu 
   path the help for all commands linked to that menu is written.  If ITEM='/' 
   the help for the complete command tree is written.  If OUTPUT=' ' the text 
   is written to the terminal.  

   \par
The output file produced with option LATEX can be processed directly by 
   LaTeX, i.e. it contains a standard header defining the meta commands used 
   for formatting the document body.  With option TEX only the document body 
   is written into the output file which can be included by a driver file 
   containing customized definitions of the standard meta commands.  Example:  
\begin{verbatim}
    MANUAL / MAN.TEX LATEX
\end{verbatim}
   \par
will produce the file MAN.TEX containg the documentation of all available 
   commands in LaTeX format.  

\ENDCMD

\DEFCMD{K}{EDIT}{KUIP}{EDIT}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Invoke the editor on the file.  The command HOST\_EDITOR can be used to 
   define the editor.  

   \par
If FNAME does not contain an extension the default filetype '.KUMAC' is 
   supplied.  The search path defined by the command DEFAULTS is used to find 
   an already existing file.  If the file does not exist it is created with 
   the given name.  

\ENDCMD

\DEFCMD{K}{PRINT}{KUIP}{PRINT}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Send a file to the printer.  The command HOST\_PRINT can be used to define 
   the host command for printing the file depending on it file extension.  

\ENDCMD

\DEFCMD{K}{PSVIEW}{KUIP}{PSVIEW}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Invoke the PostScript viewer on the file.  The command HOST\_PSVIEWER can 
   be used to define the PostScript viewer.  

   \par
If FNAME does not contain an extension the default filetype '.PS' is 
   supplied.  

\ENDCMD

\DEFCMD{K}{LAST}{KUIP}{LAST}{ [ n fname ]}

\BEGARG
\DEFARG{N}{I}{N last commands to be saved}{ D=-99 R=-99:}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Perform various operations with the history file.  

   \par
If FNAME is not specified, the current history file is assumed by default 
   (the startup history file name is LAST.KUMAC).  To change the history file 
   the command LAST 0 NEW-FNAME must be entered.  

   \par
If N.EQ.-99 (default case) the default host editor is called to edit the 
   current history file, containing all the commands of the session.  

   \par
If N.LT.0 the last -N commands are printed on the screen.  On MVS this 
   allows to edit and resubmit commands.  On workstations this allows to 
   resubmit blocks of commands by mouse-driven cut-and-paste operations.  

   \par
If N.EQ.0 the history file FNAME is rewound and set as the current one (the 
   command LAST 0 FNAME itself is not recorded).  

   \par
If N.GT.0 the last N commands of the session are saved in the current 
   history file.  

   \par
See also the command RECORDING.  

\ENDCMD

\DEFCMD{K}{MESSAG}{KUIP}{MESSAGE}{ [ string ]}

\BEGARG
\DEFARG{STRING}{C}{Message string}{ D=\EMPTY{} Separate}
\ENDARG

   \par
Write a message string on the terminal.  A useful command inside a macro.  
   Several message strings can be given in the same command line, each of them 
   separated by one or more spaces (the usual parameter separator); therefore 
   multiple blanks will be dropped and only one will be kept.  If multiple 
   blanks should not be dropped, the string must be surrounded by single 
   quotes.  

\ENDCMD

\DEFCMD{K}{SHELL}{KUIP}{SHELL}{ [ cmd ]}

\BEGARG
\DEFARG{CMD}{C}{Shell command string}{ D=\EMPTY{}}
\ENDARG

   \par
Execute a command of the host operating system.  The command string is 
   passed to the command processor defined by HOST\_SHELL.  If CMD=' ' the 
   shell is spawned as interactive subprocess.  To return from the shell enter 
   'RETURN' (the full word, not just \BRA{}CR\KET{}) or 'exit' (depending on 
   the operation system).  

\ENDCMD

\DEFCMD{K}{WAIT}{KUIP}{WAIT}{ [ string sec ]}

\BEGARG
\DEFARG{STRING}{C}{Message string}{ D=\EMPTY{}}
\DEFARG{SEC}{R}{Number of seconds}{ D=0 R=0:}
\ENDARG

   \par
Make a pause (e.g. inside a macro).  Wait a given number of seconds (if 
   SEC.GT.0) or just until \BRA{}CR\KET{} is entered (if SEC.EQ.0).  A message 
   string is also written on the terminal before waiting.  

\ENDCMD

\DEFCMD{K}{IDLE}{KUIP}{IDLE}{ sec [ string ]}

\BEGARG
\DEFARG{SEC}{I}{Number of seconds}{ R=0:}
\DEFARG{STRING}{C}{Command string}{ D=\EMPTY{}}
\ENDARG

   \par
Execute a command if program is idle.  The command string is executed if 
   there was no keyboard activity during SEC seconds.  

\ENDCMD

\DEFCMD{K}{UNITS}{KUIP}{UNITS}{}

   \par
List all Input/Output logical units currently open.  The files attached to 
   them are also shown.  

\ENDCMD

\DEFCMD{K}{EXIT}{KUIP}{EXIT}{}

   \par
End of the interactive session.  

\ENDCMD

\DEFCMD{K}{QUIT}{KUIP}{QUIT}{}

   \par
End of the interactive session.  

\ENDCMD

\DEFCBIG{K}{FUNCTI}{KUIP}{FUNCTIONS}{}

   \par
List of all KUIP System Functions.  

\begin{verbatim}
          *** KUIP System Functions ***
\end{verbatim}
\ENDVERB
   \par
The function name (and arguments) is literally replaced, at run-time, by 
   its current value.  At present, the following functions are available:  
\begin{verbatim}
    $DATE  .......................  Current date in format DD/MM/YY
    $TIME  .......................  Current time in format HH.MM.SS
    $CPTIME  .....................  CP time elapsed since last call (in sec)
    $RTIME  ......................  Real time elapsed since last call (in sec)
    $VDIM(VNAME,IDIM)  ...........  Physical length of vector VNAME
                                    on dimension IDIM (1..3)
    $VLEN(VNAME,IDIM)  ...........  As above, but for the logical length
                                    (i.e. stripping trailing zeroes)
    $NUMVEC  .....................  Current number of vectors
    $VEXIST(VNAME)  ..............  Index of vector VNAME
                                    (1..$NUMVEC or 0 if VNAME does not exist)
    $SUBSTRING(STRING,IX,NCH)  ...  STRING(IX:IX+NCH-1)
    $UPPER(STRING)  ..............  STRING changed to upper case
    $LOWER(STRING)  ..............  STRING changed to lower case
    $LEN(STRING)  ................  Length of STRING
    $INDEX(STR1,STR2)  ...........  Position of first occurrence of STR2 in 
   STR1
    $WORDS(STRING,SEP)  ..........  Number of words separated by SEP
    $WORD(STRING,K,N,SEP)  .......  Extract N words starting at word K
    $QUOTE(STRING)  ..............  Add quotes around STRING
    $UNQUOTE(STRING)  ............  Remove quotes around STRING
    $EXEC('macro args')  .........  EXITM value of EXEC call
    $DEFINED('var_name')  ........  List of defined macro variables
    $EVAL(Expression)  ...........  Result of the Expression computed by KUIP
    $SIGMA(Expression)  ..........  Result of the Expression computed by SIGMA
    $RSIGMA(Expression) ..........  As above but a decimal point is added to
                                    integer results
    $FORMAT(number,format)  ......  Format a number according to a Fortran
                                    format string, e.g.
                                    $FORMAT(1.5,F5.2) ==> ' 1.50'
                                    $FORMAT(123,I5.5) ==> '00123'
    $ARGS  .......................  Command line at program invocation
    $KEYNUM  .....................  Address of latest clicked key in style GP
    $KEYVAL  .....................  Value of latest clicked key in style GP
    $LAST  .......................  Latest command line executed
    $ANUM  .......................  Number of aliases
    $ANAM(I)  ....................  Name of I-th alias
    $AVAL(I)  ....................  Value of I-th alias
    $STYLE  ......................  Current style as defined by SET/STYLE
    $OS  .........................  Operating system name, e.g. UNIX or VMS
    $MACHINE  ....................  Hardware or Unix brand, e.g. VAX or HPUX
    $PID  ........................  Process ID
    $IQUEST(I)  ..................  Value of IQUEST(I) status vector
    $ENV(var)  ...................  Value of environment variable
    $FEXIST(file)  ...............  1 if file exists or 0 otherwise
    $SHELL(cmd,N)  ...............  N'th line of shell command output (Unix 
   only)
    $SHELL(cmd,sep)  .............  Shell output with newlines replaced by sep
    $SHELL(cmd)  .................  Same as $SHELL(cmd,' ')
\end{verbatim}

\begin{verbatim}
    $CALL('fun(args)')  ..........  Call a Fortran REAL FUNCTION
    $ICALL('ifun(args)')  ........  Call an INTEGER FUNCTION
    $LCALL('lfun(args)')  ........  Call a LOGICAL FUNCTION and return 0 or 1
    $DCALL('dfun(args)')  ........  Call a DOUBLE PRECISION FUNCTION
    $HCDIR()  ....................  Current Hbook working directory
    $HEXIST(id)  .................  1 if histogram ID exists or 0 otherwise
    $HINFO(id,'1DHISTO')  ........  1 if ID is a 1D histogram or 0 otherwise
    $HINFO(id,'2DHISTO')  ........  1 if ID is a 2D histogram or 0 otherwise
    $HINFO(id,'TABLE')  ..........  1 if ID is a table or 0 otherwise
    $HINFO(id,'PROFILE')  ........  1 if ID is a profile histogram or 0 
   otherwise
    $HINFO(id,'NTUPLE')  .........  1 if ID is a Ntuple or 0 otherwise
    $HINFO(id,'LOG')  ............  1 if ID has LOG Y scale or 0 otherwise
    $HINFO(id,'ENTRIES')  ........  Number of entries
    $HINFO(id,'MEAN')  ...........  Mean value
    $HINFO(id,'RMS')  ............  Standard deviation
    $HINFO(id,'EVENTS')  .........  Number of equivalent events
    $HINFO(id,'OVERFLOW')  .......  Content of overflow channel
    $HINFO(id,'UNDERFLOW')  ......  Content of underflow channel
    $HINFO(id,'MIN')  ............  Minimum bin content
    $HINFO(id,'MAX')  ............  Maximum bin content
    $HINFO(id,'SUM')  ............  Total histogram content
    $HINFO(id,'NSLIX')  ..........  Number of X slices
    $HINFO(id,'NSLIY')  ..........  Number of Y slices
    $HINFO(id,'NBANX')  ..........  Number of X bandes
    $HINFO(id,'NBANY')  ..........  Number of Y bandes
    $HINFO(id,'NPROX')  ..........  Projection X (0 or 1)
    $HINFO(id,'NPROY')  ..........  Projection Y (0 or 1)
    $HINFO(id,'XBINS')  ..........  Number of bins in X direction
    $HINFO(id,'XMIN')  ...........  Lower histogram limit in X direction
    $HINFO(id,'XMAX')  ...........  Upper histogram limit in X direction
    $HINFO(id,'YBINS')  ..........  Number of bins in Y direction
    $HINFO(id,'YMIN')  ...........  Lower histogram limit in Y direction
    $HINFO(id,'YMAX')  ...........  Upper histogram limit in Y direction
    $HTITLE(id)  .................  Histogram title
    $GRAFINFO('XZONES')  .........  Number of zones in X direction
    $GRAFINFO('YZONES')  .........  Number of zones in Y direction
    $GRAFINFO('NT')  .............  Current Normalization Transformation number
    $GRAFINFO('WNXMIN')  .........  Lower X limit of window in current NT
    $GRAFINFO('WNXMAX')  .........  Upper X limit of window in current NT
    $GRAFINFO('WNYMIN')  .........  Lower Y limit of window in current NT
    $GRAFINFO('WNYMAX')  .........  Upper Y limit of window in current NT
    $GRAFINFO('VPXMIN')  .........  Lower X limit of viewport in current NT
    $GRAFINFO('VPXMAX')  .........  Upper X limit of viewport in current NT
    $GRAFINFO('VPYMIN')  .........  Lower Y limit of viewport in current NT
    $GRAFINFO('VPYMAX')  .........  Upper Y limit of viewport in current NT
    $GRAFINFO('TXALIH')  .........  Horizontal text alignment
    $GRAFINFO('TXALIV')  .........  Vertical text alignment
    $GRAFINFO('TXFONT')  .........  Text font
    $GRAFINFO('TXPREC')  .........  Text precision
    $GRAFINFO('?attr')  ..........  HPLOT/HIGZ attribute (see HELP SET for 
   valid names)
    $RGBINFO(icol,'R')  ..........  Weight of Red in color table
    $RGBINFO(icol,'G')  ..........  Weight of Green in color table
    $RGBINFO(icol,'B')  ..........  Weight of Blue in color table
    $CUT(n)  .....................  Cut expression $n
    $CUTEXPAND(string)  ..........  Replace $n in the (quoted) string by 
   $CUT(n)
\end{verbatim}

\ENDCBIG

\DEFCMD{K}{BUGREP}{KUIP}{BUGREPORT}{ [ chopt ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D='B'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{B}{\par
Send a bug report
}
\DEFOPT{C}{\par
Send a comment, suggestion, etc.
}
\ENDOPT

   \par
Email a bug report or comment to the PAW team.  The local editor is invoked 
   with a template to be filled out.  After the template has been edited, 
   version information about PAW and the operating system is appended.  The 
   user is asked for a confirmation before the report is send.  

   \par
In Paw++ this command can be accessed via the \DQUOTE{}Help\DQUOTE{} menu 
   of the \DQUOTE{}Executive Window\DQUOTE{} or the \DQUOTE{}Main 
   Browser\DQUOTE{} (menu item \DQUOTE{}Mail Paw++ Developers\DQUOTE{}).  

   \par
This command is implemented only on UNIX, VMS and VM systems.  

\ENDCMD

\DEFCMD{K}{VERSIO}{KUIP}{VERSION}{}

   \par
Print the version string for PAW and the underlying packages.  

\ENDCMD
\DEFMENU{1}{ALIAS}{KUIP/ALIAS}
\ifMENUtext
   \par
Operations with aliases.  Aliases are defined to provide shortcut 
   abbreviations for the input line or some part of it.  When encountered on 
   an input line an alias is replaced by its string value which can contain 
   further aliases.  (Be careful not to define recursive aliases.) 

   \par
To juxtaposition aliases, a double slash can be used as concatenation sign. 
   Inside quoted strings and for the ALIAS commands themselves the alias 
   substitution is inhibited.  Otherwise 
\begin{verbatim}
    ALIAS/CREATE ALPHA BETA
    ALIAS/CREATE ALPHA BETA
\end{verbatim}
   \par
whould create an recursive alias BETA and 
\begin{verbatim}
    ALIAS/CREATE ALPHA BETA
    ALIAS/CREATE BETA GAMMA
    ALIAS/DELETE ALPHA
\end{verbatim}
   \par
would delete the alias name BETA instead of ALPHA itself.  


\fi

\DEFCMD{KA}{CREATE}{KUIP/ALIAS}{CREATE}{ name value [ chopt ]}

\BEGARG
\DEFARG{NAME}{C}{Alias name}{}
\DEFARG{VALUE}{C}{Alias value}{}
\DEFARG{CHOPT}{C}{Option}{ D='A'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
create an Argument alias
}
\DEFOPT{C}{\par
create a Command alias
}
\DEFOPT{N}{\par
No alias expansion of value
}
\ENDOPT

   \par
Create an alias NAME which should be substituted by VALUE.  An alias name 
   is a sequence of letters and digits starting with a letter.  The 
   underscores ('\_'), the at-sign ('@@') and the dollar-sign ('\$') count as 
   letters.  

   \par
There are two types of aliases:  Command aliases are recognized only if 
   they occur in the command position, i.e. as the first token on the line.  
   Argument aliases are recognized anywhere on the command line (except inside 
   quoted strings) if they are surrounded by one of the following separators:  
\begin{verbatim}
    blank  /  ,  =  :  .  %  '  (  )
\end{verbatim}
\ENDVERB
   \par
Also switch ON the alias translation, i.e. ALIAS/TRANSLATION ON.  If 
   CHOPT='C' then the alias is a command alias, i.e. an alias that will only 
   be translated when it is the first token on a command line.  Example:  
\begin{verbatim}
    Alias/Create GG Graph/Struct/Scratch
    Alias/Create FF File1/Name1/Name2
    GG FF/ID
\end{verbatim}
   \par
is equivalent to 
\begin{verbatim}
    Graph/Struct/Scratch File1/Name1/Name2/ID
\end{verbatim}
\begin{verbatim}
    Alias/Create LS DIR C
\end{verbatim}
   \par
is equivalent to 
\begin{verbatim}
    DIR
\end{verbatim}
   \par
only when LS is the first token on a command line.  In the following case 
   LS will not be translated 
\begin{verbatim}
    SHELL LS
\end{verbatim}
\ENDVERB
   \par
Aliases occuring inside an value are expanded indepedent whether the value 
   is enclosed by quotes.  The option -N allows to suppress this implicit 
   alias expansion.  

\ENDCMD

\DEFCMD{KA}{LIST}{KUIP/ALIAS}{LIST}{ [ name ]}

\BEGARG
\DEFARG{NAME}{C}{Alias name wildcard}{ D='*'}
\ENDARG

   \par
List all aliases matching the wildcard (names and values).  

\ENDCMD

\DEFCMD{KA}{DELETE}{KUIP/ALIAS}{DELETE}{ name}

\BEGARG
\DEFARG{NAME}{C}{Alias name wildcard}{ Loop}
\ENDARG

   \par
Delete the definition of aliases matching the wildcard.  NAME='*' deletes 
   all aliases.  

\ENDCMD

\DEFCMD{KA}{TRANSL}{KUIP/ALIAS}{TRANSLATION}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{ON}{\par
switch alias translation ON
}
\DEFOPT{OFF}{\par
switch alias translation OFF
}
\ENDOPT

   \par
Switch ON/OFF the alias translation.  If OFF, alias definitions are not 
   used in parsing the command lines.  It is automatically switched ON when an 
   alias is created.  If OPTION='?' the current value is shown.  The startup 
   value is OFF.  

\ENDCMD
\DEFMENU{1}{SET\_SHOW}{KUIP/SET\_SHOW}
\ifMENUtext
   \par
Set or show various KUIP parameters and options.  


\fi

\DEFCMD{KS}{STYLE}{KUIP/SET\_SHOW}{STYLE}{ [ option sgylen sgsize sgyspa sgbord wktype ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='?'}
\DEFARG{SGYLEN}{R}{max Y LENgth of each menu item box}{ D=0.025 R=0.005:0.25}
\DEFARG{SGSIZE}{R}{space available for the application}{ D=0.8 R=0:0.90}
\DEFARG{SGYSPA}{R}{max Y length of space between menus}{ D=0.02 R=-0.5:0.50}
\DEFARG{SGBORD}{R}{X or Y border for menus}{ D=0.015 R=0:0.25}
\DEFARG{WKTYPE}{I}{Graphics workstation type}{ D=0}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current style
}
\DEFOPT{C}{\par
Command line : select Command line input
}
\DEFOPT{AN}{\par
Menu with Numbers : select general Alpha menu (with Numbers)
}
\DEFOPT{AL}{\par
Menu with Letters : select general Alpha menu (with Letters)
}
\DEFOPT{G}{\par
Graphics menu hardware : select Graphics menu (with hardware character fonts)
}
\DEFOPT{GW}{\par
Graphics menu shadowed : select Graphics menu (with shadowed Width effect)
}
\DEFOPT{GS}{\par
Graphics menu Software : select Graphics menu (with Software character fonts)
}
\DEFOPT{GP}{\par
Panel keys : select Graphics menu (with Panel keys only, i.e. no command tree 
menu)
}
\DEFOPT{XM}{\par
Motif/X11 : select Motif/X11 interface
}
\ENDOPT

   \par
Select the user dialog style (or working mode).  The startup value is 'C' 
   (command mode).  The current value is returned by the system function 
   \$STYLE.  

   \par
The G-styles are only available if the application program is calling 
   KUWHAG instead of KUWHAT.  When one of these options is choosen the 
   remaining parameters control the geometrical layout of the menus on the 
   screen and the graphics workstation type (in case HIGZ was not 
   initialized).  

   \par
Style 'XM' is only available if the program is calling KUWHAM.  In that 
   case switching to other styles is not possible.  

\ENDCMD

\DEFCBIG{KS}{PANEL}{KUIP/SET\_SHOW}{PANEL}{ line [ gkey ]}

\BEGARG
\DEFARG{LINE}{R}{Line number}{ D=0}
\DEFARG{GKEY}{C}{Graphics key value(s)}{ D=\EMPTY{}}
\ENDARG

   \par
Set up a (user-definable) panel of commands with graphics keys.  These keys 
   are associated to pre-defined commands (or list of commands), which are 
   generally corresponding to actions frequently executed.  

   \par
The \DQUOTE{}panel interface\DQUOTE{} is available in \DQUOTE{}STYLE 
   GP\DQUOTE{} and in KUIP/Motif (but not in the basic command mode). 
   Nevertheless the syntax of the PANEL command is different in these two 
   modes of interface.  The \DQUOTE{}panel interface\DQUOTE{} is a lot more 
   powerful in KUIP/Motif, which means that the command is more complex.  

   \par
N.B. in \DQUOTE{}STYLE GP\DQUOTE{} only one panel of commands can be set 
   up, whereas in KUIP/Motif there is no limitation.  

   \par
Syntax of the command in \DQUOTE{}STYLE GP\DQUOTE{} :  

\begin{verbatim}
    PANEL x.y command
\end{verbatim}
\begin{verbatim}
    where:
    x,y       is the key position (column and row number)
    command   is the complete command name (or list of commands)
              to be excuted when the button is pressed.
\end{verbatim}
\ENDVERB
   \par
Examples:  
\begin{verbatim}
    PANEL  0                        | reset the panel (in memory)
    PANEL  2.04 MESSAGE             | initialize 4th key of 2nd line to MESSAGE
    PANEL  2.04                     | clear 4th key of 2nd line
\end{verbatim}
   \par
Note that the key number on the right of the decimal point must always be 
   defined with two digits.  

   \par
Keys ending with a minus sign make an additional request of keyboard input; 
   the complete command line will be the key text, with a blank at the place 
   of the minus, concatenated with the additional keyboard input. Example:  
\begin{verbatim}
    PANEL 1.03 'VEC/PRI-'        | entering VAB will execute VEC/PRI VAB.
\end{verbatim}
   \par
Keys ending with a double minus sign behave as above but no blank is put at 
   the place of the double minus. Example:  
\begin{verbatim}
    PANEL 1.03 'VEC/PRI V--'     | entering AB will execute VEC/PRI VAB
\end{verbatim}
   \par
The dollar sign inside a key is replaced by additional keyboard input. 
   Example:  
\begin{verbatim}
    PANEL 1.03 'VEC/PRI V($)'    | entering 11:20 will execute VEC/PRI V(11:20)
\end{verbatim}
\ENDVERB
   \par
Syntax of the command in \DQUOTE{}KUIP/Motif\DQUOTE{} :  

   \par
All what is described above (for \DQUOTE{}STYLE GP\DQUOTE{}) is still 
   available.  But the (more) general syntax in \DQUOTE{}KUIP/Motif\DQUOTE{} 
   is:  

\begin{verbatim}
    PANEL x.y command [label] [pixmap]
\end{verbatim}
\begin{verbatim}
    where:
    x,y                is the key position (column and row number)
    command            is the complete command name (or list of commands)
                       to be excuted when the button is pressed.
    label (optional)   is an alias name for this command. If specified,
                       it is used for the button label (when the appropriate
                       "View" option is selected) instead of the complete
                       command (which is generally too long for a 
   "user-friendly"
                       button label.
    pixmap (optional)  has to be specified when you want to have graphical keys
                       instead of pure text labels.
\end{verbatim}
\ENDVERB
   \par
In KUIP/Motif, the special value \DQUOTE{}0\DQUOTE{} for x.y (PANEL  0 ...) 
   can be used for different purposes (according to the 2nd parameter value):  

\begin{verbatim}
    PANEL  0 D [title] [geometry]
\end{verbatim}
\ENDVERB
   \par
can be use to display the current panel which is in memory with (optionals) 
   a given title and geometry (size and position).  

\begin{verbatim}
    PANEL  0 C [title]
\end{verbatim}
\ENDVERB
   \par
can be use to close the last panel, or the one corresponding to the given 
   title.  

   \par
Examples:  
\begin{verbatim}
    - PANEL  0 D 'This is my first panel' 500x300+500+600
\end{verbatim}
   \par
displays the panel which has been set in memory by the key definition, and 
   sets the title to ``This is my first panel'', the window size to 
   ``500x300'' (WxH) and the window position to ``500 600'' in x and y.  If no 
   title and/or no geometry is specified one is given by default.  
\begin{verbatim}
    - PANEL  0 C 'This is my first panel'
\end{verbatim}
   \par
closes (destroys and erases from the screen) the panel whith title ``This 
   is my first panel''.  If no title is specified the last created panel is 
   closed by default.  

   \par
As the \DQUOTE{}panel interface\DQUOTE{} is rather complex and powerful in 
   KUIP-Motif, if you want to know all the possibilities, we invite you to 
   refer to the KUIP User Guide (where you will also find picture 
   illustrations).  

\ENDCBIG

\DEFCMD{KS}{NEWPAN}{KUIP/SET\_SHOW}{NEWPANEL}{ line col title width height xpos ypos}

\BEGARG
\DEFARG{LINE}{I}{Number of lines}{ D=5 R=1:30}
\DEFARG{COL}{I}{Number of columns}{ D=5 R=1:30}
\DEFARG{TITLE}{C}{Panel Title}{ D='NewPanel'}
\DEFARG{WIDTH}{I}{Panel width (in pixels)}{ D=300 R=10:}
\DEFARG{HEIGHT}{I}{Panel height (in pixels)}{ D=300 R=10:}
\DEFARG{XPOS}{I}{X Position (in pixels)}{ D=0 R=0:}
\DEFARG{YPOS}{I}{Y Position (in pixels)}{ D=0 R=0:}
\ENDARG

   \par
Set up a new panel with empty keys.  This new panel must then be filled 
   interactively.  

\ENDCMD

\DEFCMD{KS}{COMMAN}{KUIP/SET\_SHOW}{COMMAND}{ [ chpath ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name for command line}{ D=\EMPTY{}}
\ENDARG

   \par
Set a filter for the parsing of command lines.  If it has been called, it 
   means that whenever a command line is entered, if and only if it is not an 
   existing command (not just ambiguous), it is inserted into the CHPATH 
   string, with \$n (n=1..9) being replaced by the n-th token of the command 
   (tokens are separated by spaces), or \$* being replaced by the whole 
   command line. Examples:  
\begin{verbatim}
    COMMAND 'V/CR $*(10)'
    AA                     =>   V/CR AA(10)
    BB                     =>   V/CR BB(10)
    V/LIST                 =>   V/LIST
\end{verbatim}
\begin{verbatim}
    COMMAND 'VECTOR/PLOT $1 555 $2'
    AA E                   =>   VECTOR/PLOT AA 555 E
    BB                     =>   VECTOR/PLOT BB 555
\end{verbatim}
\begin{verbatim}
    COMMAND                =>   shows its current value
    COMMAND *              =>   reset (equivalent to COMMAND $*)
\end{verbatim}
   \par
Note that COMMAND and subsequent command lines can be used inside macros, 
   excepted when producing macro statements (like EXEC, IF, GOTO, etc.).  For 
   example, the above examples would work also inside macros, while COMMAND 
   'EXEC \$*' or COMMAND 'GOTO \$1' will not.  

\ENDCMD

\DEFCMD{KS}{APPLIC}{KUIP/SET\_SHOW}{APPLICATION}{ path [ cmdex ]}

\BEGARG
\DEFARG{PATH}{C}{Application name}{ D=\EMPTY{}}
\DEFARG{CMDEX}{C}{Exit command}{ D='EXIT'}
\ENDARG

   \par
Set the application name.  This means that all input lines will be 
   concatenated to the string PATH (until the command specified by the 
   parameter CMDEX is executed, which resets the application to the null 
   string). The value of CMDEX may be specified if the default value EXIT has 
   to be changed (i.e. because already used by the application).  APPLICATION 
   can also be inserted in a macro: in this case at least 4 characters must be 
   specified (i.e. APPL).  

\ENDCMD

\DEFCMD{KS}{ROOT}{KUIP/SET\_SHOW}{ROOT}{ [ path ]}

\BEGARG
\DEFARG{PATH}{C}{Root directory}{ D='/'}
\ENDARG

   \par
Set the root for searching commands.  If PATH='?' the current root is 
   shown.  This allows to access commands regardless of possible ambiguities 
   with different menus.  Commands are first searched starting from the 
   current root:  if a command is found it is executed.  Only if a command is 
   not found a second pass of search is done, starting now from the top root 
   of the command tree (i.e. '/').  

\ENDCMD

\DEFCMD{KS}{TIMING}{KUIP/SET\_SHOW}{TIMING}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\DEFOPT{ALL}{}
\ENDOPT

   \par
Set ON/OFF/ALL the timing of commands.  If ON, the real time and the CPU 
   time for the latest executed command (or macro) are presented.  If ALL, the 
   time is shown for each command being executed within a macro.  The startup 
   value is OFF.  

\ENDCMD

\DEFCMD{KS}{PROMPT}{KUIP/SET\_SHOW}{PROMPT}{ prompt}

\BEGARG
\DEFARG{PROMPT}{C}{Prompt string}{ D=\EMPTY{}}
\ENDARG

   \par
Set the prompt string for the command mode dialogue.  If PROMPT is blank 
   the current prompt is left unchanged.  If PROMPT contains the character 
   sequence '[]' the current command number is inserted between the square 
   brackets.  

\ENDCMD

\DEFCMD{KS}{BREAK}{KUIP/SET\_SHOW}{BREAK}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\DEFOPT{TB}{}
\DEFOPT{?}{}
\ENDOPT

   \par
Set ON/OFF the break handling.  If OPTION='?' the current value is shown.  
   The startup value is ON.  

   \par
Hitting the keyboard interrupt (CTRL/C on VMS or CTRL/Q on the Apollo) 
   under break ON condition, the current command or macro execution will be 
   interrupted and the user will get again the application prompt.  

   \par
BREAK TB switch ON the traceback of the routines called, with their line 
   numbers, when an error occurs. This allows the detection of the routines 
   which provoked the error.  

\ENDCMD

\DEFCMD{KS}{COLUMN}{KUIP/SET\_SHOW}{COLUMNS}{ [ ncol ]}

\BEGARG
\DEFARG{NCOL}{I}{Number of columns for terminal output}{ D=80 R=-1:}
\ENDARG

   \par
Set the maximum number of columns for terminal output.  If NCOL=0 the 
   current number of columns is shown.  If NCOL=-1 the current number of 
   columns is taken from the environment variable COLUMNS.  If COLUMNS is 
   undefined the startup value is 80.  

\ENDCMD

\DEFCMD{KS}{RECORD}{KUIP/SET\_SHOW}{RECORDING}{ [ nrec ]}

\BEGARG
\DEFARG{NREC}{I}{Rate for recording on history file}{ D=25 R=0:}
\ENDARG

   \par
Set the recording rate for the history file.  Every NREC commands of the 
   session the current history file is updated.  If NREC=0 the history is not 
   kept at all (i.e. the file is not written).  See also the command LAST.  

\ENDCMD

\DEFCMD{KS}{HOSTED}{KUIP/SET\_SHOW}{HOST\_EDITOR}{ [ editor top left width height dxpad dypad npads ]}

\BEGARG
\DEFARG{EDITOR}{C}{Host editor command}{ D='?'}
\DEFARG{TOP}{I}{Top position of the edit window}{ D=20 R=0:}
\DEFARG{LEFT}{I}{Left position of the edit window}{ D=20 R=0:}
\DEFARG{WIDTH}{I}{Width of the edit window}{ D=0 R=0:}
\DEFARG{HEIGHT}{I}{Height of the edit window}{ D=0 R=0:}
\DEFARG{DXPAD}{I}{X offset for help PAD windows}{ D=30 R=0:}
\DEFARG{DYPAD}{I}{Y offset for help PAD windows}{ D=20 R=0:}
\DEFARG{NPADS}{I}{Maximum number of shifted pads}{ D=4 R=1:}
\ENDARG

   \par
Set the host command to invoke the editor.  The EDIT command will invoke 
   this editor.  If EDITOR='?' the current host editor command is shown.  

   \par
On Apollo the special value EDITOR='DM' invoke Display Manager pads.  The 
   special values EDITOR='WINDOW' and 'PAD' can be used to specify the window 
   positions (in pixel units).  'WINDOW' defines the parameters for edit pads, 
   while 'PAD' defines the parameters for read-only pads (e.g. used by 'HELP 
   -EDIT').  

   \par
On VMS the special values EDITOR='EDT' and 'TPU' invoke the callable 
   editors.  The startup time is considerably lower compared to spawning the 
   editor as a subprocess.  The callable EDT has one disadvantage though:  
   after an error, e.g. trying to edit a file in a non-existing directory, 
   subsequent calls will always fail.  The TPU call can be augmented by 
   command line options, e.g.  
\begin{verbatim}
    HOST_EDITOR TPU/DISP=DECW    | DECwindow interface to EVE
\end{verbatim}
\ENDVERB
   \par
On Unix a variety of editors are available, e.g.  
\begin{verbatim}
    HOST_EDITOR vi
    HOST_EDITOR 'emacs -geometry 80x48'
\end{verbatim}
\ENDVERB
   \par
On Unix workstations it is possible to do asynchronous editing via the KUIP 
   edit server, i.e. to start an editor in a separate window while the 
   application can continue to receive commands.  In order to do that the 
   following conditions must be fulfilled:  
\begin{verbatim}
    - The KUIP edit server 'kuesvr' must be found in the search path.
    - The editor command set by HOST_EDITOR must end with an ampersand ('&').
    - The environment variable 'DISPLAY' must be set.
\end{verbatim}
\ENDVERB
   \par
The ampersand flags your intention to use the edit server if possible.  If 
   the edit server cannot be used the ampersand will be ignored, i.e. even 
   with 
\begin{verbatim}
    HOST_EDITOR 'vi &'
\end{verbatim}
   \par
the KUIP/EDIT command will block until the editor terminates if either the 
   'kuesvr' is not available or 'DISPLAY' is undefined.  When using the edit 
   server the editor command is expected to create its own window.  'vi' being 
   a frequent choice, the above command is automatically interpreted as 
\begin{verbatim}
    HOST_EDITOR 'xterm -e vi &'
\end{verbatim}
\ENDVERB
   \par
The startup value can be defined by the environment variable 'EDITOR'.  
   Otherwise it is set to a system dependent default:  'DM' (Apollo), 'EDT' 
   (VMS), 'XEDIT' (VM/CMS), 'vi' (Unix).  

\ENDCMD

\DEFCMD{KS}{HOSTPA}{KUIP/SET\_SHOW}{HOST\_PAGER}{ [ pager ]}

\BEGARG
\DEFARG{PAGER}{C}{Host pager command}{ D='?'}
\ENDARG

   \par
Set the host command to view a file in read-only mode.  If OPTION='?' the 
   current host pager command is shown.  The 'HELP -EDIT' command will invoke 
   this pager, e.g.  
\begin{verbatim}
    HOST_PAGER more
\end{verbatim}
\ENDVERB
   \par
On Unix workstations the pager can be asynchronous by creating a separate 
   window, e.g.  
\begin{verbatim}
    HOST_PAGER 'xterm -e view &'
    HOST_PAGER 'ved &'
\end{verbatim}
\ENDVERB
   \par
On Apollo the special value PAGER='DM' defines the use of Display Manager 
   read-only pads.  The pad positions can be adjusted by the HOST\_EDITOR 
   command.  

   \par
The startup value can be defined by the environment variables 'KUIPPAGER' 
   or 'PAGER'.  If neither of them is defined the value set by the 
   HOST\_EDITOR command is used.  On VAX/VMS the startup value is 'TYPE/PAGE'. 

\ENDCMD

\DEFCMD{KS}{HOSTPR}{KUIP/SET\_SHOW}{HOST\_PRINTER}{ [ command filetype ]}

\BEGARG
\DEFARG{COMMAND}{C}{Host printer command}{ D='?'}
\DEFARG{FILETYPE}{C}{File extension}{ D=\EMPTY{}}
\ENDARG

   \par
Set the host commands for printing files with KUIP/PRINT.  The KUIP/PRINT 
   command will use the host command matching the file extension or use the 
   default command defined for FILETYPE=' '.  

   \par
If COMMAND='?' the currently set commands are shown.  If COMMAND=' ' the 
   currently defined command is delete.  The command string can contain '\$*' 
   and '\$-' to indicate the position where the file name with/without file 
   extension should be inserted.  For example, 
\begin{verbatim}
    MANUAL / refman.tex latex
    HOST_PRINTER 'latex $* ; dvips $-' .tex
    KUIP/PRINT refman.tex
\end{verbatim}
   \par
invokes the shell command 'latex refman.tex ; dvips refman'.  The 
   predefined defaults are not guaranteed to work since the actual print 
   commands are very much installation dependent.  

\ENDCMD

\DEFCMD{KS}{HOSTPS}{KUIP/SET\_SHOW}{HOST\_PSVIEWER}{ [ psviewer ]}

\BEGARG
\DEFARG{PSVIEWER}{C}{Host PostScript Viewer command}{ D='?'}
\ENDARG

   \par
Set the host command to invoke the PostScript Viewer.  The PSVIEW command 
   will invoke this PostScript Viewer.  If PSVIEWER='?' then the current 
   viewer command is shown.  

   \par
The startup value can be defined by the environment variables 
   'KUIPPSVIEWER' or 'PSVIEWER'.  

   \par
On Unix workstations it is by default set to 'ghostview'.  On VAX/VMS the 
   default commands is 'VIEW/FORM=PS/INTERFACE=DECWINDOWS'.  

\ENDCMD

\DEFCMD{KS}{HOSTSH}{KUIP/SET\_SHOW}{HOST\_SHELL}{ [ shell ]}

\BEGARG
\DEFARG{SHELL}{C}{Host shell command}{ D='?'}
\ENDARG

   \par
Set the default host shell invoked by the KUIP/SHELL command.  If 
   OPTION='?' the current host shell is shown.  The startup value is taken 
   from the 'SHELL' environment variable.  

\ENDCMD

\DEFCBIG{KS}{RECALL}{KUIP/SET\_SHOW}{RECALL\_STYLE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Command recall and editing style}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{KSH}{\par
Korn shell : Emacs like command line editing
}
\DEFOPT{KSHO}{\par
Korn shell + Overwrite : like 'KSH' but overwrite instead of insert mode
}
\DEFOPT{DCL}{\par
VAX/VMS DCL : DCL command line editing
}
\DEFOPT{DCLO}{\par
VAX/VMS DCL + Overwrite : like 'DCL' but overwrite instead of insert mode
}
\DEFOPT{NONE}{\par
disable command line editing
}
\ENDOPT

   \par
Set the command recall and editing style.  If OPTION='?' the current style 
   is shown.  The startup value is 'DCL' on VAX/VMS, 'NONE' on Cray and Apollo 
   DM pads, and 'KSH' on other systems.  

   \par
If the terminal emulator returns ANSI escape sequences (hpterm doesn't!) 
   the up/down arrow keys can be used to recall items from the command history 
   list and the left/right arrow keys to move the cursor.  

   \par
'KSH' style provides the following control keys for editing:  
\begin{verbatim}
     ^A/^E   : Move cursor to beginning/end of the line.
     ^F/^B   : Move cursor forward/backward one character.
     ^D      : Delete the character under the cursor.
     ^H, DEL : Delete the character to the left of the cursor.
     ^K      : Kill from the cursor to the end of line.
     ^L      : Redraw current line.
     ^O      : Toggle overwrite/insert mode. Text added in overwrite mode
               (including yanks) overwrites existing text, while insert mode
               does not overwrite.
     ^P/^N   : Move to previous/next item on history list.
     ^R/^S   : Perform incremental reverse/forward search for string on
               the history list.  Typing normal characters adds to the
               current search string and searches for a match.  Typing
               ^R/^S marks the start of a new search, and moves on to
               the next match.  Typing ^H or DEL deletes the last
               character from the search string, and searches from the
               starting location of the last search.
               Therefore, repeated DELs appear to unwind to the match
               nearest the point at which the last ^R or ^S was typed.
               If DEL is repeated until the search string is empty the
               search location begins from the start of the history
               list. Typing ESC or any other editing character accepts
               the current match and loads it into the buffer,
               terminating the search.
     ^T      : Toggle the characters under and to the left of the cursor.
     ^U      : Kill from the prompt to the end of line.
     ^Y      : Yank previously killed text back at current location.
               Note that this will overwrite or insert, depending on
               the current mode.
     TAB     : By default adds spaces to buffer to get to next TAB stop
               (just after every 8th column).
     LF, CR  : Returns current buffer to the program.
\end{verbatim}
\ENDVERB
   \par
'DCL' style provides the following control keys for editing:  
\begin{verbatim}
     BS/^E   : Move cursor to beginning/end of the line.
     ^F/^D   : Move cursor forward/backward one character.
     DEL     : Delete the character to the left of the cursor.
     ^A      : Toggle overwrite/insert mode.
     ^B      : Move to previous item on history list.
     ^U      : Delete from the beginning of the line to the cursor.
     TAB     : Move to next TAB stop.
     LF, CR  : Returns current buffer to the program.
\end{verbatim}

\ENDCBIG

\DEFCMD{KS}{VISIBI}{KUIP/SET\_SHOW}{VISIBILITY}{ cmd [ chopt ]}

\BEGARG
\DEFARG{CMD}{C}{Command name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{?, OFF, ON}{ D='?'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{?}{}
\DEFOPT{OFF}{}
\DEFOPT{ON}{}
\ENDOPT

   \par
Set or show the visibility attributes of a command.  

   \par
If CHOPT='OFF':  
\begin{verbatim}
    - the command it is not executable anymore
    - STYLE G draws a shadowed box on the command
    - HELP may be still requested on the command
\end{verbatim}
   \par
The startup value is ON.  

\ENDCMD

\DEFCMD{KS}{DOLLAR}{KUIP/SET\_SHOW}{DOLLAR}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Substitution of environment variables}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{ON}{\par
enable substitution
}
\DEFOPT{OFF}{\par
disable substitution
}
\ENDOPT

   \par
Set or show the status of environment variable substitution.  

   \par
This command allows to enable/disable the interpretation of environment 
   variables in command lines.  The startup value is 'ON', i.e. 
   \DQUOTE{}\$var\DQUOTE{} is substituted by the variable value.  

   \par
Note that the system function \DQUOTE{}\$ENV(var)\DQUOTE{} allows using 
   environment variables even for 'DOLLAR OFF' .  

\ENDCMD

\DEFCMD{KS}{FILECA}{KUIP/SET\_SHOW}{FILECASE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Case conversion for filenames}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{KEEP}{\par
filenames are kept as entered on the command line
}
\DEFOPT{CONVERT}{\par
filenames are case converted
}
\DEFOPT{RESTORE}{\par
restore previous FILECASE setting
}
\ENDOPT

   \par
Set or show the case conversion for filenames.  

   \par
This command has only an effect on Unix systems to select whether filenames 
   are kept as entered on the command line.  The startup value is 'CONVERT', 
   i.e. filenames are converted to lowercase.  

   \par
On other systems filenames are always converted to uppercase.  

   \par
The 'RESTORE' option set the conversion mode to the value effective before 
   the last FILECASE KEEP/CONVERT command.  E.g. the sequence 
\begin{verbatim}
        FILECASE KEEP; EDIT Read.Me; FILECASE RESTORE
\end{verbatim}
   \par
forces case sensitivity for the EDIT command and restores the previous mode 
   afterwards.  

\ENDCMD

\DEFCMD{KS}{LCDIR}{KUIP/SET\_SHOW}{LCDIR}{ [ directory ]}

\BEGARG
\DEFARG{DIR*ECTORY}{C}{Directory name}{ D=\EMPTY{}}
\ENDARG

   \par
Set or show the local working directory.  

   \par
The current working directory is set to the given path name or the current 
   directory is shown.  

   \par
To show the current directory used LCDIR without argument.  'LCDIR ~' 
   switches to the home directory.  'LCDIR .' switches back to the working 
   directory at the time the program was started.  

\ENDCMD
\DEFMENU{0}{MACRO}{MACRO}
\ifMENUtext
   \par
Macro Processor commands.  


\fi

\DEFCMD{M}{EXEC}{MACRO}{EXEC}{ mname [ margs ]}

\BEGARG
\DEFARG{MNAME}{C}{Macro name}{}
\DEFARG{MARGS}{C}{Macro arguments}{ D=\EMPTY{} Separate}
\ENDARG

   \par
Execute the command lines contained in the macro MNAME.  As a file can 
   contain several macros, the character '\#' is used to select a particular 
   macro inside a file as explained below.  

   \par
If MNAME does not contain the character '\#', the file MNAME.KUMAC is 
   searched and the first macro is executed (it may be an unnamed macro if a 
   MACRO statement is not found as first command line in the file).  

   \par
If MNAME is of the form FILE\#MACRO, the file named FILE.KUMAC is searched 
   and the macro named MACRO is executed.  

   \par
Examples:  
\begin{verbatim}
    EXEC ABC   to exec first (or unnamed) macro of file ABC.KUMAC
    EXEC ABC#M to exec macro M of file ABC.KUMAC
\end{verbatim}
\ENDVERB
   \par
The command MACRO/DEFAULTS can be used to define a directory search path 
   for macro files.  

\ENDCMD

\DEFCMD{M}{LIST}{MACRO}{LIST}{ [ mname ]}

\BEGARG
\DEFARG{MNAME}{C}{Macro name pattern}{ D=\EMPTY{}}
\ENDARG

   \par
List all macros in the search path defined by MACRO/DEFAULTS.  Macros are 
   files with the extension KUMAC.  MNAME may be specified to restrict the 
   list to the macros containing such a string in the first part of their 
   name.  For example, 
\begin{verbatim}
    MACRO/LIST ABC
\end{verbatim}
   \par
will list only macros starting with ABC.  

\ENDCMD

\DEFCMD{M}{TRACE}{MACRO}{TRACE}{ [ option level ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\DEFARG{LEVEL}{C}{Level}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\ENDOPT
\BEGOPT{LEVEL}
\DEFOPT{\EMPTY}{}
\DEFOPT{TEST}{}
\DEFOPT{WAIT}{}
\DEFOPT{FULL}{}
\DEFOPT{DEBUG}{}
\ENDOPT

   \par
Set ON/OFF the trace of commands during macro execution.  If TRACE='ON' the 
   next command is written on the terminal before being executed.  If 
   LEVEL='TEST' the command is only echoed but not executed.  If LEVEL='WAIT' 
   the command WAIT is automatically inserted after the execution of each 
   command.  The startup values are OPTION='OFF' and LEVEL=' '.  

\ENDCMD

\DEFCMD{M}{DEFAUL}{MACRO}{DEFAULTS}{ [ path option ]}

\BEGARG
\DEFARG{PATH}{C}{Search path for macro files}{ D='?'}
\DEFARG{OPTION}{C}{Automatic EXEC}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{Command}{\par
search for commands only
}
\DEFOPT{C}{\par
same as 'Command'
}
\DEFOPT{Auto}{\par
search for commands before macros
}
\DEFOPT{A}{\par
same as 'Auto'
}
\DEFOPT{AutoReverse}{\par
search for macros before commands
}
\DEFOPT{AR}{\par
same as 'AutoReverse'
}
\ENDOPT

   \par
Set or show MACRO search attributes.  

   \par
On Unix and VMS systems PATH defines a comma separated list of directories 
   in which the commands KUIP/EDIT, MACRO/EXEC, and MACRO/LIST search for 
   macro files.  For example, 
\begin{verbatim}
    MACRO/DEFAULT '.,macro,~/macro'          | Unix
    MACRO/DEFAULT '[],[.macro],[macro]'      | VMS
\end{verbatim}
   \par
defines to search files first in the current directory, then in the 
   subdirectory 'macro' of the current directory, and last the subdirectory 
   'macro' of the home directory.  

   \par
On VM/CMS system PATH defines a comma separated list of filemodes.  E.g.  
\begin{verbatim}
    MACRO/DEFAULT '*'       | search all disks
    MACRO/DEFAULT 'A,C'     | search only disks A and C
\end{verbatim}
\ENDVERB
   \par
If PATH='?' the currently defined search path is shown.  If PATH='.' the 
   search path is undefined, i.e. files are search for in the current 
   directory (A-disk on VM/CMS) only.  The startup value is PATH='.'.  

   \par
The search path is not applied if the file specification already contains 
   an explicit directory path or if it starts with a '-' character (which is 
   stripped off).  

   \par
OPTION allows to define whether macros can be invoked by their name only 
   without prepending the KUIP/EXEC command:  
\begin{verbatim}
    DEFAULT -Command
    CMD                     | CMD must be a command
    DEFAULT -Auto
    CMD                     | if CMD is not a command try EXEC CMD
    DEFAULT -AutoReverse
    CMD                     | try EXEC CMD first; if not found try command CMD
\end{verbatim}
   \par
The startup value is 'Command' (also reset by PATH='.').  

   \par
Important note:  

   \par
Inside macros the DEFAULT -A (or -AR) logic is disabled, i.e.  DEFAULT -C 
   is always assumed.  

\ENDCMD

\DEFCMD{M}{DATA}{MACRO}{DATA}{}

   \par
Application command to store immediate data into a file.  Example:  
\begin{verbatim}
    Application DATA vec.dat
    1  2  3
    4  5  6
    7  8  9
    vec.dat
    vec/read x,y,z vec.dat
\end{verbatim}

\ENDCMD
\DEFMENU{1}{GLOBAL}{MACRO/GLOBAL}
\ifMENUtext
   \par
Operations on global variables.  


\fi

\DEFCMD{MG}{CREATE}{MACRO/GLOBAL}{CREATE}{ name [ value text ]}

\BEGARG
\DEFARG{NAME}{C}{Variable name}{ Loop}
\DEFARG{VALUE}{C}{Initial value}{ D=\EMPTY{}}
\DEFARG{TEXT}{C}{Comment text}{ D=\EMPTY{}}
\ENDARG

   \par
Create a global variable.  

   \par
If used inside a macro the variable [name] is declared as global.  

\ENDCMD

\DEFCMD{MG}{IMPORT}{MACRO/GLOBAL}{IMPORT}{ name}

\BEGARG
\DEFARG{NAME}{C}{Variable name}{ Loop}
\ENDARG

   \par
Import global variables.  

   \par
If used inside a macro the variables listed are declared as global.  The 
   name may contain '*' as a wildcard matching any sequence of characters.  

\ENDCMD

\DEFCMD{MG}{DELETE}{MACRO/GLOBAL}{DELETE}{ name}

\BEGARG
\DEFARG{NAME}{C}{Variable name}{ Loop}
\ENDARG

   \par
Delete global variables.  

   \par
The global variables listed are deleted.  The name may contain '*' as a 
   wildcard matching any sequence of characters.  

\ENDCMD

\DEFCMD{MG}{LIST}{MACRO/GLOBAL}{LIST}{ [ name file ]}

\BEGARG
\DEFARG{NAME}{C}{Variable name}{ D='*'}
\DEFARG{FILE}{C}{Output file}{ D=\EMPTY{}}
\ENDARG

   \par
List global variables.  

   \par
If a file name is specified the output is the list of GLOBAL/CREATE 
   commands to define the selected global variables.  The default file 
   extension is .kumac.  

\ENDCMD
\DEFMENU{1}{SYNTAX}{MACRO/SYNTAX}
\ifMENUtext
   \par
Explanation of KUIP macro language and syntax.  

   \par
A macro is a set of command lines stored in a file, which can be created 
   and modified with any text editor.  

   \par
In addition to all available KUIP commands the  special \DQUOTE{}macro 
   statements\DQUOTE{} listed below are valid only inside macros. Note that 
   the statement keywords are fixed. Aliasing such as \DQUOTE{}ALIAS/CREATE 
   jump GOTO\DQUOTE{} is not allowed.  


\fi
\DEFMENU{2}{Expressions}{MACRO/SYNTAX/Expressions}
\ifMENUtext
   \par
Explanation of KUIP expression syntax.  

   \par
KUIP has a built-in parser for different kinds of expressions: arithmetic 
   expressions, boolean expressions, string expressions, and \DQUOTE{}garbage 
   expressions\DQUOTE{}.  


\fi

\DEFCMD{MSE}{Arithm}{MACRO/SYNTAX/Expressions}{Arithmetic}{}

   \par
Explanation of arithmetic expression syntax.  

   \par
The syntactic elements for building arithmetic expressions are:  

\begin{verbatim}
           expr ::=  number
                   | vector-name                (for scalar vectors)
                   | vector-name(expr)
                   | vector-name(expr,expr)
                   | vector-name(expr,expr,expr)
                   | [variable-name]            (if value is numeric or
                                                 the name of a scalar vector)
                   | [variable-name](expr...)   (if value is a vector name)
                   | alias-name                 (if value is numeric constant)
                   | $system-function(...)
                   | - expr
                   | expr + expr
                   | expr - expr
                   | expr * expr
                   | expr / expr
                   | (expr)
                   | ABS(expr)
                   | INT(expr)
                   | MOD(expr,expr)
\end{verbatim}
\ENDVERB
   \par
They can be used in the macro statements DO, FOR, and EXITM, in macro 
   variable assignments, as system function arguments where a numeric value is 
   expected, or as the argument to the \$EVAL function.  

   \par
Note that all arithmetic operations are done in floating point, i.e., 
   \DQUOTE{}5/2\DQUOTE{} becomes \DQUOTE{}2.5\DQUOTE{}. If a floating point 
   result appears in a place where an integer is expected, for example as an 
   index, the value is truncated.  

\ENDCMD

\DEFCMD{MSE}{Boolea}{MACRO/SYNTAX/Expressions}{Boolean}{}

   \par
Explanation of Boolean expression syntax.  

   \par
Boolean expressions can only be used in the macro statements IF, WHILE, and 
   REPEAT. The possible syntactic elements are shown below.  

\begin{verbatim}
            bool  ::= expr rel-op expr
                    | string eq-op string
                    | expr eq-op string
                    | .NOT. bool
                    | bool .AND. bool
                    | bool .OR. bool
                    | ( bool )
\end{verbatim}
\begin{verbatim}
           rel-op ::= .LT. | .LE. | .GT. | .GE.
                    |  <   |  <=  |  >   |  >=
                    | eq-op
\end{verbatim}
\begin{verbatim}
           eq-op  ::= .EQ. | .NE.
                    |  =   | <>
\end{verbatim}

\ENDCMD

\DEFCMD{MSE}{String}{MACRO/SYNTAX/Expressions}{String}{}

   \par
Explanation of string expression syntax.  

   \par
String expressions can be used in the macro statements CASE, FOR, and 
   EXITM, in macro variable assignments, as system function arguments where a 
   string value is expected, or as the argument to the \$EVAL function. They 
   may be constructed from the syntactic elements shown below.  

\begin{verbatim}
           string ::= quoted-string
                    | unquoted-string
                    | string // string             (concatenation)
                    | expr // string               (expr represented as string)
                    | [variable-name]
                    | alias-name
                    | $system-function(...)
\end{verbatim}

\ENDCMD

\DEFCMD{MSE}{Garbag}{MACRO/SYNTAX/Expressions}{Garbage}{}

   \par
Explanation of \DQUOTE{}garbage\DQUOTE{} expression syntax.  

   \par
Expressions which do not satisfy any of the other syntax rules we want to 
   call \DQUOTE{}garbage\DQUOTE{} expressions.  For example, 

\begin{verbatim}
           s = $OS$MACHINE
\end{verbatim}
\ENDVERB
   \par
is not a proper string expression. Unless they appear in a macro statement 
   where specifically only an arithmetic or a boolean expression is allowed, 
   KUIP does not complain about these syntax errors. Instead the following 
   transformations are applied:  

\begin{verbatim}
      o  alias substitution
\end{verbatim}
\begin{verbatim}
      o  macro variable replacement; values containing a
         blank character are implicitly quoted
\end{verbatim}
\begin{verbatim}
      o  system function calls are replaced one by one with
         their value provided that the argument is a syntactically
         correct expression
\end{verbatim}
\begin{verbatim}
      o  string concatenation
\end{verbatim}

\ENDCMD
\DEFMENU{2}{Variables}{MACRO/SYNTAX/Variables}
\ifMENUtext
   \par
Explanation of KUIP macro variables.  

   \par
Macro variables do not have to be declared. They become defined by an 
   assignment statement, 

\begin{verbatim}
           name = expression
\end{verbatim}
\ENDVERB
   \par
The right-hand side of the assignment can be an arithmetic expression, a 
   string expression, or a garbage expression (see MACRO/SYNTAX/Expressions). 
   The expression is evaluated and the result is stored as a string (even for 
   arithmetic expressions).  

   \par
A variable value can be used in other expressions or in command lines by 
   enclosing the name in square brackets, [name]. If the name enclosed in 
   brackets is not a macro variable then no substitution takes place.  


\fi

\DEFCMD{MSV}{Number}{MACRO/SYNTAX/Variables}{Numbered}{}

   \par
Accessing macro arguments.  

   \par
The EXEC command can pass arguments to a macro. The arguments are assigned 
   to the numbered variables [1], [2], etc., in the order given in the EXEC 
   command.  The name of the macro, including the file specification, is 
   assigned to [0].  

   \par
A numbered variable cannot be redefined, i.e., an assignment such as 
   \DQUOTE{}1 = foo\DQUOTE{} is illegal.  See MACRO/SYNTAX/SHIFT.  

\ENDCMD

\DEFCMD{MSV}{Specia}{MACRO/SYNTAX/Variables}{Special}{}

   \par
Predefined special macro variables.  

   \par
For each macro the following special variables are always defined:  

\begin{verbatim}
           [0]     Fully qualified name of the macro.
           [#]     Number of macro arguments
           [*]     List of all macro arguments, separated by blanks
           [@@]     EXITM return code of the last macro called by
                   the current one.  The value is "0" if the last
                   macro did not supply a return code or no macro
                   has been called yet.
\end{verbatim}
\ENDVERB
   \par
As for numbered variables these names cannot be used on the left-hand side 
   of an assignment. The values or [\#] and [*] are updated by the SHIFT 
   statement.  

\ENDCMD

\DEFCMD{MSV}{Indire}{MACRO/SYNTAX/Variables}{Indirection}{}

   \par
Referencing a macro variable indirectly.  

   \par
Macro variables can be referenced indirectly. If the variable [name] 
   contains the name of another variable the construct 

\begin{verbatim}
           [%name]
\end{verbatim}
\ENDVERB
   \par
is substituted by that other variable's value.  For example, this is 
   another way to traverse the list of macro arguments:  

\begin{verbatim}
           DO i=1,[#]
             arg = [%i]
             ...
           ENDDO
\end{verbatim}
\ENDVERB
   \par
There is only one level of indirection, i.e., the name contained in 
   \DQUOTE{}name\DQUOTE{} may not start with another \DQUOTE{}\%\DQUOTE{}.  

\ENDCMD

\DEFCMD{MSV}{Global}{MACRO/SYNTAX/Variables}{Global}{}

   \par
Declaring a global variable.  

\begin{verbatim}
           EXTERN name ...
\end{verbatim}
\ENDVERB
   \par
The variable names listed in the EXTERN statement are declared as global 
   variables.  If a name has not been defined with the GLOBAL/CREATE command, 
   it is created implicitly and initialized to the empty string.  The name 
   list may contain wildcards, for example 

\begin{verbatim}
           EXTERN *
\end{verbatim}
\ENDVERB
   \par
makes all defined global variables visible.  

\ENDCMD

\DEFCMD{MSV}{READ}{MACRO/SYNTAX/Variables}{READ}{}

   \par
Reading a variable value from the keyboard.  

\begin{verbatim}
           READ name  [ prompt ]
\end{verbatim}
\ENDVERB
   \par
Variable values can be queried from the user during macro execution. The 
   READ statement prompts for the variable value. If name is already defined 
   the present value will be proposed as default.  

\ENDCMD

\DEFCMD{MSV}{SHIFT}{MACRO/SYNTAX/Variables}{SHIFT}{}

   \par
Manipulation numbered variables.  

   \par
The only possible manipulation of numbered variables is provided by the 
   SHIFT statement which copies [2] into [1], [3] into [2], etc., and discards 
   the value of the last defined numbered variable. For example, the construct 

\begin{verbatim}
           WHILE [1] <> ' ' DO
             arg = [1]
             ...
             SHIFT
           ENDDO
\end{verbatim}
\ENDVERB
   \par
allows to traverse the list of macro arguments.  

\ENDCMD
\DEFMENU{2}{Definitions}{MACRO/SYNTAX/Definitions}
\ifMENUtext
   \par
Statements for defining macros.  


\fi

\DEFCMD{MSD}{MACRO}{MACRO/SYNTAX/Definitions}{MACRO}{}

   \par
Defining a macro.  

   \par
A .kumac file may contain several macros.  An individual macro has the form 

\begin{verbatim}
           MACRO macro-name [ parameter-list ]
              statements
           RETURN
\end{verbatim}
\ENDVERB
   \par
Each statement is either a command line or one of the macro constructs 
   described in this section (MACRO/SYNTAX).  For the first macro in the file 
   the MACRO header can be omitted.  For the last macro in the file the RETURN 
   trailer may be omitted.  Therefore a .kumac file containing only commands 
   (like the LAST.KUMAC) already constitutes a valid macro.  

\ENDCMD

\DEFCMD{MSD}{RETURN}{MACRO/SYNTAX/Definitions}{RETURN}{}

   \par
Ending a macro definition 

\begin{verbatim}
           RETURN [ value ]
\end{verbatim}
   \par
The RETURN statement flags the end of the macro definition and not the end 
   of macro execution, i.e., the construct 

\begin{verbatim}
           IF ... THEN
             RETURN         | error!
           ENDIF
\end{verbatim}
\ENDVERB
   \par
is illegal.  See MACRO/SYNTAX/EXITM.  

   \par
The value is stored into the variable [@@] in the calling macro. If no value 
   is given it defaults to zero.  

\ENDCMD

\DEFCMD{MSD}{EXITM}{MACRO/SYNTAX/Definitions}{EXITM}{}

   \par
Terminate macro execution and return to calling macro.  

\begin{verbatim}
           EXITM [ value ]
\end{verbatim}
\ENDVERB
   \par
In order to return from a macro prematurely the EXITM statement must be 
   used.  The value is stored into the variable [@@] in the calling macro. If 
   no value is given it defaults to zero.  

\ENDCMD

\DEFCMD{MSD}{STOPM}{MACRO/SYNTAX/Definitions}{STOPM}{}

   \par
Terminate macro execution and return to command line prompt.  

\begin{verbatim}
           STOPM
\end{verbatim}
\ENDVERB
   \par
The STOPM statement unwinds nested macro calls and returns to the command 
   line prompt.  

\ENDCMD

\DEFCMD{MSD}{ENDKUM}{MACRO/SYNTAX/Definitions}{ENDKUMAC}{}

   \par
Ignore rest of KUMAC file.  

   \par
A logical \DQUOTE{}end of file\DQUOTE{} marker.  The KUIP parser will not 
   read any part of a .kumac file which appears after the 
   \DQUOTE{}ENDKUMAC\DQUOTE{} command.  

\ENDCMD
\DEFMENU{2}{Branching}{MACRO/SYNTAX/Branching}
\ifMENUtext
   \par
Macro statements for general flow control.  


\fi

\DEFCMD{MSB}{CASE}{MACRO/SYNTAX/Branching}{CASE}{}

   \par
Select one of many branches.  

\begin{verbatim}
           CASE expression IN
           (label)  statement  [ statements ]
           ...
           (label)  statement  [ statements ]
           ENDCASE
\end{verbatim}
\ENDVERB
   \par
The CASE switch evaluates the string expression and compares it one by one 
   against the label lists until the first match is found. If a match is found 
   the statements up to the next label are executed before skipping to the 
   statement following the ENDCASE. None of the statements are executed if 
   there is no match with any label.  

   \par
Each label is a string constant and the comparison witht the selection 
   expression is case-sensitive.  If the same statement sequence should be 
   executed for distinct values a comma-separated list of values can be used.  

   \par
The \DQUOTE{}*\DQUOTE{} character in a label item acts as wildcard matching 
   any string of zero or more characters, i.e., \DQUOTE{}(*)\DQUOTE{} 
   constitutes the default label.  

\ENDCMD

\DEFCMD{MSB}{GOTOan}{MACRO/SYNTAX/Branching}{GOTO\_and\_IF\_GOTO}{}

   \par
Unconditional and conditional branching.  

\begin{verbatim}
           GOTO label
\end{verbatim}
\ENDVERB
   \par
The simplest form of flow control is provided by the GOTO statement which 
   continues execution at the statement following the target 
   \DQUOTE{}label:\DQUOTE{}. If the jump leads into the scope of a block 
   statement, for example a DO-loop, the result is undefined.  

   \par
The target may be given by a variable containing the actual label name.  

\begin{verbatim}
           IF expression GOTO label
\end{verbatim}
\ENDVERB
   \par
This old-fashioned construct is equivalent to 

\begin{verbatim}
           IF expression THEN
              GOTO label
           ENDIF
\end{verbatim}

\ENDCMD

\DEFCMD{MSB}{IFTHEN}{MACRO/SYNTAX/Branching}{IF\_THEN}{}

   \par
Conditional execution of statement blocks.  

\begin{verbatim}
           IF expression THEN
              statements
           ELSEIF expression THEN
              statements
           ...
           ELSEIF expression THEN
              statements
           ELSE
              statements
           ENDIF
\end{verbatim}
\ENDVERB
   \par
The general IF construct executes the statements following the first 
   IF/ELSEIF clause for with the boolean expression is true and then continues 
   at the statement following the ENDIF. The ELSEIF clause can be repeated any 
   number of times or can be omitted altogether. If none of the expressions is 
   true, the statements following the optional ELSE clause are executed.  

\ENDCMD

\DEFCMD{MSB}{ONERRO}{MACRO/SYNTAX/Branching}{ON\_ERROR}{}

   \par
Installing an error handler.  

   \par
Each command returns a status code which should be zero if the operation 
   was successful or non-zero if any kind of error condition occurred.  The 
   status code can be tested by \$IQUEST(1) system function.  

\begin{verbatim}
           ON ERROR GOTO label
\end{verbatim}
\ENDVERB
   \par
installs an error handler which tests the status code after each command 
   and branches to the given label when a non-zero value is found.  The error 
   handler is local to each macro.  

\begin{verbatim}
           ON ERROR EXITM  [ expression ]
\end{verbatim}
   \par
and 
\begin{verbatim}
           ON ERROR STOPM
\end{verbatim}
\ENDVERB
   \par
are short-hand notations for a corresponding EXITM or STOPM statement at 
   the targat label.  

\begin{verbatim}
           ON ERROR CONTINUE
\end{verbatim}
\ENDVERB
   \par
continues execution with the next command independent of the status code.  
   This is the initial setting when entering a macro.  

\begin{verbatim}
           OFF ERROR
\end{verbatim}
\ENDVERB
   \par
An error handler can be deactivated by this statement.  

\begin{verbatim}
           ON ERROR
\end{verbatim}
\ENDVERB
   \par
An error handler can be reactivated by this statement.  

\ENDCMD
\DEFMENU{2}{Looping}{MACRO/SYNTAX/Looping}
\ifMENUtext
   \par
Macro statements for construction loops.  


\fi

\DEFCMD{MSL}{DO}{MACRO/SYNTAX/Looping}{DO}{}

   \par
Loop incrementing a loop counter.  

\begin{verbatim}
           DO loop = start_expr, finish_expr  [, step_expr ]
              statements
           ENDDO
\end{verbatim}
\ENDVERB
   \par
The step size (setp\_expr) defaults to \DQUOTE{}1\DQUOTE{}. The arithmetic 
   expressions involved can be floating point values but care must be taken of 
   rounding errors.  

   \par
Note that \DQUOTE{}DO i=1,0\DQUOTE{} results in zero iterations and that 
   the expressions are evaluated only once.  

\ENDCMD

\DEFCMD{MSL}{FOR}{MACRO/SYNTAX/Looping}{FOR}{}

   \par
Loop over items in an expression list.  

\begin{verbatim}
           FOR name IN expr_1 [ expr_2 ... expr_n ]
              statements
           ENDFOR
\end{verbatim}
\ENDVERB
   \par
In a FOR-loop the number of iterations is determined by the number of items 
   in the blank-separated expression list. The expression list must not be 
   empty. One by one each expression evaluated and assigned to the variable 
   name before the statements are executed.  

   \par
The expressions can be of any type: arithmetic, string, or garbage 
   expressions, and they do not need to be all of the same type. In general 
   each expression is a single list item even if the result contains blanks.  

   \par
The variable [*] is treated as a special case being equivalent to the 
   expression list \DQUOTE{}[1] [2] ... [n]\DQUOTE{} which allows yet another 
   construct to traverse the macro arguments:  

\begin{verbatim}
           FOR arg IN [*]
              ...
           ENDFOR
\end{verbatim}

\ENDCMD

\DEFCMD{MSL}{REPEAT}{MACRO/SYNTAX/Looping}{REPEAT}{}

   \par
Loop until condition becomes true.  

\begin{verbatim}
           REPEAT
              statements
           UNTIL expression
\end{verbatim}
\ENDVERB
   \par
The body of a REPEAT-loop is executed at least once and iterated until the 
   boolean expression evaluates to true.  

\ENDCMD

\DEFCMD{MSL}{WHILE}{MACRO/SYNTAX/Looping}{WHILE}{}

   \par
Loop while condition is true.  

\begin{verbatim}
           WHILE expression DO
              statements
           ENDWHILE
\end{verbatim}
\ENDVERB
   \par
The WHILE-loop is iterated while the boolean expression evaluates to true. 
   The loop body is not executed at all if the boolean expression is false 
   already in the beginning.  

\ENDCMD

\DEFCMD{MSL}{BREAKL}{MACRO/SYNTAX/Looping}{BREAKL}{}

   \par
Terminate a loop.  

\begin{verbatim}
           BREAKL [ level ]
\end{verbatim}
\ENDVERB
   \par
Allows to terminate a loop prematurely. The BREAKL continues executing 
   after the end clause of a DO, FOR, WHILE, or REPEAT block, where 
   \DQUOTE{}level\DQUOTE{} indicates how many nested constructs to terminate.  
   The default value level=1 terminates the innermost loop construct.  

\ENDCMD

\DEFCMD{MSL}{NEXTL}{MACRO/SYNTAX/Looping}{NEXTL}{}

   \par
Continue with next loop iteration.  

\begin{verbatim}
           NEXTL [ level ]
\end{verbatim}
\ENDVERB
   \par
Allows to continue with the next loop iteration without executing the rest 
   of the loop body.  Execution continues just before the end clause of a DO, 
   FOR, WHILE, or REPEAT block, where \DQUOTE{}level\DQUOTE{} indicates how 
   many nested blocks to skip.  The default value level=1 skips to the end of 
   the innermost loop construct.  

\ENDCMD
\DEFMENU{0}{VECTOR}{VECTOR}
\ifMENUtext
   \par
Vector Processor commands.  Vectors are equivalent to FORTRAN 77 arrays and 
   they use the same notation except when omitting indexes (see last line 
   below).  Up to 3 dimensions are supported. Examples:  
\begin{verbatim}
    Vec(20) (mono-dimensional with 20 elements)
\end{verbatim}
   \par
may be addressed by:  
\begin{verbatim}
    Vec          for all elements
    Vec(13)      for element 13-th
    Vec(12:)     for elements 12-th to last
    Vec(:10)     for elements first to 10-th
    Vec(5:8)     for elements 5-th to 8-th
\end{verbatim}
\begin{verbatim}
    Vec(3,100) (2-dimensional with 3 columns by 100 rows):
\end{verbatim}
   \par
may be addressed by:  
\begin{verbatim}
    Vec(2,5:8)   for elements 5-th to 8-th in 2-nd column
    Vec(2:3,5:8) for elements 5-th to 8-th in 2-nd to 3-rd columns
    Vec(2,5)     for element 5-th in 2-nd column
    Vec(:,3)     for all elements in 3-rd row
    Vec(2)       for all elements in 2-nd column (SPECIAL CASE)
\end{verbatim}
   \par
The latest line shows the special (and non-standard with FORTRAN 77) 
   notation such that missing indexes are substituted to the right.  

   \par
An 'invisible' vector called '?', mono-dimensional and of length 100, is 
   always present. Is is used for communicating between user arrays and KUIP 
   vectors, being equivalenced with the real array VECTOR(100) in the labeled 
   common block /KCWORK/.  


\fi

\DEFCMD{V}{CREATE}{VECTOR}{CREATE}{ vname [ type values ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name(length)}{}
\DEFARG{TYPE}{C}{Vector type}{ D='R'}
\DEFARG{VALUES}{C}{Value list}{ D=\EMPTY{} Separate Vararg}
\ENDARG
\BEGOPT{TYPE}
\DEFOPT{R}{}
\DEFOPT{I}{}
\ENDOPT

   \par
Create a vector named VNAME (elements are set to zero).  The dimensions are 
   taken from the name, for example VEC(20), VEC(3,100), VEC(2,2,10).  Up to 3 
   dimensions are supported. Dimensions which are not specified are taken to 
   1, for example VEC(10) ---\KET{} VEC(10,1,1) and VEC ---\KET{} VEC(1,1,1).  
   The vector may be of type Real or Integer.  A vector is filled at the same 
   time if parameters are given after the TYPE:  
\begin{verbatim}
    VEC/CREATE V(10) R 1 2 3 4 5 66 77 88 99 111
    VEC/CREATE W(20) R 1 2 3
\end{verbatim}
   \par
In the last example only the first three elements are filled.  Vector 
   elements may be changed later with the command VECTOR/INPUT.  

   \par
If many equal values have to be entered consecutively, one can specify just 
   one value and precede it by a repetition factor and an asterisk. Example:  
\begin{verbatim}
    VEC/CREATE Z(20) R 5*1 2 4*3   --->   VEC/CREATE Z(20) R 1 1 1 1 1 2 3 3 3 
   3
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{LIST}{VECTOR}{LIST}{}

   \par
List all vectors (name, dimensions, type).  

\ENDCMD

\DEFCMD{V}{DELETE}{VECTOR}{DELETE}{ vlist}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Delete from memory all vectors in the list VLIST.  The vectors are 
   separated in the list by a comma and embedded blanks are not allowed. An 
   asterisk at the end of VLIST acts as wild-card:  
\begin{verbatim}
    VEC/DEL AB*          --->  deletes all vectors starting by AB
    VEC/DEL *            --->  deletes all vectors
\end{verbatim}

\ENDCMD

\DEFCMD{V}{COPY}{VECTOR}{COPY}{ vnam1 vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
Copy a vector into another one.  Mixed vector type copy is supported (e.g. 
   Integer ---\KET{} Real and viceversa).  If VNAM2 does not exist it is 
   created with the required dimensions, not necessarily the same as the 
   source vector if a sub-range was specified.  For example, if A is a 3 x 100 
   vector and B does not exist, COPY A(2,11:60) B will create B as a 50 
   elements mono-dimensional vector; a special (and non-standard with FORTRAN 
   77) notation is used such that, still using the above vectors, COPY 
   A(2,1:100) B and COPY A(2) B have the same effect.  

   \par
Note that VECTOR/COPY does not allow a range for the destination vector not 
   specifying consecutive elements (i.e. along the first dimension):  
\begin{verbatim}
    VEC/COPY V(5)      W(3,4)     | O.K.
    VEC/COPY V1(2:3,5) V2(4:5,9)  | O.K.
    VEC/COPY V1(5,2:3) V2(4:5,9)  | O.K.
    VEC/COPY V1(3,3:4) V2(4,4:5)  | NOT allowed
    VEC/COPY V1(2:3,5) V2(2,4:5)  | NOT allowed
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{INPUT}{VECTOR}{INPUT}{ vname [ values ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{VALUES}{C}{Value list}{ D=\EMPTY{} Separate Vararg}
\ENDARG

   \par
Enter values into a vector from the terminal.  Example:  
\begin{verbatim}
    VEC/INPUT V(6:10) 1.1 2.22 3.333 4.4444 5.55555
\end{verbatim}
   \par
If many equal values have to be entered consecutively, one can specify just 
   one value and precede it by a repetition factor and an asterisk. Example:  
\begin{verbatim}
    VEC/INPUT V 5*1 2 4*3   --->   VEC/INPUT V 1 1 1 1 1 2 3 3 3 3
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{PRINT}{VECTOR}{PRINT}{ vname [ dense ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{DENSE}{I}{Output density}{ D=1 R=0,1,2}
\ENDARG

   \par
Write to the terminal the content of a vector.  Enter HELP VECTOR for more 
   information on vector addressing.  

   \par
If DENSE.EQ.0 the output is one vector element per line.  If DENSE.EQ.1 the 
   output for a sequence of identical vector elements is compressed to two 
   lines stating the start and end indices.  If DENSE.EQ.2 the output for a 
   sequence of identical vector elements is compressed to a single line.  

\ENDCMD

\DEFCMD{V}{READ}{VECTOR}{READ}{ vlist fname [ format opt match ]}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Format}{ D=\EMPTY{}}
\DEFARG{OPT}{C}{Options}{ D='OC'}
\DEFARG{MATCH}{C}{Matching pattern}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPT}
\DEFOPT{OC}{}
\DEFOPT{O}{}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{}
\ENDOPT

   \par
Enter values into vector(s) from a file.  A format can be specified, e.g. 
   FORMAT='F10.5,2X,F10.5', or the free format is used if FORMAT is not 
   supplied.  

   \par
If vector(s) are not existing they will be created of the size as read from 
   the file.  

   \par
Vectors in the list VLIST are separated by a comma and embedded blanks are 
   not allowed. If subscripts are present in vector names, the smallest one is 
   taken.  

   \par
OPT is used to select between the following options:  
\begin{verbatim}
    'OC'   file is Opened, read and then Closed (default case)
    'O'    file is Opened and then read (left open for further reading)
    ' '    file is read (already open, left so for further reading)
    'C'    file is read and then Closed (already open)
\end{verbatim}
   \par
If the character 'Z' is present in OPT, the vector elements equal to zero 
   after reading are set to the latest non-zero element value (for example 
   reading 1 2 3 0 0 4 0 5 will give 1 2 3 3 3 4 4 5).  

   \par
MATCH is used to specify a pattern string, restricting the vector filling 
   only to the records in the file which verify the pattern. Example of 
   patterns:  
\begin{verbatim}
     /string/      match a string (starting in column 1)
    -/string/      do not match a string (starting in column 1)
     /string/(n)   match a string, starting in column n
     /string/(*)   match a string, starting at any column
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{WRITE}{VECTOR}{WRITE}{ vlist [ fname format chopt ]}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Format}{ D='5(1X,G13.7)'}
\DEFARG{CHOPT}{C}{Options}{ D='OC'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{OC}{}
\DEFOPT{O}{}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{}
\ENDOPT

   \par
Write to a file the content of vector(s).  If FNAME=' ' the content is 
   written to the terminal.  A format can be specified, e.g. 
   FORMAT='F10.5,2X,F10.5', or the default one is used if FORMAT is not 
   supplied.  

   \par
Vectors in the list VLIST are separated by a comma and embedded blanks are 
   not allowed. If subscripts are present in vector names, the smallest one is 
   taken.  

   \par
CHOPT is used to select between the following options:  
\begin{verbatim}
    'OC'   file is Opened, written and then Closed (default case)
    'O'    file is Opened and then written (left open for further writing)
    ' '    file is written (already open, left so for further writing)
    'C'    file is written and then Closed (already open)
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{DRAW}{VECTOR}{DRAW}{ vname [ id chopt ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{ID}{C}{Histogram Identifier}{ D='12345'}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw an histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Draw vector VNAME interpreting it as a histogram.  Optionally save the 
   contents in histogram ID.  

\ENDCMD

\DEFCMD{V}{HFILL}{VECTOR}{HFILL}{ vname id}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{ID}{C}{Histogram Identifier}{}
\ENDARG

   \par
Fill the existing histogram ID with vector VNAME.  Note that the command 
   VECTOR/PLOT can automatically book, fill and plot the contents of a vector. 

\ENDCMD

\DEFCMD{V}{PLOT}{VECTOR}{PLOT}{ vname [ id chopt ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{ID}{C}{Histogram Identifier}{ D='12345'}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw an histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Each element of VNAME is used to fill an histogram which is automatically 
   booked with 100 channels and then plotted.  If VNAME has the form 
   VNAME1\%VNAME2 then a scatter-plot of vector VNAME1 versus VNAME2 is 
   plotted. If ID is given different of 12345, then a 2-Dim histogram is 
   created with 40 bins by 40 bins and filled.  One can use the command 
   VECTOR/HFILL to fill an already existing histogram.  

\ENDCMD

\DEFCMD{V}{FIT}{VECTOR}{FIT}{ x y ey func [ chopt np par step pmin pmax errpar ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{EY}{C}{Vector of errors on Y}{ D='?'}
\DEFARG{FUNC}{C}{Function name}{}
\DEFARG{CHOPT}{C}{Character options}{ D=\EMPTY{}}
\DEFARG{NP}{I}{Number of parameters}{ D=0 R=0:20}
\DEFARG{PAR}{C}{Vector of parameters}{}
\DEFARG{STEP}{C}{Vector of steps size}{}
\DEFARG{PMIN}{C}{Vector of lower bounds}{}
\DEFARG{PMAX}{C}{Vector of upper bounds}{}
\DEFARG{ERRPAR}{C}{Vector of errors on parameters}{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Do the fit, plot the result and print the parameters.
}
\DEFOPT{0}{\par
Do not plot the result of the fit. By default the fitted function is drawn 
unless the option 'N' below is specified.
}
\DEFOPT{N}{\par
Do not store the result of the fit bin by bin with the histogram. By default 
the function is calculated at the middle of each bin and the fit results 
stored with the histogram data structure.
}
\DEFOPT{Q}{\par
Quiet mode. No print
}
\DEFOPT{V}{\par
Verbose mode. Results after each iteration are printed By default only final 
results are printed.
}
\DEFOPT{B}{\par
Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be 
specified. Default is: All parameters vary freely.
}
\DEFOPT{L}{\par
Use Log Likelihood. Default is chisquare method.
}
\DEFOPT{D}{\par
The user is assumed to compute derivatives analytically using the routine 
HDERIV. By default, derivatives are computed numerically.
}
\DEFOPT{W}{\par
Sets weights equal to 1. Default weights taken from the square root of the 
contents or from HPAKE/HBARX (PUT/ERRORS).
}
\DEFOPT{M}{\par
The interactive Minuit is invoked.
}
\DEFOPT{E}{\par
Performs a better Error evaluation (MIGRAD + HESSE + MINOS).
}
\DEFOPT{Z}{\par
FUNC is the user fitting model
}
\ENDOPT

   \par
Fit a user defined function to the points defined by the two vectors X and 
   Y and the vector of associated errors EY.  See command Histo/Fit for 
   explanation of parameters.  Note that if option 'W' is specified or EY='?' 
   (default), the array EY is ignored. Option 'L' is not available.  
\begin{verbatim}
     When option 'Z' is given, FUNC is the user fitting model.
     FUNC is a subroutine with the calling sequence:
         Subroutine FUNC(N,X,Y,EY,NPAR,IFLAG,NPFITS)
     where
         - X(N),Y(N),EY(N) are the input vectors,
         - NPAR the number of parameters
         - NPFITS is an output parameter = Number of points used in the fit
     The user must declare the common/HCFITD/FITPAD(24),FITFUN in FUNC
\end{verbatim}

\ENDCMD
\DEFMENU{1}{OPERATIONS}{VECTOR/OPERATIONS}
\ifMENUtext
   \par
Simple arithmetic operations between vectors.  In all the operations only 
   the minimum vector length is considered, i.e. an operation between a vector 
   A of dimension 10 and a vector B of dimension 5 will involve the first 5 
   elements in both vectors.  If the destination vector does not exist, it is 
   created with the same length as the source vector.  


\fi

\DEFCMD{VO}{VBIAS}{VECTOR/OPERATIONS}{VBIAS}{ vnam1 bias vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{BIAS}{R}{Bias value}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM2(I) = BIAS     + VNAM1(I) 

\ENDCMD

\DEFCMD{VO}{VSCALE}{VECTOR/OPERATIONS}{VSCALE}{ vnam1 scale vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{SCALE}{R}{Scale factor}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM2(I) = SCALE    * VNAM1(I) 

\ENDCMD

\DEFCMD{VO}{VADD}{VECTOR/OPERATIONS}{VADD}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) + VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VMULTI}{VECTOR/OPERATIONS}{VMULTIPLY}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) * VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VSUBTR}{VECTOR/OPERATIONS}{VSUBTRACT}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) - VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VDIVID}{VECTOR/OPERATIONS}{VDIVIDE}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) / VNAM2(I)     ( or 0 if VNAM2(I)=0 ) 

\ENDCMD
\DEFMENU{0}{HISTOGRAM}{HISTOGRAM}
\ifMENUtext
   \par
Manipulation of histograms, Ntuples.  Interface to the HBOOK package.  


\fi

\DEFCMD{H}{FILE}{HISTOGRAM}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=0:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in words}{ D=1024}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Existing file is opened (read mode only).
}
\DEFOPT{N}{\par
A new file is opened.
}
\DEFOPT{U}{\par
Existing file is opened to be modified.
}
\DEFOPT{D}{\par
Reset lock.
}
\ENDOPT

   \par
Open an HBOOK direct access file.  If LUN is 0 the next free logical unit 
   will be used.  If LRECL is 0 the system will determine the correct record 
   length of an existing file.  

\ENDCMD

\DEFCMD{H}{LIST}{HISTOGRAM}{LIST}{ [ chopt ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
List histograms and Ntuples in the current directory.
}
\DEFOPT{I}{\par
A verbose format is used (HINDEX), (only for //PAWC).
}
\DEFOPT{S}{\par
List with histograms sorted by increasing IDs.
}
\ENDOPT

   \par
List histograms and Ntuples in the current directory.  

\ENDCMD

\DEFCMD{H}{DELETE}{HISTOGRAM}{DELETE}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Delete histogram/Ntuple ID in Current Directory (memory).  If ID=0 delete 
   all histograms and Ntuples.  To delete histograms in disk files use command 
   HIO/HSCRATCH.  

\ENDCMD

\DEFCMD{H}{PLOT}{HISTOGRAM}{PLOT}{ [ id chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop Minus}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{} Minus}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw the histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{-}{\par
Substract contents of ID to last plotted histogram.
}
\DEFOPT{+-}{\par
Draw the delta with the last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel or cell.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\DEFOPT{K}{\par
Must be given if option 'U' is given later.
}
\DEFOPT{U}{\par
Update channels modified since last call.
}
\DEFOPT{E}{\par
Draw error bars and current marker.
}
\DEFOPT{E0}{\par
Draw error bars without symbols clipping.
}
\DEFOPT{E1}{\par
Draw small lines at the end of the error bars.
}
\DEFOPT{E2}{\par
Draw error rectangles.
}
\DEFOPT{E3}{\par
Draw a filled area through the end points of the vertical error bars.
}
\DEFOPT{E4}{\par
Draw a smoothed filled area through the end points of the vertical error bars.
}
\DEFOPT{A}{\par
Axis labels and tick marks are not drawn.
}
\DEFOPT{BOX}{\par
Draw 2-Dim with proportional boxes.
}
\DEFOPT{COL}{\par
Draw 2-Dim with a color table.
}
\DEFOPT{Z}{\par
Used with COL or SURF, it draws the color map.
}
\DEFOPT{SURF}{\par
Draw as a surface plot (angles are set via the command angle).
}
\DEFOPT{SURF1}{\par
Draw as a surface with color levels
}
\DEFOPT{SURF2}{\par
Same as SURF1 but without cell lines.
}
\DEFOPT{SURF3}{\par
Same as SURF but with the contour plot (in color) on top.
}
\DEFOPT{SURF4}{\par
Draw as a surface with Gouraud shading.
}
\DEFOPT{LEGO}{\par
Draw as a lego plot (angles are set via the command angle).
}
\DEFOPT{LEGO1}{\par
Draw lego plot with light simulation.
}
\DEFOPT{LEGO2}{\par
Draw lego plot with color levels.
}
\DEFOPT{BB}{\par
Suppress the Back Box on 3D plots.
}
\DEFOPT{FB}{\par
Suppress the Front Box on 3D plots.
}
\DEFOPT{CONT}{\par
Draw 2-Dim as a contour plot (15 levels).
}
\DEFOPT{TEXT}{\par
Draw 2-Dim as a table.
}
\DEFOPT{CHAR}{\par
Draw 2-Dim with characters (a la HBOOK).
}
\DEFOPT{HIST}{\par
Draw only histogram (no errors or associated function).
}
\DEFOPT{FUNC}{\par
Draw only the associated function (not the histogram).
}
\DEFOPT{CYL}{\par
Cylindrical coordinates for 3D plots.
}
\DEFOPT{POL}{\par
Polar coordinates for 3D plots.
}
\DEFOPT{SPH}{\par
Spherical coordinates for 3D plots.
}
\DEFOPT{PSD}{\par
Pseudo-rapidity/phi coordinates for 3D plots.
}
\ENDOPT

   \par
Plot a single histogram or a 2-Dim projection.  If ID=0 or ID=* all the 
   histograms in the current directory are plotted.  Each plotted histogram 
   will start either a new picture or a new zone in the current picture.  
\begin{verbatim}
    Histogram subranges can be specified in 2 different ways:
     1- h/pl id(ic1:ic2) with ic1 and ic2 integers means plot
                         from channel ic1 to channel ic2
     2- h/pl id(x1:x2)   with x1 and x2 reals (with a .) means plot
                         from channel corresponding to x1
     Note that the mixed mode h/pl id(x1:ic2) is also accepted
     This subrange works also for 2-DIM cases.
     Ex: Histo/plot 10(25:1.) or Histo/plot 20(4:18,0.:0.5).
\end{verbatim}
   \par
A specific histogram cycle can be accessed:  
\begin{verbatim}
     PAW > h/pl id;nc | cycle number nc is used (default is highest cycle)
\end{verbatim}
   \par
1 Dim histograms could be plotted with option LEGO or SURF.  In this case 
   the angles are THETA=1 and PHI=-1.  

   \par
When option 'E' is used, the marker type can be changed with SET MTYP, the 
   marker size with SET KSIZ, the marker color with SET PMCI.  

   \par
With Option E1, the size of the tick marks at the end of the error bars is 
   equal to the marker size and can be changed with SET KSIZ.  

   \par
When the option E is used with the option SURF1, SURF2, SURF3 or LEGO1, the 
   colors are mapped on the errors not on the content of the histogram.  

\begin{verbatim}
    To plot projection X of ID type
      PAW > HI/PLOT ID.PROX
    To plot band 1 in Y of ID type
      PAW > HI/PLOT ID.BANY.1
    To plot slice 3 in Y of ID type
      PAW > HI/PLOT ID.SLIY.3
\end{verbatim}
\ENDVERB
   \par
In addition to the Cartesian coordinate systems, Polar, cylindrical, 
   spherical, pseudo-rapidity/phi coordinates are available for LEGO and 
   SURFACE plots, including stacked lego plots.  For example:  
\begin{verbatim}
         PAW > Histo/plot 10+20+30  LEGO1,CYL | stacked cylindrical lego plot
         PAW > Histo/plot 10+20+30  LEGO1,POL |         polar
         PAW > Histo/plot 10+20+30  LEGO1,SPH |         spherical
         PAW > Histo/plot 10+20+30  LEGO1,PSD |         pseudo-rapidity/phi
\end{verbatim}
   \par
Note that the viewing angles may be changed via the command ANGLES.  The 
   axis, the front box, and the back box can be suppressed on 3D plots with 
   the options 'A', 'FB' and 'BB'.  

\ENDCMD

\DEFCMD{H}{ZOOM}{HISTOGRAM}{ZOOM}{ [ id chopt icmin icmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop Minus}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{ICMIN}{I}{First channel}{ D=1}
\DEFARG{ICMAX}{I}{Last channel}{ D=9999}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Plot the zoomed histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Plot a single histogram between channels ICMIN and ICMAX.  Each plotted 
   histogram will start either a new picture or a new zone in the current 
   picture.  If no parameters are given to the command, then the system waits 
   for two points using the graphics cursor.  To quit ZOOM, click the right 
   button of the mouse or CRTL/E.  

\ENDCMD

\DEFCMD{H}{MANYPL}{HISTOGRAM}{MANY\_PLOTS}{ idlist}

\BEGARG
\DEFARG{IDLIST}{C}{List of histogram Identifiers}{ Vararg}
\ENDARG

   \par
Plot one or several histograms into the same plot.  Plotted histograms are 
   superimposed on the same zone of the picture.  

\ENDCMD

\DEFCMD{H}{PROJEC}{HISTOGRAM}{PROJECT}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Fill all booked projections of a 2-Dim histogram.  Filling is done using 
   the 2-D contents of ID.  

\ENDCMD

\DEFCMD{H}{COPY}{HISTOGRAM}{COPY}{ id1 id2 [ title ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{New title}{ D=\EMPTY{}}
\ENDARG

   \par
Copy a histogram onto another one.  Bin definition, contents, errors, etc. 
   are preserved.  If TITLE is not given, ID2 has the same title as ID1.  

   \par
It is possible to copy a projection of a 2D histogram into a 1D histogram.  

   \par
Ranges can be specify in the first histogram identifier to reduce or 
   enlarge the X or Y scale.  

   \par
Example:  
\begin{verbatim}
       Fun2 2 x*y 40 0 1 40 0 1 ' '  | Create a 2D histogram
       Slix 2 10 ; H/proj 2          | Slices on X
       H/Copy 2.slix.3 3             | Copy the slice 3
       H/Copy 2(0.:.5,-1.:2.) 4      | Copy with new X and Y scales
\end{verbatim}

\ENDCMD

\DEFCBIG{H}{FIT}{HISTOGRAM}{FIT}{ id func [ chopt np par step pmin pmax errpar ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FUNC}{C}{Function name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NP}{I}{Number of parameters}{ D=0 R=0:34}
\DEFARG{PAR}{C}{Vector of parameters}{}
\DEFARG{STEP}{C}{Vector of steps size}{}
\DEFARG{PMIN}{C}{Vector of lower bounds}{}
\DEFARG{PMAX}{C}{Vector of upper bounds}{}
\DEFARG{ERRPAR}{C}{Vector of errors on parameters}{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Do the fit, plot the result and print the parameters.
}
\DEFOPT{0}{\par
Do not plot the result of the fit. By default the fitted function is drawn 
unless the option 'N' below is specified.
}
\DEFOPT{N}{\par
Do not store the result of the fit bin by bin with the histogram. By default 
the function is calculated at the middle of each bin and the fit results 
stored with the histogram data structure.
}
\DEFOPT{Q}{\par
Quiet mode. No print
}
\DEFOPT{V}{\par
Verbose mode. Results after each iteration are printed By default only final 
results are printed.
}
\DEFOPT{B}{\par
Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be 
specified. Default is: All parameters vary freely.
}
\DEFOPT{L}{\par
Use Log Likelihood. Default is chisquare method.
}
\DEFOPT{D}{\par
The user is assumed to compute derivatives analytically using the routine 
HDERIV. By default, derivatives are computed numerically.
}
\DEFOPT{W}{\par
Sets weights equal to 1. Default weights taken from the square root of the 
contents or from HPAKE/HBARX (PUT/ERRORS). If the L option is given (Log 
Likelihood), bins with errors=0 are excluded of the fit.
}
\DEFOPT{M}{\par
The interactive Minuit is invoked. (see Application HMINUIT below).
}
\DEFOPT{E}{\par
Performs a better Error evaluation (MIGRAD + HESSE + MINOS).
}
\DEFOPT{U}{\par
User function value is taken from /HCFITD/FITPAD(24),FITFUN.
}
\DEFOPT{K}{\par
Keep the settings of Application HMINUIT for a subsequent command.
}
\ENDOPT

   \par
Fit a user defined (and parameter dependent) function to a histogram ID 
   (1-Dim or 2-Dim) in the specified range.  FUNC may be:  
\begin{verbatim}
    A- The name of a file which contains the user defined
       function to be minimized. Function name and file name
       must be the same. For example file FUNC.FOR is:
         FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram
         COMMON/PAWPAR/PAR(2)
         FUNC=PAR(1)*X +PAR(2)*EXP(-X)
         END
        Ex: His/fit 10 func.for ! 5 par
\end{verbatim}
\begin{verbatim}
       When the option U is given, the file FUNC.FOR should look like:
         FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram
         DOUBLE PRECISION FITPAD(24),FITFUN
         COMMON/HCFITD/FITPAD,FITFUN
         FITFUN=FITPAD(1)*X +FITPAD(2)*EXP(-X)
         FUNC=FITFUN
         END
\end{verbatim}
\begin{verbatim}
    B- One of the following keywords (1-Dim only):
       G : to fit Func=par(1)*exp(-0.5*((x-par(2))/par(3))**2)
       E : to fit Func=exp(par(1)+par(2)*x)
       Pn: to fit Func=par(1)+par(2)*x+par(3)*x**2......+par(n+1)*x**n
        Ex: His/fit 10 g
\end{verbatim}
\begin{verbatim}
    C- A combination of the keywords in B with the 2 operators + or *.
       Ex: His/Fit 10 p4+g ! 8 par
           His/Fit 10 p2*g+g ! 9 par
         Note that in this case, the order of parameters in PAR must
         correspond to the order of the basic functions.
         For example, in the first case above, par(1:5) apply to
         the polynomial of degree 4 and par(6:8) to the gaussian while
         in the second case par(1:3) apply to the polynomial of degree 2,
         par(4:6) to the first gaussian and par(7:9) to the second gaussian.
         Blanks are not allowed in the expression.
\end{verbatim}
   \par
For cases A and C, before the execution of this command, the vector PAR 
   must be filled (via Vector/Input) with the initial values.  For case B, if 
   NP is set to 0, then the initial values of PAR will be calculated 
   automatically.  After the fit, the vector PAR contains the new values of 
   parameters. If the vector ERRPAR is given, it will contain the errors on 
   the fitted parameters.  A bin range may be specified with ID.  
\begin{verbatim}
     Ex. Histo/Fit 10(25:56).
\end{verbatim}
\ENDVERB
   \par
When the Histo/it command is used in a macro, it might be convenient to 
   specify MINUIT directives in the macro itself via the Application HMINUIT 
   as described in this example:  
\begin{verbatim}
        Macro fit
        Application HMINUIT exit
        name 1 par_name1
        name 2 par_name2
        migrad
        improve
        exit
        Histo/fit id fitfun.f M
        Return
\end{verbatim}

\ENDCBIG
\DEFMENU{1}{2D\_PLOT}{HISTOGRAM/2D\_PLOT}
\ifMENUtext
   \par
Plotting of 2-Dim histograms in various formats.  


\fi

\DEFCMD{H2}{LEGO}{HISTOGRAM/2D\_PLOT}{LEGO}{ [ id theta phi chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{THETA}{R}{Angle THETA in degrees}{ D=30.}
\DEFARG{PHI}{R}{Angle PHI in degrees}{ D=30.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Hidden line algorithm is used.
}
\DEFOPT{1}{\par
Hidden surface algorithm is used. The colour of the lego is given by SET HCOL 
CI where CI is a colour index. For the top and the sides of the lego the same 
hue is used but with a different light.
}
\DEFOPT{2}{\par
Hidden surface algorithm is used. The colour of each bar changes according to 
the value of Z. It is possible to change the set of colours used with SET HCOL 
c.L where L define a palette of colours given by the command ATT/PALETTE.
}
\ENDOPT

   \par
Draw a lego plot from 2-Dim or 1-Dim histograms.  It is also possible to 
   produce stacked lego plots. A stacked lego plot consists of a 
   superimposition of several histograms, whose identifiers are given in the 
   command LEGO separated by the character \DQUOTE{}+\DQUOTE{}.  
\begin{verbatim}
    PAW > LEGO ID1+ID2+ID3    | Maximum number of ID's is 10. The colours of
                              | each IDn is given by the command ATT/PALETTE
\end{verbatim}
   \par
Examples:  
\begin{verbatim}
    PAW > SET HCOL 2          | The colour the histogram is 2 (red)
    PAW > LEGO 20             | Display a lego with lines
    PAW > LEGO 20 ! ! 1       | Display a lego with different lights
    PAW > LEGO 20 ! ! 2       | Display a lego with colours
    PAW > PALETTE  1 3 2 3 4  | Create the palette number 1 with 3
                              | elements: 2,3
    PAW > SET HCOL 0.1        | The subsequent stack lego plots will use list 1
    PAW > LEGO 10+20+30       | Plot a stack of lego plots with lines
    PAW > LEGO 10+20+30 ! ! 1 | Plot a stack of lego plots with light
\end{verbatim}
   \par
Notes: - The commands OPTION BAR, SET BARW and SET BARO act on lego plots 
\begin{verbatim}
          - The options 1 and 2 must be used only on selective erase
            devices.
\end{verbatim}

\ENDCMD

\DEFCMD{H2}{SURFAC}{HISTOGRAM/2D\_PLOT}{SURFACE}{ [ id theta phi chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{THETA}{R}{Angle THETA in degrees}{ D=30.}
\DEFARG{PHI}{R}{Angle PHI in degrees}{ D=30.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Hidden line algorithm is used.
}
\DEFOPT{1}{\par
Hidden surface algorithm is used and each cell is filled with a colour 
corresponding to the Z value (or grey scale with PostScript). It is possible 
to change the set of colours used with SET HCOL ic.L where L define a palette 
of colours given by the command ATT/PALETTE.
}
\DEFOPT{2}{\par
Similar to option '1' except that the cell lines are not drawn. This is very 
useful to draw contour plots with colours if THETA=90 and PHI=0.
}
\DEFOPT{3}{\par
Surface is drawn with a contour plot in color on top. The contour plot is 
drawn with the colors defined with the command PALETTE.
}
\DEFOPT{4}{\par
Surface is drawn with Gouraud shading.
}
\ENDOPT

   \par
Draw a surface plot from 2-Dim or 1-Dim histograms.  With this command it 
   is possible to draw color contour plots:  
\begin{verbatim}
       PAW > ATT/PAL 1 3 2 3 4   | Define the palette 1 with 3 elements
       PAW > SET HCOL 0.1        | Set the list 1 as colours for histograms
       PAW > SET NDVZ 4          | Set the number of Z divisions to 4
       PAW > SURF id 90 0 2      | Draw the contour
\end{verbatim}
\ENDVERB
   \par
Note: - The options 1 to 4 must be used only on selective erase devices.  

\ENDCMD

\DEFCMD{H2}{CONTOU}{HISTOGRAM/2D\_PLOT}{CONTOUR}{ [ id nlevel chopt param ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{NLEVEL}{I}{Number of contour lines}{ D=10}
\DEFARG{CHOPT}{C}{Options}{ D='1'}
\DEFARG{PARAM}{C}{Vector of contour levels}{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{0}{\par
Use colour to distinguish contours.
}
\DEFOPT{1}{\par
Use line style to distinguish contours.
}
\DEFOPT{2}{\par
Line style and colour are the same for all contours.
}
\DEFOPT{3}{\par
The contour is drawn with filled colour levels. The levels are equidistant. 
The color indices are taken in the current palette (defined with the command 
PALETTE). If the number of levels (NLEVEL) is greater than the number of 
entries in the current palette, the palette is explore again from the 
beginning in order to reach NLEVEL.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\ENDOPT

   \par
Draw a contour plot from a 2-Dim histogram.  If PARAM is not given, contour 
   levels are equidistant.  If given, the vector PARAM may contain up to 50 
   values.  

\ENDCMD
\DEFMENU{1}{CREATE}{HISTOGRAM/CREATE}
\ifMENUtext
   \par
Creation (\DQUOTE{}booking\DQUOTE{}) of HBOOK objects in memory.  


\fi

\DEFCMD{HC}{1DHIST}{HISTOGRAM/CREATE}{1DHISTO}{ id title ncx xmin xmax [ valmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels}{ D=100}
\DEFARG{XMIN}{R}{Low edge}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge}{ D=100.}
\DEFARG{VALMAX}{R}{Maximum bin content}{ D=0.}
\ENDARG

   \par
Create a one dimensional histogram.  The contents are set to zero.  If 
   VALMAX=0, then a full word is allocated per channel, else VALMAX is used as 
   the maximum bin content allowing several channels to be stored into the 
   same machine word.  

\ENDCMD

\DEFCMD{HC}{PROFIL}{HISTOGRAM/CREATE}{PROFILE}{ id title ncx xmin xmax ymin ymax [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels}{ D=100}
\DEFARG{XMIN}{R}{Low edge in X}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge in X}{ D=100.}
\DEFARG{YMIN}{R}{Low edge in Y}{ D=-1.E30}
\DEFARG{YMAX}{R}{Upper edge in Y}{ D=1.E30}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Error on mean
}
\DEFOPT{S}{\par
Spread option
}
\ENDOPT

   \par
Create a profile histogram.  Profile histograms accumulate statistical 
   quantities of a variable y in bins of a variable x. The contents are set to 
   zero.  

\ENDCMD

\DEFCMD{HC}{BINS}{HISTOGRAM/CREATE}{BINS}{ id title ncx xbins [ valmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels}{ D=100}
\DEFARG{XBINS}{C}{Vector of NCX+1 low-edges}{}
\DEFARG{VALMAX}{R}{Maximum bin content}{ D=0.}
\ENDARG

   \par
Create a histogram with variable size bins.  The low-edge of each bin is 
   given in vector XBINS (NCX+1) values.  The contents are set to zero. See 
   1DHISTO for VALMAX.  

\ENDCMD

\DEFCMD{HC}{2DHIST}{HISTOGRAM/CREATE}{2DHISTO}{ id title ncx xmin xmax ncy ymin ymax [ valmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels in X}{ D=40}
\DEFARG{XMIN}{R}{Low edge in X}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge in X}{ D=40.}
\DEFARG{NCY}{I}{Number of channels in Y}{ D=40}
\DEFARG{YMIN}{R}{Low edge in Y}{ D=0.}
\DEFARG{YMAX}{R}{Upper edge in Y}{ D=40.}
\DEFARG{VALMAX}{R}{Maximum bin content}{ D=0.}
\ENDARG

   \par
Create a two dimensional histogram.  The contents are set to zero. See 
   1DHISTO for VALMAX.  

\ENDCMD

\DEFCMD{HC}{PROX}{HISTOGRAM/CREATE}{PROX}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\ENDARG

   \par
Create the projection onto the x axis.  The projection is not filled until 
   the Histo/Project command is executed.  
\begin{verbatim}
    To plot projection X of ID type:
      PAW > HI/PLOT ID.PROX
\end{verbatim}

\ENDCMD

\DEFCMD{HC}{PROY}{HISTOGRAM/CREATE}{PROY}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\ENDARG

   \par
Create the projection onto the y axis.  The projection may be filled with 
   Histo/Project.  
\begin{verbatim}
    To plot projection Y of ID type:
      PAW > HI/PLOT ID.PROY
\end{verbatim}

\ENDCMD

\DEFCMD{HC}{SLIX}{HISTOGRAM/CREATE}{SLIX}{ id nslices}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{NSLICES}{I}{Number of slices}{}
\ENDARG

   \par
Create projections onto the x axis, in y-slices.  The projection may be 
   filled with Histo/Project.  
\begin{verbatim}
    To plot slice 3 in X of ID type:
      PAW > HI/PLOT ID.SLIX.3
\end{verbatim}

\ENDCMD

\DEFCMD{HC}{SLIY}{HISTOGRAM/CREATE}{SLIY}{ id nslices}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{NSLICES}{I}{Number of slices}{}
\ENDARG

   \par
Create projections onto the y axis, in x-slices.  The projection may be 
   filled with Histo/Project.  
\begin{verbatim}
    To plot slice 2 in Y of ID type:
      PAW > HI/PLOT ID.SLIY.2
\end{verbatim}

\ENDCMD

\DEFCMD{HC}{BANX}{HISTOGRAM/CREATE}{BANX}{ id ymin ymax}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{YMIN}{R}{Low edge in Y}{}
\DEFARG{YMAX}{R}{Upper edge in Y}{}
\ENDARG

   \par
Create a projection onto the x axis, in a band of y. Several bands can be 
   defined on the one histogram. The projection may be filled with 
   Histo/Project.  
\begin{verbatim}
    To plot band 1 in X of ID type:
      PAW > HI/PLOT ID.BANX.1
\end{verbatim}

\ENDCMD

\DEFCMD{HC}{BANY}{HISTOGRAM/CREATE}{BANY}{ id xmin xmax}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{XMIN}{R}{Low edge in X}{}
\DEFARG{XMAX}{R}{Upper edge in X}{}
\ENDARG

   \par
Create a projection onto the y axis, in a band of x. Several bands can be 
   defined on the one histogram. The projection may be filled with 
   Histo/Project.  
\begin{verbatim}
    To plot band 1 in Y of ID type:
      PAW > HI/PLOT ID.BANY.1
\end{verbatim}

\ENDCMD

\DEFCMD{HC}{TITLEG}{HISTOGRAM/CREATE}{TITLE\_GLOBAL}{ [ chtitl chopt ]}

\BEGARG
\DEFARG{CHTITL}{C}{Global title}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
The global title is plotted at the top of each picture.
}
\DEFOPT{U}{\par
If the option 'UTIT' is on, a user title is plotted at the bottom of each 
histogram.
}
\ENDOPT

   \par
Set the global title.  The size and the Y position of the global title may 
   be changed by the commands SET GSIZ and SET YGTI respectively. The size and 
   the Y position of the user title may be changed by the commands SET TSIZ 
   and SET YHTI respectively.  

\ENDCMD
\DEFMENU{1}{HIO}{HISTOGRAM/HIO}
\ifMENUtext
   \par
Input/Output operations of histograms.  


\fi

\DEFCMD{HH}{HRIN}{HISTOGRAM/HIO}{HRIN}{ id [ icycle iofset ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{ICYCLE}{I}{Cycle number}{ D=999}
\DEFARG{IOFSET}{I}{Offset}{ D=0}
\ENDARG

   \par
Read histogram/Ntuple ID from the current directory on direct access file 
   to memory.  An identical histogram is created but with an ID equal to that 
   of the original histogram plus the offset IOFSET.  Identifier may be '0' or 
   '*' (for all histograms).  If ICYCLE \KET{} 1000 and ID=0 read all 
   histograms in all subdirectories as well.  If IOFSET = 99999 then the 
   contents of histogram ID on the disk file are added to the current 
   histogram in memory if it exists. For example to add all histograms from 
   FILE1 and FILE2 in memory, the sequence of commands can be:  
\begin{verbatim}
    PAW > Histo/File 1 FILE1
    PAW > Hrin 0
    PAW > Histo/File 2 FILE2
    PAW > Hrin 0 ! 99999
\end{verbatim}

\ENDCMD

\DEFCMD{HH}{HROUT}{HISTOGRAM/HIO}{HROUT}{ id [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Write histo/Ntuple ID from memory to current directory.
}
\DEFOPT{T}{\par
Writes all histograms in subdirectories as well.
}
\ENDOPT

   \par
Write histo/Ntuple ID from memory to current directory.  Identifier may be 
   '0' or '*' (for all histograms).  

\ENDCMD

\DEFCMD{HH}{HSCRAT}{HISTOGRAM/HIO}{HSCRATCH}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Delete histogram ID in Current Directory on disk.  If ID='0' or '*' delete 
   all histograms.  To delete histograms in memory use command HISTO/DELETE.  

\ENDCMD

\DEFCMD{HH}{HFETCH}{HISTOGRAM/HIO}{HFETCH}{ id fname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Fetch histogram ID from file FNAME.  FNAME has been created by the old 
   version of HBOOK3 (Unformatted).  

\ENDCMD

\DEFCMD{HH}{HREAD}{HISTOGRAM/HIO}{HREAD}{ id fname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Read histogram ID from file FNAME.  FNAME has been created by the old 
   version of HBOOK3 (Formatted).  

\ENDCMD

\DEFCMD{HH}{PRINT}{HISTOGRAM/HIO}{PRINT}{ id [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Print histograms.
}
\DEFOPT{S}{\par
Only statistics (Number of entries, mean, RMS, underflow, overflow) are 
printed.
}
\ENDOPT

   \par
Print histograms (line-printer format) on screen.  The command OUTPUT\_LP 
   may be used to change the output file.  

\ENDCMD

\DEFCMD{HH}{DUMP}{HISTOGRAM/HIO}{DUMP}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Dump the histogram ZEBRA data structure on the terminal.  

\ENDCMD

\DEFCMD{HH}{OUTPUT}{HISTOGRAM/HIO}{OUTPUT\_LP}{ [ lun fname ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ D=6}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Change the HBOOK \DQUOTE{}line printer\DQUOTE{} file name.  If FNAME=' ' 
   then OUTPUT is appended to an already opened file on unit LUN.  If LUN is 
   negative, the file is closed and subsequent output is directed to unit 6.  

\ENDCMD

\DEFCMD{HH}{GLOBAL}{HISTOGRAM/HIO}{GLOBAL\_SECT}{ gname}

\BEGARG
\DEFARG{GNAME}{C}{Global section name}{ D=\EMPTY{}}
\ENDARG

   \par
Map the global section GNAME (VAX only).  The current directory is changed 
   to //GNAME.  

\ENDCMD

\DEFCMD{HH}{GRESET}{HISTOGRAM/HIO}{GRESET}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\ENDARG

   \par
Reset histogram ID in the global section.  

\ENDCMD
\DEFMENU{1}{OPERATIONS}{HISTOGRAM/OPERATIONS}
\ifMENUtext
   \par
Histogram operations and comparisons.  


\fi

\DEFCMD{HO}{ADD}{HISTOGRAM/OPERATIONS}{ADD}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Add histograms: ID3 = C1*ID1 + C2*ID2.  Applicable to 1-Dim and 2-Dim 
   histograms.  See command HRIN to add histograms with same IDS from 
   different files.  If option 'E' is set, error bars are calculated for ID3.  

\ENDCMD

\DEFCMD{HO}{SUBTRA}{HISTOGRAM/OPERATIONS}{SUBTRACT}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Subtract histograms: ID3 = C1*ID1 - C2*ID2.  Applicable to 1-Dim and 2-Dim 
   histograms.  If option 'E' is set, error bars are calculated for ID3.  

\ENDCMD

\DEFCMD{HO}{MULTIP}{HISTOGRAM/OPERATIONS}{MULTIPLY}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Multiply histogram contents: ID3 = C1*ID1 * C2*ID2.  Applicable to 1-Dim 
   and 2-Dim histograms.  If option 'E' is set, error bars are calculated for 
   ID3.  

\ENDCMD

\DEFCMD{HO}{DIVIDE}{HISTOGRAM/OPERATIONS}{DIVIDE}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Divide histograms: ID3 = C1*ID1 / C2*ID2.  Applicable to 1-Dim and 2-Dim 
   histograms.  If option 'E' is set, error bars are calculated for ID3.  

\ENDCMD

\DEFCMD{HO}{RESET}{HISTOGRAM/OPERATIONS}{RESET}{ id [ title ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{New title}{ D=\EMPTY{}}
\ENDARG

   \par
Reset contents and errors of an histogram.  Bin definition is not modified. 

\ENDCMD

\DEFCMD{HO}{DIFF}{HISTOGRAM/OPERATIONS}{DIFF}{ id1 id2 [ chopt ]}

\BEGARG
\DEFARG{ID1}{C}{First Histogram Identifier}{}
\DEFARG{ID2}{C}{Second Histogram Identifier}{}
\DEFARG{CHOPT}{C}{Options}{ D='D'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
The comparison is done only on the shape of the two histograms.
}
\DEFOPT{N}{\par
Include also comparison of the relative normalisation of the two histograms, 
in addition to comparing the shapes. PROB is then a combined confidence level 
taking account of absolute contents.
}
\DEFOPT{D}{\par
Debug printout, produces a blank line and two lines of information at each 
call, including the ID numbers, the number of events in each histogram, the 
PROB value, and the maximum Kolmogorov distance between the two histograms. 
For 2-Dim histograms, there are two Kolmogorov distances (see below). If 'N' 
is specified, there is a third line of output giving the PROB for shape alone, 
and for normalisation.
}
\DEFOPT{O}{\par
Overflow, requests that overflow bins be taken into account.
}
\DEFOPT{U}{\par
Underflow, requests that underflow bins be taken into account.
}
\DEFOPT{L}{\par
Left: include x-underflows
}
\DEFOPT{R}{\par
Right: include x-overflows
}
\DEFOPT{T}{\par
Top: include y-overflows
}
\DEFOPT{B}{\par
Bottom: include y-underflows
}
\DEFOPT{F1}{\par
Histogram 1 has no error (is a function)
}
\DEFOPT{F2}{\par
Histogram 2 has no error (is a function)
}
\ENDOPT

   \par
Test of compatibility for two 1-Dim histograms ID1 and ID2.  A probability 
   PROB is calculated as a number between zero and one, where PROB near one 
   indicates very similar histograms, and PROB near zero means that it is very 
   unlikely that the two arose from the same parent distribution.  For two 
   histograms sampled randomly from the same distribution, PROB will be 
   (approximately) uniformly distributed between 0 and 1.  See discussion in 
   HBOOK manual under \DQUOTE{}HDIFF- Statistical Considerations\DQUOTE{}.  By 
   default (if no options are selected with CHOPT) the comparison is done only 
   on the shape of the two histograms, without consideration of the difference 
   in numbers of events, and ignoring all underflow and overflow bins.  

\ENDCMD

\DEFCMD{HO}{SORT}{HISTOGRAM/OPERATIONS}{SORT}{ id [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{CHOPT}{C}{Options}{ D='XA'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{X}{\par
X-axis is being treated.
}
\DEFOPT{Y}{\par
Y-axis is being treated.
}
\DEFOPT{Z}{\par
Z-axis is being treated.
}
\DEFOPT{A}{\par
Alphabetically.
}
\DEFOPT{E}{\par
Reverse alphabetical order.
}
\DEFOPT{D}{\par
By increasing channel contents.
}
\DEFOPT{V}{\par
By decreasing channel contents.
}
\ENDOPT

   \par
Sort the alphanumeric labels of the histogram ID according to the value of 
   CHOPT.  

\ENDCMD

\DEFCMD{HO}{SMOOTH}{HISTOGRAM/OPERATIONS}{SMOOTH}{ id [ option sensit smooth ]}

\BEGARG
\DEFARG{ID}{C}{Histogram or Ntuple Identifier}{ Minus}
\DEFARG{OPTION}{C}{Options}{ D='2M'}
\DEFARG{SENSIT}{R}{Sensitivity parameter}{ D=1. R=0.3:3.}
\DEFARG{SMOOTH}{R}{Smoothness parameter}{ D=1. R=0.3:3.}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{0}{\par
Replace original histogram by smoothed.
}
\DEFOPT{1}{\par
Replace original histogram by smoothed.
}
\DEFOPT{2}{\par
Store values of smoothed function and its parameters without replacing the 
original histogram (but see note below) - the smoothed function can be 
displayed at editing time - see HISTOGRAM/PLOT.
}
\DEFOPT{M}{\par
Invoke multiquadric smoothing (see HBOOK routine HQUAD).
}
\DEFOPT{Q}{\par
Invoke the 353QH algorithm (see HBOOK routine HSMOOF).
}
\DEFOPT{S}{\par
Invoke spline smoothing.
}
\DEFOPT{V}{\par
Verbose (default for all except 1-D histogram).
}
\DEFOPT{N}{\par
Do not plot the result of the fit.
}
\DEFOPT{F}{\par
Write Fortran77 function to HQUADF.DAT (multiquadric only)
}
\ENDOPT

   \par
Smooth a histogram or \DQUOTE{}simple\DQUOTE{} ntuple.  
   (\DQUOTE{}simple\DQUOTE{} = 1, 2, or 3 variables.) 

   \par
For multiquadric smoothing, SENSIT controls the sensitivity to statistical 
   fluctuations.  SMOOTH controls the (radius of) curvature of the 
   multiquadric basis functions.  

   \par
Notes:  

   \par
1) The multiquadric basis functions are SQRT(R**2+D**2), where R is the 
   distance from the \DQUOTE{}centre\DQUOTE{}, and D is a scale parameter and 
   also the curvature at the \DQUOTE{}centre\DQUOTE{}.  
   \DQUOTE{}Centres\DQUOTE{} are located at points where the 2nd differential 
   or Laplacian of event density is statistically significant.  

   \par
2) The data must be statistically independent, i.e. events (weighted or 
   unweighted) drawn randomly from a parent probability distribution or 
   differential cross-section.  

   \par
For spline smoothing, SENSIT and SMOOTH control the no. of knots (= 10 * 
   SENSIT) and degree of splines (= SMOOTH + 2) (thus if SENSIT and SMOOTH are 
   at their default values a 10-knot cubic spline is used).  

   \par
Notes:  

   \par
1) The spline option ALWAYS replaces the contents of a 2-D histogram.  
   (Also chi-squared is unavailable in this case.) 

   \par
2) Use the SPLINE command for more flexibility.  

\ENDCMD

\DEFCMD{HO}{SPLINE}{HISTOGRAM/OPERATIONS}{SPLINE}{ id [ isel knotx kx ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{ISEL}{I}{Option flag}{ D=2}
\DEFARG{KNOTX}{I}{Number of knots}{ D=10}
\DEFARG{KX}{I}{Degree of the spline}{ D=3}
\ENDARG

   \par
Smooth 1-Dim or 2-Dim histogram ID using B-splines.  If ID is a 1-Dim 
   histogram then:  
\begin{verbatim}
    ISEL = 0,1 replace original histogram by smoothed.
         = 2   superimpose as a function when editing.
\end{verbatim}
   \par
If ID is a 2-Dim histogram then original contents are replaced.  

\ENDCMD

\DEFCMD{HO}{FUNCTI}{HISTOGRAM/OPERATIONS}{FUNCTION}{ id ufunc}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{UFUNC}{C}{Name of the function}{}
\ENDARG

   \par
Associate the function UFUNC with the histogram ID.  

   \par
Example:  
\begin{verbatim}
       HIS/OP/FUN 110 X**2
       H/PL 110
\end{verbatim}

\ENDCMD

\DEFCMD{HO}{PARAM}{HISTOGRAM/OPERATIONS}{PARAM}{ id [ isel r2min maxpow ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{ISEL}{I}{Control word}{ D=11}
\DEFARG{R2MIN}{R}{Min correlation coefficient}{ D=1.}
\DEFARG{MAXPOW}{I}{Max degree of polynomials}{ D=5 R=1:20}
\ENDARG

   \par
Perform a regression on contents of the 1-Dim histogram ID.  Find the best 
   parameterisation in terms of elementary functions (regressors). See HBOOK 
   guide HPARAM.  Control word ISEL=1000*T +100*W +10*S +P 
\begin{verbatim}
    S = 1 resulting parametric fit superimposed on histogram
        0 no superposition
    P = 0 minimal output: the residual sum of squares is printed
        1 normal output: in addition, the problem characteristics and
          options are printed; also the standard deviations and
          confidence intervals of the coefficients.
        2 extensive output: the results of each iteration are printed
          with the normal output.
    W = 0 weights on histogram contents are already defined via HBARX
          or HPAKE. If not they are taken to be equal to the
          square-root of the contents.
        1 weights are equal to 1.
    T = 0 monomials will be selected as the elementary functions
        1 Chebyshev polynomials with a definition region: [-1,1]
        2 Legendre polynomials with a definition region: [-1,1]
        3 shifted Chebyshev polynomials with a definition region: [0,1]
        4 Laguerre polynomials with a definition region: [0,+infinite]
        5 Hermite polynomials with a definition region: [-inf,+inf]
\end{verbatim}
   \par
The FORTRAN code of the parameterisation is written onto the file 
   FPARAM.DAT.  

\ENDCMD

\DEFCMD{HO}{HSETPR}{HISTOGRAM/OPERATIONS}{HSETPR}{ param value}

\BEGARG
\DEFARG{PARAM}{C}{Parameter name}{ D='FEPS'}
\DEFARG{VALUE}{R}{Parameter value}{ D=0.001}
\ENDARG

   \par
Set various parameters for command PARAM.  

\ENDCMD
\DEFMENU{1}{GET\_VECT}{HISTOGRAM/GET\_VECT}
\ifMENUtext
   \par
Fill a vector from values stored in HBOOK objects.  


\fi

\DEFCMD{HG}{CONTEN}{HISTOGRAM/GET\_VECT}{CONTENTS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get contents of histogram ID into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{ERRORS}{HISTOGRAM/GET\_VECT}{ERRORS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get errors of histogram ID into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{FUNCTI}{HISTOGRAM/GET\_VECT}{FUNCTION}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get function associated to histogram ID into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{ABSCIS}{HISTOGRAM/GET\_VECT}{ABSCISSA}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get values of center of bins abscissa into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{REBIN}{HISTOGRAM/GET\_VECT}{REBIN}{ id x y ex ey [ n ifirst ilast chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{X}{C}{Name of vector X}{}
\DEFARG{Y}{C}{Name of vector Y}{}
\DEFARG{EX}{C}{Name of vector EX}{}
\DEFARG{EY}{C}{Name of vector EY}{}
\DEFARG{N}{I}{Number of elements to fill}{ D=100}
\DEFARG{IFIRST}{I}{First bin}{ D=1}
\DEFARG{ILAST}{I}{Last bin}{ D=100}
\DEFARG{CHOPT}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{N}{\par
Do not normalize values in Y
}
\ENDOPT

   \par
The specified channels of the 1-Dim histogram ID are cumulated (rebinned) 
   into new bins. The final contents of the new bin is the average of the 
   original bins by default. If the option N is given, the final contents of 
   the new bin is the sum of the original bins.  Get contents and errors into 
   vectors, grouping bins.  Bin width and centers are also extracted.  Allow 
   to combine 2, 3 or more bins into one.  
\begin{verbatim}
      E.g.:  REBIN 110 X Y EX EY 25 11 85
              will group by 3 channels 11 to 85  and return
              new abscissa, contents and errors.
              Errors in X are equal to 1.5*BINWIDTH.
      N.B.:
             REBIN ID X Y EX EY  is a convenient way to return in
             one call abscissa, contents and errors for 1-Dim histogram.
             In this case the errors in X are equal to 0.5*BINWIDTH.
\end{verbatim}

\ENDCMD
\DEFMENU{1}{PUT\_VECT}{HISTOGRAM/PUT\_VECT}
\ifMENUtext
   \par
Replace histogram contents with values in a vector.  


\fi

\DEFCMD{HP}{CONTEN}{HISTOGRAM/PUT\_VECT}{CONTENTS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Replace contents of histogram with values of vector VNAME.  

\ENDCMD

\DEFCMD{HP}{ERRORS}{HISTOGRAM/PUT\_VECT}{ERRORS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Replace errors of histogram with values of vector VNAME.  

\ENDCMD
\DEFMENU{1}{SET}{HISTOGRAM/SET}
\ifMENUtext
   \par
Set histogram attributes.  


\fi

\DEFCMD{HS}{MAXIMU}{HISTOGRAM/SET}{MAXIMUM}{ id vmax}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{VMAX}{R}{Maximum value}{}
\ENDARG

   \par
Set the maximum value on the Y axis.  To select again an automatic scale, 
   just set VMAX equal to the minimum.  

   \par
Example:  
\begin{verbatim}
       MIN id 0 ; MAX id 0
\end{verbatim}
   \par
Reset the default scaling.  

\ENDCMD

\DEFCMD{HS}{MINIMU}{HISTOGRAM/SET}{MINIMUM}{ id vmin}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{VMIN}{R}{Minimum value}{}
\ENDARG

   \par
Set the minimum value on the Y axis.  To select again an automatic scale, 
   just set VMIN equal to the maximum.  

   \par
Example:  
\begin{verbatim}
       MIN id 0 ; MAX id 0
\end{verbatim}
   \par
Reset the default scaling.  

\ENDCMD

\DEFCMD{HS}{NORMAL}{HISTOGRAM/SET}{NORMALIZE\_FACTOR}{ id [ xnorm ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{XNORM}{R}{Normalisation factor}{ D=1}
\ENDARG

   \par
Set the contents/errors normalisation factor.  Only valid for histograms 
   (1-Dim).  (does not change contents, only presentation).  

\ENDCMD

\DEFCMD{HS}{SCALEF}{HISTOGRAM/SET}{SCALE\_FACTOR\_2D}{ id [ xscale ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{XSCALE}{R}{Scale factor}{ D=0}
\ENDARG

   \par
Set the scale factor for histograms (2-Dim).  

\ENDCMD

\DEFCMD{HS}{IDOPT}{HISTOGRAM/SET}{IDOPT}{ id option}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{OPTION}{C}{Options}{}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{SETD*}{\par
Set all options to the default values
}
\DEFOPT{SHOW}{\par
Print all the options currently set
}
\DEFOPT{BLAC}{\par
1 Dim histogram printed with X characters
}
\DEFOPT{CONT*}{\par
1 Dim histogram is printed with the contour option
}
\DEFOPT{STAR}{\par
1 Dim histogram is printed with a * at the Y value
}
\DEFOPT{SCAT*}{\par
Print a 2 Dim histogram as a scatter-plot
}
\DEFOPT{TABL}{\par
Print a 2 Dim histogram as a table
}
\DEFOPT{PROE*}{\par
Plot errors as the error on mean of bin in Y for profile histograms
}
\DEFOPT{PROS}{\par
Plot errors as the Spread of each bin in Y for profile histograms
}
\DEFOPT{STAT}{\par
Mean value and RMS computed at filling time
}
\DEFOPT{NSTA*}{\par
Mean value and RMS computed from bin contents only
}
\DEFOPT{ERRO}{\par
Errors bars printed as SQRT(contents)
}
\DEFOPT{NERR*}{\par
Do not print print error bars
}
\DEFOPT{INTE}{\par
Print the values of integrated contents bin by bin
}
\DEFOPT{NINT*}{\par
Do not print integrated contents
}
\DEFOPT{LOGY}{\par
1 Dim histogram is printed in Log scale in Y
}
\DEFOPT{LINY*}{\par
1 Dim histogram is printed in linear scale in Y
}
\DEFOPT{PCHA*}{\par
Print channel numbers
}
\DEFOPT{NPCH}{\par
Do not print channel numbers
}
\DEFOPT{PCON*}{\par
Print bin contents
}
\DEFOPT{NPCO}{\par
Do not print bin contents
}
\DEFOPT{PLOW*}{\par
Print values of low edge of the bins
}
\DEFOPT{NPLO}{\par
Do not print the low edge
}
\DEFOPT{PERR}{\par
Print the values of the errors for each bin
}
\DEFOPT{NPER*}{\par
Do not print the values of the errors
}
\DEFOPT{PFUN}{\par
Print the values of the associated function bin by bin
}
\DEFOPT{NPFU*}{\par
Do not print the values of the associated function
}
\DEFOPT{PHIS*}{\par
Print the histogram profile
}
\DEFOPT{NPHI}{\par
Do not print the histogram profile
}
\DEFOPT{PSTA*}{\par
Print the values of statistics (entries,mean,RMS,etc.)
}
\DEFOPT{NPST}{\par
Do not print values of statistics
}
\DEFOPT{ROTA}{\par
Print histogram rotated by 90 degrees
}
\DEFOPT{NROT*}{\par
Print histogram vertically
}
\DEFOPT{1EVL}{\par
Force an integer value for the steps in the Y axis
}
\DEFOPT{AEVL*}{\par
Steps for the Y axis are automatically computed
}
\DEFOPT{2PAG}{\par
Histogram is printed over two pages
}
\DEFOPT{1PAG*}{\par
Histogram is printed in one single page
}
\DEFOPT{AUTO*}{\par
Automatic scaling
}
\ENDOPT

   \par
Set options for histogram ID. (* means default).  

\ENDCMD
\DEFMENU{0}{FUNCTION}{FUNCTION}
\ifMENUtext
   \par
Operations with Functions. Creation and plotting.  


\fi

\DEFCMD{F}{FUN1}{FUNCTION}{FUN1}{ id ufunc ncx xmin xmax [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{UFUNC}{C}{Name of the function}{}
\DEFARG{NCX}{I}{Number of channels}{ D=100 R=1:}
\DEFARG{XMIN}{R}{Low edge}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge}{ D=100.}
\DEFARG{CHOPT}{C}{Options}{ D='P'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{P}{\par
The function is drawn.
}
\ENDOPT

   \par
Create a one dimensional histogram and fill the bins with the values of a 
   (single-valued) function.  The function UFUNC may be given in two ways:  

   \par
-An expression of the variable x in case of a simple function.  
\begin{verbatim}
    Ex: FUN1  10 sin(x)/x  100 0 10
\end{verbatim}
   \par
-UFUNC is the name of a COMIS function in a text file with the name 
   UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).  

\ENDCMD

\DEFCMD{F}{FUN2}{FUNCTION}{FUN2}{ id ufunc ncx xmin xmax ncy ymin ymax [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{}
\DEFARG{UFUNC}{C}{Name of the function}{}
\DEFARG{NCX}{I}{Number of channels in X}{ D=40 R=1:}
\DEFARG{XMIN}{R}{Low edge in X}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge in X}{ D=40.}
\DEFARG{NCY}{I}{Number of channels in Y}{ D=40 R=1:}
\DEFARG{YMIN}{R}{Low edge in Y}{ D=0.}
\DEFARG{YMAX}{R}{Upper edge in Y}{ D=40.}
\DEFARG{CHOPT}{C}{Options}{ D='S'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Create the histogram.
}
\DEFOPT{S}{\par
The function is drawn as a surface.
}
\DEFOPT{L}{\par
The function is drawn as a lego plot.
}
\DEFOPT{C}{\par
The function is drawn as a contour plot.
}
\ENDOPT

   \par
Create a two dimensional histogram and fill the bins with the values of a 
   (two-valued) function.  The function UFUNC may be given in two ways:  

   \par
-An expression of the variables x and y in case of a simple function.  
\begin{verbatim}
    Ex: FUN2  10 abs(sin(x**2+y**2)) 40 -2 2 40 -2 2 C
\end{verbatim}
   \par
-UFUNC is the name of a COMIS function in a text file with the name 
   UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).  

\ENDCMD

\DEFCMD{F}{DRAW}{FUNCTION}{DRAW}{ ufunc [ chopt ]}

\BEGARG
\DEFARG{UFUNC}{C}{Name of function}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Draw the function UFUNC in the current ranges specified by the command:  
   RANGE XLOW XUP YLOW YUP ZLOW ZUP and with THETHA and PHI angles specified 
   by the command ANGLE THETA PHI. The number of points to evaluate the 
   function between XLOW, XUP YLOW, YUP, and ZLOW, ZUP can be changed by the 
   command POINTS NPX NPY NPZ.  

   \par
The function UFUNC may be given in two ways:  - As an expression of the 
   variables X, Y, Z in the case of a 
\begin{verbatim}
     simple function.
     Ex:
     PAW >  FUN/DRAW X*Y*Z         | equivalent to :
     PAW >  FUN/DRAW X*Y*Z=0
     PAW >  FUN/DRAW X**2+Y**2+Z**2=1
     PAW >  FUN/DRAW X**2+Y**2=1-Z**2
\end{verbatim}
   \par
- As a COMIS function in a text file with the name UFUNC.FTN or 
\begin{verbatim}
     UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).
     Ex:
     The file FTEST.FOR contains:
\end{verbatim}
\begin{verbatim}
     FUNCTION FTEST(X,Y,Z)
     IF(X.LE.0..AND.Y.LE.0.)THEN
       FTEST=(X+0.5)**2+(Y+0.5)**2+(Z+0.5)**2-0.2
     ELSE
       FTEST=(X-0.5)**2+(Y-0.5)**2+(Z-0.5)**2-0.1
     ENDIF
     END
\end{verbatim}
\begin{verbatim}
     PAW > RANGE -1 1 -1 1 -1 1  | Define the range as a cube between -1 1 in 
   the 3
                                   directions
     PAW > POINTS 20 20 20       | FUN/DRAW will use 20 points in the 3 
   directions
     PAW > FUN/DRAW FTEST.FOR    | Draw 2 spheres centered on (-0.5,-0.5,-0.5)
                                   and (0.5,0.5,0.5) with the radius SQRT(0.2)
                                   and SQRT(0.1)
\end{verbatim}

\ENDCMD

\DEFCMD{F}{PLOT}{FUNCTION}{PLOT}{ ufunc xlow xup [ chopt ]}

\BEGARG
\DEFARG{UFUNC}{C}{Name of function}{}
\DEFARG{XLOW}{R}{Lower limit}{}
\DEFARG{XUP}{R}{Upper limit}{}
\DEFARG{CHOPT}{C}{Options}{ D='C'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{L}{\par
Connect channel contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Plot single-valued function UFUNC between XLOW and XUP.  The function UFUNC 
   may be given in two ways:  

   \par
-An expression of the variable x in case of a simple function.  
\begin{verbatim}
    Ex: FUN/PLOT   sin(x)/x  0 10
\end{verbatim}
   \par
-UFUNC is the name of a COMIS function in a text file with the name 
   UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).  For example, 
   if the file FTEST.FOR contains:  
\begin{verbatim}
         FUNCTION FTEST(X)
         FTEST=SIN(X)*EXP(-0.1*X)
         END
\end{verbatim}
   \par
Then, FUN/PLOT FTEST.FOR 0 10, will interpret the Fortran code in the file 
   FTEST.FOR and draw the function for x between 0 and 10.  

   \par
The number of points to evaluate the function between XLOW and XUP can be 
   changed by the command /FUN/POINTS. Only 1-Dim functions are supported. For 
   2-Dim use FUN2.  

\ENDCMD

\DEFCMD{F}{POINTS}{FUNCTION}{POINTS}{ [ npx npy npz ]}

\BEGARG
\DEFARG{NPX}{I}{Number of points on X axis}{ D=20 R=2:1000}
\DEFARG{NPY}{I}{Number of points on Y axis}{ D=20 R=2:1000}
\DEFARG{NPZ}{I}{Number of points on Z axis}{ D=20 R=2:1000}
\ENDARG

   \par
Change the number of points to be used by FUN/DRAW and FUN/PLOT. Note that 
   the default for NPX is 20 for 3-Dim plots (FUN/DRAW) but it is 100 for 
   1-Dim plots (FUN/PLOT).  

\ENDCMD

\DEFCMD{F}{RANGE}{FUNCTION}{RANGE}{ [ xlow xup ylow yup zlow zup ]}

\BEGARG
\DEFARG{XLOW}{R}{X Lower limit}{ D=-1.}
\DEFARG{XUP}{R}{X Upper limit}{ D=1.}
\DEFARG{YLOW}{R}{Y Lower limit}{ D=-1.}
\DEFARG{YUP}{R}{Y Upper limit}{ D=1}
\DEFARG{ZLOW}{R}{Z Lower limit}{ D=-1.}
\DEFARG{ZUP}{R}{Z Upper limit}{ D=1.}
\ENDARG

   \par
Change the range used by FUN/DRAW.  

\ENDCMD

\DEFCMD{F}{ANGLE}{FUNCTION}{ANGLE}{ [ theta phi ]}

\BEGARG
\DEFARG{THETA}{R}{Angle THETA in degrees}{ D=30.}
\DEFARG{PHI}{R}{Angle PHI in degrees}{ D=30.}
\ENDARG

   \par
Change the angle used by FUN/DRAW and HISTO/PLOT.  

\ENDCMD
\DEFMENU{0}{NTUPLE}{NTUPLE}
\ifMENUtext
   \par
Ntuple creation and related operations.  


\fi

\DEFCMD{N}{CREATE}{NTUPLE}{CREATE}{ idn title nvar chrzpa nprime varlist}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{TITLE}{C}{Ntuple title}{ D=\EMPTY{}}
\DEFARG{NVAR}{I}{Number of variables}{ D=1 R=1:512}
\DEFARG{CHRZPA}{C}{RZ path}{ D=\EMPTY{}}
\DEFARG{NPRIME}{I}{Primary allocation}{ D=1000}
\DEFARG{VARLIST}{C}{Names of the NVAR variables}{ Vararg}
\ENDARG

   \par
Create a Row\_Wise\_Ntuple. (See below how to create a 
   Column\_Wise\_Ntuple).  The Ntuple may be created either purely in memory 
   or possibly using an automatic overflow to an RZ file.  Memory allocation 
   works in the following way.  If CHRZPA = '  ', then a bank of NPRIME words 
   is created. When the space in this bank is exhausted at filling time, a new 
   linear structure of length NPRIME is created and this process will be 
   repeated should the structure become exhausted.  If CHRZPA contains the top 
   directory name of an already existing RZ file (as declared with 
   HISTO/FILE), then a bank of length NPRIME is also created, but at filling 
   time, this bank is moved to the RZ file when full, and then it is 
   overwritten by any new entries.  The Ntuple can be filled by calling HFN 
   from an interactively defined subroutine called by the command NTUPLE/LOOP 
   or by NTUPLE/READ.  The number of variables per data point is given in the 
   parameter NVAR.  

   \par
To create a Column\_Wise\_Ntuple, create a file, eg. newnt.f  with:  
\begin{verbatim}
         Subroutine Newnt
         character*8 mother,in1,in2
         common/ntupc/mother,in1,in2
         common/ntupr/xover
         lin=41
         lout=42
         id=1
         open(unit=lin,file='datafile.dat',status='old')
         call hropen(lout,'NTUPLE','New_Ntuple.hbook','N',1024,istat)
         call hbnt(id,'New Ntuple',' ')
         call hbname(id,'ntupr',xover,'XOVER')
         call hbnamc(id,'ntupc',mother,'MOTHER:c*8,in1:c*8,in2:c*8')
     10  read(lin,1000,end=20,err=20)xover,mother,in1,in2
\end{verbatim}
   \par
1000  format(e15.7,2x,a,7x,a,7x,a) 
\begin{verbatim}
         call hfnt(1)
         go to 10
     20  call hrout(id,icycle,' ')
         call hrend('NTUPLE')
         close (lin)
         close (lout)
         end
\end{verbatim}
   \par
and then call this routine via the CALL command:  
\begin{verbatim}
      PAW > call newnt.f
\end{verbatim}

\ENDCMD

\DEFCMD{N}{LIST}{NTUPLE}{LIST}{}

   \par
List all Ntuples in the Current Directory.  Note that the command 
   HISTO/LIST lists all histograms and Ntuples in the Current Directory.  

\ENDCMD

\DEFCMD{N}{PRINT}{NTUPLE}{PRINT}{ idn}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\ENDARG

   \par
Print a summary about Ntuple IDN.  Number of entries, variables names and 
   limits are listed.  

\ENDCMD

\DEFCMD{N}{HMERGE}{NTUPLE}{HMERGE}{ outfile infiles}

\BEGARG
\DEFARG{OUTFILE}{C}{Output file name}{ D=\EMPTY{}}
\DEFARG{INFILES}{C}{Input file names}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Merge HBOOK files containing histograms and/or ntuples. Ntuples are merged 
   and histograms with the same ID are added. The INFILES are merged into a 
   new file OUTFILE. If OUTFILE already exists, it is overwritten.  

   \par
Note that if there is a histogram in PAW memory that has the same 
   identifier as a histogram in one of the files to be merged, then the 
   contents of the histogram in memory are added to those of the histogram in 
   the file. This can be avoided by deleting the memory histogram (using 
   H/DEL) before issuing the HMERGE command.  

\ENDCMD

\DEFCBIG{N}{DUPLIC}{NTUPLE}{DUPLICATE}{ id1 id2 [ newbuf title option ]}

\BEGARG
\DEFARG{ID1}{C}{Source Ntuple}{}
\DEFARG{ID2}{I}{New Ntuple}{}
\DEFARG{NEWBUF}{I}{Buffer size}{ D=-1}
\DEFARG{TITLE}{C}{Title of ID2}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Options}{ D='A'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{A}{\par
Set the Addresses of variables in common /PAWCR4,etc/.
}
\DEFOPT{M}{\par
Create ID2 as a Memory resident Ntuple.
}
\DEFOPT{\EMPTY}{\par
Copy ID1 structure in ID2. Reset addresses of variables.
}
\ENDOPT

   \par
The structure of Ntuple ID1 is duplicated in a new ntuple ID2.  This 
   command is useful when one wants to create an ntuple with the same 
   variables but only a subset of the events. NEWBUF is the buffer size for 
   ID2. If NEWBUF\BRA{}0 the buffer size of ID1 is taken. If NEWBUF=0 the 
   current buffer size is taken (10000 words for RWNs). NEWBUF\KET{}0 will be 
   the new buffer size. If TITLE=' ' ID2 has the same title as ID1.  In case 
   of a disk-resident ntuple (default), ID2 is created into the current 
   working directory which must be open in WRITE mode.  

   \par
Example with a Row Wise Ntuple:  
\begin{verbatim}
       Macro DUPRWN
       Close 0
       Hi/File 1 source.hbook
       Hi/File 2 new.hbook ! N
       Nt/Dup //lun1/30 2
       *
       Application Comis Quit
             Real Function Dup(dum)
             Include ?
             If (X.gt.0..Or.Y.gt.0.) call hfn(2,X)
             dup=1.
             end
       Quit
       *
       nt/loop //lun1/30 dup
       hrout 2
\end{verbatim}
   \par
Note that the statement \DQUOTE{}include ?\DQUOTE{} allows to create 
   automatically the inlude file (comis.inc) corresponding to the ntuple 
   structure. The command UWFUNC is not required in this case.  

   \par
Example with a Column Wise Ntuple:  
\begin{verbatim}
       Macro DUPCWN
       *
        Close 0                    | Close all the currently opened file
        H/file 1 source.hbook
        Uwfunc //lun1/1 source.inc | generate source.inc
        H/file 2 new.hbook ! N     | Create a new hbook file
        Nt/Dup //lun1/1 2          | Duplicate the ntuple 1 in the ntuple 2
       *
       * Comis routine which Loop on all events of Id1 and select some events
       * to be written in the new ntuple Id2.
       *
       Application COMIS quit
             Subroutine ntdup(Id1,Id2)
             Include 'source.inc'
             Call Hnoent(Id1,Noent)
             Do Ievent=1,Noent
                Call Hgnt(Id1,Ievent,Ierr)
                If (Ierr.ne.0) Goto 20
                If (X.Gt.0..Or.Y.Gt.0.) Then
                   Call Hfnt(Id2)
                Endif
             Enddo
         20  Continue
       *
             End
       Quit
       *
        Call Ntdup(1,2)             | Execute the routine Ntdup
        Hrout 2                     | Write Id2 on disk
\end{verbatim}

\ENDCBIG

\DEFCMD{N}{RECOVE}{NTUPLE}{RECOVER}{ idn}

\BEGARG
\DEFARG{IDN}{I}{Ntuple Identifier}{}
\ENDARG

   \par
To recover Ntuple ID. If the job producing the Ntuple crashed or the header 
   was not stored correctly in the file with HROUT, RECOVER will scan the 
   Ntuple to rebuild the header table and recompute the number of entries. The 
   file on which the Ntuple resides must be open in Update mode.  

\ENDCMD

\DEFCMD{N}{SCAN}{NTUPLE}{SCAN}{ idn [ uwfunc nevent ifirst option varlis ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{UWFUNC}{C}{User cut function}{ D='0'}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\DEFARG{VARLIS}{C}{Names of the NVARS variables to scan}{ D=\EMPTY{} Vararg}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{S}{\par
Graphical scan (spider plot).
}
\DEFOPT{\EMPTY}{\par
Alphanumeric output of the Ntuple.
}
\DEFOPT{S2}{\par
Graphical scan (segments plot).
}
\DEFOPT{A}{\par
Used with \DQUOTE{}S\DQUOTE{} it displays the average spider.
}
\ENDOPT

   \par
Scan the entries of an Ntuple subject to user cuts.  Scan the variables for 
   NEVENT events starting at IFIRST, requiring that the events satisfy cut 
   UWFUNC. In the case of Alphanumeric output Up to 8 variables may be 
   scanned, the default is to scan the first 8 variables.  

   \par
When the option S (Spider plot) is specified, each event is presented in a 
   graphical form (R versus PHI plot) to give a multi dimensional view of the 
   event. Each variable is represented on a separate axis with a scale ranging 
   from the minimum to the maximum value of the variable. A line joins all the 
   current points on every axis where each point corresponds to the current 
   value of the variable. When the HCOL parameter is specified (eg SET HCOL 
   1002) a fill area is drawn.  

   \par
VARLIS may contain a list of the original variables, expressions of the 
   original variables or/and ranges of variables.  A range can be given in the 
   following form:  
\begin{verbatim}
    :          means all variables (default).
    var1:var2  means from variable var1 to variable var2 included.
    var1:      means from variable var1 to the last.
    :var2      means from variable 1 to variable var2
\end{verbatim}
\ENDVERB
   \par
For example, if IDN=30 has the 3 variables X,Y,Z,U,V,W one can do:  
\begin{verbatim}
    PAW > scan 30
    PAW > scan 30 option=s
          each event is drawn as a spider plot.
    PAW > scan 30 option=sa
          each event is drawn as a spider plot and the average spider
          plot is also drawn.
    PAW > set 2BUF 1
    PAW > scan 30 option=s2
    More...? ( <CR>/N/G ) G
          answering "G" with double buffer on, create a graphical
          animation of the ntuple content.
    PAW > scan 30 option=s  X:Z W
    PAW > scan 30 z>10
    PAW > scan 30 z>10 ! ! ! z abs(x) y+z x func.for
          where func.for is a COMIS function returning an expression
          of the original variables. This function func.for may be
          generated automatically by the PAW command:
    PAW > uwfunc 30 func.for
\end{verbatim}

\ENDCMD

\DEFCMD{N}{LOOP}{NTUPLE}{LOOP}{ idn uwfunc [ nevent ifirst ]}

\BEGARG
\DEFARG{IDN}{C}{Identifier of Ntuple}{}
\DEFARG{UWFUNC}{C}{Selection function or cut identifier}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\ENDARG

   \par
Invoke the selection function UWFUNC for each event starting at event 
   IFIRST.  In UWFUNC, the user can fill one or several histograms previously 
   booked.  The loop will be terminated if UWFUNC returns a negative value.  
   For more information about UWFUNC, see command NTUPLE/PLOT.  

\ENDCMD

\DEFCMD{N}{MERGE}{NTUPLE}{MERGE}{ idn1 idn2 [ uwfunc nevent ifirst ]}

\BEGARG
\DEFARG{IDN1}{C}{Identifier of first Ntuple}{}
\DEFARG{IDN2}{C}{Identifier of second Ntuple}{}
\DEFARG{UWFUNC}{C}{Selection function or cut identifier}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\ENDARG

   \par
Merge two Disk-Resident Row-Wise-Ntuples.  Invoke the selection function 
   UWFUNC for each of the NEVENT events starting at event IFIRST of Ntuple 
   IDN1.  Suppose you have 4 files containing Ntuple ID=10 and you want to 
   merge the 4 files into the file 4, the sequence is:  
\begin{verbatim}
    PAW >Histo/file 1 file1
    PAW >Histo/file 2 file2
    PAW >Histo/file 3 file3
    PAW >Histo/file 4 file4 1024 U
    PAW >Ntuple/Merge //lun1/10 //lun4/10
    PAW >Ntuple/Merge //lun2/10 //lun4/10
    PAW >Ntuple/Merge //lun3/10 //lun4/10
    PAW >Ntuple/plot 10.x .........
\end{verbatim}
   \par
Only the events with UWFUNC\KET{}0 are appended to IDN2. IDN2 may be empty. 
   Note that the Ntuple variables may be redefined inside UWFUNC.  For more 
   information about UWFUNC, see command NTUPLE/PLOT.  Note that this command 
   cannot be used for memory resident ntuples or CWNs.  Use instead the 
   command HMERGE.  

\ENDCMD

\DEFCMD{N}{PROJEC}{NTUPLE}{PROJECT}{ idh idn [ uwfunc nevent ifirst ]}

\BEGARG
\DEFARG{IDH}{C}{Identifier of histogram to fill}{}
\DEFARG{IDN}{C}{Identifier of Ntuple}{}
\DEFARG{UWFUNC}{C}{Selection function or cut identifier}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\ENDARG

   \par
Project an Ntuple onto a 1-Dim or 2-Dim histogram, possibly using a 
   selection function or predefined cuts.  IDN may be given as IDN or IDN.X , 
   IDN.Y\%X , IDN.1, IDN.2\%1.  Y\%X means variable Y of Ntuple IDN versus 
   variable X.  For more information about UWFUNC, see command NTUPLE/PLOT.  
   The histogram IDH is not reset before filling. This allows several PROJECTs 
   from different Ntuples.  

\ENDCMD

\DEFCMD{N}{READ}{NTUPLE}{READ}{ idn fname [ format opt nevent match ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{FORMAT}{C}{Format}{ D='*'}
\DEFARG{OPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=1000000}
\DEFARG{MATCH}{C}{Matching pattern}{ D=\EMPTY{}}
\ENDARG

   \par
Read Ntuple values from the alphanumeric file FNAME with the format 
   specifications in FORMAT.  

   \par
This command works for row wise Ntuple only.  

   \par
Before executing this command, the Ntuple IDN must have been created with 
   the command Ntuple/Create.  

   \par
MATCH is used to specify a pattern string, restricting the Ntuple filling 
   only to the records in the file which verify the pattern. The possible 
   patterns are:  

\begin{verbatim}
     /string/      match a string (starting in column 1)
    -/string/      do not match a string (starting in column 1)
     /string/(n)   match a string, starting in column n
     /string/(*)   match a string, starting at any column
\end{verbatim}
\ENDVERB
   \par
Example:  
\begin{verbatim}
       H/del *
       Appl Data ntmatch.dat
        101. 201. 301.   C
        102. 202. 302.
        103. 203. 303.   C
        104. 204. 304.   C
        105. 205. 305.
        106. 206. 306.
        107. 207. 307.
        108. 208. 308.
        109. 209. 309.
       ntmatch.dat
       Nt/Create 4 'Test of Match' 3 ! ! Xmatch Ymatch Zmatch
       Nt/Read 4 ntmatch.dat ! ! ! -/C/(*)
       Nt/SCAN 4
\end{verbatim}
   \par
In this macro all the lines with a C at the end are not read.  

\ENDCMD

\DEFCBIG{N}{PLOT}{NTUPLE}{PLOT}{ idn [ uwfunc nevent ifirst nupd option idh ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{UWFUNC}{C}{Selection function}{ D='0'}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\DEFARG{NUPD}{I}{Frequency to update histogram}{ D=100000000}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\DEFARG{IDH}{I}{Identifier of histogram to fill}{ D=1000000}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of IDN to last plotted ntuple.
}
\DEFOPT{B}{\par
Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel or cell.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\DEFOPT{U}{\par
Update channels modified since last call.
}
\DEFOPT{E}{\par
Compute (HBARX) and draw error bars with current marker.
}
\DEFOPT{A}{\par
Axis labels and tick marks are not drawn.
}
\DEFOPT{\EMPTY}{\par
Draw the ntuple as an histogram.
}
\DEFOPT{PROF}{\par
Fill a Profile histogram (mean option).
}
\DEFOPT{PROFS}{\par
Fill a Profile histogram (spread option).
}
\DEFOPT{PROFI}{\par
Fill a Profile histogram (integer spread option).
}
\ENDOPT

   \par
Project and plot an Ntuple as a (1-Dim or 2-Dim) histogram with automatic 
   binning (ID=1000000), possibly using a selection algorithm. See parameter 
   CHOPT in command HISTO/PLOT to have more details on the possible OPTION.  
\begin{verbatim}
    IDN may be given as IDN
                        IDN.X
                        IDN.Y%X
                        IDN.1
                        IDN.2%1
                        IDN.expression1
                        IDN.expression1%expression2
\end{verbatim}
   \par
Y\%X means a scatter-plot Y(I) versus X(I) where I is the event number.  
   2\%1 means a scatter-plot variable 2 versus variable 1.  In this example, X 
   and Y are the names of the variables 1 and 2 respectively.  Expression 1 is 
   any numerical expression of the Ntuple variables.  It may include a call to 
   a COMIS function.  
\begin{verbatim}
    UWFUNC may have the following forms:
    1- UWFUNC='0' or missing (only IDN given). No selection is applied.
    2- UWFUNC is a CUT or combination of valid CUTS created by the
       command NTUPLE/CUTS. Ex:
              UWFUNC=$1            means use cut $1
              UWFUNC=$1.AND.$2
              UWFUNC=.NOT.($1.AND.$2)
              UWFUNC=($1.OR.$2).AND.$3
    3- UWFUNC is a FORTRAN expression
       Ex:    X>3.14.AND.(Y<Z+3.15)
    4- UWFUNC is a variable name or an arithmetic expression
       Ex:   NT/PLOT 30.X Y  weight of each event is variable Y
             NT/PLOT 30.X X**2+Y**2
    5- UWFUNC is the name of a selection function in a text file with
       the name UWFUNC.FTN, UWFUNC.FOR, UWFUNC FORTRAN (Apollo, VAX, IBM).
\end{verbatim}
   \par
The command UWFUNC may be used to generate automatically this function.  
   For example if IDN=30 is an Ntuple with 3 variables per event and 10000 
   events, then 
\begin{verbatim}
       NTUPLE/PLOT 30.X SELECT.FOR
\end{verbatim}
   \par
will process the 10000 events of the Ntuple IDN=30. For each event, the 
   function SELECT is called. It returns the weight of the event.  Example:  
\begin{verbatim}
       FUNCTION SELECT(X)
       DIMENSION X(3)
       IF(X(1)**1+X(2)**2.LT.1.5)THEN
          SELECT=0.
       ELSE
          SELECT=1.
       ENDIF
       END
\end{verbatim}
   \par
The file SELECT.FOR (VAX), SELECT.FTN (Apollo) or SELECT FORTRAN (IBM) can 
   be edited from PAW using the command EDIT. Note that if the suffix (.FTN, 
   .FORTRAN or .FOR) is omitted, then COMIS will start from the precompiled 
   version in memory and not from the file. Results of a selection can be 
   saved in a MASK (See NTUPLE/MASK).  
\begin{verbatim}
    Ex: NT/PLOT 30.X Z<0.4>>MNAME(4)
        means mark bit 4 in mask MNAME for all events satisfying
        the condition Z<0.4
\end{verbatim}
   \par
A MASK may also be given as input to a selection expression.  
\begin{verbatim}
    Ex:  NT/PLOT 30.X MNAME(4).and.Z<0.4
         means all events satisfying bit 4 of MNAME AND Z<0.4
\end{verbatim}
   \par
It is possible to plot expressions of the original variables.  
\begin{verbatim}
    Ex 1:  NT/PLOT 30.SIN(X)%SQRT(Y**2+Z**2)  Z<0.4
        plots a scatter-plot of variable U versus V for all events
        satisfying the condition Z<0.4. U and V are defined as being
        U=SIN(X) and V=SQRT(X**2+Y**2)
    Ex 2:  NT/PLOT 30.FUNC.FTN(X)%(SIN(Y)+3.)  Z<0.2.and.TEST.FTN>6
        plots a scatter-plot of variable U versus V for all events
        satisfying the condition (Z<0.2 and the result of the COMIS
        function TEST.FTN >6). U and V are defined as being
        U=Result of the COMIS function FUNC.FTN,  V=SIN(Y)+3.
\end{verbatim}
   \par
The default identifier of the histogram being filled is IDH=1000000.  At 
   the next invocation of this command, it will be overwritten.  If either 
   NEVENT or IFIRST or NUPD are negative, then the identifier of the histogram 
   being filled will be taken as IDH=-NEVENT or IDH=-IFIRST or IDH=-NUPD. IDH 
   may have been created with H/CREATE.  Before filling IDH, the contents of 
   IDH are reset if IDH already exists. Use NTUPLE/PROJECT to cumulate several 
   passes into IDH.  Note that IDH not equal to 1000000 is a convenient way to 
   force user binning.  Every NUPD events, the current status of the  
   histogram is displayed.  

\ENDCBIG

\DEFCMD{N}{CHAIN}{NTUPLE}{CHAIN}{ [ cname entry ]}

\BEGARG
\DEFARG{CNAME}{C}{Chain Name}{ D=\EMPTY{}}
\DEFARG{ENTRY}{C}{Chain Member(s) \PIPE{} -P Path}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Using the chain command one can build logical Ntuples of unlimited size.  
   The chain command creates an Ntuple chain CNAME and add member(s) ENTRY.  
   If the chain already exists the member is simply added.  More than one 
   member may be specified at a time.  A chain can contain three different 
   type of members: files, logical units and other chains. The member type is 
   deduced from the format of the member. Entries containing the characters . 
   / : ; \$ are considered to be files, entries like //LUN4 are assumed to be 
   logical units and all other type of entries are chains. Chain names must be 
   unique.  After a chain has been defined it can be traversed, by all Ntuple 
   commands (NT/PLOT, NT/PROJ, NT/LOOP), by changing the current working 
   directory to the chain: CD //CNAME.  A member may be deleted from a chain 
   by preceding it by a - sign. A complete chain can be deleted by preceding 
   the chain name by a -. All chains can be deleted by giving a - as chain 
   name. Not specifying any parameters results in the listing of all defined 
   chains. A chain tree will be printed by appending a \KET{} character to the 
   chain name.  The path of all chain members, from chain CNAME downwards, can 
   be changed by specifying a chain path. This is done by giving a chain name 
   followed by the -P option and a path specification. The chain path will be 
   pre-pended to the member names. Chains down the tree can override a path 
   specified higher up in the tree.  
\begin{verbatim}
    Examples of chain (Ntuple tree) definition:
    CHAIN   Year93  Jan Feb March April May ...
    CHAIN   Jan     Week1 Week2 Week3 Week4
    CHAIN   Week1   file1.hbook file2.hbook ...
    CHAIN   Week2   file3.hbook file4.hbook ...
    CD //Jan
    NT/PLOT 10.e     ; loop over all files in chains Week1, Week2, Week3, ...
    CD //Year93      ; loop over all files in chains Jan, Feb, March, ...
    CHAIN Year93 -P /user/delphi   ; all files from chain Year93 downward will
                                     be changed to /user/delphi/file1.hbook, 
   ...
    CHAIN Year93>    ; print the chain tree Year93
    CHAIN -Feb       ; delete chain Feb
    CHAIN Jan -file3.hbook   ; delete file3.hbook from chain Jan
\end{verbatim}

\ENDCMD

\DEFCMD{N}{DRAW}{NTUPLE}{DRAW}{ idn [ value option ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{VALUE}{C}{Isosurface value (for 3-D)}{ D='0'}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Draw a simple ntuple (1, 2 or 3 variables).  For simple ntuples, with 1, 2 
   or 3 variables per event, this command will draw a histogram with HPLOT 
   options.  If the ntuple has an associated functional representation, as the 
   result, e.g., of using SMOOTH, it will also draw the function.  No 
   selections are allowed.  

   \par
For 3-variable ntuples which have been SMOOTHed, give a VALUE for the 
   isosurface of event density.  If VALUE=0, an isosurface value half way 
   between the minimum and maximum fitted smoothing function values will be 
   used.  

\ENDCMD

\DEFCMD{N}{WAVE}{NTUPLE}{WAVE}{ idn [ lun ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{LUN}{I}{Logical unit no.}{ D=-1}
\ENDARG

   \par
Produce a formatted file suitable for Wavefront's Data Visualiser.  Only 
   for simple 3-variable ntuples which have been SMOOTHed.  A file with 
   logical unit no. LUN must previously have been opened with the FORTRAN/FILE 
   command.  

\ENDCMD

\DEFCMD{N}{CUTS}{NTUPLE}{CUTS}{ cutid [ option fname wkid ]}

\BEGARG
\DEFARG{CUTID}{C}{Cut identifier}{}
\DEFARG{OPTION}{C}{Options}{ D='P' Minus}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{WKID}{I}{Workstation identifier}{ D=1}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{G}{\par
Define a new cut CUTID using graphics input on the latest 1-Dim or 2-Dim 
projection of the Ntuple. For a 1-Dim projection, give 2 points cutmin,cutmax. 
For a 2-Dim projection, give up to 20 points to delimit the selected area. The 
polygon will automatically be closed by PAW.
}
\DEFOPT{X}{\par
Same as G but with a tracking cross cursor.
}
\DEFOPT{P}{\par
Print definition of cut CUTID.
}
\DEFOPT{-}{\par
Reset cut CUTID.
}
\DEFOPT{R}{\par
Read definition of cut CUTID from file FNAME.
}
\DEFOPT{W}{\par
Write definition of cut CUTID on file FNAME (text file).
}
\DEFOPT{D}{\par
Draw cut contour.
}
\ENDOPT

   \par
Define the CUTID with the format \$nn.  nn is an integer between 1 and 99.  
   This cut can then be used in subsequent commands NTUPLE/PLOT, PROJECT.  
\begin{verbatim}
     OPTION='expression'  allows to define the cut CUTID. For example
     the command:
      PAW > CUTS $1 X<0.8.and.Y<SQRT(X)
     defines the cut $1.
\end{verbatim}
   \par
Note that CUTID=\$0 means all cuts except for 'G' option.  When option G is 
   selected, graphical cuts are only operational for plots of the original 
   Ntuple variables, not for expressions of these variables.  WKID allows to 
   define in which window the locator is performed (option 'G' or 'X' only).  

\ENDCMD

\DEFCMD{N}{CSELEC}{NTUPLE}{CSELECT}{ [ chopt csize ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D='N'}
\DEFARG{CSIZE}{R}{Comment size}{ D=0.28}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Comment is left adjusted to the current zone
}
\DEFOPT{R}{\par
Comment is right adjusted to the current zone
}
\DEFOPT{C}{\par
Comment is centered to the current zone
}
\DEFOPT{B}{\par
Comment is drawn below the top zone line
}
\DEFOPT{N}{\par
All subsequent NTUPLE/PLOT commands will print the selection mechanism with 
the options specified in CHOPT.
}
\ENDOPT

   \par
To write selection mechanism as a comment on the picture.  By default, the 
   comment is drawn left justified above the top zone line.  Example:  
\begin{verbatim}
    CSEL          All coming NT/PLOT commands will draw a comment
                  of size CSIZE=0.28cm Left justified.
    CSEL NRB 0.4  All coming NT/PLOT commands will draw a comment
                  of size 0.4 cm Right justified Below the top line.
    CSEL  CB      Draw previous selection mechanism Centered Below
                  the top zone line.
\end{verbatim}
   \par
The Global title font (SET GFON) with precision 1 is used to draw the text. 

\ENDCMD

\DEFCMD{N}{MASK}{NTUPLE}{MASK}{ mname [ chopt number ]}

\BEGARG
\DEFARG{MNAME}{C}{Mask name}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NUMBER}{I}{Bit number}{ D=0}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Existing mask on file MNAME.MASK is attached for READ only.
}
\DEFOPT{U}{\par
Existing mask on file MNAME.MASK is attached for UPDATE.
}
\DEFOPT{N}{\par
A new mask on file MNAME.MASK is created for NUMBER events.
}
\DEFOPT{P}{\par
The comments for all active bits is printed.
}
\DEFOPT{C}{\par
Mask is closed.
}
\DEFOPT{R}{\par
Reset bit number NUMBER.If NUMBER=99, resets all bits.
}
\ENDOPT

   \par
Perform Operations with masks.  A mask is a direct-access file with the 
   name MNAME.MASK.  It must contain as many 32 bit words as there are events 
   in the associated Ntuple.  Masks are interesting when only a few events of 
   a Ntuple are selected with a time consuming selection algorithm. For 
   example if the command:  
\begin{verbatim}
      NT/PLOT 30.X  Z<0.4.AND.SELECT.FTN>>MNAME(6)
\end{verbatim}
   \par
then for all events in Ntuple 30 satisfying the condition above, the bit 6 
   in the corresponding mask words will be set. One can then use the mask as 
   selection mechanism. Example:  
\begin{verbatim}
      NT/PLOT 30.X MNAME(6)
\end{verbatim}
   \par
will produce the same results than the NT/PLOT command above, but will be 
   much faster if only a small fraction of all the events is selected.  MASKS 
   are automatically saved across PAW sessions on files.  Example:  
\begin{verbatim}
      MASK  TEST N 10000
         creates a new mask on file TEST.MASK with enough words to
         process a Ntuple with 10000 events
      MASK  TEST UP
         opens an existing mask for update and
         prints the active selection bits with explanation
\end{verbatim}

\ENDCMD

\DEFCMD{N}{UWFUNC}{NTUPLE}{UWFUNC}{ idn fname [ chopt ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Generate the FORTRAN skeleton of a selection function.
}
\DEFOPT{E}{\par
Present the selection function in the local editor.
}
\DEFOPT{P}{\par
Code to print events is generated (not valid for new Ntuples).
}
\DEFOPT{T}{\par
Names of the Ntuple variables are generated in DATA statements (not valid for 
new Ntuples).
}
\ENDOPT

   \par
To generate the FORTRAN skeleton of a selection function or the INCLUDE 
   file with the columns declaration.  

   \par
A FORTRAN function is generated if the FNAME is of the form, xxx.f, 
   xxx.for, xxx.fortran. Otherwise an INCLUDE file is generated.  Example:  If 
   Ntuple ID=30 has variable names [X,Y,Z,ETOT,EMISS,etc] then:  

   \par
NTUPLE/UWFUNC 30 SELECT.FOR   will generate the file SELECT.FOR with:  
\begin{verbatim}
         FUNCTION SELECT(XDUMMY)
         COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc
         SELECT=1.
         END
\end{verbatim}
   \par
Then using the command EDIT one can modify this file which could then look 
   something like (IDNEVT is the event number):  
\begin{verbatim}
         FUNCTION SELECT(XDUMMY)
         COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc
         IF(X**2+Y**2.GT.Z**2.OR.ETOT.GT.20.)THEN
            SELECT=1.
         ELSE
            SELECT=0.
         ENDIF
         END
\end{verbatim}
   \par
If in a subsequent command NTUPLE/PLOT, the selection function SELECT is 
   used, then:  
\begin{verbatim}
      If NTUPLE/PLOT 30.ETOT SELECT.FOR
         VIDN1=ETOT
      If NTUPLE/PLOT 30.SQRT(X**2+Y**2)%(ETOT-EMISS)
         VIDN1=ETOT-EMISS
         VIDN2=SQRT(X**2+Y**2)
\end{verbatim}
\ENDVERB
   \par
NTUPLE/UWFUNC 30 SELECT.INC will generate an include file. This include 
   file may be referenced in a selection function in the following way:  
\begin{verbatim}
         FUNCTION SELECT(XDUMMY)
         include 'select.inc'
         SELECT=1.
         IF(X.LE.Y)SELECT=0.
         END
\end{verbatim}
\ENDVERB
   \par
Note that the command UWFUNC is not required if the SELECT function has the 
   following form:  
\begin{verbatim}
         FUNCTION SELECT(XDUMMY)
         include ?
         SELECT=1.
         IF(X.LE.Y)SELECT=0.
         END
\end{verbatim}
   \par
In this case (thanks to the statement \DQUOTE{}include ?\DQUOTE{}) the 
   include file will be generated automatically with the name 
   \DQUOTE{}comis.inc\DQUOTE{}.  

\ENDCMD

\DEFCMD{N}{LINTRA}{NTUPLE}{LINTRA}{ idn [ chopt nevent ifirst nvars varlis ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\DEFARG{NVARS}{I}{Number of the most significant variables }{ D=20 R=0:20}
\DEFARG{VARLIS}{C}{Names of the NVARS most significant variables }{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{N}{\par
The variables are normalized. This option is useful in the case the ranges of 
variables are very different
}
\DEFOPT{P}{\par
Print more results about the analysis
}
\ENDOPT

   \par
Data reduction on Ntuple.  The method used is the PRINCIPAL COMPONENTS 
   ANALYSIS.  The Principal Components Analysis method consists in applying a 
   linear transformation to the original variables of a ntuple.  This 
   transformation is described by an orthogonal matrix and is equivalent to a 
   rotation of the original space to a new set of coordinates vectors, which 
   hopefully provide easier identification and dimensionality reduction. This 
   matrix is real positive definite and symmetric and has all its eigenvalues 
   greater than zero.  Among the family of all complete orthonormal bases, the 
   basis formed by the eigenvectors of the covariance matrix and belonging to 
   the largest eigenvalues corresponds to the most significant features for 
   the description of the original ntuple.  Reduction of the variables for 
   NEVENT events starting at IFIRST The default is to take all the 20 first 
   variables.  This command creates a file : -\KET{} XTOXSI.FORTRAN or 
   xtoxsi.for,xtoxsi.ftn.  This file contains a Fortran function which 
   computes the new variables.  These new variables can be visualized in PAW 
   with for example:  
\begin{verbatim}
    PAW > Ntuple/plot id.xtoxsi.ftn(1)
    PAW > Ntuple/plot id.xtoxsi.ftn(1)%xtoxsi.ftn(3)
\end{verbatim}

\ENDCMD

\DEFCMD{N}{VMEM}{NTUPLE}{VMEM}{ [ mxsize ]}

\BEGARG
\DEFARG{MXSIZE}{I}{Maximum size of dynamic memory buffer in MBytes}{ D=-1 R=-2:128}
\ENDARG

   \par
Change or show the size of the dynamic memory buffer used to store Ntuple 
   columns during Ntuple analysis. The default is 10 MB. Giving a value of 0 
   turns the buffer facility off. The upper limit is 128 MB, but be sure you 
   have enough swap space and realize that when the buffer is swapped to disk 
   you loose part of the benefit of the buffer facility (which is to reduce 
   the number of disk accesses). Omitting the argument or specifying -1 will 
   show you the current upper limit and used and free space. Giving -2 shows 
   which columns are currently stored in memory.  

\ENDCMD
\DEFMENU{0}{GRAPHICS}{GRAPHICS}
\ifMENUtext
   \par
Interface to the graphics packages HPLOT and HIGZ.  


\fi

\DEFCMD{G}{SET}{GRAPHICS}{SET}{ [ chatt value ]}

\BEGARG
\DEFARG{CHATT}{C}{Attribute name}{ D='SHOW'}
\DEFARG{VALUE}{R}{Attribute value}{ D=0}
\ENDARG

   \par
Set a specific HPLOT attribute.  If CHATT='SHOW', print defaults and 
   current values for all attributes.  If CHATT='*', restore default values 
   for all attributes.  If VALUE=0, the attribute is set to its default value. 

\begin{verbatim}
 +-----------------------------------------------------------------------------+
 |                       HPLSET : Current values in use                        |
 +------------+---------------+---------------+--------------------------------+
 |  Parameter | Current value | Default value |          Explanation           |
 +------------+---------------+---------------+--------------------------------+
 |    XSIZ    |     20.00     |     20.00     | Size along X                   |
 |    YSIZ    |     20.00     |     20.00     | Size along Y                   |
 |    XMGL    |      2.00     |      2.00     | X MarGin Left                  |
 |    XMGR    |      2.00     |      2.00     | X MarGin Right                 |
 |    XLAB    |      1.40     |      1.40     | distance y axis to LABel       |
 |    XVAL    |       .40     |       .40     | distance y axis to axis VALues |
 |    XTIC    |       .30     |       .30     | X axis TICk marks length       |
 |    YMGL    |      2.00     |      2.00     | Y MarGin Low                   |
 |    YMGU    |      2.00     |      2.00     | Y MarGin Up                    |
 |    YLAB    |       .80     |       .80     | distance x axis to LABel       |
 |    YVAL    |       .20     |       .20     | distance x axis to axis VALues |
 |    YTIC    |       .30     |       .30     | Y axis TICk marks length       |
 |    YNPG    |       .60     |       .60     | Y position for Number of PaGe  |
 |    YGTI    |      1.50     |      1.50     | Y position of Global TItle     |
 |    YHTI    |      1.20     |      1.20     | Y position of Histogram TItle  |
 |    SMGR    |       .00     |       .00     | Stat MarGin Right (%)          |
 |    SMGU    |       .00     |       .00     | Stat MarGin Up (%)             |
 |    KSIZ    |       .28     |       .28     | Hershey charact. (HPLKEY) SIZe |
 |    GSIZ    |       .28     |       .28     | Global title SIZe              |
 |    TSIZ    |       .28     |       .28     | histogram Title SIZe           |
 |    ASIZ    |       .28     |       .28     | Axis label SIZe                |
 |    CSIZ    |       .28     |       .28     | Comment and stat SIZe          |
 |    PSIZ    |       .28     |       .28     | Page number SIZe               |
 |    VSIZ    |       .28     |       .28     | axis Values SIZe               |
 |    SSIZ    |       .28     |       .28     | aSterisk SIZe (for functions)  |
 |    2SIZ    |       .28     |       .28     | scatter-plot & table char. SIZe|
 |    XWIN    |      2.00     |      2.00     | X space between WINdows        |
 |    YWIN    |      2.00     |      2.00     | Y space between WINdows        |
 |    HMAX    |       .90     |       .90     | Histogram MAXimum for scale    |
 |    PASS    |      1.00     |      1.00     | number of PASS for characters  |
 |    CSHI    |       .03     |       .03     | Character SHIft between 2 pass |
 |    BARO    |       .25     |       .25     | BAR histogram Offset (%)       |
 |    BARW    |       .50     |       .50     | BAR histogram Width (%)        |
 |    DASH    |       .15     |       .15     | length of basic DASHed segment |
 |    DMOD    |         1     |         1     | Dash MODe (or type) for lines  |
 |    GRID    |         3     |         3     | GRID line type                 |
 |    DATE    |         2     |         2     | DATE position                  |
 |    FILE    |         1     |         1     | FILE name position             |
 |    STAT    |      1111     |      1111     | STAT values to be plotted      |
 |    FIT     |       101     |       101     | FIT values to be plotted       |
 |    HTYP    |         0     |         0     | Histogram  fill area TYPe      |
 |    BTYP    |         0     |         0     | Box fill area TYPe             |
 |    PTYP    |         0     |         0     | Picture fill area TYPe         |
 |    FTYP    |         0     |         0     | Function fill area TYPe        |
 |    HCOL    |       .00     |      1.00     | Histogram fill area COLor      |
 |    BCOL    |      1.00     |      1.00     | Box fill area and shading COLor|
 |    PCOL    |         1     |         1     | Picture fill area COLor        |
 |    FCOL    |         1     |         1     | Function fill area COLor       |
 |    XCOL    |         1     |         1     | X axis COLor                   |
 |    YCOL    |         1     |         1     | Y axis COLor                   |
 |    HWID    |         1     |         1     | Histogram line WIDth           |
 |    BWID    |         1     |         1     | Box line WIDth                 |
 |    PWID    |         1     |         1     | Picture line WIDth             |
 |    FWID    |         1     |         1     | Function line WIDth            |
 |    XWID    |         1     |         1     | X ticks WIDth                  |
 |    YWID    |         1     |         1     | Y ticks WIDth                  |
 |    TFON    |         2     |         2     | Text (and Title) FONT and PREC |
 |    GFON    |         2     |         2     | Global title FONT and PREC     |
 |    VFON    |         2     |         2     | axis Values FONT and PREC      |
 |    LFON    |         2     |         2     | axis Labels FONT and PREC      |
 |    CFON    |         2     |         2     | Comment FONT and PREC          |
 |    NDVX    |  10510.00     |  10510.00     | Number of DIVisions for X axis |
 |    NDVY    |  10510.00     |  10510.00     | Number of DIVisions for Y axis |
 |    NDVZ    |  10510.00     |  10510.00     | Number of DIVisions for Z axis |
 |    FPGN    |         1     |         1     | First PaGe Number              |
 |    ERRX    |       .50     |       .50     | ERRor on X (% of bin width)    |
 |    1DEF    |         0     |         0     | 1D Plot Option                 |
 |    2DEF    |         0     |         0     | 2D Plot Option                 |
 +------------+---------------+---------------+--------------------------------+
 +-----------------------------------------------------------------------------+
 |                        IGSET : Current values in use                        |
 +-------------+---------------+---------------+-------------------------------+
 |  Parameter  | Current value | Default value |          Explanation          |
 +-------------+---------------+---------------+-------------------------------+
 |    FAIS     |       0       |        0      | Fill area interior style      |
 |    FASI     |       1       |        1      | Fill area style index         |
 |    LTYP     |       1       |        1      | Line type                     |
 |    BASL     |        .150   |         .010  | Basic segment length (NDC)    |
 |    LWID     |       1.000   |        1.000  | Line width                    |
 |    MTYP     |       1       |        1      | Marker type                   |
 |    MSCF     |       1.000   |        1.000  | Marker scale factor           |
 |    PLCI     |       1       |        1      | Polyline color index          |
 |    PMCI     |       1       |        1      | Polymarker color index        |
 |    FACI     |       1       |        1      | Fill area color index         |
 |    TXCI     |       1       |        1      | Text color index              |
 |    TXAL     |       0  0    |        0  0   | Text alignment                |
 |    CHHE     |        .280   |         .010  | Character height              |
 |    TANG     |        .000   |         .000  | Text angle                    |
 |    TXFP     |       0  2    |        0  2   | Text font and precision       |
 |    PICT     |       1       |        1      | Current automatic number      |
 |    BORD     |       0       |        0      | Border flag                   |
 |    PASS     |       1       |        1      | Number of pass in IGTEXT      |
 |    CSHI     |        .030   |         .020  | IGTEXT shift                  |
 |    LASI     |        .018   |         .018  | Label axis size               |
 |    LAOF     |        .013   |         .013  | Label axis offset             |
 |    TMSI     |        .019   |         .019  | Tick marks size               |
 |    AWLN     |        .000   |         .000  | Axis wire lenght              |
 |    BARO     |        .250   |         .250  | Offset of IGHIST (IGRAPH) bars|
 |    BARW     |        .500   |         .500  | Width of IGHIST (IGRAPH) bars |
 |    NCOL     |       8       |        8      | Number of COLors              |
 |    CLIP     |       1       |        1      | Clipping mode                 |
 |    NLIN     |      40       |       40      | Number of line for 3D shapes  |
 |    AURZ     |       0       |        0      | Automatic saving flag         |
 |    DIME     |       2       |        2      | Dimension used (2D or 3D)     |
 +-------------+---------------+---------------+-------------------------------+
\end{verbatim}
\ENDCMD

\DEFCMD{G}{OPTION}{GRAPHICS}{OPTION}{ [ choptn ]}

\BEGARG
\DEFARG{CHOPTN}{C}{Option name}{ D='SHOW'}
\ENDARG

   \par
Set general plotting options for HPLOT.  If CHOPTN='SHOW' print all current 
   and default options.  If CHOPTN='*', restore all default options.  

\begin{verbatim}
 +-----------------------------------------------------------------------------+
 |                            HPLOPT : Option values                           |
 +-------------+-------------+---------------+---------------------------------+
 |   Current   |   Default   |  Alternative  |           Explanation           |
 +-------------+-------------+---------------+---------------------------------+
 |     VERT    |     VERT    |      HORI     | VERTical or HORIzontal          |
 |             |             |               | orientation of paper            |
 |     NEAH    |     NEAH    |      EAH      | Error bars And Histogram are    |
 |             |             |               | plotted (if both are present)   |
 |     NCHA    |     NCHA    |      CHA      | scatter plots drawn with dots   |
 |             |             |               | (NCHA) or 1 char./bin (CHA)     |
 |     NAST    |     NAST    |      AST      | functions drawn with (AST)      |
 |             |             |               | or without (NAST) asterisks     |
 |     SOFT    |     SOFT    |      HARD     | SOFTware or HARDware characters |
 |             |             |               | are used                        |
 |     NSQR    |     NSQR    |      SQR      | size is set to the largest      |
 |             |             |               | square (SQR)                    |
 |     HTIT    |     HTIT    |      UTIT     | HBOOK TITle (HTIT)              |
 |             |             |               | or User TITle (UTIT) is printed |
 |     TAB     |     TAB     |      NTAB     | table printed as TABles (TAB)   |
 |             |             |               | or scatter plots (NTAB)         |
 |     BOX     |     BOX     |      NBOX     | a box is (BOX) or is not (NBOX) |
 |             |             |               | drawn around picture            |
 |     NTIC    |     NTIC    |      TIC      | cross-wires are drawned (TIC)   |
 |             |             |               | or not (NTIC) on each plot      |
 |     NSTA    |     NSTA    |      STA      | STAtistics are printed (STA)    |
 |             |             |               | or not (NSTA) on each plot      |
 |     NFIT    |     NFIT    |      FIT      | FIT parameters are printed      |
 |             |             |               | or not (NFIT) on each plot      |
 |     NZFL    |     NZFL    |      ZFL      | picture is (ZFL) or is not      |
 |             |             |               | (NZFL) put in Z data base       |
 |     NPTO    |     NPTO    |      PTO      | PTO (Please Turn Over)          |
 |             |             |               | (NPTO)                          |
 |     NBAR    |     NBAR    |      BAR      | BAR charts for histogram        |
 |             |             |               | (NBAR)                          |
 |     DVXR    |     DVXR    |      DVXI     | Integer (DVXI) or Real (DVXR)   |
 |             |             |               | divisions for X axis            |
 |     DVYR    |     DVYR    |      DVYI     | Integer (DVYI) or Real (DVYR)   |
 |             |             |               | divisions for Y axis            |
 |     NGRI    |     NGRI    |      GRID     | GRID or not grid (NGRI)         |
 |             |             |               | on X and Y axis                 |
 |     NDAT    |     NDAT    |      DATE     | DATE is printed (DATE)          |
 |             |             |               | or not (NDAT) on each plot      |
 |     NFIL    |     NFIL    |      FILE     | FILE name is printed (FILE)     |
 |             |             |               | or not (NFIL) on each plot      |
 |     A4      |     A4      |      A0/6     | page format for the plotter     |
 |             |             |               | (A0,A1,A2,A3,A4,A5,A6)          |
 |     NOPG    |     NOPG    |      P        | page number is (P   )           |
 |             |             |               | or is not (NOPG) printed        |
 |     LINY    |     LINY    |      LOGY     | LINear or LOGarithmic scale     |
 |             |             |               | in Y                            |
 |     LINX    |     LINX    |      LOGX     | LINear or LOGarithmic scale     |
 |             |             |               | in X                            |
 |     LINZ    |     LINZ    |      LOGZ     | LINear or LOGarithmic scale     |
 |             |             |               | in Z (Lego or Surface)          |
 |     NHST    |     HSTA    |      HNST     | Filling statistics (HSTA)       |
 |             |             |               | (HNST)                          |
 +-------------+-------------+---------------+---------------------------------+
\end{verbatim}
\ENDCMD

\DEFCBIG{G}{METAFI}{GRAPHICS}{METAFILE}{ [ lun metafl chmeta ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ D=0}
\DEFARG{METAFL}{I}{Metafile ID}{ D=0}
\DEFARG{CHMETA}{C}{Metafile name}{ D=\EMPTY{}}
\ENDARG

   \par
Set the metafile logical unit and metafile type.  This command controls the 
   destination of the subsequent graphics output.  Example:  
\begin{verbatim}
    LUN =-10 output only on metafile opened on unit 10;
    LUN =  0 output only on screen;
    LUN = 10 output on both screen and metafile opened on unit 10;
\end{verbatim}
   \par
Use the command FORTRAN/FILE to open a new file, FORTRAN/CLOSE to close it. 
   Note that PAW opens the file PAW.METAFILE on the unit 10 at initialisation 
   time.  
\begin{verbatim}
    METAFL=   4 Appendix E GKS.
    METAFL=-111 HIGZ/PostScript (Portrait).
    METAFL=-112 HIGZ/PostScript (Landscape).
    METAFL=-113 HIGZ/Encapsulated PostScript.
    METAFL=-114 HIGZ/PostScript Color (Portrait).
    METAFL=-115 HIGZ/PostScript Color (Landscape).
    METAFL=-777 HIGZ/LaTex Encapsulated.
    METAFL=-778 HIGZ/LaTex.
\end{verbatim}
   \par
The PostScript metafile types have the following format:  
\begin{verbatim}
                      -[Format][Nx][Ny][Type]
    Where:
\end{verbatim}
   \par
[Format] Is an integer between 0 and 99 which defines the format of the 
\begin{verbatim}
            paper. For example if Format=3 the paper is in the standard
            A3 format. Format=4 and Format=0 are the same and
            define an A4 page.
            The A0 format is selected by Format=99.
            The US format Letter is selected by Format=100.
            The US format Legal is selected by Format=200.
            The US format Ledger is selected by Format=300.
\end{verbatim}
   \par
[Nx, Ny] Specify respectively the number of zones on the x and y axis.  
\begin{verbatim}
            Nx and Ny are integers between 1 and 9.
\end{verbatim}
   \par
[Type]   Can be equal to:  
\begin{verbatim}
            1: Portrait mode with a small margin at the bottom of the page.
            2: Landscape mode with a small margin at the bottom of the page.
            4: Portrait mode with a large margin at the bottom of the page.
            5: Landscape mode with a large margin at the bottom of the page.
               The large margin is useful for some PostScript printers (very
               often for the colour printers) as they need more space to grip
               the paper for mechanical reasons. Note that some PostScript
               colour printers can also use the so called "special A4" format
               permitting the full usage of the A4 area; in this case larger
               margins are not necessary and {\tt Type}=1 or 2 can be used.
            3: Encapsulated PostScript. This Type permits the generation of
               files which can be included in other documents, for example
               in LaTeX files. Note that with this Type, Nx and Ny must always
               be equal to 1, and Format has no meaning. The size of the 
   picture
               must be specified by the user via the SIZE command. Therefore
               the workstation type for Encapsulated PostScript is -113. For
               example if the name of an encapsulated PostScript file is
               example.eps, the inclusion of this file into a LaTeX file will
               be possible via (in the LaTeX file):
                       \begin{figure}
                        \epsffile{example.eps}
                        \caption{Example of Encapsulated PostScript in LaTeX.}
                        \label{EXAMPLE}
                       \end{figure}
\end{verbatim}
   \par
With Type=1,2,4 and 5 the pictures are centered on the page, and the usable 
   area on paper is proportional to the dimensions of A4 format.  Examples:  
   -111 or -4111 defines an A4 page not divided.  -6322 define an A6 landscape 
   page divided in 3 columns and 2 rows.  
\begin{verbatim}
                       +-------+-------+-------+
                       |   1   |   2   |   3   |
                       +-------+-------+-------+
                       |   4   |   5   |   6   |
                       +-------+-------+-------+
\end{verbatim}
   \par
The first picture  will be drawn  in the area 1. After each clear the 
   screen, the graphics output will appear in the next area in the order 
   defined above.  If a page is filled, a new page is used with the same grid. 
   Note that empty pages are not printed in order to save paper.  Ignoring 
   formats smaller than A12, the total number of possible different PostScript 
   workstation types is: 4x9x9x13+1 = 4213 ! Note: this command open a 
   metafile on the workstation identifier number 2.  

\ENDCBIG

\DEFCMD{G}{WORKST}{GRAPHICS}{WORKSTATION}{ iwkid [ chopt iwtyp ]}

\BEGARG
\DEFARG{IWKID}{I}{Workstation ID}{ D=1 Loop}
\DEFARG{CHOPT}{C}{Options}{ D='OA'}
\DEFARG{IWTYP}{I}{Workstation type}{ D=1}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{O}{\par
Open a new workstation
}
\DEFOPT{C}{\par
Close a workstation
}
\DEFOPT{A}{\par
Activate a workstation
}
\DEFOPT{D}{\par
Deactivate a workstation
}
\DEFOPT{L}{\par
Give the list of open workstations
}
\ENDOPT

   \par
To create/delete workstations or change status.  
\begin{verbatim}
       IWKID > 0  Do the action specified by CHOPT on the
                  workstation identified by IWKID.
       IWKID = 0  Do the action specified by CHOPT on all
                  workstations.
       IWKID < 0  Do the action specified by CHOPT on the
                  workstation identified by -IWKID and the
                  complementary action on all the others.
\end{verbatim}
   \par
Note: IWKID should not be equal to 2 if a metafile is actived because the 
   command METAFILE use it already.  

\ENDCMD
\DEFMENU{1}{MISC}{GRAPHICS/MISC}
\ifMENUtext
   \par
Miscellaneous HPLOT functions.  


\fi

\DEFCMD{GM}{NEXT}{GRAPHICS/MISC}{NEXT}{}

   \par
Clear the screen.  Initialize a new HIGZ picture if option ZFL or ZFL1 has 
   been selected.  Select the Normalisation Transformation number 1 (cm).  

\ENDCMD

\DEFCMD{GM}{CLR}{GRAPHICS/MISC}{CLR}{}

   \par
Clear the screen.  

\ENDCMD

\DEFCMD{GM}{LOCATE}{GRAPHICS/MISC}{LOCATE}{ [ ntpri chopt wkid ]}

\BEGARG
\DEFARG{NTPRI}{C}{Transformation with highest priority}{ D='-1'}
\DEFARG{CHOPT}{C}{Options}{ D='R'}
\DEFARG{WKID}{I}{Workstation identifier}{ D=1}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{R}{\par
Request mode is used to locate the points (default)
}
\DEFOPT{S}{\par
Sample mode is used to locate the points
}
\DEFOPT{I}{\par
Integrate an histogram between 2 bins
}
\DEFOPT{+}{\par
Use the tracking cross (default is cross-hair)
}
\DEFOPT{T}{\par
The output is done on the terminal.
}
\ENDOPT

   \par
Locate points on the screen using the graphics cursor and output 
   coordinates on terminal.  Control is returned when the BREAK (right) mouse 
   button is clicked (or CRTL/E) or when 20 points are located.  The optional 
   parameter NTPRI may be specified to locate a point in the specific 
   transformation number NTPRI.  NTPRI=-1 (default) means that all the 
   histogram transformation numbers (10, 20, etc.) have priority on 
   transformation number 1.  WKID allows to define in which window the locator 
   is performed.  
\begin{verbatim}
    Note: With the Motif version of PAW the locator is automatically
\end{verbatim}
   \par
invoke when the mouse cursor enter the window.  

\ENDCMD

\DEFCMD{GM}{VLOCAT}{GRAPHICS/MISC}{VLOCATE}{ vecx vecy [ chopt ntpri wkid ]}

\BEGARG
\DEFARG{VECX}{C}{Vector for coordinates X}{}
\DEFARG{VECY}{C}{Vector for coordinates Y}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{} Minus}
\DEFARG{NTPRI}{I}{Transformation with highest priority}{ D=-1}
\DEFARG{WKID}{I}{Workstation identifier}{ D=1}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Use the cross-hair
}
\DEFOPT{+}{\par
Use the tracking cross
}
\DEFOPT{-}{\par
Use the rubber line
}
\DEFOPT{L}{\par
Connect points by a polyline
}
\DEFOPT{P}{\par
Draw the current polymarker at each point
}
\DEFOPT{*}{\par
Draw a * at each point
}
\DEFOPT{S}{\par
Sample mode is used. Allows to see the coordinates of point before clicking
}
\ENDOPT

   \par
Locate a set of points using the graphics cursor.  Return corresponding 
   coordinates in vectors X and Y.  If vectors X or Y do not exist, they are 
   automatically created.  Control is returned when the point is outside 
   picture limits or when the BREAK (right) mouse button is clicked (or 
   CRTL/E).  The optional parameter NTPRI may be specified to locate a point 
   in the specific transformation number NTPRI (see LOCATE).  WKID allows to 
   define in which window the locator is performed.  

\ENDCMD

\DEFCMD{GM}{HMOVE}{GRAPHICS/MISC}{HMOVE}{}

   \par
Change the contents of a histogram channel using the cursor.  Position the 
   cursor to the channel to be changed, trigger graphics input, position the 
   cursor to the new channel value (a rubber band box is used to visualize the 
   change), trigger graphics input to fix the new value.  

\ENDCMD
\DEFMENU{1}{VIEWING}{GRAPHICS/VIEWING}
\ifMENUtext
   \par
To define Normalisation transformations.  Either automatically (ZONE and 
   SIZE) or 'by hand' (SVP, SWN and SELNT).  


\fi

\DEFCMD{GV}{ZONE}{GRAPHICS/VIEWING}{ZONE}{ [ nx ny ifirst chopt ]}

\BEGARG
\DEFARG{NX}{I}{Number of divisions along X}{ D=1}
\DEFARG{NY}{I}{Number of divisions along Y}{ D=1}
\DEFARG{IFIRST}{I}{First division number}{ D=1}
\DEFARG{CHOPT}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{}
\DEFOPT{S}{\par
Redefine zones on current picture
}
\DEFOPT{\EMPTY}{\par
Define the zones for all subsequent pictures.
}
\ENDOPT

   \par
Subdivide the picture into NX by NY zones, starting at zone IFIRST (count 
   along X first).  

   \par
Note that the command ZONE doesn't define the normalisation transformations 
   (see SWN, SVP and SELNT). They are define only when commands like H/PLOT, 
   NULL etc .. are performed.  

\ENDCMD

\DEFCMD{GV}{SIZE}{GRAPHICS/VIEWING}{SIZE}{ [ xsize ysize ]}

\BEGARG
\DEFARG{XSIZE}{R}{Size along X}{ D=20.}
\DEFARG{YSIZE}{R}{Size along Y}{ D=20.}
\ENDARG

   \par
Set the size of the picture.  On the terminal, the pictures will have the 
   ratio YSIZE/XSIZE, and, if a metafile is produced, pictures will be YSIZE 
   by XSIZE cm.  This command sets the parameters for the normalisation 
   transformation number 1 to [0-XSIZE], [0-YSIZE].  

\ENDCMD

\DEFCMD{GV}{SVP}{GRAPHICS/VIEWING}{SVP}{ nt x1 x2 y1 y2}

\BEGARG
\DEFARG{NT}{I}{Normalisation transformation number}{}
\DEFARG{X1}{R}{Low X  of viewport in NDC}{ D=0 R=0:1}
\DEFARG{X2}{R}{High X of viewport in NDC}{ D=1 R=0:1}
\DEFARG{Y1}{R}{Low Y  of viewport in NDC}{ D=0 R=0:1}
\DEFARG{Y2}{R}{High Y of viewport in NDC}{ D=1 R=0:1}
\ENDARG

   \par
Set the viewport of the normalisation transformation NT in the Normalized 
   Device Coordinates (NDC). Note that the command SELNT should be invoke in 
   order to validate the viewport parameters.  

   \par
This command, and also SWN, should not be used for a common PAW usage 
   (H/PLOT, GRAPH etc ...). Commands like ZONE and SIZE should be used.  

\ENDCMD

\DEFCMD{GV}{SWN}{GRAPHICS/VIEWING}{SWN}{ nt x1 x2 y1 y2}

\BEGARG
\DEFARG{NT}{I}{Normalize transformation number}{}
\DEFARG{X1}{R}{Low X  of window in WC}{ D=0}
\DEFARG{X2}{R}{High X of window in WC}{ D=20}
\DEFARG{Y1}{R}{Low Y  of window in WC}{ D=0}
\DEFARG{Y2}{R}{High Y of window in WC}{ D=20}
\ENDARG

   \par
Set the window of the normalisation transformation NT in World Coordinates 
   (WC). Note that the command SELNT should be invoke in order to validate the 
   window parameters.  

   \par
Example:  
\begin{verbatim}
       Nul 0 1 -1 1      | Draw an empty frame (0,1)x(-1,1)
       Line 0 0 1 1      | Draw a line in (0,1)x(-1,1)
       Swn 10 0 10 0 10  | Change the coordinates to (0,10)x(0,10)
       Selnt 10          | Activate the coordinates (0,10)x(0,10)
       Line 0 0 1 1      | Draw a line in (0,10)x(0,10)
\end{verbatim}
\ENDVERB
   \par
This command, and also SVP, should not be used for a common PAW usage 
   (H/PLOT, GRAPH etc ...). Commands like ZONE and SIZE should be used.  

\ENDCMD

\DEFCMD{GV}{SELNT}{GRAPHICS/VIEWING}{SELNT}{ nt}

\BEGARG
\DEFARG{NT}{I}{Normalisation transformation number}{}
\ENDARG

   \par
Select a normalisation transformation number.  
\begin{verbatim}
     If ZONE 2 2 is active , then:        If ZONE 1 1 is active, then:
    +------------------------------+    +-----------------------------+
    |                              |    |                             |
    |  +----------+   +---------+  |    |  +-----------------------+  |
    |  |          |   |         |  |    |  |                       |  |
    |  |   NT=10  |   |  NT=20  |  |    |  |                       |  |
    |  |          |   |         |  |    |  |                       |  |
    |  +----------+   +---------+  |    |  |                       |  |
    |                              |    |  |         NT=10         |  |
    |  +----------+   +---------+  |    |  |                       |  |
    |  |          |   |         |  |    |  |                       |  |
    |  |   NT=30  |   |  NT=40  |  |    |  |                       |  |
    |  |          |   |         |  |    |  |                       |  |
    |  +----------+   +---------+  |    |  |                       |  |
    |                              |    |  +-----------------------+  |
    |             NT=1             |    |             NT=1            |
    +------------------------------+    +-----------------------------+
\end{verbatim}
\ENDVERB
   \par
Example:  
\begin{verbatim}
       Zone 1 2          | Define 2 zones.
       Nul 0 1 -1 1      | Draw an empty frame in the first zone
       Nul 0 1 -1 1      | Draw an empty frame in the second zone
       Line 0 0 1 1      | Draw a line in second zone
       Selnt 10          | select the first zone
       Line 0 0 1 1      | Draw a line in the first zone
\end{verbatim}

\ENDCMD
\DEFMENU{1}{PRIMITIVES}{GRAPHICS/PRIMITIVES}
\ifMENUtext
   \par
Call HIGZ drawing primitives 


\fi

\DEFCMD{GP}{PLINE}{GRAPHICS/PRIMITIVES}{PLINE}{ n x y}

\BEGARG
\DEFARG{N}{I}{Number of points}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\ENDARG

   \par
Draw a polyline of N points X,Y in the current Normalisation 
   transformation.  The PLINE attributes can be changed with the command SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NUL -1 1 0 1           | Draw a frame (cf HELP NULL)
    * Create vector X and Y (cf HELP SIGMA)
       SIGMA X=ARRAY(100,-1#1)
       SIGMA Y=X*X
       SET PLCI 4             | The line color is blue
       SET LWID 6             | The line width is 6
       SET LTYP 2             | The line type is dashed
       PLINE 100 X Y          | Draw a 100 points line
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{LINE}{GRAPHICS/PRIMITIVES}{LINE}{ x1 y1 x2 y2}

\BEGARG
\DEFARG{X1}{R}{X first coordinate}{}
\DEFARG{Y1}{R}{Y first coordinate}{}
\DEFARG{X2}{R}{X second coordinate}{}
\DEFARG{Y2}{R}{Y second coordinate}{}
\ENDARG

   \par
Draw a line connecting points (X1,Y1) and (X2,Y2) in the current 
   Normalisation transformation. This command is kept for backward 
   compatibility. It has a reverse calling sequence compare to BOX or ARROW 
   and it doesn't take LOG scales into account. It is recommended to use DLINE 
   instead. The LINE attributes can be changed with the command SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NUL 0 5 0 5            | Draw a frame (cf HELP NULL)
       SET PLCI 2             | The line color is red
       SET LWID 6             | The line width is 6
       SET LTYP 3             | The line type is dotted
       LINE 0 0 5 5           | Draw a line
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{DLINE}{GRAPHICS/PRIMITIVES}{DLINE}{ x1 x2 y1 y2}

\BEGARG
\DEFARG{X1}{R}{X first coordinate}{}
\DEFARG{X2}{R}{X second coordinate}{}
\DEFARG{Y1}{R}{Y first coordinate}{}
\DEFARG{Y2}{R}{Y second coordinate}{}
\ENDARG

   \par
Draw a line connecting points (X1,Y1) and (X2,Y2) in the current 
   Normalisation transformation taking care of logarithmic scales. The DLINE 
   attributes can be changed with the command SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       OPTION LOGY            | Log scale on the Y axis.
       NUL 0 5 1 100          | Draw a frame (cf HELP NULL)
       SET PLCI 2             | The line color is red
       SET LWID 6             | The line width is 6
       SET LTYP 1             | The line type is solid
       DLINE 0 5 1 10         | Draw a line
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{FAREA}{GRAPHICS/PRIMITIVES}{FAREA}{ n x y}

\BEGARG
\DEFARG{N}{I}{Number of points}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\ENDARG

   \par
Fill the area defined by the N points X,Y in the current Normalisation 
   transformation.  The FAREA attributes can be changed with the command SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NUL -1.1 1.1 -1.1 1.1  | Draw a frame (cf HELP NULL)
    * Create vector X and Y (cf HELP SIGMA)
       SIGMA X=ARRAY(100,-3.14#3.14)
       SIGMA Y=SIN(X)*COS(X)
       SIGMA X=COS(X)
       SET FACI 2             | The fill area color is red
       SET FAIS 1             | The fill area interior style is solid
       FAREA 100 X Y          | Draw a 100 points line
       SET FACI 1             | The fill area color is black
       SET FAIS 0             | The fill area interior style is hollow
       FAREA 100 X Y          | Draw a 100 points line
       SET FAIS 3             | The fill area interior style is hatched
       SET FASI 245           | Defines the type of hatches
       FAREA 100 X Y          | Draw a 100 points line
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{PMARKE}{GRAPHICS/PRIMITIVES}{PMARKER}{ n x y}

\BEGARG
\DEFARG{N}{I}{Number of points}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\ENDARG

   \par
Draw polymarkers at the N points X,Y in the current Normalisation 
   transformation.  The PMARKER attributes can be changed with the command 
   SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NUL -3.2 3.2 -1 1      | Draw a frame (cf HELP NULL)
    * Create vector X and Y (cf HELP SIGMA)
       SIGMA X=ARRAY(100,-3.14#3.14)
       SIGMA Y=SIN(X)*COS(X)
       SET PMCI 6             | The marker color is magenta
       SET MTYP 3             | The marker type is *
       SET MSCF 2             | The marker size is 2
       PMARKER 100 X Y        | Draw a 100 points polymarker
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{BOX}{GRAPHICS/PRIMITIVES}{BOX}{ x1 x2 y1 y2}

\BEGARG
\DEFARG{X1}{R}{X coordinate of first corner}{}
\DEFARG{X2}{R}{X coordinate of second corner}{}
\DEFARG{Y1}{R}{Y coordinate of first corner}{}
\DEFARG{Y2}{R}{Y coordinate of second corner}{}
\ENDARG

   \par
Draw and fill a box with the current fill area and line attributes.  Use 
   the current Normalisation transformation.  The BOX attributes can be 
   changed with the command SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NULL 0 10 0 10         | Draw a frame (cf HELP NULL)
       SET FAIS 0             | Fill area interior style hollow
       BOX 1 3 1 3            | Draw a box
       SET FAIS 1             | Fill area interior style solid
       BOX 1 3 3 5            | Draw a box
       SET FAIS 3             | Fill area interior style hatched
       SET FASI 245           | Changes the type of hatches
       BOX 1 3 5 7            | Draw a box
       SET FASI 3             | Changes the type of hatches
       BOX 3 5 5 7            | Draw a box
       SET BORD 1             | The border is requested
       SET PLCI 2             | Line color is red
       SET FASI 4             | Changes the type of hatches
       BOX 5 7 5 7            | Draw a box
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{FBOX}{GRAPHICS/PRIMITIVES}{FBOX}{ x1 x2 y1 y2 x3 x4 y3 y4}

\BEGARG
\DEFARG{X1}{R}{X coord of first corner of ext box}{}
\DEFARG{X2}{R}{X coord of second corner of ext box}{}
\DEFARG{Y1}{R}{Y coord of first corner of ext box}{}
\DEFARG{Y2}{R}{Y coord of second corner of ext box}{}
\DEFARG{X3}{R}{X coord of first corner of int box}{}
\DEFARG{X4}{R}{X coord of second corner of int box}{}
\DEFARG{Y3}{R}{Y coord of first corner of int box}{}
\DEFARG{Y4}{R}{Y coord of second corner of int box}{}
\ENDARG

   \par
Draw and fill a frame (2 nested boxes) with the current fill area and line 
   attributes.  Use the current Normalisation transformation.  The FBOX 
   attributes can be changed with the command SET.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NULL 0 10 0 10         | Draw a frame (cf HELP NULL)
       SET FAIS 3             | Fill area interior style hatched
       SET FASI 3             | Changes the type of hatches
       SET FACI 2             | Fill are color is red
       SET PLCI 4             | Line color is blue
       SET LWID 8             | The line width is 8
       SET BORD 1             | The border is requested
       FBOX 1 9 1 9 3 7 3 7   | Draw a frame box
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{ARROW}{GRAPHICS/PRIMITIVES}{ARROW}{ x1 x2 y1 y2 [ size ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of start point}{}
\DEFARG{X2}{R}{X coordinate of end point}{}
\DEFARG{Y1}{R}{Y coordinate of start point}{}
\DEFARG{Y2}{R}{Y coordinate of end point}{}
\DEFARG{SIZE}{R}{Arrow size}{ D=0.4}
\ENDARG

   \par
Draw an arrow Use the current Normalisation transformation.  The ARROW 
   attributes can be changed with the command SET.  ARROW and LINE attributes 
   are the same.  

\begin{verbatim}
       (X1,Y1) ----> (X2,Y2) if SIZE>0.
       (X1,Y1) <---> (X2,Y2) if SIZE<0.
\end{verbatim}
\ENDVERB
   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NULL 0 10 0 7          | Draw a frame (cf HELP NULL)
       ARROW 1 9 1 1 .2       | Draw a simple arrow (left to right)
       ARROW 9 1 2 2 .4       | Draw a simple arrow (right to left)
       ARROW 1 9 3 3 -.8      | Draw a double arrow
       SET PLCI 2             | Arrow color is red
       ARROW 1 9 4 4 -.8      | Draw a double arrow
       SET LWID 8             | Arrow line width is 8
       ARROW 1 9 5 5 -.8      | Draw a double arrow
       SET LTYP 3             | Arrow line type is dotted
       ARROW 1 9 6 6 -.8      | Draw a double arrow
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{HELIX}{GRAPHICS/PRIMITIVES}{HELIX}{ [ x1 y1 x2 y2 r wi phi ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of the begin of helix}{ D=0.}
\DEFARG{Y1}{R}{Y coordinate of the begin of helix}{ D=0.}
\DEFARG{X2}{R}{X coordinate of the end of helix}{ D=10.}
\DEFARG{Y2}{R}{Y coordinate of the end of helix}{ D=10.}
\DEFARG{R}{R}{Radius of helix}{ D=.3}
\DEFARG{WI}{R}{Number of turns  }{ D=1.}
\DEFARG{PHI}{R}{Projection angle }{ D=15.}
\ENDARG

   \par
Draw an helix with the current line attributes.  Use the current 
   Normalisation transformation.  Feynman graph: gluon phi = 30, photon phi = 
   0.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *             | Reset the defaults
       NUL 0 10 0 10 'AB'        | Draw a frame (cf HELP NULL)
       HELIX 1 1 3 3 ! 10 !      | Draw an helix
       SET LWID 8                | Helix line width is 8
       HELIX 3 3 7 7 1  5 !      | Draw an helix
       SET PLCI 2                | Arrow color is red
       SET LTYP 2                | Helix line type is dashed
       HELIX 7 7 10 10 .2 5 10   | Draw an helix
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{ARCHEL}{GRAPHICS/PRIMITIVES}{ARCHELIX}{ [ x1 y1 x2 y2 r wi phi rl ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of the begin of helix}{ D=0.}
\DEFARG{Y1}{R}{Y coordinate of the begin of helix}{ D=0.}
\DEFARG{X2}{R}{X coordinate of the end of helix}{ D=10.}
\DEFARG{Y2}{R}{Y coordinate of the end of helix}{ D=10.}
\DEFARG{R}{R}{Radius of helix}{ D=.3}
\DEFARG{WI}{R}{Number of turns  }{ D=1.}
\DEFARG{PHI}{R}{Projection angle }{ D=30.}
\DEFARG{RL}{R}{Radius   of loop }{ D=15.}
\ENDARG

   \par
Draw an archelix with the current line attributes.  Use the current 
   Normalisation transformation.  Feynman graph: gluon phi = 30, photon phi = 
   0.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *               | Reset the defaults
       NUL 0 10 0 10 'AB'          | Draw a frame (cf HELP NULL)
       ARCHELIX 1 1 3 3 ! 9 ! 1    | Draw an helix
       SET LWID 8                  | Helix line width is 8
       ARCHELIX 3 3 7 7 ! 9 ! 1    | Draw an helix
       SET PLCI 2                  | Arrow color is red
       SET LTYP 2                  | Helix line type is dashed
       ARCHELIX 7 7 10 10 ! 9 ! 3  | Draw an helix
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{ARLINE}{GRAPHICS/PRIMITIVES}{ARLINE}{ [ x1 y1 x2 y2 h ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of the begin}{ D=0.}
\DEFARG{Y1}{R}{Y coordinate of the begin}{ D=0.}
\DEFARG{X2}{R}{X coordinate of the end}{ D=10.}
\DEFARG{Y2}{R}{Y coordinate of the end}{ D=10.}
\DEFARG{H}{R}{arrow size}{ D=.5}
\ENDARG

   \par
Draw a line with arrow in middle (fermion line) with the current line and 
   fill area attributes.  Use the current Normalisation transformation.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NULL 0 10 0 6          | Draw a frame (cf HELP NULL)
       ARLINE 1 1 9 1 .2      | Draw a arrow line (left to right)
       ARLINE 9 2 1 2 .4      | Draw a arrow line (right to left)
       SET PLCI 2             | Arrow color is red
       SET FAIS 1             | Fill area interior style solid
       ARLINE 9 3 1 3 .4      | Draw a arrow line (right to left)
       SET LWID 8             | Arrow line width is 8
       SET FACI 4             | The fill area color is blue
       ARLINE 9 4 1 4 .4      | Draw a arrow line (right to left)
       SET LTYP 3             | Arrow line type is dotted
       ARLINE 9 5 1 5 .4      | Draw a arrow line (right to left)
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{FPOINT}{GRAPHICS/PRIMITIVES}{FPOINT}{ [ x y r ]}

\BEGARG
\DEFARG{X}{R}{X      }{ D=0.}
\DEFARG{Y}{R}{Y      }{ D=0.}
\DEFARG{R}{R}{Radius }{ D=.5}
\ENDARG

   \par
Draw a filled point (vertex) with the current fill area attributes.  Use 
   the current Normalisation transformation.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NULL 0 10 0 10         | Draw a frame (cf HELP NULL)
       SET FAIS 1             | Fill area interior style solid
       FPOINT 5 1 .1          | Draw a filled point
       FPOINT 5 3 .2          | Draw a filled point
       FPOINT 5 5 .3          | Draw a filled point
       SET FACI 4             | The fill area color is blue
       FPOINT 5 7 .4          | Draw a filled point
       FPOINT 5 9 .5          | Draw a filled point
\end{verbatim}

\ENDCMD

\DEFCBIG{GP}{AXIS}{GRAPHICS/PRIMITIVES}{AXIS}{ x0 x1 y0 y1 wmin wmax ndiv [ chopt ]}

\BEGARG
\DEFARG{X0}{R}{X axis origin in WC}{}
\DEFARG{X1}{R}{X end axis in WC}{}
\DEFARG{Y0}{R}{Y axis origin in WC}{}
\DEFARG{Y1}{R}{Y end axis in WC}{}
\DEFARG{WMIN}{R}{Lowest value for labels}{}
\DEFARG{WMAX}{R}{Highest value for labels}{}
\DEFARG{NDIV}{I}{Number of divisions}{ D=510}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{} Minus}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw an axis with default values.
}
\DEFOPT{G}{\par
Logarithmic scale, default is linear.
}
\DEFOPT{B}{\par
Blank axis. Useful to superpose axis.
}
\DEFOPT{U}{\par
Unlabeled axis, default is labeled.
}
\DEFOPT{+}{\par
Tick marks are drawn on Positive side. (default)
}
\DEFOPT{-}{\par
Tick marks are drawn on the negative side.
}
\DEFOPT{=}{\par
Tick marks are drawn on Equal side
}
\DEFOPT{P}{\par
Labels are drawn Parallel to the axis
}
\DEFOPT{O}{\par
Labels are drawn Orthogonal to the axis (Top to Down).
}
\DEFOPT{0}{\par
Labels are drawn Orthogonal to the axis (Down to Top).
}
\DEFOPT{R}{\par
labels are Right adjusted on tick mark.
}
\DEFOPT{L}{\par
labels are Left adjusted on tick mark.
}
\DEFOPT{C}{\par
labels are Centered on tick mark.
}
\DEFOPT{M}{\par
In the Middle of the divisions.
}
\DEFOPT{Y}{\par
Direction of labels DOWN . Default is RIGHT
}
\DEFOPT{.}{\par
Dot obligatory
}
\DEFOPT{T}{\par
Alphanumeric labels .
}
\DEFOPT{S}{\par
Tick marks Size
}
\DEFOPT{H}{\par
Labels Height
}
\DEFOPT{D}{\par
Distance labels-axis
}
\DEFOPT{N}{\par
No bining optimisation
}
\DEFOPT{I}{\par
Integer labeling
}
\ENDOPT

   \par
Draw an axis in the current Normalisation transformation.  
\begin{verbatim}
           NDIV=N1 + 100*N2 + 10000*N3
           N1, N2, N3 = Number of 1st, 2nd, 3rd divisions respectively, eg:.
               NDIV=0 --> no tick marks.
               NDIV=2 --> 2 divisions, one tick mark in the middle
                        of the axis.
     Orientation of tick marks on axis: Tick marks are normally drawn
     on the positive side of the axis.However, if X0=X1, then Negative .
           CHOPT='+': tick marks are drawn on Positive side. (default)
           CHOPT='-': tick marks are drawn on the negative side.
           i.e: '+-' --> tick marks are drawn on both sides of the axis.
     Position of labels on axis: Labels are normally drawn on side
     opposite to tick marks.However:
           CHOPT= '='   on Equal side
     Orientation of labels on axis: Labels are normally drawn
     parallel to the axis. However if X0=X1, then Orthogonal
                                   if Y0=Y1, then Parallel
           CHOPT= 'P' : Parallel to the axis
           CHOPT= 'O' : Orthogonal to the axis (Top to Down).
           CHOPT= '0' : Orthogonal to the axis (Down to Top).
     Position of labels on tick marks: Labels are centered on
     tick marks. However , if X0=X1, then they are right adjusted.
           CHOPT='R': labels are Right adjusted on tick mark.
                      (default is centered)
           CHOPT='L': labels are Left adjusted on tick mark.
           CHOPT='C': labels are Centered on tick mark.
           CHOPT='M': In the Middle of the divisions.
     Direction of labels: Default is RIGHT
           CHOPT='Y':   Down
     Format of labels: Blank characters are stripped, and then the
     label is correctly aligned. The dot,if last character of the
     string, is also stripped, unless
           CHOPT='.'     Dot obligatory
     In the following, we have some parameters, like
     tick marks length and characters height (in percentage
     of the length of the axis).The default values are as follows:
        Primary tick marks: 3.0 %
        Secondary tick marks: 1.5 %
        Third order tick marks: .75 %
        Characters height for labels: 2%
        Characters spacing (related to height): 40%
        Labels offset: 4.0 %
     Type of labels: Labels are normally numeric . However, alphanumeric
     labels can be drawn (see command LABEL).
           CHOPT='T':   Alphanumeric labels .
     Intrinsic parameters: These values can be changed with the command
     SET. The default value is used unless the corresponding option is
     selected by CHOPT:
           CHOPT='D' The distance between the labels and the axis
                     (the offset) is given by the preceding command
                     SET with the parameter LAOF.
           CHOPT='H' The size (height) of the labels is given by the
                     preceding command SET with the parameter LASI.
           CHOPT='S' The size of the tick marks is given by the preceding
                     command SET with the parameter TMSI.
     Axis bining optimisation: By default the axis bining is optimized .
           CHOPT='N': No bining optimisation
           CHOPT='I': Integer labeling
\end{verbatim}
\ENDVERB
   \par
Example:  
\begin{verbatim}
       SET * ; OPT *                          | Reset the defaults
       NUL 0 12 0 12 'A'                      | Draw a frame (cf HELP NULL)
       AXIS 1  11  1  1  0  100  510 'A'      | Axis with arrow
       AXIS 1  11  3  3  1  10000  510 'G'    | LOG axis
       LABEL 1 11 a b c d e f g h i j k       | define alphanumeric labels
       AXIS 1  11  5  5  0  12  11 'NATY'     | alphanumeric labeling
       AXIS 1  11  6  6  -100  0  510 'A'
       AXIS 11  1  7  7  -100  0  810 'A+-'   | Double side tick marks
       AXIS 1  11  8  11  0  1234567  615 'A' | exponent is required
\end{verbatim}
\ENDVERB
   \par
Note that the command TIC provides a simpler interface to redraw axis on 
   the current plot. Moreover it use the NDVX, NDVY etc .. attributes.  

\ENDCBIG

\DEFCMD{GP}{ARC}{GRAPHICS/PRIMITIVES}{ARC}{ x1 y1 r1 [ r2 phimin phimax ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of centre}{}
\DEFARG{Y1}{R}{Y coordinate of centre}{}
\DEFARG{R1}{R}{Inner radius}{}
\DEFARG{R2}{R}{Outer radius}{ D=-1.}
\DEFARG{PHIMIN}{R}{Minimum angle}{ D=0.}
\DEFARG{PHIMAX}{R}{Maximum angle}{ D=360.}
\ENDARG

   \par
Draw an arc of circle with the current fill area and line attributes.  Use 
   the current Normalisation transformation.  If R1 is not equal to R2 the 
   area between the two arcs of radius R1 and R2 is filled according to the 
   current fill area attributes.  The border is never drawn unless the 
   interior style is hollow or the command SET BORD 1 has been called. If R1 
   is equal to R2 a polyline is drawn.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *          | Reset the defaults
       NULL 0 20 0 20 'AB'    | Draw a frame (cf HELP NULL)
       SET PLCI 2             | Line color is red
       SET LWID 6             | Line width is 6
       ARC  5  5 4 4 ! !      | Draw an circle
       ARC  5 15 4 4 30 260   | Draw an arc of circle
       SET FAIS 3             | Fill area with hatches
       SET FASI 3             | Type of hatches
       ARC 15 15 1 4 ! !      | Draw an arc
       SET BORD 1             | Border is requested
       ARC 15  5 1 4 30 !     | Draw an arc
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{PIE}{GRAPHICS/PRIMITIVES}{PIE}{ x0 y0 radius n values [ chopt iao ias iac ]}

\BEGARG
\DEFARG{X0}{R}{X coordinate of centre of the pie}{}
\DEFARG{Y0}{R}{Y coordinate of centre of the pie}{}
\DEFARG{RADIUS}{R}{Radius of the pie chart}{}
\DEFARG{N}{I}{Number of values}{}
\DEFARG{VALUES}{C}{Vector name for N values}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{IAO}{C}{Name of vector with offsets}{ D=\EMPTY{}}
\DEFARG{IAS}{C}{Name of vector with styles}{ D=\EMPTY{}}
\DEFARG{IAC}{C}{Name of vector with colors}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw a Pie Chart with default values.
}
\DEFOPT{C}{\par
Colours array is present.
}
\DEFOPT{L}{\par
Alphanumeric labels are required.
}
\DEFOPT{O}{\par
Offset array is present.
}
\DEFOPT{N}{\par
The label of each slice will be the corresponding numeric value in array 
VALUES.
}
\DEFOPT{P}{\par
The label of each slice will be in expressed in percentage.
}
\DEFOPT{S}{\par
Style array is present.
}
\DEFOPT{H}{\par
Force the labels size to be the current character height. Without this option 
the labels size is computed automatically.
}
\DEFOPT{R}{\par
Draw the labels aligned on the radius of each slice.
}
\ENDOPT

   \par
Draw a pie chart in the current Normalisation transformation.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *                                 | Reset the defaults
       NULL 0 20 0 20 'AB'                           | Draw a frame
       LABEL 1 5 'Lab1' 'Lab2' 'Lab3' 'Lab4' 'Lab5'  | define labels
    * Initialize vectors
       V/CRE VWS(5) R 28.3 18.6 16.9 13.5 22.7
       V/CRE OFFSET(5)  R 2*0. 2*20. 0.
       V/CRE COLOUR(5)  R 2 3 4 5 6
       SET FAIS 1                                    | Fill solid
       SET BORD 1                                    | Draw the border
       PIE 10. 10. 7.  5 VWS 'L' OFFSET ! COLOUR     | Draw the pie chart
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{TEXT}{GRAPHICS/PRIMITIVES}{TEXT}{ x y text size [ angle chopt ]}

\BEGARG
\DEFARG{X}{R}{X coordinate}{}
\DEFARG{Y}{R}{Y coordinate}{}
\DEFARG{TEXT}{C}{Text to be drawn}{}
\DEFARG{SIZE}{R}{Text size}{ D=0.3}
\DEFARG{ANGLE}{R}{Comment angle}{ D=0}
\DEFARG{CHOPT}{C}{Justification option}{ D='L'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{L}{\par
Text is Left justified.
}
\DEFOPT{C}{\par
Text is Centered.
}
\DEFOPT{R}{\par
Text is Right justified.
}
\ENDOPT

   \par
Draw text at position X,Y in the current normalisation transformation using 
   the software font IGTEXT. SIZE is always given in centimeters (as defined 
   by the command SIZE). A boldface effect can be obtained using the 
   parameters PASS and CSHI of the command SET. The text color can be changed 
   by SET TXCI.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *                                   | Reset the defaults
       NULL 0 10 0 10                                  | Draw a frame
       TEXT 5 1 'Left justified' .5 0. L
       TEXT 5 2 'Centered' .5 0. C
       TEXT 5 3 'Right justified' .5 0. R
       TEXT 5 4 '-- 30 degrees' .5 30. L
       TEXT 5 4 '-- 60 degrees' .5 60. L
       TEXT 5 4 '-- 90 degrees' .5 90. L
       TEXT 5 4 '-- 120 degrees' .5 120. L
       TEXT 5 4 '-- 150 degrees' .5 150. L
       TEXT 5 8 'Some Greek ... [a, b, c, d]' .5 0. C
       Set PASS 7                                      | Number of passes
       TEXT 5 9 'Bold TEXT' .5 0. C
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{ITX}{GRAPHICS/PRIMITIVES}{ITX}{ x y text}

\BEGARG
\DEFARG{X}{R}{X coordinate}{}
\DEFARG{Y}{R}{Y coordinate}{}
\DEFARG{TEXT}{C}{Text to be drawn}{}
\ENDARG

   \par
Draw text at position X,Y in the current Normalisation transformation, 
   using the current font parameters.  The font and the precision can be 
   changed by SET TXFP.  The character size can be changed by SET CHHE.  The 
   text color can be changed by SET TXCI.  The text orientation can be changed 
   with SET TXAL.  The text angle can be changed by SET TANG.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *                         | Reset the defaults
       NULL 0 10 0 6                         | Draw a frame
       SET TXFP -20                          | Times bold
       SET CHHE .5                           | Text size 0.5 cm
       SET TXAL 10                           | Horizontal align. Left
       ITX 5 1 'Left justified'
       SET TXAL 20                           | Horizontal align. Center
       ITX 5 2 'Centered'
       SET TXAL 30                           | Horizontal align. Right
       ITX 5 3 'Right justified'
       SET TXAL 12                           | Vertical align. Top
       ITX .2 4 'Top justified'
       SET TXAL 13                           | Vertical align. Middle
       ITX .2 5 'Middle justified'
       SET TXAL  0                           | Default align.
       SET TANG 30                           | Angle 30 degrees
       ITX 5 4 '-- 30 degrees --'
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{LABELS}{GRAPHICS/PRIMITIVES}{LABELS}{ labnum nlabs chlabs}

\BEGARG
\DEFARG{LABNUM}{I}{Label identifier}{ D=1 R=1:9}
\DEFARG{NLABS}{I}{Number of labels}{ D=0 R=0:50}
\DEFARG{CHLABS}{C}{List of labels}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Define a list of alphanumeric labels to be used by subsequent commands such 
   as PIE and AXIS. The position of the labels on the axis may be changed with 
   SET NDVX (NDVY).  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *                 | Reset the defaults
       ZONE 1 3
       LABEL 1 3 AAAAA BBBBB CCCCC   | Define labels
       SET NDVX 3.15                 | 3 div, lab id 1, 5=center on bin
       NULL 0 10 0 1                 | Draw a frame
       SET NDVX 3.11                 | 3 div, lab id 1, 1=center on tick
       NULL 0 10 0 1                 | Draw a frame
       SET NDVX 3.18                 | 3 div, lab id 1, 8=bottom -> up
       NULL 0 10 0 1                 | Draw a frame
\end{verbatim}
\ENDVERB
   \par
A full description of the possible alignments is given in the PAW manual 
   (see NDVX in the index).  

\ENDCMD

\DEFCMD{GP}{PAVE}{GRAPHICS/PRIMITIVES}{PAVE}{ x1 x2 y1 y2 [ dz isbox isfram chopt ]}

\BEGARG
\DEFARG{X1}{R}{X bottom left corner of box}{}
\DEFARG{X2}{R}{X top right corner of box}{}
\DEFARG{Y1}{R}{Y bottom left corner of box}{}
\DEFARG{Y2}{R}{Y top right corner of box}{}
\DEFARG{DZ}{R}{Box width}{ D=0.4}
\DEFARG{ISBOX}{I}{Box style}{ D=0}
\DEFARG{ISFRAM}{I}{Frame style}{ D=5}
\DEFARG{CHOPT}{C}{Option}{ D='TR'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{TR}{\par
Top and Right frame are drawn
}
\DEFOPT{TL}{\par
Top and Left frame
}
\DEFOPT{BR}{\par
Bottom and Right frame
}
\DEFOPT{BL}{\par
Bottom and Left frame
}
\DEFOPT{L}{\par
Left frame only
}
\DEFOPT{R}{\par
Right frame only
}
\DEFOPT{T-}{\par
Top frame only pointing left
}
\DEFOPT{B-}{\par
Bottom frame only pointing left
}
\DEFOPT{S}{\par
Shadow mode
}
\DEFOPT{K}{\par
Key mode
}
\ENDOPT

   \par
Draw a paving-block (box with 3D effect).  ISBOX (ISFRAM) may be 
   1000+ICOLOR where ICOLOR is the color index of the box (frame), otherwise 
   the style index.  If ISBOX (ISFRAM) = 0, only the box contour is drawn with 
   the current polyline attributes.  

   \par
Example:  
\begin{verbatim}
       SET * ; OPT *                         | Reset the defaults
       NULL 0 10 0 10                        | Draw a frame
       PAVE 1 4 1 4 ! ! 1001 CHOPT=TRS
       PAVE 5 9 1 4 ! ! 1001 CHOPT=BLS
       PAVE 1 4 5 9 ! !    3 CHOPT=TR
       PAVE 5 9 5 9 ! !    3 CHOPT=BL
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{HIST}{GRAPHICS/PRIMITIVES}{HIST}{ n x y [ chopt ]}

\BEGARG
\DEFARG{N}{I}{Number of values}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\DEFARG{CHOPT}{C}{Options}{ D='AHW'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
X and Y axes are drawn (default).
}
\DEFOPT{H}{\par
An histogram is drawn as a contour (default).
}
\DEFOPT{W}{\par
The Window/Viewport parameters are automatically computed from the X and Y 
values (default).
}
\DEFOPT{R}{\par
The histogram is Rotated, i.e. the values in X are used for the ordinate and 
the values in Y for the abscissa (default is the contrary). If option R is 
selected (and option 'N' is not selected), the user must give: 2 values for Y 
(Y(1)=YMIN and Y(2)=YMAX) N values for X, one for each bin. Otherwise the user 
must give: N values for Y, one for each bin. 2 values for X (X(1)=XMIN and 
X(2)=XMAX) If option 'N' is selected see below.
}
\DEFOPT{N}{\par
Non equidistant bins (default is equidistant). The arrays X and Y must be 
dimensioned as follows: If option R is not selected (default) then give: (N+1) 
values for X (limits of bins). N values for Y, one for each bin. Otherwise 
give: (N+1) values for Y (limits of bins). N values for X, one for each bin.
}
\DEFOPT{F}{\par
The area delimited by the histogram is filled according to the fill area 
interior style and the fill area style index or colour index. Contour is not 
drawn unless CHOPT='H' is also selected.
}
\DEFOPT{C}{\par
A Smooth curve is drawn across points at the centre of each bin of the 
histogram.
}
\DEFOPT{L}{\par
A straight Line is drawn across points at the centre of each bin of the 
histogram.
}
\DEFOPT{*}{\par
A star is plotted at the center of each bin of the histogram.
}
\DEFOPT{P}{\par
Idem as '*' but with the current marker.
}
\DEFOPT{B}{\par
A Bar chart with equidistant bins is drawn as fill areas. (Contours are 
drawn). The bar origin and the bar width can be controlled by the routine SET 
using the options BARO and BARW respectively.
}
\ENDOPT

   \par
Draw an histogram defined by arrays X and Y.  The number of components 
   needed in vectors X and/or in Y may be dependent upon the value of CHOPT 
   (see options 'R' and 'N').  To set Log scales in X and/or Y, use OPT 
   LOGX/LOGY.  Note that when an option is specified, it is also necessary to 
   specify the options 'W' or 'HW' in order to start a new zone or/and draw 
   the axes.  

   \par
Example 
\begin{verbatim}
       SET * ; OPT *                         | Reset the defaults
       Zone 1 2
    * This command needs vectors
       V/CREATE Y(10) r 1 2 3 4 5 5 4 3 2 1
       V/CREATE X(11) r 1 2 4 6 8 10 15 16 20 21 30
       HIST 10 X Y 'WH'                      | Equidistant bins
       HIST 10 X Y 'HWN'                     | Non Equidistant bins
\end{verbatim}

\ENDCMD

\DEFCMD{GP}{GRAPH}{GRAPHICS/PRIMITIVES}{GRAPH}{ n x y [ chopt ]}

\BEGARG
\DEFARG{N}{I}{Number of values}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\DEFARG{CHOPT}{C}{Options}{ D='ALW'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
X and Y axes are drawn (default).
}
\DEFOPT{L}{\par
Every point is connected with a straight line. (default)
}
\DEFOPT{W}{\par
The Window/Viewport parameters are automatically computed from the X and Y 
values (default).
}
\DEFOPT{C}{\par
The values in Y are plotted in the form of a smooth curve. A Spline 
approximation algorithm is used.
}
\DEFOPT{F}{\par
A fill area is drawn. If the option 'CF' is used the contour of the fill area 
is smooth. The border of the fill area is drawn if the command SET BORD 1 has 
been typed. The fill area type may be changed via the SET parameters FASI and 
FASI
}
\DEFOPT{R}{\par
The graph is Rotated, i.e. the values in X are used for the ordinate and the 
values in Y for the abscissa (default is the contrary).
}
\DEFOPT{B}{\par
A Bar chart with equidistant bins is drawn as fill areas. (Contours are 
drawn). The bar origin and the bar width can be controlled by the routine SET 
using the options BARO and BARW respectively.
}
\DEFOPT{*}{\par
A star is plotted at every point.
}
\DEFOPT{P}{\par
A marker is plotted at every point, according to current marker type and 
polymarker colour index.
}
\ENDOPT

   \par
Draw a curve through a set of points.  To set Log scales in X and/or Y, use 
   OPT LOGX/LOGY.  Note that when an option is specified, it is also necessary 
   to specify the options 'AW' or 'ALW' in order to start a new zone or/and 
   draw the axes.  

   \par
Example 
\begin{verbatim}
       SET * ; OPT *                           | Reset the defaults
       ZONE 1 2
    * This command needs vectors
       V/CREATE Y(10) r 1 2 3 4 5 5 4 3 2 1
       V/CREATE X(11) r 1 2 4 6 8 10 15 16 20 21
       GRAPH 10 X Y 'WC*L'                     | Draw an "open" graph
       SET FAIS 3                              | Interior style: hatched
       SET FASI 245                            | Define hatches type
       SET BORD 1                              | Border requested
       NULL 0 22 0 6                           | define new scales
       GRAPH 10 X Y 'CF*'                      | Draw an "closed" graph
\end{verbatim}

\ENDCMD
\DEFMENU{1}{ATTRIBUTES}{GRAPHICS/ATTRIBUTES}
\ifMENUtext
   \par
Change HIGZ attributes.  


\fi

\DEFCMD{GA}{COLORT}{GRAPHICS/ATTRIBUTES}{COLOR\_TABLE}{ icol [ red green blue ]}

\BEGARG
\DEFARG{ICOL}{I}{Color Index}{ D=1}
\DEFARG{RED}{R}{Weight of red}{ D=0. R=0.:1.}
\DEFARG{GREEN}{R}{Weight of green}{ D=0. R=0.:1.}
\DEFARG{BLUE}{R}{Weight of blue}{ D=0. R=0.:1.}
\ENDARG

   \par
Define the color ICOL.  

\ENDCMD

\DEFCMD{GA}{PALETT}{GRAPHICS/ATTRIBUTES}{PALETTE}{ palnb [ nel list ]}

\BEGARG
\DEFARG{PALNB}{I}{Palette number}{ D=0 R=0:9}
\DEFARG{NEL}{I}{Number of elements in the palette}{ D=0 R=0:50}
\DEFARG{LIST}{I}{List of the palette elements}{ D=0}
\ENDARG

   \par
Define a palette of attributes.  The palette number is used in the command 
   SET. The command SET HCOL 0.1 defines the palette number 1 as colour 
   indices used by the command LEGO in case of stacked lego plots and plotting 
   of SURFACE with options 1 or 2, LEGO with option 2 and CONTOUR with option 
   3.  

   \par
By default the palettes are initialized with 6 elements:  2,3,4,5,6,7.  

   \par
If the number of elements (NEL) is equal to 0 (default), the palette is 
   filled automatically according to the number of colours defined with the 
   command SET NCOL:  

\begin{verbatim}
    a) If NCOL is smaller or equal to 8, the palette is filled with a
       subset of the 8 basic colours.
       Examples:
       PAW > SET NCOL 8        | Define the number of colours
       PAW > PALETTE 1         | The palette 1 is filled with
                               | 8 elements: 0,5,7,3,6,2,4,1
       PAW > SET NCOL 4        | Define the number of colours
       PAW > PALETTE 1         | The palette 1 is filled with
                               | 4 elements: 0,5,7,3
\end{verbatim}
\begin{verbatim}
    b) If NCOL is greater than 8, the palette is filled
       with colours varying continuously from blue to red. This is
       called a "geographical palette".
       Examples:
       PAW > SET NCOL 16     | Define the number of colours
       PAW > PALETTE 1         | Fill palette 1 with 8 elements
                               | (8,9,10,11,12,13,14,15) varying
                               | continuously from blue to red
       Note that after the command SET NCOL, the color indices from
       8 to NCOL are set with gray levels. The command PALETTE 1
       reset the same indices with a "geographical palette" varying
       continuously from blue to red.
\end{verbatim}

\ENDCMD
\DEFMENU{1}{HPLOT}{GRAPHICS/HPLOT}
\ifMENUtext
   \par
Draw various HPLOT objects (symbols, errors, key, etc.).  


\fi

\DEFCMD{GH}{SYMBOL}{GRAPHICS/HPLOT}{SYMBOLS}{ x y n [ isymb ssize ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{N}{I}{Number of points}{ D=1}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{SSIZE}{R}{Symbol size}{ D=0.28}
\ENDARG

   \par
Draw the same symbol at several points x,y in the current normalisation 
   transformation.  

\ENDCMD

\DEFCMD{GH}{ERRORS}{GRAPHICS/HPLOT}{ERRORS}{ x y ex ey n [ isymb ssize chopt ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{EX}{C}{Vector of X error bars}{}
\DEFARG{EY}{C}{Vector of Y error bars}{}
\DEFARG{N}{I}{Number of points}{ D=1}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{SSIZE}{R}{Symbol size}{ D=0.28}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Coordinates are expressed in histogram coordinates (of the last drawn 
histogram). Error bars are drawn.
}
\DEFOPT{C}{\par
Coordinates are expressed in centimeters.
}
\DEFOPT{W}{\par
A new window is defined and axis are drawn.
}
\DEFOPT{1}{\par
Draw small lines at the end of the error bars.
}
\DEFOPT{2}{\par
Draw error rectangles.
}
\DEFOPT{3}{\par
Draw a filled area through the end points of the vertical error bars.
}
\DEFOPT{4}{\par
Draw a smoothed filled area through the end points of the vertical error bars.
}
\DEFOPT{0}{\par
Turn off the symbols clipping.
}
\ENDOPT

   \par
Draw (according to the CHOPT value) a series of points using a symbol and 
   error bars in horizontal and vertical direction in the current 
   normalisation transformation.  

   \par
By default, the symbols are not drawn if they are on the edges of the plot: 
   the option '0' allows to turn off this symbols clipping.  

   \par
With Option 1, the size of the tick marks at the end of the error bars is 
   equal to the marker size and can be changed with SET KSIZ.  

   \par
If ISYMB = 0 or SSIZE = 0. no symbol is drawn.  

   \par
Note that the options can be cumulated.  

\ENDCMD

\DEFCMD{GH}{AERROR}{GRAPHICS/HPLOT}{AERRORS}{ x y exl exu eyl eyu n [ isymb ssize chopt ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{EXL}{C}{Vector of X error bars (Low)}{}
\DEFARG{EXU}{C}{Vector of X error bars (Up)}{}
\DEFARG{EYL}{C}{Vector of Y error bars (Low)}{}
\DEFARG{EYU}{C}{Vector of Y error bars (Up)}{}
\DEFARG{N}{I}{Number of points}{ D=1}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{SSIZE}{R}{Symbol size}{ D=0.28}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Coordinates are expressed in histogram coordinates (of the last drawn 
histogram). Error bars are drawn.
}
\DEFOPT{C}{\par
Coordinates are expressed in centimeters.
}
\DEFOPT{W}{\par
A new window is defined and axis are drawn.
}
\DEFOPT{1}{\par
Draw small lines at the end of the error bars.
}
\DEFOPT{2}{\par
Draw error rectangles.
}
\DEFOPT{3}{\par
Draw a filled area through the end points of the vertical error bars.
}
\DEFOPT{4}{\par
Draw a smoothed filled area through the end points of the vertical error bars.
}
\DEFOPT{0}{\par
Turn off the symbols clipping.
}
\ENDOPT

   \par
Draw (according to the CHOPT value) a series of points using a symbol and 
   asymmetric error bars in horizontal and vertical direction in the current 
   normalisation transformation.  

   \par
By default, the symbols are not drawn if they are on the edges of the plot: 
   the option '0' allows to turn off this symbols clipping.  

   \par
With Option 1, the size of the tick marks at the end of the error bars is 
   equal to the marker size and can be changed with SET KSIZ.  

   \par
If ISYMB = 0 or SSIZE = 0. no symbol is drawn.  

   \par
Note that the options can be cumulated.  

\ENDCMD

\DEFCMD{GH}{KEY}{GRAPHICS/HPLOT}{KEY}{ x y [ iatt text dx chopt ]}

\BEGARG
\DEFARG{X}{R}{X coordinate of comment}{}
\DEFARG{Y}{R}{Y coordinate of comment}{}
\DEFARG{IATT}{I}{Attribute value}{ D=24}
\DEFARG{TEXT}{C}{Legend}{ D=\EMPTY{}}
\DEFARG{DX}{R}{Box width}{ D=1.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
IATT is a marker type
}
\DEFOPT{F}{\par
IATT is a fill area color index
}
\DEFOPT{H}{\par
IATT is a hatches type
}
\DEFOPT{L}{\par
IATT is a line type
}
\DEFOPT{W}{\par
IATT is a line width
}
\ENDOPT

   \par
Draw one legend and its explanation at a point x,y in the current 
   normalisation transformation.  

   \par
The legend can be:  
\begin{verbatim}
        - A marker type (default)
        - A filled box (CHOPT=F), in this case IATT is a color
          and DX is the width of the box.
        - A hatched  box (CHOPT=H), in this case IATT is a hatches type
          and DX is the width of the box.
        - A line (CHOPT=L), in this case IATT is a line type
          and DX is the length of the line.
        - A line (CHOPT=W), in this case IATT is a line width
          and DX is the length of the line.
\end{verbatim}
\ENDVERB
   \par
Example 
\begin{verbatim}
       SET * ; OPT *                     | Reset the defaults
       NUL 0 10 0 8 A                    | Draw a frame
       KEY 5 2 ! 'Key 1'                 | Key with marker
       KEY 5 3 2 'Key 2' ! F             | Key with filled box
       SET FACI 3                        | Change color for next key
       key 5 4 2 'Key 3' 2 H             | Key with hatches. DX is modified
       key 5 5 2 'Key 4' ! L             | Key with line type
       SET PLCI 4                        | Change color for next key
       SET CSIZ .4                       | Change key size
       KEY 5 6 8 'Key 5' 1.5 W           | Key with line width
\end{verbatim}

\ENDCMD

\DEFCMD{GH}{TICKS}{GRAPHICS/HPLOT}{TICKS}{ [ chopt xval yval ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{XVAL}{R}{X position}{ D=1.E30}
\DEFARG{YVAL}{R}{Y position}{ D=1.E30}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Tick marks are drawn on the edges of the picture
}
\DEFOPT{X}{\par
Cross-wire drawn perpendicular to the X-axis
}
\DEFOPT{Y}{\par
Cross-wire drawn perpendicular to the Y-axis
}
\DEFOPT{A}{\par
Value drawn Above cross-wire
}
\DEFOPT{B}{\par
Value drawn Below cross-wire
}
\DEFOPT{L}{\par
Value drawn Left of cross-wire
}
\DEFOPT{R}{\par
Value drawn Right of cross-wire
}
\ENDOPT

   \par
Draw 'cross-wires' on a picture, optionally with tick marks and values.  
   Cross-wires are lines perpendicular to the X and/or Y axis.  
\begin{verbatim}
    XVAL intersection on the X-axis
    YVAL intersection on the Y-axis
\end{verbatim}
   \par
The values of XVAL are always histogram coordinates.  

   \par
The tick marks will be drawn on both side of the cross wire, unless the 
   cross-wires are requested on the boundary of the box surrounding the 
   histogram (i.e. at the extreme limits of the drawn histogram). In this case 
   tick marks will only be drawn inside the box.  

   \par
The options 'A' and 'B' (for Above and Below) refer only to the cross-wire 
   perpendicular to the Y axis.  In each case only one cross-wire will be 
   drawn.  

   \par
Similarly 'L' and 'R' (Left and Right) refer only to the cross-wires 
   perpendicular to the X-axis.  

   \par
It is possible to redefine the length of tick marks on the X or Y axis with 
   SET XTIC or SET YTIC.  

   \par
The position of the axis values may be changed with SET XVAL or SET YVAL.  

   \par
The Number of divisions can be cahnged with SET NDVX and SET NDVY.  

   \par
This command combines with the command NUL is a easy way to redraw axis on 
   the current plot.  

   \par
Example 
\begin{verbatim}
       SET * ; OPT *                     | Reset the defaults
       Nul 0 1 0 1                       | draw an empty frame with axis
       Set ndvy 5                        | Change number of Y divisions
       Nul 0 10 0 10 ABS                 | Redefine the scales
       Tic XR 5 !                        | Axis in the new coordinates
\end{verbatim}

\ENDCMD

\DEFCMD{GH}{ATITLE}{GRAPHICS/HPLOT}{ATITLE}{ [ xtit ytit ztit ialgn chopt ]}

\BEGARG
\DEFARG{XTIT}{C}{X Axis title}{ D=\EMPTY{}}
\DEFARG{YTIT}{C}{Y Axis title}{ D=\EMPTY{}}
\DEFARG{ZTIT}{C}{Z Axis title}{ D=\EMPTY{}}
\DEFARG{IALGN}{I}{Axis titles alignment}{ D=0}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Axis title are drawn on the left and on the bottom of the plot.
}
\DEFOPT{R}{\par
Y axis title is drawn on the right of the plot.
}
\DEFOPT{T}{\par
X axis title is drawn on the top of the plot.
}
\ENDOPT

   \par
Draw axis titles on the axes of the present plot zone.  The parameter IALGN 
   defined where the title is aligned i.e:  on the beginning, the middle or at 
   the end of the axis. The alignment parameter has 3 digits (one for each 
   axis): xyz where x, y and z may have independently the following values:  
\begin{verbatim}
    1: Begining of the axis
    2: Middle of the axis
    3: End of the axis (0 is equivalent to 3)
\end{verbatim}
   \par
Example:  
\begin{verbatim}
    NUL 0 10 0 10
    NUL 0 100 0 100 S
    ATITLE 'End of axis' 'Middle of axis on the right' ! 320 R
    ATITLE 'Beginning of axis' 'End of axis' ! 130
    ATITLE 'Middle of axis on the top' 'Beginning of axis' ! 210 T
\end{verbatim}

\ENDCMD

\DEFCMD{GH}{GRID}{GRAPHICS/HPLOT}{GRID}{}

   \par
Draw a grid in cm.  

\ENDCMD

\DEFCMD{GH}{NULL}{GRAPHICS/HPLOT}{NULL}{ [ xmin xmax ymin ymax chopt ]}

\BEGARG
\DEFARG{XMIN}{R}{Low range in X}{ D=0.}
\DEFARG{XMAX}{R}{High range in X}{ D=1.}
\DEFARG{YMIN}{R}{Low range in Y}{ D=0.}
\DEFARG{YMAX}{R}{High range in Y}{ D=1.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw a frame box only.
}
\DEFOPT{S}{\par
Redefine the scale for the current zone.
}
\DEFOPT{A}{\par
Axis labels and tick marks are not drawn.
}
\DEFOPT{B}{\par
The box is not drawn.
}
\ENDOPT

   \par
Draw a frame box.  If XMIN, XMAX, etc. are given, draw a frame box with the 
   window coordinates set to XMIN, XMAX, YMIN, YMAX. Axis labels and tick 
   marks are drawn by default.  

\ENDCMD
\DEFMENU{0}{PICTURE}{PICTURE}
\ifMENUtext
   \par
Creation and manipulation of HIGZ pictures.  


\fi

\DEFCMD{P}{FILE}{PICTURE}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in words}{ D=1024}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Existing file is opened.
}
\DEFOPT{N}{\par
A new file is opened.
}
\DEFOPT{U}{\par
Existing file is modified.
}
\DEFOPT{A}{\par
Automatic saving.
}
\ENDOPT

   \par
Open a HIGZ direct access picture file.  If CHOPT='AU' or 'AN', pictures 
   will be automatically saved on the direct access file. This automatic 
   saving facility can be switched off using SET AURZ 0.  

\ENDCMD

\DEFCMD{P}{LIST}{PICTURE}{LIST}{}

   \par
List all the HIGZ pictures currently stored in memory.  

\ENDCMD

\DEFCMD{P}{CREATE}{PICTURE}{CREATE}{ pname}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ Loop}
\ENDARG

   \par
Create a new picture, named PNAME, in memory.  Note that all commands which 
   start a new picture (clear workstation) automatically create pictures named 
   PICT1, PICT2, etc.  if the command OPTION ZFL or OPTION ZFL1 has been 
   executed.  

\ENDCMD

\DEFCMD{P}{DELETE}{PICTURE}{DELETE}{ pname}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Delete the picture PNAME from memory.  PNAME='*' means all pictures.  

\ENDCMD

\DEFCMD{P}{SCRATC}{PICTURE}{SCRATCH}{ pname [ icycle ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\DEFARG{ICYCLE}{I}{Cycle number }{ D=9999}
\ENDARG

   \par
Delete the picture PNAME from current directory on disk.  

\ENDCMD

\DEFCMD{P}{PLOT}{PICTURE}{PLOT}{ [ pname ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Plot the picture PNAME.  PNAME=' ' means the current picture.  PNAME='*' 
   means all pictures.  

\ENDCMD

\DEFCMD{P}{MODIFY}{PICTURE}{MODIFY}{ [ pname chopt ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{S}{\par
Software characters are used for the text in menus.
}
\DEFOPT{A}{\par
The option shadow is used.
}
\ENDOPT

   \par
Edit the picture PNAME.  PNAME=' ' means the current picture.  This command 
   is only available on workstations.  

\ENDCMD

\DEFCMD{P}{MERGE}{PICTURE}{MERGE}{ pname [ x y scale chopt ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{}
\DEFARG{X}{R}{X coordinates (NDC) where to draw PNAME}{ D=0}
\DEFARG{Y}{R}{Y coordinates (NDC) where to draw PNAME}{ D=0}
\DEFARG{SCALE}{R}{Scale factor}{ D=1.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Merge the picture PNAME with the current picture.
}
\DEFOPT{D}{\par
Picture PNAME is displayed during merging.
}
\ENDOPT

   \par
Add the picture PNAME to the current picture.  

\ENDCMD

\DEFCMD{P}{COPY}{PICTURE}{COPY}{ pname1 pname2}

\BEGARG
\DEFARG{PNAME1}{C}{Picture name}{}
\DEFARG{PNAME2}{C}{New picture name}{ Loop}
\ENDARG

   \par
Copy a picture.  

\ENDCMD

\DEFCMD{P}{RENAME}{PICTURE}{RENAME}{ pname1 pname2}

\BEGARG
\DEFARG{PNAME1}{C}{Old picture name}{}
\DEFARG{PNAME2}{C}{New picture name}{}
\ENDARG

   \par
Rename a picture.  

\ENDCMD

\DEFCMD{P}{PRINT}{PICTURE}{PRINT}{ [ file ]}

\BEGARG
\DEFARG{FILE}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Print the current picture.  The current picture is transformed into a 
   printable file.  The file type is defined according to the extension of the 
   file name i.e.  

\begin{verbatim}
      FILE = filename.ps    A PostScript file is generated (-111)
      FILE = filename.eps   A Encapsulated PostScript file
                            is generated (-113)
      FILE = filename.tex   A LaTex file is generated (-778)
\end{verbatim}
   \par
Do HELP META for details about the metafile types.  Note that a new picture 
   is automatically created for each new plot if the OPTION ZFL1 is on.  

   \par
If FILE=HIGZPRINTER or FILE=' ' the PostScript file paw.ps (-111) is 
   generated and the operating system command defined by the environment 
   variable HIGZPRINTER is executed.  

   \par
The environment variable HIGZPRINTER should be defined as follow:  
\begin{verbatim}
      On UNIX sytems:
             setenv HIGZPRINTER 'lp -dprinter_name paw.ps'
        or
             export HIGZPRINTER='lp -dprinter_name paw.ps'
      On VAX/VMS sytems:
             HIGZPRINTER == "XPRINT paw.ps /PRINTER=printer_name"
      On CERNVM:
             setenv HIGZPRINTER 'XPRINT PAW PS (PR printer_name'
\end{verbatim}
\ENDVERB
   \par
Note that if the environment variable HIGZPRINTER is not defined the file 
   paw.ps is created but not printed.  

\ENDCMD

\DEFCMD{P}{IZOUT}{PICTURE}{IZOUT}{ [ pname ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Write the picture PNAME to a direct access picture file (see command 
   PICTURE/FILE).  PNAME=' ' means the current picture.  PNAME='*' means all 
   pictures.  

\ENDCMD

\DEFCMD{P}{IZIN}{PICTURE}{IZIN}{ pname [ icycle ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ Loop}
\DEFARG{ICYCLE}{I}{Cycle number }{ D=9999}
\ENDARG

   \par
Read picture into memory from a direct access picture file.  (see command 
   PICTURE/FILE).  PNAME='*' means all pictures.  

\ENDCMD

\DEFCMD{P}{IZPICT}{PICTURE}{IZPICT}{ pname [ chopt ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{}
\DEFARG{CHOPT}{C}{Options}{ D='M'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{M}{\par
Make a new picture in memory with name PNAME. An empty structure is created in 
memory and becomes the current picture. If PNAME = ' ', the picture is 
automatically named as PICTnnn, where the starting value of nnn is either 0 
(default), or the value assigned by SET to the parameter PICT.
}
\DEFOPT{D}{\par
Display the picture PNAME in memory.
}
\DEFOPT{S}{\par
Scratch the picture PNAME from memory. If PNAME = ' ' the current picture is 
scratched.
}
\DEFOPT{N}{\par
The picture following the current picture in memory becomes the current 
picture. If the current picture is the last one in memory, the first picture 
in memory becomes the current picture.
}
\DEFOPT{L}{\par
Give the list of the pictures in memory, following the sequence of their 
storage in memory.
}
\DEFOPT{F}{\par
The First picture in memory becomes the current picture.
}
\DEFOPT{P}{\par
Print the picture data structure. Useful to debug programs.
}
\DEFOPT{C}{\par
Set Current picture. All calls to HIGZ graphic functions are stored in the 
current structure according to the option selected be IGZSET.
}
\ENDOPT

   \par
Perform various operations on a picture.  PNAME=' ' means the current 
   picture.  PNAME='*' means all pictures.  

\ENDCMD

\DEFCMD{P}{SWITCH}{PICTURE}{SWITCH}{ [ chopt ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D='G'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{G}{\par
graphics output only.
}
\DEFOPT{Z}{\par
Graphics primitives stored in ZEBRA memory only.
}
\ENDOPT

   \par
Set the graphics switch to control plotting output to terminal (G) and/or 
   picture in memory (Z).  

\ENDCMD

\DEFCMD{P}{IGSET}{PICTURE}{IGSET}{ [ chatt value ]}

\BEGARG
\DEFARG{CHATT}{C}{Attribute name}{ D='SHOW'}
\DEFARG{VALUE}{R}{Attribute value}{ D=0.}
\ENDARG

   \par
Set a HIGZ attribute.  If CHATT='SHOW' print default and current values for 
   all attributes.  If CHATT='*' restore default values for all attributes.  
   If VALUE=0, the attribute is set to its default value.  

\begin{verbatim}
 +-----------------------------------------------------------------------------+
 |                        IGSET : Current values in use                        |
 +-------------+---------------+---------------+-------------------------------+
 |  Parameter  | Current value | Default value |          Explanation          |
 +-------------+---------------+---------------+-------------------------------+
 |    FAIS     |       0       |        0      | Fill area interior style      |
 |    FASI     |       1       |        1      | Fill area style index         |
 |    LTYP     |       1       |        1      | Line type                     |
 |    BASL     |        .150   |         .010  | Basic segment length (NDC)    |
 |    LWID     |       1.000   |        1.000  | Line width                    |
 |    MTYP     |       1       |        1      | Marker type                   |
 |    MSCF     |       1.000   |        1.000  | Marker scale factor           |
 |    PLCI     |       1       |        1      | Polyline color index          |
 |    PMCI     |       1       |        1      | Polymarker color index        |
 |    FACI     |       1       |        1      | Fill area color index         |
 |    TXCI     |       1       |        1      | Text color index              |
 |    TXAL     |       0  0    |        0  0   | Text alignment                |
 |    CHHE     |        .280   |         .010  | Character height              |
 |    TANG     |        .000   |         .000  | Text angle                    |
 |    TXFP     |       0  2    |        0  2   | Text font and precision       |
 |    PICT     |       1       |        1      | Current automatic number      |
 |    BORD     |       0       |        0      | Border flag                   |
 |    PASS     |       1       |        1      | Number of pass in IGTEXT      |
 |    CSHI     |        .030   |         .020  | IGTEXT shift                  |
 |    LASI     |        .018   |         .018  | Label axis size               |
 |    LAOF     |        .013   |         .013  | Label axis offset             |
 |    TMSI     |        .019   |         .019  | Tick marks size               |
 |    AWLN     |        .000   |         .000  | Axis wire lenght              |
 |    BARO     |        .250   |         .250  | Offset of IGHIST (IGRAPH) bars|
 |    BARW     |        .500   |         .500  | Width of IGHIST (IGRAPH) bars |
 |    NCOL     |       8       |        8      | Number of COLors              |
 |    CLIP     |       1       |        1      | Clipping mode                 |
 |    NLIN     |      40       |       40      | Number of line for 3D shapes  |
 |    AURZ     |       0       |        0      | Automatic saving flag         |
 |    DIME     |       2       |        2      | Dimension used (2D or 3D)     |
 +-------------+---------------+---------------+-------------------------------+
\end{verbatim}
\ENDCMD
\DEFMENU{0}{ZEBRA}{ZEBRA}
\ifMENUtext
   \par
Interfaces to the ZEBRA RZ, FZ and DZ packages.  


\fi
\DEFMENU{1}{RZ}{ZEBRA/RZ}
\ifMENUtext
   \par
ZEBRA/RZ package: direct access Input/Output.  


\fi

\DEFCMD{ZR}{FILE}{ZEBRA/RZ}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in WORDS}{ D=1024}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Read only mode.
}
\DEFOPT{U}{\par
Update mode.
}
\ENDOPT

   \par
Open an existing direct access file.  

\ENDCMD

\DEFCMD{ZR}{MAKE}{ZEBRA/RZ}{MAKE}{ lun fname [ lrecl nrec nwkey chform chtags ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in WORDS}{ D=1024}
\DEFARG{NREC}{I}{Number of records}{ D=1000}
\DEFARG{NWKEY}{I}{Number of words per Key}{ D=1}
\DEFARG{CHFORM}{C}{Key format}{ D='I'}
\DEFARG{CHTAGS}{C}{List of Tags}{ D='HBOOK-ID'}
\ENDARG
\BEGOPT{CHFORM}
\DEFOPT{I}{}
\DEFOPT{B}{}
\DEFOPT{A}{}
\DEFOPT{H}{}
\ENDOPT

   \par
Open a new direct access file.  

\ENDCMD

\DEFCMD{ZR}{MDIR}{ZEBRA/RZ}{MDIR}{ chdir [ nwkey chform chtags ]}

\BEGARG
\DEFARG{CHDIR}{C}{Directory name}{}
\DEFARG{NWKEY}{I}{Number of words per Key}{ D=1}
\DEFARG{CHFORM}{C}{CHFORM}{ D='I'}
\DEFARG{CHTAGS}{C}{List of Tags}{ D='HBOOK-ID'}
\ENDARG

   \par
Create a new RZ directory below the current directory.  

\ENDCMD

\DEFCMD{ZR}{DDIR}{ZEBRA/RZ}{DDIR}{ chdir}

\BEGARG
\DEFARG{CHDIR}{C}{Directory name}{}
\ENDARG

   \par
Delete the directory CHDIR from the current directory.  

\ENDCMD

\DEFCMD{ZR}{LDIR}{ZEBRA/RZ}{LDIR}{ [ chpath chopt ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
List contents of a directory.
}
\DEFOPT{A}{\par
List all the Ntuple extensions.
}
\DEFOPT{T}{\par
List a directory Tree.
}
\ENDOPT

   \par
List contents of a directory (memory or disk).  To list all RZ files 
   currently opened, type 'LD //'.  Note that if the Current Directory is 
   //PAWC, this command uses the same format as HISTO/LIST.  

\ENDCMD

\DEFCMD{ZR}{CDIR}{ZEBRA/RZ}{CDIR}{ [ chpath chopt ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Change the current working directory (CWD).  IF CHPATH is given make it the 
   new CWD.  Otherwise, print the pathname of the CWD.  
\begin{verbatim}
    Ex.  CD dir1         ; make DIR1 the new CWD
         CD //file1/dir2 ; make //FILE1/DIR2 the new CWD
         CD              ; print the name of the CWD
\end{verbatim}

\ENDCMD

\DEFCMD{ZR}{PURGE}{ZEBRA/RZ}{PURGE}{ [ keep ]}

\BEGARG
\DEFARG{KEEP}{I}{Number of cycles to be kept}{ D=1}
\ENDARG

   \par
Purge an RZ directory.  

\ENDCMD

\DEFCMD{ZR}{LOCK}{ZEBRA/RZ}{LOCK}{ [ chlock ]}

\BEGARG
\DEFARG{CHLOCK}{C}{Lock identifier}{ D='RZFILE'}
\ENDARG

   \par
Lock an RZ directory.  

\ENDCMD

\DEFCMD{ZR}{FREE}{ZEBRA/RZ}{FREE}{ [ chlock ]}

\BEGARG
\DEFARG{CHLOCK}{C}{Lock identifier}{ D='RZFILE'}
\ENDARG

   \par
Free an RZ directory.  

\ENDCMD

\DEFCMD{ZR}{STAT}{ZEBRA/RZ}{STAT}{ chpath}

\BEGARG
\DEFARG{CHPATH}{C}{Name of top directory}{}
\ENDARG

   \par
Print space statistics for an RZ file.  

\ENDCMD
\DEFMENU{1}{FZ}{ZEBRA/FZ}
\ifMENUtext
   \par
ZEBRA/FZ package: sequential access Input/Output.  


\fi

\DEFCMD{ZF}{FILE}{ZEBRA/FZ}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in words}{ D=900}
\DEFARG{CHOPT}{C}{Options}{ D='IX'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{I}{\par
Input file.
}
\DEFOPT{O}{\par
Output file.
}
\DEFOPT{X}{\par
Binary exchange mode.
}
\DEFOPT{A}{\par
Alphanumeric exchange mode.
}
\ENDOPT

   \par
Open an FZ sequential formatted or unformatted file.  

\ENDCMD

\DEFCMD{ZF}{TOFZ}{ZEBRA/FZ}{TOFZ}{ lun [ chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number of FZ file}{ R=1:128}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Copy the current directory tree onto an FZ file.  

\ENDCMD

\DEFCMD{ZF}{FRFZ}{ZEBRA/FZ}{FRFZ}{ lun [ chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number of FZ file}{ R=1:128}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Copy the FZ file into the current directory tree.  

\ENDCMD

\DEFCMD{ZF}{TOALPH}{ZEBRA/FZ}{TOALPHA}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{Name of the FZ text file}{}
\ENDARG

   \par
Copy the current directory tree onto a FZ file.  An alphanumeric format is 
   used.  The file FNAME can be exchanged between different machines.  

\ENDCMD

\DEFCMD{ZF}{FRALPH}{ZEBRA/FZ}{FRALPHA}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{Name of the FZ text file}{}
\ENDARG

   \par
Copy the FZ alphanumeric file into the current directory.  

\ENDCMD
\DEFMENU{1}{DZ}{ZEBRA/DZ}
\ifMENUtext
   \par
ZEBRA/DZ package: debugging.  


\fi

\DEFCMD{ZD}{SHOW}{ZEBRA/DZ}{SHOW}{ name [ number chopt ]}

\BEGARG
\DEFARG{NAME}{C}{Bank name}{}
\DEFARG{NUMBER}{I}{Bank number}{ D=1}
\DEFARG{CHOPT}{C}{Options}{ D='BSV'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{B}{\par
Print the bank.
}
\DEFOPT{S}{\par
Print the bank contents from left to right Sideways with up to ten elements 
per line.
}
\DEFOPT{V}{\par
Print the vertical (down) structure.
}
\DEFOPT{D}{\par
Print the bank contents from top to bottom Downwards with five elements per 
line.
}
\DEFOPT{L}{\par
Print the linear structure.
}
\DEFOPT{Z}{\par
Print the data part of each bank in hexadecimal format
}
\ENDOPT

   \par
Display the contents of a bank or a data structure identified by its NAME 
   and NUMBER.  The output format of the data part is controlled by the 
   internal or external I/O characteristic.  

\ENDCMD

\DEFCMD{ZD}{SURV}{ZEBRA/DZ}{SURV}{ name [ number ]}

\BEGARG
\DEFARG{NAME}{C}{Bank name}{}
\DEFARG{NUMBER}{I}{Bank number}{ D=1}
\ENDARG

   \par
Print a survey of the structure identified by NAME, NUMBER.  

\ENDCMD

\DEFCMD{ZD}{SNAP}{ZEBRA/DZ}{SNAP}{ [ idiv chopt ]}

\BEGARG
\DEFARG{IDIV}{I}{Division number }{ D=2 R=0:24}
\DEFARG{CHOPT}{C}{Options}{ D='M'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{M}{\par
Print Map entry for each bank
}
\DEFOPT{E}{\par
Extend map entry to dump all links of each bank (otherwise only as many links 
as will fit on a line)
}
\DEFOPT{F}{\par
Full. Dump all active banks, links and data
}
\DEFOPT{K}{\par
Kill. Dropped banks to be treated as active (dropped banks are not normally 
dumped under D or F option)
}
\DEFOPT{L}{\par
Dump all Link areas associated with the store
}
\DEFOPT{W}{\par
Dump the Working space, links and data
}
\DEFOPT{Z}{\par
Dump the information in hexadecimal.
}
\ENDOPT

   \par
Snap of one or more divisions.  Provides a snapshot of one or more 
   divisions in a ZEBRA store.  The kind of information provided is controlled 
   by CHOPT.  

\ENDCMD

\DEFCMD{ZD}{VERIFY}{ZEBRA/DZ}{VERIFY}{ [ idiv chopt ]}

\BEGARG
\DEFARG{IDIV}{I}{Division number }{ D=0 R=0:24}
\DEFARG{CHOPT}{C}{Options}{ D='CLSU'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{C}{\par
Check chaining of banks only
}
\DEFOPT{L}{\par
Check validity of the structural links (implies 'C')
}
\DEFOPT{S}{\par
Check the store parameters
}
\DEFOPT{U}{\par
Check the validity of the up and origin (implies 'C')
}
\DEFOPT{F}{\par
Errors are considered fatal and generate a call to ZFATAL
}
\ENDOPT

   \par
Check the structure of one or more ZEBRA divisions.  The verification 
   detail depends on the settings in CHOPT.  

\ENDCMD

\DEFCMD{ZD}{STORE}{ZEBRA/DZ}{STORE}{ [ ixstor ]}

\BEGARG
\DEFARG{IXSTOR}{I}{Store number}{ D=0 R=0:24}
\ENDARG

   \par
Display the structure of the ZEBRA store IXSTOR.  Output the parameters 
   characterizing the store, followed by a list of all divisions and all link 
   areas associated with the store in question.  

\ENDCMD
\DEFMENU{0}{FORTRAN}{FORTRAN}
\ifMENUtext
   \par
Interface to MINUIT, COMIS, SIGMA and FORTRAN Input/Output.  


\fi

\DEFCMD{F}{HMINUI}{FORTRAN}{HMINUIT}{}

   \par
To input commands for Interactive MINUIT in a macro.  Example:  
\begin{verbatim}
    Application HMINUIT EXIT
    SET EPS 1.E-14
    MIGRAD
    SET PRIN 2
    MINOS
    EXIT
    Histo/fit 10 g m
\end{verbatim}

\ENDCMD

\DEFCMD{F}{COMIS}{FORTRAN}{COMIS}{}

   \par
Invoke the COMIS FORTRAN interpreter.  COMIS allows to execute FORTRAN 
   routines without recompiling and relinking. It communicates with PAW 
   commands through vectors and functions. COMIS has its PAW-independent 
   command structure.  Example in command mode:  
\begin{verbatim}
    PAW > Comis
    CS >    do 10 i=1,10
    MND>       x=sqrt(i)*10.
    MND>       print *,i,x
    MND> 10 continue
    MND>    END
    CS > quit
    PAW >
\end{verbatim}
   \par
COMIS code may be inserted into a macro. Example:  
\begin{verbatim}
    Vector/Create Y(10) r 1 2 3 4 5 6 7 8 9 10
    *
    *  In the following COMIS code, the statement "Vector Y" declares
    *  to COMIS an existing KUIP vector. KUIP dimension is assumed.
    *  The statement "Vector X(10)" creates a new KUIP vector.
    *  (Note that SUBROUTINEs must be declared before the MAIN program)
    *  (KUIP vectors cannot be created into the MAIN program)
    *
    APPLIcation COMIS QUIT
          SUBROUTINE DEMO
          Vector Y
          Vector X(10)
          do 10 i=1,10
             XX=i
             X(i)=Y(i)*sqrt(XX)*10.
      10  CONTINUE
          END
          CALL DEMO
          END
    QUIT
    Vector/print X       | Print KUIP vector created by COMIS
\end{verbatim}

\ENDCMD

\DEFCMD{F}{CALL}{FORTRAN}{CALL}{ urout}

\BEGARG
\DEFARG{UROUT}{C}{User routine}{}
\ENDARG

   \par
Execute the routine UROUT.  UROUT may be a routine compiled and linked with 
   PAW.  For example : CALL HPRINT(10).  

   \par
UROUT may also be the name of a file which can be edited interactively with 
   the command EDIT. For example if file UROUT.FOR contains:  
\begin{verbatim}
        SUBROUTINE UROUT(N)
        SUM=0.
        DO 10 I=1,N
          SUM=SUM+I
     10 CONTINUE
        PRINT *,SUM
        END
\end{verbatim}
   \par
Then one can type CALL UROUT.FOR(10). The routine UROUT may also contain 
   references to the library routines mentioned below.  

   \par
The functions \$CALL, \$ICALL, and \$DCALL allow to call REAL, INTEGER, and 
   DOUBLE PRECISION functions, respectively.  The function call must be 
   enclosed in quotes, for example:  
\begin{verbatim}
        $CALL('fun.f(1.5)')
\end{verbatim}
   \par
with file fun.f containing 
\begin{verbatim}
        FUNCTION FUN(X)
        FUN=X**2
        END
\end{verbatim}
\ENDVERB
   \par
The following routines from the CERN Program Library can be called:  

\begin{verbatim}
   From HBOOK:
      HBOOK1,HBOOK2,HBOOKN,HFILL,HF1,HPRINT,HDELET,HRESET
      HFITGA,HFITPO,HFITEX,HPROJ1,HPROJ2,HFN,HGFIT,HRENID
      HROPEN,PAOPEN,PACLOS,PAREAD,PAWRIT,HCDIR,HGIVEN,HKIND
      HTITLE,HBFUN1,HBFUN2,HRNDM1,HRNDM2,HBARX,HBARY,HDIFFB
      HPAK,HPAKE,HUNPAK,HGIVE,HGN,HGNF,HGNPAR,HF2,HFF1,HFF2
      HRIN,HROUT,HI,HIE,HIX,HIJ,HIF,HIDALL,HNOENT,HX,HXY
      HTITLE,HCOPY,HSTATI,HBPROF,HOPERA,HIDOPT,HDERIV,HBAR2
      HMAXIM,HMINIM,HMAX,HMIN,HSUM,HNORMA,HMCINI,HMCMLL
      HEXIST,HREND,HRGET,HRPUT,HSCR,HFIND,HCX,HCXY,HLABEL
      HBPROX,HBPROY,HBANDX,HBANDY,HBSLIX,HBSLIY,HPROF2
      HBOOKB,HBSTAT,HDIFF,HUNPKE,HREBIN,HERROR,HGNTB,HSTAF
      HOUTPU,HERMES,HISTDO,HFUNC,HXI,HIJXY,HXYIJ,HLPOS,HFC1
      HSPLI1,HSPLI2,HMDIR,HLDIR,HLOCAT,HFITH,HFITV,HFINAM
      HBNT,HBNAME,HBNAMC,HFNT,HFNTB,HGNT,HGNTF,HGNTV,HBSET
      HRENAME,HNTDUP,HFITHN
   From HPLOT:
      HPLOT,HPLSYM,HPLERR,HPLEGO,HPLNT,HPLSUR,HPLSOF,HPLFRA
      HPLABL,HPLSET,HPLGIV,HPLOC,HPLTOC,HPLNEW,HPLOPT
   From ZEBRA:
      MZSTOR,MZDIV,MZLINK,MZWORK,MZBOOK,MZDROP,MZPUSH
      MZWIPE,MZGARB,MZFORM,LZFIND,LZFID,DZSHOW,DZVERI
      FZIN,FZOUT,FZFILE,FZENDI,FZENDO
      RZCDIR,RZLDIR,RZFILE,RZEND,RZIN,RZOUT,RZVIN,RZVOUT
      RZOPEN,RZIODO,RZCLOS,RZQUOT
   From KUIP:
      KUGETV,KUDPAR,KUVECT,KILEXP,KUTIME,KUEXEL,KUPROS
      KUNWG,KUCMD,KUGUID,KUNDPV,KUPAR,KUPVAL,KUACT
   From HIGZ:
      IPL,IPM,IFA,IGTEXT,IGBOX,IGAXIS,IGPIE,IGRAPH,IGHIST
      IGARC,IGLBL,IGRNG,IGMETA,IGSA,IGSET,IRQLC,IRQST,ISCR
      ISELNT,ISFAIS,ISFASI,ISLN,ISMK,ISVP,ISWN,ITX,ICLRWK
      IGPAVE,IGTERM,ISFACI,IGHTOR
   From KERNLIB:
      VZERO,UCOPY,RANNOR,LENOCC,SBIT0,SBIT1,SBYT
      JBIT,JBYT,UCTOH,UHTOC,CLTOU,CUTOL,ERF,ERFC,FREQ,GAMMA
      PROB,DENLAN,DSTLAN,DIFLAN,XM1LAN,XM2LAN,RANLAN
      RNDM,RDMIN,RDMOUT,SORTZV,CSF77

   The following common blocks may be referenced:
     /PAWC/, /QUEST/, /KCWORK/, /PAWPAR/, /PAWIDN/
     /HCFITS/, /HCFITD/, /RZCLUN/
\end{verbatim}
\ENDCMD

\DEFCMD{F}{LOOP}{FORTRAN}{LOOP}{ ntimes urout}

\BEGARG
\DEFARG{NTIMES}{I}{Number of calls}{ D=1}
\DEFARG{UROUT}{C}{User routine}{}
\ENDARG

   \par
The routine UROUT is called NTIMES times.  See command CALL for explanation 
   of UROUT.  

\ENDCMD

\DEFCMD{F}{FILE}{FORTRAN}{FILE}{ lun fname [ status ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{STATUS}{C}{File status}{ D='DONTKNOW'}
\ENDARG
\BEGOPT{STATUS}
\DEFOPT{OLD}{\par
Open existing file for reading.
}
\DEFOPT{APPEND}{\par
Open existing file and position at EOF.
}
\DEFOPT{NEW}{\par
Create new file; error if already existing.
}
\DEFOPT{UNKNOWN}{\par
Open existing or create new file.
}
\DEFOPT{DONTKNOW}{\par
Like UNKNOWN except on VMS opens highest cycle.
}
\ENDOPT

   \par
Open a FORTRAN formatted text file.  UNKNOWN opens a file for write access 
   without flagging an error if the file already exists.  On VMS a new cycle 
   is created.  DONTKNOW is the same as UNKNOWN except on VMS where the 
   highest cycle is opened.  This option should be used if it is not yet known 
   whether the file will be read or written.  

\ENDCMD

\DEFCMD{F}{CLOSE}{FORTRAN}{CLOSE}{ lun}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=0:128}
\ENDARG

   \par
Close the file on unit LUN.  If the file has been opened with HISTO/FILE, 
   PICTURE/FILE, etc, then before closing the unit, PAW will close correctly 
   the file with CALL HREND or FZENDI(O), ICLWK, etc.  Giving 0 as unit will 
   close all open files.  

\ENDCMD

\DEFCMD{F}{REWIND}{FORTRAN}{REWIND}{ lun}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\ENDARG

   \par
Rewind the file on unit LUN.  

\ENDCMD

\DEFCMD{F}{SIGMA}{FORTRAN}{SIGMA}{ [ expr ]}

\BEGARG
\DEFARG{EXPR}{C}{Expression}{ D=\EMPTY{}}
\ENDARG

   \par
Invoke the SIGMA package.  SIGMA is an array manipulation package using its 
   own vector-oriented language, outside the PAW command conventions.  SIGMA 
   may be invoked in one of the three following ways:  
\begin{verbatim}
    1- Using the KUIP $SIGMA function. Example:
       PAW > Vector/Create x(10) r 1 2 3 4 5 6 7 8 9 10
       PAW > Graph 10 x $sigma(sqrt(x))
\end{verbatim}
\begin{verbatim}
    2- Using the SIGMA command. Example:
       PAW > sigma x=array(10,1#10)
       PAW > sigma y=sqrt(x)
       PAW > Graph 10 x y
\end{verbatim}
\begin{verbatim}
    3- Using the APPLication command. Example:
       PAW > APPLication SIGMA
       SIGMA > x=array(10,1#10)
       SIGMA > y=sqrt(x)
       SIGMA > exit
       PAW > Graph 10 x y
\end{verbatim}

\ENDCMD
\DEFMENU{0}{NETWORK}{NETWORK}
\ifMENUtext
   \par
To access files on remote computers.  To send messages to a remote process 
   (ZEBRA server) 


\fi

\DEFCMD{N}{RLOGIN}{NETWORK}{RLOGIN}{ host}

\BEGARG
\DEFARG{HOST}{C}{Host name}{ D=\EMPTY{}}
\ENDARG

   \par
Start a communication with a remote machine HOST.  Current Directory will 
   be changed to //HOST.  

\ENDCMD

\DEFCMD{N}{RSHELL}{NETWORK}{RSHELL}{ message}

\BEGARG
\DEFARG{MESSAGE}{C}{Message to remote host}{ D=\EMPTY{}}
\ENDARG

   \par
Send MESSAGE to current remote host.  Note that the Current Directory must 
   be //HOST (see RLOGIN).  Some PAW commands (Histo/Plot, Histo/List) can 
   communicate directly with HOST.  

\ENDCMD
\DEFMENU{1}{PIAF}{NETWORK/PIAF}
\ifMENUtext
   \par
To establish and control the connection to the Piaf server.  The Parallel 
   Interactive Analysis Facility (Piaf) is a cluster of 5 high-performance HP 
   workstations.  

   \par
A locally running PAW session (client) connected to the Piaf server can 
   access Hbook RZ files stored on the server side in a transparent way.  
   Commands with high CPU or I/O requirements, e.g. NT/PLOT and NT/PROJECT are 
   processed by the server and only the resulting histograms etc. are sent 
   back to the client.  

   \par
In order to use the Piaf server the PAW client must have been compiled with 
   the communications option CZ using TCP/IP as transport protocol.  


\fi

\DEFCMD{NP}{CONNEC}{NETWORK/PIAF}{CONNECT}{ [ server node ]}

\BEGARG
\DEFARG{SERVER}{C}{Server name}{ D='piaf'}
\DEFARG{NODE}{C}{Front-end node}{ D='128.141.201.28'}
\ENDARG

   \par
Establish a connection to the Piaf server.  Subsequent HISTO/FILE commands 
   can refer to files on the server using path names '//piaf/file.hbook'.  

\ENDCMD

\DEFCMD{NP}{STAGE}{NETWORK/PIAF}{STAGE}{ source [ target option ]}

\BEGARG
\DEFARG{SOURCE}{C}{Source file identifier}{}
\DEFARG{TARGET}{C}{Target file name}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{N}{\par
NoWait. Submit the request to the staging system and return immediately.
}
\ENDOPT

   \par
Stage an Ntuple file on the Piaf server.  The source file identifier can be 
   the name of a local file on the client system, a Fatmen path, or a tape 
   identifier.  If the target file name is not specified it is constructed 
   from the source identifier.  

   \par
Unless the option N is used the STAGE command waits until the staging is 
   completed and the file is ready to be used.  

\ENDCMD

\DEFCMD{NP}{GET}{NETWORK/PIAF}{GET}{ remote [ local format recl ]}

\BEGARG
\DEFARG{REMOTE}{C}{Remote file name}{}
\DEFARG{LOCAL}{C}{Local file name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Text or binary}{ D='RZ'}
\DEFARG{RECL}{I}{Record length in bytes}{ D=0 R=0:}
\ENDARG
\BEGOPT{FORMAT}
\DEFOPT{T}{\par
Text file.
}
\DEFOPT{RZ}{\par
Zebra RZ file in exchange format.
}
\DEFOPT{BIN}{\par
Binary file with record length given by RECL.
}
\ENDOPT

   \par
Copy a file from the Piaf server to the client system.  If not specified 
   the local file name will be same as the remote file name.  RECL needs to be 
   specified only for BIN format.  For IBM only: A text file with RECL=0 is 
   written in V-format.  Otherwise it is written in F-format with the given 
   LRECL.  

\ENDCMD

\DEFCMD{NP}{PUT}{NETWORK/PIAF}{PUT}{ local [ remote format ]}

\BEGARG
\DEFARG{LOCAL}{C}{Local file name}{}
\DEFARG{REMOTE}{C}{Remote file name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Text or binary}{ D='RZ'}
\ENDARG
\BEGOPT{FORMAT}
\DEFOPT{T}{\par
Text file.
}
\DEFOPT{RZ}{\par
Zebra RZ file in exchange format.
}
\DEFOPT{BIN}{\par
Binary file.
}
\ENDOPT

   \par
Copy a file from the client system to the Piaf server.  If not specified 
   the remote file name will be same as the local file name.  Note for VMS: 
   Avoid text files with variable record length.  Use Stream\_LF format 
   instead.  

\ENDCMD

\DEFCMD{NP}{LS}{NETWORK/PIAF}{LS}{ [ files ]}

\BEGARG
\DEFARG{FILES}{C}{File pattern}{ D=\EMPTY{}}
\ENDARG

   \par
List files stored on the Piaf server.  

\ENDCMD

\DEFCMD{NP}{CAT}{NETWORK/PIAF}{CAT}{ file}

\BEGARG
\DEFARG{FILE}{C}{File name}{}
\ENDARG

   \par
Print a Piaf file on the terminal.  

\ENDCMD

\DEFCMD{NP}{RM}{NETWORK/PIAF}{RM}{ file}

\BEGARG
\DEFARG{FILE}{C}{File name}{}
\ENDARG

   \par
Delete a Piaf file.  

\ENDCMD

\DEFCMD{NP}{MV}{NETWORK/PIAF}{MV}{ from to}

\BEGARG
\DEFARG{FROM}{C}{Old file name}{}
\DEFARG{TO}{C}{New file name}{}
\ENDARG

   \par
Rename a Piaf file.  

\ENDCMD

\DEFCMD{NP}{CP}{NETWORK/PIAF}{CP}{ from to}

\BEGARG
\DEFARG{FROM}{C}{Old file name}{}
\DEFARG{TO}{C}{New file name}{}
\ENDARG

   \par
Copy a Piaf file to a new file.  

\ENDCMD

\DEFCMD{NP}{PWD}{NETWORK/PIAF}{PWD}{}

   \par
Show current Piaf working directory.  

\ENDCMD

\DEFCMD{NP}{MKDIR}{NETWORK/PIAF}{MKDIR}{ dir}

\BEGARG
\DEFARG{DIR}{C}{Directory name}{}
\ENDARG

   \par
Create a new directory on Piaf.  

\ENDCMD

\DEFCMD{NP}{RMDIR}{NETWORK/PIAF}{RMDIR}{ dir}

\BEGARG
\DEFARG{DIR}{C}{Directory name}{}
\ENDARG

   \par
Delete a directory on Piaf.  

\ENDCMD

\DEFCMD{NP}{MESSAG}{NETWORK/PIAF}{MESSAGE}{ mess}

\BEGARG
\DEFARG{MESS}{C}{Message}{}
\ENDARG

   \par
Send a message to Piaf.  

\ENDCMD

\DEFCMD{NP}{STATUS}{NETWORK/PIAF}{STATUS}{}

   \par
Inquire the status of the Piaf server.  

\ENDCMD

\DEFCMD{NP}{MODE}{NETWORK/PIAF}{MODE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Processing mode}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
Inquire the current mode.
}
\DEFOPT{SEQ}{\par
Set sequential processing mode.
}
\DEFOPT{PAR}{\par
Set parallel processing mode.
}
\ENDOPT

   \par
Inquire or change the processing mode of the Piaf server.  In parallel mode 
   the Piaf server uses slave servers to process Ntuple requests on all 
   available machines in parallel.  

   \par
With certain types of COMIS selection functions, e.g. when reading from an 
   external file for each event, parallel processing is not possible.  The 
   Piaf server should be switched to sequential mode, i.e. the master server 
   alone processes the Ntuple request.  

\ENDCMD

\DEFCMD{NP}{LOGLEV}{NETWORK/PIAF}{LOGLEVEL}{ level}

\BEGARG
\DEFARG{LEVEL}{I}{Log level}{ D=0}
\ENDARG

   \par
Set the level of diagnostic output from the Piaf server.  

\ENDCMD

\DEFCMD{NP}{DISCON}{NETWORK/PIAF}{DISCONNECT}{}

   \par
Close the connection to the Piaf server.  

\ENDCMD
\DEFMENU{0}{OBSOLETE}{OBSOLETE}
\ifMENUtext
   \par
Obsolete commands 


\fi
\DEFMENU{1}{GRAPHICS}{OBSOLETE/GRAPHICS}
\ifMENUtext

\fi
\DEFMENU{2}{ATTRIBUTES}{OBSOLETE/GRAPHICS/ATTRIBUTES}
\ifMENUtext

\fi

\DEFCMD{OGA}{SMK}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SMK}{ [ mkt ]}

\BEGARG
\DEFARG{MKT}{I}{Marker type}{ D=1}
\ENDARG

   \par
Set the marker type.  Obsolete command use SET MTYP 

\ENDCMD

\DEFCMD{OGA}{SLN}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SLN}{ [ iln ]}

\BEGARG
\DEFARG{ILN}{I}{Line style}{ D=1 R=1:}
\ENDARG

   \par
Set the line style.  Obsolete command use  SET LTYP.  

\ENDCMD

\DEFCMD{OGA}{SFAIS}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SFAIS}{ [ ints ]}

\BEGARG
\DEFARG{INTS}{I}{Fill area interior style}{ D=0 R=0:3}
\ENDARG

   \par
Set the fill area interior style.  Obsolete command use SET FAIS.  

\ENDCMD

\DEFCMD{OGA}{SFASI}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SFASI}{ [ styli ]}

\BEGARG
\DEFARG{STYLI}{I}{Fill area style index}{ D=1}
\ENDARG

   \par
Set the fill area style index.  Obsolete command use SET FASI.  

\ENDCMD

\DEFCMD{OGA}{SFACI}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SFACI}{ [ ifaci ]}

\BEGARG
\DEFARG{IFACI}{I}{Fill area color index}{ D=1}
\ENDARG

   \par
Set the fill area color index.  Obsolete command use SET FACI.  

\ENDCMD

\DEFCMD{OGA}{SPLCI}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SPLCI}{ [ iplci ]}

\BEGARG
\DEFARG{IPLCI}{I}{Polyline color index}{ D=1}
\ENDARG

   \par
Set the polyline color index.  Obsolete command use SET PLCI.  

\ENDCMD

\DEFCMD{OGA}{SPMCI}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SPMCI}{ [ ipmci ]}

\BEGARG
\DEFARG{IPMCI}{I}{Polymarker color index}{ D=1}
\ENDARG

   \par
Set the polymarker color index.  Obsolete command use SET PMCI.  

\ENDCMD

\DEFCMD{OGA}{STXCI}{OBSOLETE/GRAPHICS/ATTRIBUTES}{STXCI}{ [ itxci ]}

\BEGARG
\DEFARG{ITXCI}{I}{Text color index}{ D=1}
\ENDARG

   \par
Set the text color index.  Obsolete command use SET TXCI.  

\ENDCMD

\DEFCMD{OGA}{STXFP}{OBSOLETE/GRAPHICS/ATTRIBUTES}{STXFP}{ [ ifont iprec ]}

\BEGARG
\DEFARG{IFONT}{I}{Font number}{ D=0}
\DEFARG{IPREC}{I}{Font precision}{ D=2}
\ENDARG

   \par
Set text font and precision.  Obsolete command use SET TXFP.  

\ENDCMD

\DEFCMD{OGA}{SCHH}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SCHH}{ [ chh ]}

\BEGARG
\DEFARG{CHH}{R}{Character height}{ D=0.28}
\ENDARG

   \par
Set the character height.  Obsolete command use SET CHHE.  

\ENDCMD

\DEFCMD{OGA}{SLWSC}{OBSOLETE/GRAPHICS/ATTRIBUTES}{SLWSC}{ [ lw ]}

\BEGARG
\DEFARG{LW}{R}{Line width}{ D=1 R=1:}
\ENDARG

   \par
Set the line width scale factor.  Obsolete command use SET LWID.  

\ENDCMD
@


1.5
log
@page-break mods for final print
@
text
@d12 70
d101 5
a105 4
Give the help of a command.  If ITEM is a command its full explanation is 
   given:  syntax (as given by the command USAGE), functionality, list of 
   parameters with their attributes (prompt, type, default, range, etc.).  If 
   ITEM='/' the help for all commands is given.  
d108 7
a114 1
If HELP is entered without parameters or ITEM is a submenu, the dialogue 
d119 7
a125 6
'HELP -EDIT' (or just 'HELP -E') switches to edit mode:  instead of writing 
   the help text to the terminal output, it is written into a temporary file 
   and the pager or editor defined by the command HOST\_PAGER is invoked.  (On 
   Unix workstations the pager can be defined to display the help text 
   asynchrously in a separated window.) 'HELP -NOEDIT' (or just 'HELP -N') 
   switches back to standard mode.  The startup value is system dependent.  
d346 3
d415 7
d500 7
d703 1
a703 1
Select the user dialogue style (or working mode).  The startup value is 'C' 
d720 1
a720 1
\DEFCMD{KS}{PANEL}{KUIP/SET\_SHOW}{PANEL}{ line [ gkey ]}
d728 3
a730 4
Set up a panel of graphics keys. The \DQUOTE{}panel interface\DQUOTE{} is 
   available in \DQUOTE{}STYLE GP\DQUOTE{} and in KUIP/Motif (not in the basic 
   command mode).  N.B. in \DQUOTE{}STYLE GP\DQUOTE{} only one panel of 
   commands can be set up, whereas in KUIP/Motif there is no limitation.  
d733 24
a759 4
    PANEL  2 A/L QUIT V/L           | initialize line 2 with 3 graphics keys,
                                      respectively A/L, QUIT, V/L
    PANEL  2 A/L ' '  V/L ' ' ' '   | initialize line 2 with 5 graphics keys,
                                      and fill 1st and 3rd keys
a761 2
    PANEL -2.08                     | initialize line 2 with 8 graphics keys
    PANEL -6.16                     | initialize line 6 with 16 graphics keys
d788 29
a816 2
In KUIP/Motif there are 2 addditinal commands in order to display or to 
   close one panel:  
d819 7
d830 4
d851 7
a857 1
\ENDCMD
d864 1
a864 1
\DEFARG{TITLE}{C}{Panel Title}{ D='New Panel'}
d872 2
a873 1
Set up a new panel with empty keys (to be filled interactively).  
d1677 1
a1677 1
Explanation of KUIP macro syntax.  
d3153 14
a3166 3
   the angles are THETA=1 and PHI=-1.  When option 'E' is used, the marker 
   type can be changed with SET MTYP, the marker size with SET KSIZ, the 
   marker color with SET PMCI.  
d3175 1
d3270 18
a3287 3
Copy a histogram (not Ntuple) onto another one.  Bin definition, contents, 
   errors, etc. are preserved.  If TITLE is not given, ID2 has the same title 
   as ID1.  
a3966 3

\finalnewpage

d4067 1
a4067 1
Include also comparison of the relative normalization of the two histograms, 
d4077 1
a4077 1
and for normalization.
d4257 19
d4287 1
a4287 1
   parameterization in terms of elementary functions (regressors). See HBOOK 
d4310 1
a4310 1
The FORTRAN code of the parameterization is written onto the file 
d4468 9
a4476 1
   just set VMAX less then the minimum.  
d4489 9
a4497 1
   just set VMIN greater then the maximum.  
d4505 1
a4505 1
\DEFARG{XNORM}{R}{Normalization factor}{ D=1}
d4509 1
a4509 1
Set the contents/errors normalization factor.  Only valid for histograms 
a4531 6

   \par
Set options for histogram ID. (* means default).  

\finalnewpage

d4649 3
d4992 7
d5001 1
a5001 1
\DEFCMD{N}{DUPLIC}{NTUPLE}{DUPLICATE}{ id1 id2 [ newbuf title option ]}
d5032 3
d5036 54
a5089 22
    Example of use:
      Macro Dup
      Histo/file 1 source.hbook
      Histo/file 2 New.hbook ! N
      Ntuple/Dupl //lun1/10 20
      Nt/loop //lun1/10  duplic.f
      Hrout 20
      Return
\end{verbatim}
\begin{verbatim}
      File duplic.f:
            real function duplic(dum)
            include ?
      *-* The call to HGNT is only necessary for CWNs
      *-* For RWNs, replace HFNT by HFN(20,xvar) where xvar is the name
      *-* of the first variable in /PAWCR4/
            if(some_condition)then
               call hgnt(10,idnevt,ierr)
               call hfnt(20)
            endif
            duplic=1.
            end
d5092 1
a5092 1
\ENDCMD
d5126 3
d5169 5
d5256 1
a5256 1
\DEFCMD{N}{READ}{NTUPLE}{READ}{ idn fname [ format chopt nevent ]}
d5262 1
a5262 1
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
d5264 1
d5269 42
a5310 2
   specifications in FORMAT.  Before executing this command, the Ntuple IDN 
   must have been created with the command Ntuple/Create.  
d5781 15
d6084 1
a6084 1
   Note that PAW opens the file PAW.METAFILE on the unit 10 at initialization 
d6165 2
a6166 1
   workstation types is: 4x9x9x13+1 = 4213 ! 
a6205 5

\ENDCMD

\DEFCMD{G}{SLIDE}{GRAPHICS}{SLIDE}{}

d6207 2
a6208 1
Invoke the SLIDE package.  
d6223 1
a6223 1
   been selected.  Select the Normalization Transformation number 1 (cm).  
d6332 1
a6332 1
To define Normalization transformations.  Either automatically (ZONE and 
d6360 5
d6377 1
a6377 1
   by XSIZE cm.  This command sets the parameters for the normalization 
d6385 1
a6385 1
\DEFARG{NT}{I}{Normalization transformation number}{}
d6393 1
a6393 1
Set the viewport of the normalization transformation NT in the Normalized 
d6397 4
d6414 1
a6414 1
Set the window of the normalization transformation NT in World Coordinates 
d6416 4
a6419 1
   window parameters.  For example:  
d6421 5
a6425 5
         PAW > Nul 0 1 -1 1      | Draw an empty frame (0,1)x(-1,1)
         PAW > Line 0 0 1 1      | Draw a line in (0,1)x(-1,1)
         PAW > Swn 10 0 10 0 10  | Change the coordinates to (0,10)x(0,10)
         PAW > Selnt 10          | Activate the coordinates (0,10)x(0,10)
         PAW > Line 0 0 1 1      | Draw a line in (0,10)x(0,10)
d6427 4
d6437 1
a6437 1
\DEFARG{NT}{I}{Normalization transformation number}{}
d6441 1
a6441 1
Select a normalization transformation number.  
d6461 11
d6491 1
a6491 1
Draw a polyline of N points X,Y in the current Normalization 
d6521 1
a6521 1
   Normalization transformation. This command is kept for backward 
d6550 1
a6550 1
   Normalization transformation taking care of logarithmic scales. The DLINE 
d6576 1
a6576 1
Fill the area defined by the N points X,Y in the current Normalization 
d6610 1
a6610 1
Draw polymarkers at the N points X,Y in the current Normalization 
d6641 1
a6641 1
   the current Normalization transformation.  The BOX attributes can be 
d6681 1
a6681 1
   attributes.  Use the current Normalization transformation.  The FBOX 
d6711 1
a6711 1
Draw an arrow Use the current Normalization transformation.  The ARROW 
d6752 1
a6752 1
   Normalization transformation.  Feynman graph: gluon phi = 30, photon phi = 
d6785 1
a6785 1
   Normalization transformation.  Feynman graph: gluon phi = 30, photon phi = 
d6815 1
a6815 1
   fill area attributes.  Use the current Normalization transformation.  
d6846 1
a6846 1
   the current Normalization transformation.  
d6938 1
a6938 1
No bining optimization
d6946 1
a6946 1
Draw an axis in the current Normalization transformation.  
d7002 2
a7003 2
     Axis bining optimization: By default the axis bining is optimized .
           CHOPT='N': No bining optimization
d7020 4
d7040 1
a7040 1
   the current Normalization transformation.  If R1 is not equal to R2 the 
d7110 1
a7110 1
Draw a pie chart in the current Normalization transformation.  
d7152 1
a7152 1
Draw text at position X,Y in the current normalization transformation using 
d7187 1
a7187 1
Draw text at position X,Y in the current Normalization transformation, 
a7321 3

\finalnewpage

d7556 1
a7556 1
Draw the same symbol at several points x,y in the current normalization 
d7604 15
a7618 4
   normalization transformation.  By default, the symbols are not drawn if 
   they are on the edges of the plot: the option '0' allows to turn off this 
   symbols clipping.  If ISYMB = 0 or SSIZE = 0. no symbol is drawn.  Note 
   that the options can be cumulated.  
a7629 3
\ENDARG
\finalnewpage
\BEGARG
d7667 15
a7681 4
   normalization transformation.  By default, the symbols are not drawn if 
   they are on the edges of the plot: the option '0' allows to turn off this 
   symbols clipping.  If ISYMB = 0 or SSIZE = 0. no symbol is drawn.  Note 
   that the options can be cumulated.  
d7685 1
a7685 1
\DEFCMD{GH}{KEY}{GRAPHICS/HPLOT}{KEY}{ x y [ isymb text ]}
d7690 1
a7690 1
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
d7692 2
d7695 17
d7714 31
a7744 2
Draw one symbol and its explanation (legend) at a point x,y in the current 
   normalization transformation.  
d7787 40
a7826 11
The values of XVAL are always histogram coordinates.  The tick marks will 
   be drawn on both side of the cross wire, unless the cross-wires are 
   requested on the boundary of the box surrounding the histogram (i.e. at the 
   extreme limits of the drawn histogram). In this case tick marks will only 
   be drawn inside the box.  The options 'A' and 'B' (for Above and Below) 
   refer only to the cross-wire perpendicular to the Y axis.  In each case 
   only one cross-wire will be drawn.  Similarly 'L' and 'R' (Left and Right) 
   refer only to the cross-wires perpendicular to the X-axis.  It is possible 
   to redefine the length of tick marks on the X or Y axis with SET XTIC or 
   SET YTIC.  The position of the axis values may be changed with SET XVAL or 
   SET YVAL.  
d7830 1
a7830 1
\DEFCMD{GH}{ATITLE}{GRAPHICS/HPLOT}{ATITLE}{ [ xtit ytit ztit ]}
d7836 2
d7839 11
d7852 18
a7869 1
Draw axis titles on the axes of the present plot zone.  
d8781 1
a8781 1
      HRENAME,HNTDUP
d8798 1
a8798 1
      IGPAVE,IGTERM,ISFACI,IGHTOR,IGONT
@


1.4
log
@Version Feb. 13th 1995 (MG)
@
text
@d3783 3
d4316 6
a4438 3
   \par
Set options for histogram ID. (* means default).  

d6975 3
d7275 3
@


1.3
log
@new version from cdf
@
text
@d162 1
a162 1
   the command LAST 0 NEWFNAME must be entered.  
d266 1
a266 1
\DEFCMD{K}{FUNCTI}{KUIP}{FUNCTIONS}{}
d291 2
a292 1
    $INDEX(STR1,STR2)  ...........  Position of first occurence of STR2 in STR1
d297 2
d317 1
d321 4
d328 4
d381 30
d511 5
a515 1
\DEFCMD{KA}{LIST}{KUIP/ALIAS}{LIST}{}
d518 1
a518 1
List all aliases (names and values).  
d522 1
a522 1
\DEFCMD{KA}{DELETE}{KUIP/ALIAS}{DELETE}{ alist}
d525 1
a525 1
\DEFARG{ALIST}{C}{Alias list}{ Loop}
d529 2
a530 4
Delete the definition of aliases in the list ALIST.  The aliases are 
   separated in the list by a comma and imbedded blanks are not allowed.  If 
   ALIST='*' then delete all aliases and the alias translation is switched OFF 
   (i.e.: ALIAS/TRANSLATION OFF is executed).  
d1025 2
a1026 2
   will invoke this PostScript Viewer.  If PSVIEWER='?' the current host 
   editor command is shown.  
d1033 2
a1034 6
On VAX/VMS the PostScript Viewer command is by default set to 
   'VIEW/FORM=PS/INTERFACE=DECWINDOWS'.  

   \par
On Unixworkstations it is by default set to 'ghostview' 

d1107 1
a1107 1
               Therefore, repeated DEL's appear to unwind to the match
d1411 1
a1411 1
OPTION allows to define whether macros can be envoked by their name only 
d1447 70
d1778 24
d2248 1
a2248 1
    Vec(3,100) (bi-dimensional with 3 columns by 100 rows):
d2266 1
a2266 1
   vectors, being equivalenced with the real array VECTOR(100) in the labelled 
d2326 2
a2327 2
   separated in the list by a comma and imbedded blanks are not allowed. An 
   asterisk at the end of VLIST acts as string placeholder:  
d2394 1
a2394 1
\DEFARG{DENSE}{I}{Output density}{ D=1 R=0:2}
d2435 1
a2435 1
Vectors in the list VLIST are separated by a comma and imbedded blanks are 
d2489 1
a2489 1
Vectors in the list VLIST are separated by a comma and imbedded blanks are 
d2940 6
d2997 2
a2998 2
   type can be changed with SMK, the marker size with SET KSIZ, the marker 
   color with SPMCI.  
d3001 1
a3001 1
      HI/PLOT ID.PROX
d3003 1
a3003 1
      HI/PLOT ID.BANY.1
d3005 1
a3005 1
      HI/PLOT ID.SLIY.3
d3012 4
a3015 4
         PAW > Histo/plot 10+20+30  LEGO1CYL  | stacked cylindrical lego plot
         PAW > Histo/plot 10+20+30  LEGO1POL  |         polar
         PAW > Histo/plot 10+20+30  LEGO1SPH  |         spherical
         PAW > Histo/plot 10+20+30  LEGO1PSD  |         pseudo-rapidity/phi
d3018 3
a3020 1
Note that the viewing angles may be changed via the command ANGLES.  
d3107 1
a3107 1
\DEFCMD{H}{FIT}{HISTOGRAM}{FIT}{ id func [ chopt np par step pmin pmax errpar ]}
d3157 1
a3157 1
The interactive Minuit is invoked.
d3165 3
d3221 16
d3238 1
a3238 1
\ENDCMD
d3485 4
d3501 4
d3518 4
d3535 4
d3551 7
a3557 2
Create a projection onto the x axis, in a band of y.  The projection may be 
   filled with Histo/Project.  
d3570 7
a3576 2
Create a projection onto the y axis, in a band of x.  The projection may be 
   filled with Histo/Project.  
d4179 1
a4179 1
\DEFCMD{HG}{REBIN}{HISTOGRAM/GET\_VECT}{REBIN}{ id x y ex ey [ n ifirst ilast ]}
d4190 1
d4192 5
d4199 6
a4204 2
Get contents and errors into vectors, grouping bins.  Bin width and centers 
   are also extracted.  Allow to combine 2, 3 or more bins into one.  
d4761 72
d4847 1
a4847 1
\DEFCMD{N}{SCAN}{NTUPLE}{SCAN}{ idn [ uwfunc nevent ifirst nvars varlis ]}
d4854 1
a4854 1
\DEFARG{NVARS}{I}{Number of variables to scan}{ D=8}
d4857 12
d4873 25
a4897 4
   UWFUNC. Up to 8 variables may be scanned, the default is to scan the first 
   8 variables.  VARLIS may contain a list of the original variables or/and 
   expressions of the original variables.  For example, if IDN=30 has the 3 
   variables X,Y,Z, one can do:  
d4900 6
d4907 1
a4907 1
    PAW > scan 30 z>10 ! ! 5 z abs(x) y+z x func.for
d4944 4
a4947 4
Merge two Ntuples.  Invoke the selection function UWFUNC for each of the 
   NEVENT events starting at event IFIRST of Ntuple IDN1.  Suppose you have 4 
   files containing Ntuple ID=10 and you want to merge the 4 files into the 
   file 4, the sequence is:  
d4961 3
a4963 1
   information about UWFUNC, see command NTUPLE/PLOT.  
d5421 6
a5426 1
To generate the FORTRAN skeleton of a selection function.  Example:  If 
d5460 11
d5561 2
a5562 2
 |    XSIZ    |     20.00     |     20.00     | length of X axis               |
 |    YSIZ    |     20.00     |     20.00     | length of Y axis               |
d6067 2
a6068 1
   Device Coordinates (NDC).  
d6084 9
a6092 1
   (WC).  
d6143 15
a6157 2
   transformation.  Use commands SLN, SLWSC and SPLCI (or IGSET) to change 
   line attributes.  
d6172 15
a6186 2
   Normalization transformation.  Use commands SLN, SLWSC and SPLCI (or IGSET) 
   to change line attributes.  
d6201 14
a6214 2
   Normalization transformation taking care of logarithmic scales.  Use 
   commands SLN, SLWSC and SPLCI (or IGSET) to change line attributes.  
d6228 21
a6248 2
   transformation.  Use commands SFASI, SFAIS and SFACI (or IGSET) to change 
   fill area attributes.  
d6262 16
a6277 2
   transformation.  Use commands SMK and SPMCI (or IGSET) to change polymarker 
   attributes.  
d6291 23
a6313 2
Draw and fill a box with the current fill area attributes.  Use the current 
   Normalization transformation.  
d6320 8
a6327 8
\DEFARG{X1}{R}{X coord of 1st corner of ext box}{}
\DEFARG{X2}{R}{X coord of 2nd corner of ext box}{}
\DEFARG{Y1}{R}{Y coord of 1st corner of ext box}{}
\DEFARG{Y2}{R}{Y coord of 2nd corner of ext box}{}
\DEFARG{X3}{R}{X coord of 1st corner of int box}{}
\DEFARG{X4}{R}{X coord of 2nd corner of int box}{}
\DEFARG{Y3}{R}{Y coord of 1st corner of int box}{}
\DEFARG{Y4}{R}{Y coord of 2nd corner of int box}{}
d6331 17
a6347 2
Draw and fill a frame (2 nested boxes) with the current fill area 
   attributes.  Use the current Normalization transformation.  
d6362 24
a6385 3
Draw an arrow (X1,Y1) ----\KET{} (X2,Y2) if SIZE\KET{}0.  Draw an arrow 
   (X1,Y1) \BRA{}---\KET{} (X2,Y2) if SIZE\BRA{}0.  Use the current 
   Normalization transformation.  
d6402 2
a6403 1
Plots an helix on current page Feynman graph: gluon phi = 30, photon phi = 
d6406 13
d6435 2
a6436 1
Plots an helix on current page Feynman graph: gluon phi = 30, photon phi = 
d6439 13
d6465 19
a6483 1
Line with arrow (fermion line) 
d6496 16
a6511 1
Draw filled point (vertex) 
d6644 1
a6644 1
     IGSET. The default value is used unless the corresponding option is
d6648 1
a6648 1
                     IGSET with the parameter LAOF.
d6650 1
a6650 1
                     preceding command IGSET with the parameter LASI.
d6652 1
a6652 1
                     command IGSET with the parameter TMSI.
d6657 14
d6686 22
a6707 5
Draw an arc of circle in the current Normalization transformation.  If R1 
   is not equal to R2 the area between the two arcs of radius R1 and R2 is 
   filled according to the current fill area attributes.  The border is never 
   drawn unless the interior style is hollow or the command IGSET BORD 1 has 
   been called. If R1 is equal to R2 a polyline is drawn.  
d6759 15
d6800 2
a6801 2
   the software font IGTEXT.  SIZE is always given in centimeters (as defined 
   by the command SIZE).  Boldface effects can be obtained using the 
d6803 19
a6821 1
   by IGSET TXCI.  
d6836 25
a6860 3
   changed by IGSET TXFP.  The character size can be changed by IGSET CHHE.  
   The text color can be changed by IGSET TXCI.  The text orientation can be 
   changed with IGSET TXAL.  The text angle can be changed by IGSET TANG.  
d6873 21
a6893 3
Define a list of labels to be used by subsequent commands such as PIE and 
   AXIS.  The position of the labels on the axis may be changed with SET NDVX 
   (NDVY).  
d6945 1
a6945 1
   the style index.  If ISBOX (ISFRAM) =0, only the box contour is drawn with 
d6948 11
d7015 2
a7016 2
drawn). The bar origin and the bar width can be controlled by the routine 
IGSET using the options BARO and BARW respectively.
d7025 1
a7025 1
   specify the options 'AW' or 'AHW' in order to start a new zone or/and draw 
d7028 12
d7067 3
a7069 3
is smooth. The border of the fill area is drawn if the command IGSET BORD 1 
has been typed. The fill area type may be changed via the IGSET parameters 
FASI and FASI
d7077 2
a7078 2
drawn). The bar origin and the bar width can be controlled by the routine 
IGSET using the options BARO and BARW respectively.
d7095 16
a7119 125
\DEFCMD{GA}{SLN}{GRAPHICS/ATTRIBUTES}{SLN}{ [ iln ]}

\BEGARG
\DEFARG{ILN}{I}{Line style}{ D=1 R=1:}
\ENDARG

   \par
Set the line style (IGSET LTYP can also be used).  

\ENDCMD

\DEFCMD{GA}{SFAIS}{GRAPHICS/ATTRIBUTES}{SFAIS}{ [ ints ]}

\BEGARG
\DEFARG{INTS}{I}{Fill area interior style}{ D=0 R=0:3}
\ENDARG

   \par
Set the fill area interior style (IGSET FAIS can also be used):  
\begin{verbatim}
    Hollow=0, Solid=1, Pattern=2, Hatch=3
\end{verbatim}

\ENDCMD

\DEFCMD{GA}{SFASI}{GRAPHICS/ATTRIBUTES}{SFASI}{ [ styli ]}

\BEGARG
\DEFARG{STYLI}{I}{Fill area style index}{ D=1}
\ENDARG

   \par
Set the fill area style index (IGSET FASI can also be used).  

\ENDCMD

\DEFCMD{GA}{SFACI}{GRAPHICS/ATTRIBUTES}{SFACI}{ [ ifaci ]}

\BEGARG
\DEFARG{IFACI}{I}{Fill area color index}{ D=1}
\ENDARG

   \par
Set the fill area color index (IGSET FACI can also be used).  

\ENDCMD

\DEFCMD{GA}{SPLCI}{GRAPHICS/ATTRIBUTES}{SPLCI}{ [ iplci ]}

\BEGARG
\DEFARG{IPLCI}{I}{Polyline color index}{ D=1}
\ENDARG

   \par
Set the polyline color index (IGSET PLCI can also be used).  

\ENDCMD

\DEFCMD{GA}{SPMCI}{GRAPHICS/ATTRIBUTES}{SPMCI}{ [ ipmci ]}

\BEGARG
\DEFARG{IPMCI}{I}{Polymarker color index}{ D=1}
\ENDARG

   \par
Set the polymarker color index (IGSET PMCI can also be used).  

\ENDCMD

\DEFCMD{GA}{STXCI}{GRAPHICS/ATTRIBUTES}{STXCI}{ [ itxci ]}

\BEGARG
\DEFARG{ITXCI}{I}{Text color index}{ D=1}
\ENDARG

   \par
Set the text color index (IGSET TXCI can also be used).  

\ENDCMD

\DEFCMD{GA}{STXFP}{GRAPHICS/ATTRIBUTES}{STXFP}{ [ ifont iprec ]}

\BEGARG
\DEFARG{IFONT}{I}{Font number}{ D=0}
\DEFARG{IPREC}{I}{Font precision}{ D=2}
\ENDARG

   \par
Set text font and precision (IGSET TXFP can also be used).  

\ENDCMD

\DEFCMD{GA}{SCHH}{GRAPHICS/ATTRIBUTES}{SCHH}{ [ chh ]}

\BEGARG
\DEFARG{CHH}{R}{Character height}{ D=0.28}
\ENDARG

   \par
Set the character height (IGSET CHHE can also be used).  

\ENDCMD

\DEFCMD{GA}{SLWSC}{GRAPHICS/ATTRIBUTES}{SLWSC}{ [ lw ]}

\BEGARG
\DEFARG{LW}{R}{Line width}{ D=1 R=1:}
\ENDARG

   \par
Set the line width scale factor (IGSET LWID can also be used).  

\ENDCMD

\DEFCMD{GA}{SMK}{GRAPHICS/ATTRIBUTES}{SMK}{ [ mkt ]}

\BEGARG
\DEFARG{MKT}{I}{Marker type}{ D=1}
\ENDARG

   \par
Set the marker type (IGSET MTYP can also be used).  

\ENDCMD

d7155 1
a7155 1
   command IGSET NCOL:  
d7161 1
a7161 1
       PAW > IGSET NCOL 8      | Define the number of colours
d7164 1
a7164 1
       PAW > IGSET NCOL 4      | Define the number of colours
d7173 1
a7173 1
       PAW > IGSET NCOL 16     | Define the number of colours
d7177 1
a7177 1
       Note that after the command IGSET NCOL, the color indices from
d7378 1
a7378 1
\DEFCMD{GH}{ATITLE}{GRAPHICS/HPLOT}{ATITLE}{ [ xtit ytit ]}
d7383 1
d7462 1
a7462 1
   saving facility can be switched off using IGSET AURZ 0.  
d7672 1
a7672 1
(default), or the value assigned by IGSET to the parameter PICT.
d8247 5
a8251 3
   PAW.  For example : CALL HPRINT(10).  UROUT may also be the name of a file 
   which can be edited interactively with the command EDIT. For example if 
   file UROUT.FOR contains:  
d8262 20
a8281 3
Then one can type CALL UROUT.FOR(10). The routine UROUT may also contains 
   references to the library routines mentioned below.  The following routines 
   from the CERN Program Library can be called:  
d8291 1
a8291 1
      HTITLE,HCOPY,HSTATI,HBPROF,HOPERA,HIDOPT,HDERIV
d8299 1
d8321 1
a8321 1
      RNDM,RDMIN,RDMOUT,CSF77
d8325 1
a8325 1
     /HCFITS/, /HCFITD/
d8734 1
a8734 1
Obsolete commands.  
d8738 1
a8738 1
\DEFMENU{1}{HISTOGRAM}{OBSOLETE/HISTOGRAM}
d8742 1
a8742 1
\DEFMENU{2}{FIT}{OBSOLETE/HISTOGRAM/FIT}
d8744 53
d8798 9
a8806 2
Fitting and smoothing (1-Dim or 2-Dim) histograms.  Results are given as 
   histogram-associated functions, and fit parameters printed on screen.  
d8808 2
d8811 1
a8811 1
\fi
d8813 1
a8813 1
\DEFCMD{OHF}{EXPONE}{OBSOLETE/HISTOGRAM/FIT}{EXPONENTIAL}{ id [ isel iftlow iftup ]}
d8816 1
a8816 4
\DEFARG{ID}{C}{histogram Identifier}{}
\DEFARG{ISEL}{I}{option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
d8820 1
a8820 14
Fit histogram ID with an exponential function between channels IFTLOW and 
   IFTUP.  Obsolete command. Use Command Hist/Fit instead.  Control word ISEL 
   = 100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
\end{verbatim}
d8824 1
a8824 1
\DEFCMD{OHF}{GAUSS}{OBSOLETE/HISTOGRAM/FIT}{GAUSS}{ id [ isel iftlow iftup ]}
d8827 1
a8827 4
\DEFARG{ID}{C}{histogram Identifier}{}
\DEFARG{ISEL}{I}{option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
d8831 1
a8831 14
Fit histogram ID with a Gaussian between channels IFTLOW and IFTUP.  
   Obsolete command. Use Command Hist/Fit instead.  Control word ISEL = 
   100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
\end{verbatim}
d8835 1
a8835 1
\DEFCMD{OHF}{POLYNO}{OBSOLETE/HISTOGRAM/FIT}{POLYNOMIAL}{ id ncoeff [ isel iftlow iftup ]}
d8838 2
a8839 5
\DEFARG{ID}{C}{histogram Identifier}{}
\DEFARG{NCOEFF}{I}{Number of coefficients}{ D=3}
\DEFARG{ISEL}{I}{option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
d8843 1
a8843 14
Fit histogram ID with a polynomial between channels IFTLOW and IFTUP.  
   NCOEFF is the degree of the polynomial plus one.  Obsolete command. Use 
   Command Hist/Fit instead.  Control word ISEL = 100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
\end{verbatim}
d8847 1
a8847 1
\DEFCMD{OHF}{FUNCTI}{OBSOLETE/HISTOGRAM/FIT}{FUNCTION}{ id func np dpar [ isel iftlow iftup step pmin pmax ]}
d8850 1
a8850 10
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FUNC}{C}{Function name}{}
\DEFARG{NP}{I}{Number of parameters}{}
\DEFARG{DPAR}{C}{Vector of parameters}{}
\DEFARG{ISEL}{I}{Option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
\DEFARG{STEP}{C}{Vector of steps size}{}
\DEFARG{PMIN}{C}{Vector of lower bounds}{}
\DEFARG{PMAX}{C}{Vector of upper bounds}{}
d8854 10
a8863 11
Obsolete command. Use Command Hist/Fit instead.  Fit a user defined (and 
   parameter dependent) function to a histogram ID between channels IFTLOW and 
   IFTUP.  FUNC is the name of a file which contains the user defined function 
   to be minimized. For example file FUNC.FOR is:  
\begin{verbatim}
         DOUBLE PRECISION FUNCTION FUNC(X)
         DOUBLE PRECISION X,DPAR
         COMMON/PAWPAR/DPAR(100)
         FUNC=DPAR(1)*X +DPAR(2)*EXP(-X)
         END
\end{verbatim}
d8865 1
a8865 16
After the fit, the vector DPAR contains the new values of parameters.  
   Control word ISEL = 10000*B+100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
     B=0 All parameters vary freely (vectors STEP,PMIN,PMAX not required)
       1 Some or all parameters are bounded
         STEP(I)=0 means parameter I is fixed to its initial value
\end{verbatim}
@


1.2
log
@mods for updated run
@
text
@d2843 2
a2844 2
     2- h/pl id(x1:x2) with x1 and x2 reals (with a .) means plot
                       from channel corresponding to x1
d2847 1
a2847 1
    Ex: Histo/plot 10(25:1.) or Histo/plot 20(4:18,0.:0.5).
d2850 5
a5561 3
\begin{verbatim}

\end{verbatim}
@


1.1
log
@Initial revision
@
text
@d5558 1
@
