head     1.1;
branch   ;
access   ;
symbols  ;
locks    goossens:1.1; strict;
comment  @% @;


1.1
date     94.06.09.10.00.06;  author goossens;  state Exp;
branches ;
next     ;


desc
@initial entry
@



1.1
log
@Initial revision
@
text
@\DEFMENU{0}{KUIP}{KUIP}
Command Processor commands.  

\DEFCMD{K}{HELP}{KUIP}{HELP}{ [ item option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu path}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{View mode}{ D='N'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{EDIT}{\par
The help text is written to a file and the editor is invoked,
}
\DEFOPT{E}{\par
Same as 'EDIT'.
}
\DEFOPT{NOEDIT}{\par
The help text is output on the terminal output.
}
\DEFOPT{N}{\par
Same as 'NOEDIT'
}
\ENDOPT

   \par
Give the help of a command.  If ITEM is a command its full explanation is 
   given:  syntax (as given by the command USAGE), functionality, list of 
   parameters with their attributes (prompt, type, default, range, etc.).  If 
   ITEM='/' the help for all commands is given.  

   \par
If HELP is entered without parameters or ITEM is a submenu, the dialogue 
   style is switched to 'AN', guiding the user in traversing the tree command 
   structure.  

   \par
'HELP -EDIT' (or just 'HELP -E') switches to edit mode:  instead of writing 
   the help text to the terminal output, it is written into a temporary file 
   and the pager or editor defined by the command HOST\_PAGER is invoked.  (On 
   Unix workstations the pager can be defined to display the help text 
   asynchrously in a separated window.) 'HELP -NOEDIT' (or just 'HELP -N') 
   switches back to standard mode.  The startup value is system dependent.  

\ENDCMD

\DEFCMD{K}{USAGE}{KUIP}{USAGE}{ item}

\BEGARG
\DEFARG{ITEM}{C}{Command name}{}
\ENDARG

   \par
Give the syntax of a command.  If ITEM='/' the syntax of all commands is 
   given.  

\ENDCMD

\DEFCMD{K}{MANUAL}{KUIP}{MANUAL}{ item [ output option ]}

\BEGARG
\DEFARG{ITEM}{C}{Command or menu path}{}
\DEFARG{OUTPUT}{C}{Output file name}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Text formatting system}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{\par
plain text : plain text format
}
\DEFOPT{LATEX}{\par
LaTeX format (encapsulated)
}
\DEFOPT{TEX}{\par
LaTeX format (without header)
}
\ENDOPT

   \par
Write on a file the text formatted help of a command.  If ITEM is a menu 
   path the help for all commands linked to that menu is written.  If ITEM='/' 
   the help for the complete command tree is written.  If OUTPUT=' ' the text 
   is written to the terminal.  

   \par
The output file produced with option LATEX can be processed directly by 
   LaTeX, i.e. it contains a standard header defining the meta commands used 
   for formatting the document body.  With option TEX only the document body 
   is written into the output file which can be included by a driver file 
   containing customized definitions of the standard meta commands.  Example:  
\begin{verbatim}
    MANUAL / MAN.TEX LATEX
\end{verbatim}
   \par
will produce the file MAN.TEX containg the documentation of all available 
   commands in LaTeX format.  

\ENDCMD

\DEFCMD{K}{EDIT}{KUIP}{EDIT}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Invoke the editor on the file.  The command HOST\_EDITOR can be used to 
   define the editor.  

   \par
If FNAME does not contain an extension the default filetype '.KUMAC' is 
   supplied.  The search path defined by the command DEFAULTS is used to find 
   an already existing file.  If the file does not exist it is created with 
   the given name.  

\ENDCMD

\DEFCMD{K}{LAST}{KUIP}{LAST}{ [ n fname ]}

\BEGARG
\DEFARG{N}{I}{N last commands to be saved}{ D=-99 R=-99:}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Perform various operations with the history file.  

   \par
If FNAME is not specified, the current history file is assumed by default 
   (the startup history file name is LAST.KUMAC).  To change the history file 
   the command LAST 0 NEWFNAME must be entered.  

   \par
If N.EQ.-99 (default case) the default host editor is called to edit the 
   current history file, containing all the commands of the session.  

   \par
If N.LT.0 the last -N commands are printed on the screen.  On MVS this 
   allows to edit and resubmit commands.  On workstations this allows to 
   resubmit blocks of commands by mouse-driven cut-and-paste operations.  

   \par
If N.EQ.0 the history file FNAME is rewound and set as the current one (the 
   command LAST 0 FNAME itself is not recorded).  

   \par
If N.GT.0 the last N commands of the session are saved in the current 
   history file.  

   \par
See also the command RECORDING.  

\ENDCMD

\DEFCMD{K}{MESSAG}{KUIP}{MESSAGE}{ [ string ]}

\BEGARG
\DEFARG{STRING}{C}{Message string}{ D=\EMPTY{} Separate}
\ENDARG

   \par
Write a message string on the terminal.  A useful command inside a macro.  
   Several message strings can be given in the same command line, each of them 
   separated by one or more spaces (the usual parameter separator); therefore 
   multiple blanks will be dropped and only one will be kept.  If multiple 
   blanks should not be dropped, the string must be surrounded by single 
   quotes.  

\ENDCMD

\DEFCMD{K}{SHELL}{KUIP}{SHELL}{ [ cmd ]}

\BEGARG
\DEFARG{CMD}{C}{Shell command string}{ D=\EMPTY{}}
\ENDARG

   \par
Execute a command of the host operating system.  The command string is 
   passed to the command processor defined by HOST\_SHELL.  If CMD=' ' the 
   shell is spawned as interactive subprocess.  To return from the shell enter 
   'RETURN' (the full word, not just \BRA{}CR\KET{}) or 'exit' (depending on 
   the operation system).  

\ENDCMD

\DEFCMD{K}{WAIT}{KUIP}{WAIT}{ [ string sec ]}

\BEGARG
\DEFARG{STRING}{C}{Message string}{ D=\EMPTY{}}
\DEFARG{SEC}{R}{Number of seconds}{ D=0 R=0:}
\ENDARG

   \par
Make a pause (e.g. inside a macro).  Wait a given number of seconds (if 
   SEC.GT.0) or just until \BRA{}CR\KET{} is entered (if SEC.EQ.0).  A message 
   string is also written on the terminal before waiting.  

\ENDCMD

\DEFCMD{K}{UNITS}{KUIP}{UNITS}{}

   \par
List all Input/Output logical units currently open.  The files attached to 
   them are also shown.  

\ENDCMD

\DEFCMD{K}{EXIT}{KUIP}{EXIT}{}

   \par
End of the interactive session.  

\ENDCMD

\DEFCMD{K}{QUIT}{KUIP}{QUIT}{}

   \par
End of the interactive session.  

\ENDCMD

\DEFCMD{K}{FUNCTI}{KUIP}{FUNCTIONS}{}

\begin{verbatim}
          *** KUIP System Functions ***
\end{verbatim}
\ENDVERB
   \par
The function name (and arguments) is literally replaced, at run-time, by 
   its current value.  At present, the following functions are available:  
\begin{verbatim}
    $DATE  .......................  Current date in format DD/MM/YY
    $TIME  .......................  Current time in format HH.MM.SS
    $CPTIME  .....................  CP time elapsed since last call (in sec)
    $RTIME  ......................  Real time elapsed since last call (in sec)
    $VDIM(VNAME,IDIM)  ...........  Physical length of vector VNAME
                                    on dimension IDIM (1..3)
    $VLEN(VNAME,IDIM)  ...........  As above, but for the logical length
                                    (i.e. stripping trailing zeroes)
    $NUMVEC  .....................  Current number of vectors
    $VEXIST(VNAME)  ..............  Index of vector VNAME
                                    (1..$NUMVEC or 0 if VNAME does not exist)
    $SUBSTRING(STRING,IX,NCH)  ...  STRING(IX:IX+NCH-1)
    $UPPER(STRING)  ..............  STRING changed to upper case
    $LOWER(STRING)  ..............  STRING changed to lower case
    $LEN(STRING)  ................  Length of STRING
    $INDEX(STR1,STR2)  ...........  Position of first occurence of STR2 in STR1
    $WORDS(STRING,SEP)  ..........  Number of words separated by SEP
    $WORD(STRING,K,N,SEP)  .......  Extract N words starting at word K
    $QUOTE(STRING)  ..............  Add quotes around STRING
    $UNQUOTE(STRING)  ............  Remove quotes around STRING
    $EVAL(Expression)  ...........  Result of the Expression computed by KUIP
    $SIGMA(Expression)  ..........  Result of the Expression computed by SIGMA
    $RSIGMA(Expression) ..........  As above but a decimal point is added to
                                    integer results
    $FORMAT(number,format)  ......  Format a number according to a Fortran
                                    format string, e.g.
                                    $FORMAT(1.5,F5.2) ==> ' 1.50'
                                    $FORMAT(123,I5.5) ==> '00123'
    $ARGS  .......................  Command line at program invocation
    $KEYNUM  .....................  Address of latest clicked key in style GP
    $KEYVAL  .....................  Value of latest clicked key in style GP
    $LAST  .......................  Latest command line executed
    $ANUM  .......................  Number of aliases
    $ANAM(I)  ....................  Name of I-th alias
    $AVAL(I)  ....................  Value of I-th alias
    $STYLE  ......................  Current style as defined by SET/STYLE
    $OS  .........................  Operating system name, e.g. UNIX or VMS
    $MACHINE  ....................  Hardware or Unix brand, e.g. VAX or HPUX
\end{verbatim}

\begin{verbatim}
    $HEXIST(id)  .................  1 if histogram ID exists or 0 otherwise
    $HINFO(id,'ENTRIES')  ........  Number of entries
    $HINFO(id,'MEAN')  ...........  Mean value
    $HINFO(id,'RMS')  ............  Standard deviation
    $HINFO(id,'EVENTS')  .........  Number of equivalent events
    $HINFO(id,'OVERFLOW')  .......  Content of overflow channel
    $HINFO(id,'UNDERFLOW')  ......  Content of underflow channel
    $HINFO(id,'MIN')  ............  Minimum bin content
    $HINFO(id,'MAX')  ............  Maximum bin content
    $HINFO(id,'SUM')  ............  Total histogram content
    $HINFO(id,'XBINS')  ..........  Number of bins in X direction
    $HINFO(id,'XMIN')  ...........  Lower histogram limit in X direction
    $HINFO(id,'XMAX')  ...........  Upper histogram limit in X direction
    $HINFO(id,'YBINS')  ..........  Number of bins in Y direction
    $HINFO(id,'YMIN')  ...........  Lower histogram limit in Y direction
    $HINFO(id,'YMAX')  ...........  Upper histogram limit in Y direction
    $HTITLE(id)  .................  Histogram title
    $GRAFINFO('XZONES')  .........  Number of zones in X direction
    $GRAFINFO('YZONES')  .........  Number of zones in Y direction
    $GRAFINFO('NT')  .............  Current Normalization Transformation number
    $GRAFINFO('WNXMIN')  .........  Lower X limit of window in current NT
    $GRAFINFO('WNXMAX')  .........  Upper X limit of window in current NT
    $GRAFINFO('WNYMIN')  .........  Lower Y limit of window in current NT
    $GRAFINFO('WNYMAX')  .........  Upper Y limit of window in current NT
    $GRAFINFO('VPXMIN')  .........  Lower X limit of viewport in current NT
    $GRAFINFO('VPXMAX')  .........  Upper X limit of viewport in current NT
    $GRAFINFO('VPYMIN')  .........  Lower Y limit of viewport in current NT
    $GRAFINFO('VPYMAX')  .........  Upper Y limit of viewport in current NT
    $GRAFINFO('?attr')  ..........  HPLOT/HIGZ attribute (see HELP SET for 
   valid names)
    $CUT(n)  .....................  Cut expression $n
    $CUTEXPAND(string)  ..........  Replace $n in the (quoted) string by 
   $CUT(n)
\end{verbatim}

\ENDCMD
\DEFMENU{1}{ALIAS}{KUIP/ALIAS}

Operations with aliases.  Aliases are defined to provide shortcut 
   abbreviations for the input line or some part of it.  When encountered on 
   an input line an alias is replaced by its string value which can contain 
   further aliases.  (Be careful not to define recursive aliases.) 

   \par
To juxtaposition aliases, a double slash can be used as concatenation sign. 
   Inside quoted strings and for the ALIAS commands themselves the alias 
   substitution is inhibited.  Otherwise 
\begin{verbatim}
    ALIAS/CREATE ALPHA BETA
    ALIAS/CREATE ALPHA BETA
\end{verbatim}
   \par
whould create an recursive alias BETA and 
\begin{verbatim}
    ALIAS/CREATE ALPHA BETA
    ALIAS/CREATE BETA GAMMA
    ALIAS/DELETE ALPHA
\end{verbatim}
   \par
would delete the alias name BETA instead of ALPHA itself.  

\DEFCMD{KA}{CREATE}{KUIP/ALIAS}{CREATE}{ name value [ chopt ]}

\BEGARG
\DEFARG{NAME}{C}{Alias name}{}
\DEFARG{VALUE}{C}{Alias value}{}
\DEFARG{CHOPT}{C}{Option}{ D='A'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
create an Argument alias
}
\DEFOPT{C}{\par
create a Command alias
}
\DEFOPT{N}{\par
No alias expansion of value
}
\ENDOPT

   \par
Create an alias NAME which should be substituted by VALUE.  An alias name 
   is a sequence of letters and digits starting with a letter.  The 
   underscores ('\_'), the at-sign ('@@') and the dollar-sign ('\$') count as 
   letters.  

   \par
There are two types of aliases:  Command aliases are recognized only if 
   they occur in the command position, i.e. as the first token on the line.  
   Argument aliases are recognized anywhere on the command line (except inside 
   quoted strings) if they are surrounded by one of the following separators:  
\begin{verbatim}
    blank  /  ,  =  :  .  %  '  (  )
\end{verbatim}
\ENDVERB
   \par
Also switch ON the alias translation, i.e. ALIAS/TRANSLATION ON.  If 
   CHOPT='C' then the alias is a command alias, i.e. an alias that will only 
   be translated when it is the first token on a command line.  Example:  
\begin{verbatim}
    Alias/Create GG Graph/Struct/Scratch
    Alias/Create FF File1/Name1/Name2
    GG FF/ID
\end{verbatim}
   \par
is equivalent to 
\begin{verbatim}
    Graph/Struct/Scratch File1/Name1/Name2/ID
\end{verbatim}
\begin{verbatim}
    Alias/Create LS DIR C
\end{verbatim}
   \par
is equivalent to 
\begin{verbatim}
    DIR
\end{verbatim}
   \par
only when LS is the first token on a command line.  In the following case 
   LS will not be translated 
\begin{verbatim}
    SHELL LS
\end{verbatim}
\ENDVERB
   \par
Aliases occuring inside an value are expanded indepedent whether the value 
   is enclosed by quotes.  The option -N allows to suppress this implicit 
   alias expansion.  

\ENDCMD

\DEFCMD{KA}{LIST}{KUIP/ALIAS}{LIST}{}

   \par
List all aliases (names and values).  

\ENDCMD

\DEFCMD{KA}{DELETE}{KUIP/ALIAS}{DELETE}{ alist}

\BEGARG
\DEFARG{ALIST}{C}{Alias list}{}
\ENDARG

   \par
Delete the definition of aliases in the list ALIST.  The aliases are 
   separated in the list by a comma and imbedded blanks are not allowed.  If 
   ALIST='*' then delete all aliases and the alias translation is switched OFF 
   (i.e.: ALIAS/TRANSLATION OFF is executed).  

\ENDCMD

\DEFCMD{KA}{TRANSL}{KUIP/ALIAS}{TRANSLATION}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{ON}{\par
switch alias translation ON
}
\DEFOPT{OFF}{\par
switch alias translation OFF
}
\ENDOPT

   \par
Switch ON/OFF the alias translation.  If OFF, alias definitions are not 
   used in parsing the command lines.  It is automatically switched ON when an 
   alias is created.  If OPTION='?' the current value is shown.  The startup 
   value is OFF.  

\ENDCMD
\DEFMENU{1}{SET\_SHOW}{KUIP/SET\_SHOW}

Set or show various KUIP parameters and options.  

\DEFCMD{KS}{STYLE}{KUIP/SET\_SHOW}{STYLE}{ [ option sgylen sgsize sgyspa sgbord wktype ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='?'}
\DEFARG{SGYLEN}{R}{max Y LENgth of each menu item box}{ D=0.025 R=0.005:0.25}
\DEFARG{SGSIZE}{R}{space available for the application}{ D=0.8 R=0:0.90}
\DEFARG{SGYSPA}{R}{max Y length of space between menus}{ D=0.02 R=-0.5:0.50}
\DEFARG{SGBORD}{R}{X or Y border for menus}{ D=0.015 R=0:0.25}
\DEFARG{WKTYPE}{I}{Graphics workstation type}{ D=0}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current style
}
\DEFOPT{C}{\par
Command line : select Command line input
}
\DEFOPT{AN}{\par
Menu with Numbers : select general Alpha menu (with Numbers)
}
\DEFOPT{AL}{\par
Menu with Letters : select general Alpha menu (with Letters)
}
\DEFOPT{G}{\par
Graphics menu hardware : select Graphics menu (with hardware character fonts)
}
\DEFOPT{GW}{\par
Graphics menu shadowed : select Graphics menu (with shadowed Width effect)
}
\DEFOPT{GS}{\par
Graphics menu Software : select Graphics menu (with Software character fonts)
}
\DEFOPT{GP}{\par
Panel keys : select Graphics menu (with Panel keys only, i.e. no command tree 
menu)
}
\DEFOPT{XM}{\par
Motif/X11 : select Motif/X11 interface
}
\ENDOPT

   \par
Select the user dialogue style (or working mode).  The startup value is 'C' 
   (command mode).  The current value is returned by the system function 
   \$STYLE.  

   \par
The G-styles are only available if the application program is calling 
   KUWHAG instead of KUWHAT.  When one of these options is choosen the 
   remaining parameters control the geometrical layout of the menus on the 
   screen and the graphics workstation type (in case HIGZ was not 
   initialized).  

   \par
Style 'XM' is only available if the program is calling KUWHAM.  In that 
   case switching to other styles is not possible.  

\ENDCMD

\DEFCMD{KS}{PANEL}{KUIP/SET\_SHOW}{PANEL}{ line [ gkey ]}

\BEGARG
\DEFARG{LINE}{R}{Line number}{ D=0}
\DEFARG{GKEY}{C}{Graphics key value(s)}{ D=\EMPTY{}}
\ENDARG

   \par
Set up the panel of graphics keys (used by STYLE GP).  

   \par
Examples:  
\begin{verbatim}
    PANEL  0                        | reset the panel
    PANEL  2 A/L QUIT V/L           | initialize line 2 with 3 graphics keys,
                                      respectively A/L, QUIT, V/L
    PANEL  2 A/L ' '  V/L ' ' ' '   | initialize line 2 with 5 graphics keys,
                                      and fill 1st and 3rd keys
    PANEL  2.04 MESSAGE             | initialize 4th key of 2nd line to MESSAGE
    PANEL  2.04                     | clear 4th key of 2nd line
    PANEL -2.08                     | initialize line 2 with 8 graphics keys
    PANEL -6.16                     | initialize line 6 with 16 graphics keys
\end{verbatim}
   \par
Note that the key number on the right of the decimal point must always be 
   defined with two digits.  

   \par
Keys ending with a minus sign make an additional request of keyboard input; 
   the complete command line will be the key text, with a blank at the place 
   of the minus, concatenated with the additional keyboard input. Example:  
\begin{verbatim}
    PANEL 1.03 'VEC/PRI-'        | entering VAB will execute VEC/PRI VAB.
\end{verbatim}
   \par
Keys ending with a double minus sign behave as above but no blank is put at 
   the place of the double minus. Example:  
\begin{verbatim}
    PANEL 1.03 'VEC/PRI V--'     | entering AB will execute VEC/PRI VAB
\end{verbatim}
   \par
The dollar sign inside a key is replaced by additional keyboard input. 
   Example:  
\begin{verbatim}
    PANEL 1.03 'VEC/PRI V($)'    | entering 11:20 will execute VEC/PRI V(11:20)
\end{verbatim}

\ENDCMD

\DEFCMD{KS}{NEWPAN}{KUIP/SET\_SHOW}{NEWPANEL}{ line col title width height xpos ypos}

\BEGARG
\DEFARG{LINE}{I}{Number of lines}{ D=5 R=1:30}
\DEFARG{COL}{I}{Number of columns}{ D=5 R=1:30}
\DEFARG{TITLE}{C}{Panel Title}{ D='New Panel'}
\DEFARG{WIDTH}{I}{Panel width (in pixels)}{ D=300 R=10:}
\DEFARG{HEIGHT}{I}{Panel height (in pixels)}{ D=300 R=10:}
\DEFARG{XPOS}{I}{X Position (in pixels)}{ D=0 R=0:}
\DEFARG{YPOS}{I}{Y Position (in pixels)}{ D=0 R=0:}
\ENDARG

   \par
Set up a new panel with empty keys (to be filled interactively).  

\ENDCMD

\DEFCMD{KS}{COMMAN}{KUIP/SET\_SHOW}{COMMAND}{ [ chpath ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name for command line}{ D=\EMPTY{}}
\ENDARG

   \par
Set a filter for the parsing of command lines.  If it has been called, it 
   means that whenever a command line is entered, if and only if it is not an 
   existing command (not just ambiguous), it is inserted into the CHPATH 
   string, with \$n (n=1..9) being replaced by the n-th token of the command 
   (tokens are separated by spaces), or \$* being replaced by the whole 
   command line. Examples:  
\begin{verbatim}
    COMMAND 'V/CR $*(10)'
    AA                     =>   V/CR AA(10)
    BB                     =>   V/CR BB(10)
    V/LIST                 =>   V/LIST
\end{verbatim}
\begin{verbatim}
    COMMAND 'VECTOR/PLOT $1 555 $2'
    AA E                   =>   VECTOR/PLOT AA 555 E
    BB                     =>   VECTOR/PLOT BB 555
\end{verbatim}
\begin{verbatim}
    COMMAND                =>   shows its current value
    COMMAND *              =>   reset (equivalent to COMMAND $*)
\end{verbatim}
   \par
Note that COMMAND and subsequent command lines can be used inside macros, 
   excepted when producing macro statements (like EXEC, IF, GOTO, etc.).  For 
   example, the above examples would work also inside macros, while COMMAND 
   'EXEC \$*' or COMMAND 'GOTO \$1' will not.  

\ENDCMD

\DEFCMD{KS}{APPLIC}{KUIP/SET\_SHOW}{APPLICATION}{ [ path cmdex ]}

\BEGARG
\DEFARG{PATH}{C}{Application name}{ D=\EMPTY{}}
\DEFARG{CMDEX}{C}{Exit command}{ D='EXIT'}
\ENDARG

   \par
Set the application name.  This means that all input lines will be 
   concatenated to the string PATH (until the command specified by the 
   parameter CMDEX is executed, which resets the application to the null 
   string). The value of CMDEX may be specified if the default value EXIT has 
   to be changed (i.e. because already used by the application).  APPLICATION 
   can also be inserted in a macro: in this case at least 4 characters must be 
   specified (i.e. APPL).  

\ENDCMD

\DEFCMD{KS}{ROOT}{KUIP/SET\_SHOW}{ROOT}{ [ path ]}

\BEGARG
\DEFARG{PATH}{C}{Root directory}{ D='/'}
\ENDARG

   \par
Set the root for searching commands.  If PATH='?' the current root is 
   shown.  This allows to access commands regardless of possible ambiguities 
   with different menus.  Commands are first searched starting from the 
   current root:  if a command is found it is executed.  Only if a command is 
   not found a second pass of search is done, starting now from the top root 
   of the command tree (i.e. '/').  

\ENDCMD

\DEFCMD{KS}{TIMING}{KUIP/SET\_SHOW}{TIMING}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\DEFOPT{ALL}{}
\ENDOPT

   \par
Set ON/OFF/ALL the timing of commands.  If ON, the real time and the CPU 
   time for the latest executed command (or macro) are presented.  If ALL, the 
   time is shown for each command being executed within a macro.  The startup 
   value is OFF.  

\ENDCMD

\DEFCMD{KS}{PROMPT}{KUIP/SET\_SHOW}{PROMPT}{ prompt}

\BEGARG
\DEFARG{PROMPT}{C}{Prompt string}{ D=\EMPTY{}}
\ENDARG

   \par
Set the prompt string for the command mode dialogue.  If PROMPT is blank 
   the current prompt is left unchanged.  If PROMPT contains the character 
   sequence '[]' the current command number is inserted between the square 
   brackets.  

\ENDCMD

\DEFCMD{KS}{BREAK}{KUIP/SET\_SHOW}{BREAK}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\DEFOPT{TB}{}
\DEFOPT{?}{}
\ENDOPT

   \par
Set ON/OFF the break handling.  If OPTION='?' the current value is shown.  
   The startup value is ON.  

   \par
Hitting the keyboard interrupt (CTRL/C on VMS or CTRL/Q on the Apollo) 
   under break ON condition, the current command or macro execution will be 
   interrupted and the user will get again the application prompt.  

   \par
BREAK TB switch ON the traceback of the routines called, with their line 
   numbers, when an error occurs. This allows the detection of the routines 
   which provoked the error.  

\ENDCMD

\DEFCMD{KS}{COLUMN}{KUIP/SET\_SHOW}{COLUMNS}{ [ ncol ]}

\BEGARG
\DEFARG{NCOL}{I}{Number of columns for terminal output}{ D=80 R=-1:}
\ENDARG

   \par
Set the maximum number of columns for terminal output.  If NCOL=0 the 
   current number of columns is shown.  If NCOL=-1 the current number of 
   columns is taken from the environment variable COLUMNS.  If COLUMNS is 
   undefined the startup value is 80.  

\ENDCMD

\DEFCMD{KS}{RECORD}{KUIP/SET\_SHOW}{RECORDING}{ [ nrec ]}

\BEGARG
\DEFARG{NREC}{I}{Rate for recording on history file}{ D=25 R=0:}
\ENDARG

   \par
Set the recording rate for the history file.  Every NREC commands of the 
   session the current history file is updated.  If NREC=0 the history is not 
   kept at all (i.e. the file is not written).  See also the command LAST.  

\ENDCMD

\DEFCMD{KS}{HOSTED}{KUIP/SET\_SHOW}{HOST\_EDITOR}{ [ editor top left width height dxpad dypad npads ]}

\BEGARG
\DEFARG{EDITOR}{C}{Host editor command}{ D='?'}
\DEFARG{TOP}{I}{Top position of the edit window}{ D=20 R=0:}
\DEFARG{LEFT}{I}{Left position of the edit window}{ D=20 R=0:}
\DEFARG{WIDTH}{I}{Width of the edit window}{ D=0 R=0:}
\DEFARG{HEIGHT}{I}{Height of the edit window}{ D=0 R=0:}
\DEFARG{DXPAD}{I}{X offset for help PAD windows}{ D=30 R=0:}
\DEFARG{DYPAD}{I}{Y offset for help PAD windows}{ D=20 R=0:}
\DEFARG{NPADS}{I}{Maximum number of shifted pads}{ D=4 R=1:}
\ENDARG

   \par
Set the host command to invoke the editor.  The EDIT command will invoke 
   this editor.  If EDITOR='?' the current host editor command is shown.  

   \par
On Apollo the special value EDITOR='DM' invoke Display Manager pads.  The 
   special values EDITOR='WINDOW' and 'PAD' can be used to specify the window 
   positions (in pixel units).  'WINDOW' defines the parameters for edit pads, 
   while 'PAD' defines the parameters for read-only pads (e.g. used by 'HELP 
   -EDIT').  

   \par
On VMS the special values EDITOR='EDT' and 'TPU' invoke the callable 
   editors.  The startup time is considerably lower compared to spawning the 
   editor as a subprocess.  The callable EDT has one disadvantage though:  
   after an error, e.g. trying to edit a file in a non-existing directory, 
   subsequent calls will always fail.  The TPU call can be augmented by 
   command line options, e.g.  
\begin{verbatim}
    HOST_EDITOR TPU/DISP=DECW    | DECwindow interface to EVE
\end{verbatim}
\ENDVERB
   \par
On Unix a variety of editors are available, e.g.  
\begin{verbatim}
    HOST_EDITOR vi
    HOST_EDITOR 'emacs -geometry 80x48'
\end{verbatim}
\ENDVERB
   \par
On Unix workstations it is possible to do asynchronous editing via the KUIP 
   edit server, i.e. to start an editor in a separate window while the 
   application can continue to receive commands.  In order to do that the 
   following conditions must be fulfilled:  
\begin{verbatim}
    - The KUIP edit server 'kuesvr' must be found in the search path.
    - The editor command set by HOST_EDITOR must end with an ampersand ('&').
    - The environment variable 'DISPLAY' must be set.
\end{verbatim}
\ENDVERB
   \par
The ampersand flags your intention to use the edit server if possible.  If 
   the edit server cannot be used the ampersand will be ignored, i.e. even 
   with 
\begin{verbatim}
    HOST_EDITOR 'vi &'
\end{verbatim}
   \par
the KUIP/EDIT command will block until the editor terminates if either the 
   'kuesvr' is not available or 'DISPLAY' is undefined.  When using the edit 
   server the editor command is expected to create its own window.  'vi' being 
   a frequent choice, the above command is automatically interpreted as 
\begin{verbatim}
    HOST_EDITOR 'xterm -e vi &'
\end{verbatim}
\ENDVERB
   \par
The startup value can be defined by the environment variable 'EDITOR'.  
   Otherwise it is set to a system dependent default:  'DM' (Apollo), 'EDT' 
   (VMS), 'XEDIT' (VM/CMS), 'vi' (Unix).  

\ENDCMD

\DEFCMD{KS}{HOSTPA}{KUIP/SET\_SHOW}{HOST\_PAGER}{ [ pager ]}

\BEGARG
\DEFARG{PAGER}{C}{Host pager command}{ D='?'}
\ENDARG

   \par
Set the host command to view a file in read-only mode.  If OPTION='?' the 
   current host pager command is shown.  The 'HELP -EDIT' command will invoke 
   this pager, e.g.  
\begin{verbatim}
    HOST_PAGER more
\end{verbatim}
\ENDVERB
   \par
On Unix workstations the pager can be asynchronous by creating a separate 
   window, e.g.  
\begin{verbatim}
    HOST_PAGER 'xterm -e view &'
    HOST_PAGER 'ved &'
\end{verbatim}
\ENDVERB
   \par
On Apollo the special value PAGER='DM' defines the use of Display Manager 
   read-only pads.  The pad positions can be adjusted by the HOST\_EDITOR 
   command.  

   \par
The startup value can be defined by the environment variables 'KUIPPAGER' 
   or 'PAGER'.  If neither of them is defined the value set by the 
   HOST\_EDITOR command is used.  On VAX/VMS the startup value is 'TYPE/PAGE'. 

\ENDCMD

\DEFCMD{KS}{HOSTSH}{KUIP/SET\_SHOW}{HOST\_SHELL}{ [ shell ]}

\BEGARG
\DEFARG{SHELL}{C}{Host shell command}{ D='?'}
\ENDARG

   \par
Set the default host shell invoked by the KUIP/SHELL command.  If 
   OPTION='?' the current host shell is shown.  The startup value is taken 
   from the 'SHELL' environment variable.  

\ENDCMD

\DEFCBIG{KS}{RECALL}{KUIP/SET\_SHOW}{RECALL\_STYLE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Command recall and editing style}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{KSH}{\par
Korn shell : Emacs like command line editing
}
\DEFOPT{KSHO}{\par
Korn shell + Overwrite : like 'KSH' but overwrite instead of insert mode
}
\DEFOPT{DCL}{\par
VAX/VMS DCL : DCL command line editing
}
\DEFOPT{DCLO}{\par
VAX/VMS DCL + Overwrite : like 'DCL' but overwrite instead of insert mode
}
\DEFOPT{NONE}{\par
disable command line editing
}
\ENDOPT

   \par
Set the command recall and editing style.  If OPTION='?' the current style 
   is shown.  The startup value is 'DCL' on VAX/VMS, 'NONE' on Cray and Apollo 
   DM pads, and 'KSH' on other systems.  

   \par
If the terminal emulator returns ANSI escape sequences (hpterm doesn't!) 
   the up/down arrow keys can be used to recall items from the command history 
   list and the left/right arrow keys to move the cursor.  

   \par
'KSH' style provides the following control keys for editing:  
\begin{verbatim}
     ^A/^E   : Move cursor to beginning/end of the line.
     ^F/^B   : Move cursor forward/backward one character.
     ^D      : Delete the character under the cursor.
     ^H, DEL : Delete the character to the left of the cursor.
     ^K      : Kill from the cursor to the end of line.
     ^L      : Redraw current line.
     ^O      : Toggle overwrite/insert mode. Text added in overwrite mode
               (including yanks) overwrites existing text, while insert mode
               does not overwrite.
     ^P/^N   : Move to previous/next item on history list.
     ^R/^S   : Perform incremental reverse/forward search for string on
               the history list.  Typing normal characters adds to the
               current search string and searches for a match.  Typing
               ^R/^S marks the start of a new search, and moves on to
               the next match.  Typing ^H or DEL deletes the last
               character from the search string, and searches from the
               starting location of the last search.
               Therefore, repeated DEL's appear to unwind to the match
               nearest the point at which the last ^R or ^S was typed.
               If DEL is repeated until the search string is empty the
               search location begins from the start of the history
               list. Typing ESC or any other editing character accepts
               the current match and loads it into the buffer,
               terminating the search.
     ^T      : Toggle the characters under and to the left of the cursor.
     ^U      : Kill from the prompt to the end of line.
     ^Y      : Yank previously killed text back at current location.
               Note that this will overwrite or insert, depending on
               the current mode.
     TAB     : By default adds spaces to buffer to get to next TAB stop
               (just after every 8th column).
     LF, CR  : Returns current buffer to the program.
\end{verbatim}
\ENDVERB
   \par
'DCL' style provides the following control keys for editing:  
\begin{verbatim}
     BS/^E   : Move cursor to beginning/end of the line.
     ^F/^D   : Move cursor forward/backward one character.
     DEL     : Delete the character to the left of the cursor.
     ^A      : Toggle overwrite/insert mode.
     ^B      : Move to previous item on history list.
     ^U      : Delete from the beginning of the line to the cursor.
     TAB     : Move to next TAB stop.
     LF, CR  : Returns current buffer to the program.
\end{verbatim}

\ENDCBIG

\DEFCMD{KS}{VISIBI}{KUIP/SET\_SHOW}{VISIBILITY}{ cmd [ chopt ]}

\BEGARG
\DEFARG{CMD}{C}{Command name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{?, OFF, ON}{ D='?'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{?}{}
\DEFOPT{OFF}{}
\DEFOPT{ON}{}
\ENDOPT

   \par
Set or show the visibility attributes of a command.  

   \par
If CHOPT='OFF':  
\begin{verbatim}
    - the command it is not executable anymore
    - STYLE G draws a shadowed box on the command
    - HELP may be still requested on the command
\end{verbatim}
   \par
The startup value is ON.  

\ENDCMD

\DEFCMD{KS}{FILECA}{KUIP/SET\_SHOW}{FILECASE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Case conversion for filenames}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{KEEP}{\par
filenames are kept as entered on the command line
}
\DEFOPT{CONVERT}{\par
filenames are case converted
}
\DEFOPT{RESTORE}{\par
restore previous FILECASE setting
}
\ENDOPT

   \par
Set or show the case conversion for filenames.  

   \par
This command has only an effect on Unix systems to select whether filenames 
   are kept as entered on the command line.  The startup value is 'CONVERT', 
   i.e. filenames are converted to lowercase.  

   \par
On other systems filenames are always converted to uppercase.  

   \par
The 'RESTORE' option set the conversion mode to the value effective before 
   the last FILECASE KEEP/CONVERT command.  E.g. the sequence 
\begin{verbatim}
        FILECASE KEEP; EDIT Read.Me; FILECASE RESTORE
\end{verbatim}
   \par
forces case sensitivity for the EDIT command and restores the previous mode 
   afterwards.  

\ENDCMD

\DEFCMD{KS}{LCDIR}{KUIP/SET\_SHOW}{LCDIR}{ [ directory ]}

\BEGARG
\DEFARG{DIR*ECTORY}{C}{Directory name}{ D=\EMPTY{}}
\ENDARG

   \par
Set or show the local working directory.  

   \par
The current working directory is set to the given path name or the current 
   directory is shown.  

   \par
To show the current directory used LCDIR without argument.  'LCDIR ~' 
   switches to the home directory.  'LCDIR .' switches back to the working 
   directory at the time the program was started.  

\ENDCMD
\DEFMENU{0}{MACRO}{MACRO}

Macro Processor commands.  

\DEFCMD{M}{EXEC}{MACRO}{EXEC}{ mname [ margs ]}

\BEGARG
\DEFARG{MNAME}{C}{Macro name}{}
\DEFARG{MARGS}{C}{Macro arguments}{ D=\EMPTY{} Separate}
\ENDARG

   \par
Execute the command lines contained in the macro MNAME.  As a file can 
   contain several macros, the character '\#' is used to select a particular 
   macro inside a file as explained below.  

   \par
If MNAME does not contain the character '\#', the file MNAME.KUMAC is 
   searched and the first macro is executed (it may be an unnamed macro if a 
   MACRO statement is not found as first command line in the file).  

   \par
If MNAME is of the form FILE\#MACRO, the file named FILE.KUMAC is searched 
   and the macro named MACRO is executed.  

   \par
Examples:  
\begin{verbatim}
    EXEC ABC   to exec first (or unnamed) macro of file ABC.KUMAC
    EXEC ABC#M to exec macro M of file ABC.KUMAC
\end{verbatim}
\ENDVERB
   \par
The command MACRO/DEFAULTS can be used to define a directory search path 
   for macro files.  

\ENDCMD

\DEFCMD{M}{LIST}{MACRO}{LIST}{ [ mname ]}

\BEGARG
\DEFARG{MNAME}{C}{Macro name pattern}{ D=\EMPTY{}}
\ENDARG

   \par
List all macros in the search path defined by MACRO/DEFAULTS.  Macros are 
   files with the extension KUMAC.  MNAME may be specified to restrict the 
   list to the macros containing such a string in the first part of their 
   name.  For example, 
\begin{verbatim}
    MACRO/LIST ABC
\end{verbatim}
   \par
will list only macros starting with ABC.  

\ENDCMD

\DEFCMD{M}{TRACE}{MACRO}{TRACE}{ [ option level ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\DEFARG{LEVEL}{C}{Level}{ D=\EMPTY{} R=' ,TEST,WAIT'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\ENDOPT

   \par
Set ON/OFF the trace of commands during macro execution.  If TRACE='ON' the 
   next command is written on the terminal before being executed.  If 
   LEVEL='TEST' the command is only echoed but not executed.  If LEVEL='WAIT' 
   the command WAIT is automatically inserted after the execution of each 
   command.  The startup values are OPTION='OFF' and LEVEL=' '.  

\ENDCMD

\DEFCMD{M}{DEFAUL}{MACRO}{DEFAULTS}{ [ path option ]}

\BEGARG
\DEFARG{PATH}{C}{Search path for macro files}{ D='?'}
\DEFARG{OPTION}{C}{Automatic EXEC}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
show current setting
}
\DEFOPT{COMMAND}{\par
search for commands only
}
\DEFOPT{C}{\par
same as 'Command'
}
\DEFOPT{AUTO}{\par
search for commands before macros
}
\DEFOPT{A}{\par
same as 'Auto'
}
\DEFOPT{AUTOREVERSE}{\par
search for macros before commands
}
\DEFOPT{AR}{\par
same as 'AutoReverse'
}
\ENDOPT

   \par
Set or show MACRO search attributes.  

   \par
On Unix and VMS systems PATH defines a comma separated list of directories 
   in which the commands KUIP/EDIT, MACRO/EXEC, and MACRO/LIST search for 
   macro files.  For example, 
\begin{verbatim}
    MACRO/DEFAULT '.,macro,~/macro'          | Unix
    MACRO/DEFAULT '[],[.macro],[macro]'      | VMS
\end{verbatim}
   \par
defines to search files first in the current directory, then in the 
   subdirectory 'macro' of the current directory, and last the subdirectory 
   'macro' of the home directory.  

   \par
On VM/CMS system PATH defines a comma separated list of filemodes.  E.g.  
\begin{verbatim}
    MACRO/DEFAULT '*'       | search all disks
    MACRO/DEFAULT 'A,C'     | search only disks A and C
\end{verbatim}
\ENDVERB
   \par
If PATH='?' the currently defined search path is shown.  If PATH='.' the 
   search path is undefined, i.e. files are search for in the current 
   directory (A-disk on VM/CMS) only.  The startup value is PATH='.'.  

   \par
The search path is not applied if the file specification already contains 
   an explicit directory path or if it starts with a '-' character (which is 
   stripped off).  

   \par
OPTION allows to define whether macros can be envoked by their name only 
   without prepending the KUIP/EXEC command:  
\begin{verbatim}
    DEFAULT -Command
    CMD                     | CMD must be a command
    DEFAULT -Auto
    CMD                     | if CMD is not a command try EXEC CMD
    DEFAULT -AutoReverse
    CMD                     | try EXEC CMD first; if not found try command CMD
\end{verbatim}
   \par
The startup value is 'Command' (also reset by PATH='.').  

   \par
Important note:  

   \par
Inside macros the DEFAULT -A (or -AR) logic is disabled, i.e.  DEFAULT -C 
   is always assumed.  

\ENDCMD

\DEFCMD{M}{RECURS}{MACRO}{RECURSION}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Option}{ D='ON'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{ON}{}
\DEFOPT{OFF}{}
\ENDOPT

   \par
Set ON/OFF the option to execute macros recursively.  The startup value is 
   OFF.  

\ENDCMD
\DEFMENU{0}{VECTOR}{VECTOR}

Vector Processor commands.  Vectors are equivalent to FORTRAN 77 arrays and 
   they use the same notation except when omitting indexes (see last line 
   below).  Up to 3 dimensions are supported. Examples:  
\begin{verbatim}
    Vec(20) (mono-dimensional with 20 elements)
\end{verbatim}
   \par
may be addressed by:  
\begin{verbatim}
    Vec          for all elements
    Vec(13)      for element 13-th
    Vec(12:)     for elements 12-th to last
    Vec(:10)     for elements first to 10-th
    Vec(5:8)     for elements 5-th to 8-th
\end{verbatim}
\begin{verbatim}
    Vec(3,100) (bi-dimensional with 3 columns by 100 rows):
\end{verbatim}
   \par
may be addressed by:  
\begin{verbatim}
    Vec(2,5:8)   for elements 5-th to 8-th in 2-nd column
    Vec(2:3,5:8) for elements 5-th to 8-th in 2-nd to 3-rd columns
    Vec(2,5)     for element 5-th in 2-nd column
    Vec(:,3)     for all elements in 3-rd row
    Vec(2)       for all elements in 2-nd column (SPECIAL CASE)
\end{verbatim}
   \par
The latest line shows the special (and non-standard with FORTRAN 77) 
   notation such that missing indexes are substituted to the right.  

   \par
An 'invisible' vector called '?', mono-dimensional and of length 100, is 
   always present. Is is used for communicating between user arrays and KUIP 
   vectors, being equivalenced with the real array VECTOR(100) in the labelled 
   common block /KCWORK/.  

\DEFCMD{V}{CREATE}{VECTOR}{CREATE}{ vname [ type values ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name(length)}{}
\DEFARG{TYPE}{C}{Vector type}{ D='R' R='R,I'}
\DEFARG{VALUES}{C}{Value list}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Create a vector named VNAME (elements are set to zero).  The dimensions are 
   taken from the name, for example VEC(20), VEC(3,100), VEC(2,2,10).  Up to 3 
   dimensions are supported. Dimensions which are not specified are taken to 
   1, for example VEC(10) ---\KET{} VEC(10,1,1) and VEC ---\KET{} VEC(1,1,1).  
   The vector may be of type Real or Integer.  A vector is filled at the same 
   time if parameters are given after the TYPE:  
\begin{verbatim}
    VEC/CREATE V(10) R 1 2 3 4 5 66 77 88 99 111
    VEC/CREATE W(20) R 1 2 3
\end{verbatim}
   \par
In the last example only the first three elements are filled.  Vector 
   elements may be changed later with the command VECTOR/INPUT.  

   \par
If many equal values have to be entered consecutively, one can specify just 
   one value and precede it by a repetition factor and an asterisk. Example:  
\begin{verbatim}
    VEC/CREATE Z(20) R 5*1 2 4*3   --->   VEC/CREATE Z(20) R 1 1 1 1 1 2 3 3 3 
   3
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{LIST}{VECTOR}{LIST}{}

   \par
List all vectors (name, dimensions, type).  

\ENDCMD

\DEFCMD{V}{DELETE}{VECTOR}{DELETE}{ vlist}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{ D=\EMPTY{}}
\ENDARG

   \par
Delete from memory all vectors in the list VLIST.  The vectors are 
   separated in the list by a comma and imbedded blanks are not allowed. An 
   asterisk at the end of VLIST acts as string placeholder:  
\begin{verbatim}
    VEC/DEL AB*          --->  deletes all vectors starting by AB
    VEC/DEL *            --->  deletes all vectors
\end{verbatim}

\ENDCMD

\DEFCMD{V}{COPY}{VECTOR}{COPY}{ vnam1 vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
Copy a vector into another one.  Mixed vector type copy is supported (e.g. 
   Integer ---\KET{} Real and viceversa).  If VNAM2 does not exist it is 
   created with the required dimensions, not necessarily the same as the 
   source vector if a sub-range was specified.  For example, if A is a 3 x 100 
   vector and B does not exist, COPY A(2,11:60) B will create B as a 50 
   elements mono-dimensional vector; a special (and non-standard with FORTRAN 
   77) notation is used such that, still using the above vectors, COPY 
   A(2,1:100) B and COPY A(2) B have the same effect.  

   \par
Note that VECTOR/COPY does not allow a range for the destination vector not 
   specifying consecutive elements (i.e. along the first dimension):  
\begin{verbatim}
    VEC/COPY V(5)      W(3,4)     | O.K.
    VEC/COPY V1(2:3,5) V2(4:5,9)  | O.K.
    VEC/COPY V1(5,2:3) V2(4:5,9)  | O.K.
    VEC/COPY V1(3,3:4) V2(4,4:5)  | NOT allowed
    VEC/COPY V1(2:3,5) V2(2,4:5)  | NOT allowed
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{INPUT}{VECTOR}{INPUT}{ vname [ values ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{VALUES}{C}{Value list}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Enter values into a vector from the terminal.  Example:  
\begin{verbatim}
    VEC/INPUT V(6:10) 1.1 2.22 3.333 4.4444 5.55555
\end{verbatim}
   \par
If many equal values have to be entered consecutively, one can specify just 
   one value and precede it by a repetition factor and an asterisk. Example:  
\begin{verbatim}
    VEC/INPUT V 5*1 2 4*3   --->   VEC/INPUT V 1 1 1 1 1 2 3 3 3 3
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{PRINT}{VECTOR}{PRINT}{ vname [ dense ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{DENSE}{I}{Output density}{ D=1 R=0:2}
\ENDARG

   \par
Write to the terminal the content of a vector.  Enter HELP VECTOR for more 
   information on vector addressing.  

   \par
If DENSE.EQ.0 the output is one vector element per line.  If DENSE.EQ.1 the 
   output for a sequence of identical vector elements is compressed to two 
   lines stating the start and end indices.  If DENSE.EQ.2 the output for a 
   sequence of identical vector elements is compressed to a single line.  

\ENDCMD

\DEFCMD{V}{READ}{VECTOR}{READ}{ vlist fname [ format opt match ]}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Format}{ D=\EMPTY{}}
\DEFARG{OPT}{C}{Options}{ D='OC' R='OC,O, ,C'}
\DEFARG{MATCH}{C}{Matching pattern}{ D=\EMPTY{}}
\ENDARG

   \par
Enter values into vector(s) from a file.  A format can be specified, e.g. 
   FORMAT='F10.5,2X,F10.5', or the free format is used if FORMAT is not 
   supplied.  

   \par
If vector(s) are not existing they will be created of the size as read from 
   the file.  

   \par
Vectors in the list VLIST are separated by a comma and imbedded blanks are 
   not allowed. If subscripts are present in vector names, the smallest one is 
   taken.  

   \par
OPT is used to select between the following options:  
\begin{verbatim}
    'OC'   file is Opened, read and then Closed (default case)
    'O'    file is Opened and then read (left open for further reading)
    ' '    file is read (already open, left so for further reading)
    'C'    file is read and then Closed (already open)
\end{verbatim}
   \par
If the character 'Z' is present in OPT, the vector elements equal to zero 
   after reading are set to the latest non-zero element value (for example 
   reading 1 2 3 0 0 4 0 5 will give 1 2 3 3 3 4 4 5).  

   \par
MATCH is used to specify a pattern string, restricting the vector filling 
   only to the records in the file which verify the pattern. Example of 
   patterns:  
\begin{verbatim}
     /string/      match a string (starting in column 1)
    -/string/      do not match a string (starting in column 1)
     /string/(n)   match a string, starting in column n
     /string/(*)   match a string, starting at any column
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{WRITE}{VECTOR}{WRITE}{ vlist [ fname format chopt ]}

\BEGARG
\DEFARG{VLIST}{C}{Vector list}{}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Format}{ D='5(1X,G13.7)'}
\DEFARG{CHOPT}{C}{Options}{ D='OC'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{OC}{}
\DEFOPT{O}{}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{}
\ENDOPT

   \par
Write to a file the content of vector(s).  If FNAME=' ' the content is 
   written to the terminal.  A format can be specified, e.g. 
   FORMAT='F10.5,2X,F10.5', or the default one is used if FORMAT is not 
   supplied.  

   \par
Vectors in the list VLIST are separated by a comma and imbedded blanks are 
   not allowed. If subscripts are present in vector names, the smallest one is 
   taken.  

   \par
CHOPT is used to select between the following options:  
\begin{verbatim}
    'OC'   file is Opened, written and then Closed (default case)
    'O'    file is Opened and then written (left open for further writing)
    ' '    file is written (already open, left so for further writing)
    'C'    file is written and then Closed (already open)
\end{verbatim}
   \par
Enter HELP VECTOR for more information on vector addressing.  

\ENDCMD

\DEFCMD{V}{DRAW}{VECTOR}{DRAW}{ vname [ id chopt ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{ID}{C}{Histogram Identifier}{ D='12345'}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw an histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Draw vector VNAME interpreting it as a histogram.  Optionally save the 
   contents in histogram ID.  

\ENDCMD

\DEFCMD{V}{HFILL}{VECTOR}{HFILL}{ vname id}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{ID}{C}{Histogram Identifier}{}
\ENDARG

   \par
Fill the existing histogram ID with vector VNAME.  Note that the command 
   VECTOR/PLOT can automatically book, fill and plot the contents of a vector. 

\ENDCMD

\DEFCMD{V}{PLOT}{VECTOR}{PLOT}{ vname [ id chopt ]}

\BEGARG
\DEFARG{VNAME}{C}{Vector name}{}
\DEFARG{ID}{C}{Histogram Identifier}{ D='12345'}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw an histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Each element of VNAME is used to fill an histogram which is automatically 
   booked with 100 channels and then plotted.  If VNAME has the form 
   VNAME1\%VNAME2 then a scatter-plot of vector VNAME1 versus VNAME2 is 
   plotted. If ID is given different of 12345, then a 2-Dim histogram is 
   created with 40 bins by 40 bins and filled.  One can use the command 
   VECTOR/HFILL to fill an already existing histogram.  

\ENDCMD

\DEFCMD{V}{FIT}{VECTOR}{FIT}{ x y ey func [ chopt np par step pmin pmax errpar ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{EY}{C}{Vector of errors on Y}{ D='?'}
\DEFARG{FUNC}{C}{Function name}{}
\DEFARG{CHOPT}{C}{Character options}{ D=\EMPTY{}}
\DEFARG{NP}{I}{Number of parameters}{ D=0 R=0:20}
\DEFARG{PAR}{C}{Vector of parameters}{}
\DEFARG{STEP}{C}{Vector of steps size}{}
\DEFARG{PMIN}{C}{Vector of lower bounds}{}
\DEFARG{PMAX}{C}{Vector of upper bounds}{}
\DEFARG{ERRPAR}{C}{Vector of errors on parameters}{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Do the fit, plot the result and print the parameters.
}
\DEFOPT{0}{\par
Do not plot the result of the fit. By default the fitted function is drawn 
unless the option 'N' below is specified.
}
\DEFOPT{N}{\par
Do not store the result of the fit bin by bin with the histogram. By default 
the function is calculated at the middle of each bin and the fit results 
stored with the histogram data structure.
}
\DEFOPT{Q}{\par
Quiet mode. No print
}
\DEFOPT{V}{\par
Verbose mode. Results after each iteration are printed By default only final 
results are printed.
}
\DEFOPT{B}{\par
Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be 
specified. Default is: All parameters vary freely.
}
\DEFOPT{L}{\par
Use Log Likelihood. Default is chisquare method.
}
\DEFOPT{D}{\par
The user is assumed to compute derivatives analytically using the routine 
HDERIV. By default, derivatives are computed numerically.
}
\DEFOPT{W}{\par
Sets weights equal to 1. Default weights taken from the square root of the 
contents or from HPAKE/HBARX (PUT/ERRORS).
}
\DEFOPT{M}{\par
The interactive Minuit is invoked.
}
\DEFOPT{E}{\par
Performs a better Error evaluation (MIGRAD + HESSE + MINOS).
}
\ENDOPT

   \par
Fit a user defined function to the points defined by the two vectors X and 
   Y and the vector of associated errors EY.  See command Histo/Fit for 
   explanation of parameters.  Note that if option 'W' is specified or EY='?' 
   (default), the array EY is ignored. Option 'L' is not available.  

\ENDCMD
\DEFMENU{1}{OPERATIONS}{VECTOR/OPERATIONS}

Simple arithmetic operations between vectors.  In all the operations only 
   the minimum vector length is considered, i.e. an operation between a vector 
   A of dimension 10 and a vector B of dimension 5 will involve the first 5 
   elements in both vectors.  If the destination vector does not exist, it is 
   created with the same length as the source vector.  

\DEFCMD{VO}{VBIAS}{VECTOR/OPERATIONS}{VBIAS}{ vnam1 bias vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{BIAS}{R}{Bias value}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM2(I) = BIAS     + VNAM1(I) 

\ENDCMD

\DEFCMD{VO}{VSCALE}{VECTOR/OPERATIONS}{VSCALE}{ vnam1 scale vnam2}

\BEGARG
\DEFARG{VNAM1}{C}{Source vector name}{}
\DEFARG{SCALE}{R}{Scale factor}{}
\DEFARG{VNAM2}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM2(I) = SCALE    * VNAM1(I) 

\ENDCMD

\DEFCMD{VO}{VADD}{VECTOR/OPERATIONS}{VADD}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) + VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VMULTI}{VECTOR/OPERATIONS}{VMULTIPLY}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) * VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VSUBTR}{VECTOR/OPERATIONS}{VSUBTRACT}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) - VNAM2(I) 

\ENDCMD

\DEFCMD{VO}{VDIVID}{VECTOR/OPERATIONS}{VDIVIDE}{ vnam1 vnam2 vnam3}

\BEGARG
\DEFARG{VNAM1}{C}{First source vector name}{}
\DEFARG{VNAM2}{C}{Second source vector name}{}
\DEFARG{VNAM3}{C}{Destination vector name}{}
\ENDARG

   \par
VNAM3(I) = VNAM1(I) / VNAM2(I)     ( or 0 if VNAM2(I)=0 ) 

\ENDCMD
\DEFMENU{0}{HISTOGRAM}{HISTOGRAM}

Manipulation of histograms, Ntuples.  Interface to the HBOOK package.  

\DEFCMD{H}{FILE}{HISTOGRAM}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=0:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in words}{ D=1024}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Existing file is opened (read mode only).
}
\DEFOPT{N}{\par
A new file is opened.
}
\DEFOPT{U}{\par
Existing file is opened to be modified.
}
\DEFOPT{D}{\par
Reset lock.
}
\ENDOPT

   \par
Open an HBOOK direct access file.  If LUN is 0 the next free logical unit 
   will be used.  If LRECL is 0 the system will determine the correct record 
   length of an existing file.  

\ENDCMD

\DEFCMD{H}{LIST}{HISTOGRAM}{LIST}{ [ chopt ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
List histograms and Ntuples in the current directory.
}
\DEFOPT{I}{\par
A verbose format is used (HINDEX), (only for //PAWC).
}
\DEFOPT{S}{\par
List with histograms sorted by increasing IDs.
}
\ENDOPT

   \par
List histograms and Ntuples in the current directory.  

\ENDCMD

\DEFCMD{H}{DELETE}{HISTOGRAM}{DELETE}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Delete histogram/Ntuple ID in Current Directory (memory).  If ID=0 delete 
   all histograms and Ntuples.  To delete histograms in disk files use command 
   HIO/HSCRATCH.  

\ENDCMD

\DEFCMD{H}{PLOT}{HISTOGRAM}{PLOT}{ [ id chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop Minus}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{} Minus}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw the histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{-}{\par
Substract contents of ID to last plotted histogram.
}
\DEFOPT{+-}{\par
Draw the delta with the last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel or cell.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\DEFOPT{K}{\par
Must be given if option 'U' is given later.
}
\DEFOPT{U}{\par
Update channels modified since last call.
}
\DEFOPT{E}{\par
Draw error bars and current marker. E0 is also allowed.
}
\DEFOPT{E1}{\par
Draw small lines at the end of the error bars.
}
\DEFOPT{E2}{\par
Draw error rectangles.
}
\DEFOPT{E3}{\par
Draw a filled area through the end points of the vertical error bars.
}
\DEFOPT{E4}{\par
Draw a smoothed filled area through the end points of the vertical error bars.
}
\DEFOPT{A}{\par
Axis labels and tick marks are not drawn.
}
\DEFOPT{BOX}{\par
Draw 2-Dim with proportional boxes.
}
\DEFOPT{COL}{\par
Draw 2-Dim with a color table.
}
\DEFOPT{Z}{\par
Used with COL or SURF, it draws the color map.
}
\DEFOPT{SURF}{\par
Draw as a surface plot (angles are set via the command angle).
}
\DEFOPT{SURF1}{\par
Draw as a surface with color levels
}
\DEFOPT{SURF2}{\par
Same as SURF1 but without cell lines.
}
\DEFOPT{SURF3}{\par
Same as SURF but with the contour plot (in color) on top.
}
\DEFOPT{SURF4}{\par
Draw as a surface with Gouraud shading.
}
\DEFOPT{LEGO}{\par
Draw as a lego plot (angles are set via the command angle).
}
\DEFOPT{LEGO1}{\par
Draw lego plot with light simulation.
}
\DEFOPT{LEGO2}{\par
Draw lego plot with color levels.
}
\DEFOPT{CONT}{\par
Draw 2-Dim as a contour plot (15 levels).
}
\DEFOPT{TEXT}{\par
Draw 2-Dim as a table.
}
\DEFOPT{CHAR}{\par
Draw 2-Dim with characters (a la HBOOK).
}
\DEFOPT{HIST}{\par
Draw only histogram (no errors or associated function).
}
\DEFOPT{FUNC}{\par
Draw only the associated function (not the histogram).
}
\DEFOPT{CYL}{\par
Cylindrical coordinates for 3D plots.
}
\DEFOPT{POL}{\par
Polar coordinates for 3D plots.
}
\DEFOPT{SPH}{\par
Spherical coordinates for 3D plots.
}
\DEFOPT{PSD}{\par
Pseudo-rapidity/phi coordinates for 3D plots.
}
\ENDOPT

   \par
Plot a single histogram or a 2-Dim projection.  If ID=0 or ID=* all the 
   histograms in the current directory are plotted.  Each plotted histogram 
   will start either a new picture or a new zone in the current picture.  
\begin{verbatim}
    Histogram subranges can be specified in 2 different ways:
     1- h/pl id(ic1:ic2) with ic1 and ic2 integers means plot
                         from channel ic1 to channel ic2
     2- h/pl id(x1:x2) with x1 and x2 reals (with a .) means plot
                       from channel corresponding to x1
     Note that the mixed mode h/pl id(x1:ic2) is also accepted
     This subrange works also for 2-DIM cases.
    Ex: Histo/plot 10(25:1.) or Histo/plot 20(4:18,0.:0.5).
\end{verbatim}
   \par
1 Dim histograms could be plotted with option LEGO or SURF.  In this case 
   the angles are THETA=1 and PHI=-1.  When option 'E' is used, the marker 
   type can be changed with SMK, the marker size with SET KSIZ, the marker 
   color with SPMCI.  
\begin{verbatim}
    To plot projection X of ID type
      HI/PLOT ID.PROX
    To plot band 1 in Y of ID type
      HI/PLOT ID.BANY.1
    To plot slice 3 in Y of ID type
      HI/PLOT ID.SLIY.3
\end{verbatim}
   \par
In addition to the Cartesian coordinate systems, Polar, cylindrical, 
   spherical, pseudo-rapidity/phi coordinates are available for LEGO and 
   SURFACE plots, including stacked lego plots.  For example:  
\begin{verbatim}
         PAW > Histo/plot 10+20+30  LEGO1CYL  | stacked cylindrical lego plot
         PAW > Histo/plot 10+20+30  LEGO1POL  |         polar
         PAW > Histo/plot 10+20+30  LEGO1SPH  |         spherical
         PAW > Histo/plot 10+20+30  LEGO1PSD  |         pseudo-rapidity/phi
\end{verbatim}
   \par
Note that the viewing angles may be changed via the command ANGLES.  

\ENDCMD

\DEFCMD{H}{ZOOM}{HISTOGRAM}{ZOOM}{ [ id chopt icmin icmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop Minus}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{ICMIN}{I}{First channel}{ D=1}
\DEFARG{ICMAX}{I}{Last channel}{ D=9999}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Plot the zoomed histogram.
}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{B}{\par
Select Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Plot a single histogram between channels ICMIN and ICMAX.  Each plotted 
   histogram will start either a new picture or a new zone in the current 
   picture.  If no parameters are given to the command, then the system waits 
   for two points using the graphics cursor.  To quit ZOOM, click the right 
   button of the mouse or CRTL/E.  

\ENDCMD

\DEFCMD{H}{MANYPL}{HISTOGRAM}{MANY\_PLOTS}{ idlist}

\BEGARG
\DEFARG{IDLIST}{C}{List of histogram Identifiers}{ Vararg}
\ENDARG

   \par
Plot one or several histograms into the same plot.  Plotted histograms are 
   superimposed on the same zone of the picture.  

\ENDCMD

\DEFCMD{H}{PROJEC}{HISTOGRAM}{PROJECT}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Fill all booked projections of a 2-Dim histogram.  Filling is done using 
   the 2-D contents of ID.  

\ENDCMD

\DEFCMD{H}{COPY}{HISTOGRAM}{COPY}{ id1 id2 [ title ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{New title}{ D=\EMPTY{}}
\ENDARG

   \par
Copy a histogram (not Ntuple) onto another one.  Bin definition, contents, 
   errors, etc. are preserved.  If TITLE is not given, ID2 has the same title 
   as ID1.  

\ENDCMD

\DEFCMD{H}{FIT}{HISTOGRAM}{FIT}{ id func [ chopt np par step pmin pmax errpar ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FUNC}{C}{Function name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NP}{I}{Number of parameters}{ D=0 R=0:34}
\DEFARG{PAR}{C}{Vector of parameters}{}
\DEFARG{STEP}{C}{Vector of steps size}{}
\DEFARG{PMIN}{C}{Vector of lower bounds}{}
\DEFARG{PMAX}{C}{Vector of upper bounds}{}
\DEFARG{ERRPAR}{C}{Vector of errors on parameters}{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Do the fit, plot the result and print the parameters.
}
\DEFOPT{0}{\par
Do not plot the result of the fit. By default the fitted function is drawn 
unless the option 'N' below is specified.
}
\DEFOPT{N}{\par
Do not store the result of the fit bin by bin with the histogram. By default 
the function is calculated at the middle of each bin and the fit results 
stored with the histogram data structure.
}
\DEFOPT{Q}{\par
Quiet mode. No print
}
\DEFOPT{V}{\par
Verbose mode. Results after each iteration are printed By default only final 
results are printed.
}
\DEFOPT{B}{\par
Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be 
specified. Default is: All parameters vary freely.
}
\DEFOPT{L}{\par
Use Log Likelihood. Default is chisquare method.
}
\DEFOPT{D}{\par
The user is assumed to compute derivatives analytically using the routine 
HDERIV. By default, derivatives are computed numerically.
}
\DEFOPT{W}{\par
Sets weights equal to 1. Default weights taken from the square root of the 
contents or from HPAKE/HBARX (PUT/ERRORS).
}
\DEFOPT{M}{\par
The interactive Minuit is invoked.
}
\DEFOPT{E}{\par
Performs a better Error evaluation (MIGRAD + HESSE + MINOS).
}
\ENDOPT

   \par
Fit a user defined (and parameter dependent) function to a histogram ID 
   (1-Dim or 2-Dim) in the specified range.  FUNC may be:  
\begin{verbatim}
    A- The name of a file which contains the user defined
       function to be minimized. Function name and file name
       must be the same. For example file FUNC.FOR is:
         FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram
         COMMON/PAWPAR/PAR(2)
         FUNC=PAR(1)*X +PAR(2)*EXP(-X)
         END
        Ex: His/fit 10 func.for ! 5 par
\end{verbatim}
\begin{verbatim}
    B- One of the following keywords (1-Dim only):
       G : to fit Func=par(1)*exp(-0.5*((x-par(2))/par(3))**2)
       E : to fit Func=exp(par(1)+par(2)*x)
       Pn: to fit Func=par(1)+par(2)*x+par(3)*x**2......+par(n+1)*x**n
        Ex: His/fit 10 g
\end{verbatim}
\begin{verbatim}
    C- A combination of the keywords in B with the 2 operators + or *.
       Ex: His/Fit 10 p4+g ! 8 par
           His/Fit 10 p2*g+g ! 9 par
         Note that in this case, the order of parameters in PAR must
         correspond to the order of the basic functions.
         For example, in the first case above, par(1:5) apply to
         the polynomial of degree 4 and par(6:8) to the gaussian while
         in the second case par(1:3) apply to the polynomial of degree 2,
         par(4:6) to the first gaussian and par(7:9) to the second gaussian.
         Blanks are not allowed in the expression.
\end{verbatim}
   \par
For cases A and C, before the execution of this command, the vector PAR 
   must be filled (via Vector/Input) with the initial values.  For case B, if 
   NP is set to 0, then the initial values of PAR will be calculated 
   automatically.  After the fit, the vector PAR contains the new values of 
   parameters. If the vector ERRPAR is given, it will contain the errors on 
   the fitted parameters.  A bin range may be specified with ID.  
\begin{verbatim}
     Ex. Histo/Fit 10(25:56).
\end{verbatim}

\ENDCMD
\DEFMENU{1}{2D\_PLOT}{HISTOGRAM/2D\_PLOT}

Plotting of 2-Dim histograms in various formats.  

\DEFCMD{H2}{LEGO}{HISTOGRAM/2D\_PLOT}{LEGO}{ [ id theta phi chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{THETA}{R}{Angle THETA in degrees}{ D=30.}
\DEFARG{PHI}{R}{Angle PHI in degrees}{ D=30.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Hidden line algorithm is used.
}
\DEFOPT{1}{\par
Hidden surface algorithm is used. The colour of the lego is given by SET HCOL 
CI where CI is a colour index. For the top and the sides of the lego the same 
hue is used but with a different light.
}
\DEFOPT{2}{\par
Hidden surface algorithm is used. The colour of each bar changes according to 
the value of Z. It is possible to change the set of colours used with SET HCOL 
c.L where L define a palette of colours given by the command ATT/PALETTE.
}
\ENDOPT

   \par
Draw a lego plot from 2-Dim or 1-Dim histograms.  It is also possible to 
   produce stacked lego plots. A stacked lego plot consists of a 
   superimposition of several histograms, whose identifiers are given in the 
   command LEGO separated by the character \DQUOTE{}+\DQUOTE{}.  
\begin{verbatim}
    PAW > LEGO ID1+ID2+ID3    | Maximum number of ID's is 10. The colours of
                              | each IDn is given by the command ATT/PALETTE
\end{verbatim}
   \par
Examples:  
\begin{verbatim}
    PAW > SET HCOL 2          | The colour the histogram is 2 (red)
    PAW > LEGO 20             | Display a lego with lines
    PAW > LEGO 20 ! ! 1       | Display a lego with different lights
    PAW > LEGO 20 ! ! 2       | Display a lego with colours
    PAW > PALETTE  1 3 2 3 4  | Create the palette number 1 with 3
                              | elements: 2,3
    PAW > SET HCOL 0.1        | The subsequent stack lego plots will use list 1
    PAW > LEGO 10+20+30       | Plot a stack of lego plots with lines
    PAW > LEGO 10+20+30 ! ! 1 | Plot a stack of lego plots with light
\end{verbatim}
   \par
Notes: - The commands OPTION BAR, SET BARW and SET BARO act on lego plots 
\begin{verbatim}
          - The options 1 and 2 must be used only on selective erase
            devices.
\end{verbatim}

\ENDCMD

\DEFCMD{H2}{SURFAC}{HISTOGRAM/2D\_PLOT}{SURFACE}{ [ id theta phi chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{THETA}{R}{Angle THETA in degrees}{ D=30.}
\DEFARG{PHI}{R}{Angle PHI in degrees}{ D=30.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Hidden line algorithm is used.
}
\DEFOPT{1}{\par
Hidden surface algorithm is used and each cell is filled with a colour 
corresponding to the Z value (or grey scale with PostScript). It is possible 
to change the set of colours used with SET HCOL ic.L where L define a palette 
of colours given by the command ATT/PALETTE.
}
\DEFOPT{2}{\par
Similar to option '1' except that the cell lines are not drawn. This is very 
useful to draw contour plots with colours if THETA=90 and PHI=0.
}
\DEFOPT{3}{\par
Surface is drawn with a contour plot in color on top. The contour plot is 
drawn with the colors defined with the command PALETTE.
}
\DEFOPT{4}{\par
Surface is drawn with Gouraud shading.
}
\ENDOPT

   \par
Draw a surface plot from 2-Dim or 1-Dim histograms.  With this command it 
   is possible to draw color contour plots:  
\begin{verbatim}
       PAW > ATT/PAL 1 3 2 3 4   | Define the palette 1 with 3 elements
       PAW > SET HCOL 0.1        | Set the list 1 as colours for histograms
       PAW > SET NDVZ 4          | Set the number of Z divisions to 4
       PAW > SURF id 90 0 2      | Draw the contour
\end{verbatim}
\ENDVERB
   \par
Note: - The options 1 to 4 must be used only on selective erase devices.  

\ENDCMD

\DEFCMD{H2}{CONTOU}{HISTOGRAM/2D\_PLOT}{CONTOUR}{ [ id nlevel chopt param ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{NLEVEL}{I}{Number of contour lines}{ D=10}
\DEFARG{CHOPT}{C}{Options}{ D='1'}
\DEFARG{PARAM}{C}{Vector of contour levels}{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{0}{\par
Use colour to distinguish contours.
}
\DEFOPT{1}{\par
Use line style to distinguish contours.
}
\DEFOPT{2}{\par
Line style and colour are the same for all contours.
}
\DEFOPT{3}{\par
The contour is drawn with filled colour levels. The levels are equidistant. 
The color indices are taken in the current palette (defined with the command 
PALETTE). If the number of levels (NLEVEL) is greater than the number of 
entries in the current palette, the palette is explore again from the 
beginning in order to reach NLEVEL.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\ENDOPT

   \par
Draw a contour plot from a 2-Dim histogram.  If PARAM is not given, contour 
   levels are equidistant.  If given, the vector PARAM may contain up to 50 
   values.  

\ENDCMD
\DEFMENU{1}{CREATE}{HISTOGRAM/CREATE}

Creation (\DQUOTE{}booking\DQUOTE{}) of HBOOK objects in memory.  

\DEFCMD{HC}{1DHIST}{HISTOGRAM/CREATE}{1DHISTO}{ id title ncx xmin xmax [ valmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels}{ D=100}
\DEFARG{XMIN}{R}{Low edge}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge}{ D=100.}
\DEFARG{VALMAX}{R}{Maximum bin content}{ D=0.}
\ENDARG

   \par
Create a one dimensional histogram.  The contents are set to zero.  If 
   VALMAX=0, then a full word is allocated per channel, else VALMAX is used as 
   the maximum bin content allowing several channels to be stored into the 
   same machine word.  

\ENDCMD

\DEFCMD{HC}{PROFIL}{HISTOGRAM/CREATE}{PROFILE}{ id title ncx xmin xmax ymin ymax [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels}{ D=100}
\DEFARG{XMIN}{R}{Low edge in X}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge in X}{ D=100.}
\DEFARG{YMIN}{R}{Low edge in Y}{ D=-1.E30}
\DEFARG{YMAX}{R}{Upper edge in Y}{ D=1.E30}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Error on mean
}
\DEFOPT{S}{\par
Spread option
}
\ENDOPT

   \par
Create a profile histogram.  Profile histograms accumulate statistical 
   quantities of a variable y in bins of a variable x. The contents are set to 
   zero.  

\ENDCMD

\DEFCMD{HC}{BINS}{HISTOGRAM/CREATE}{BINS}{ id title ncx xbins [ valmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels}{ D=100}
\DEFARG{XBINS}{C}{Vector of NCX+1 low-edges}{}
\DEFARG{VALMAX}{R}{Maximum bin content}{ D=0.}
\ENDARG

   \par
Create a histogram with variable size bins.  The low-edge of each bin is 
   given in vector XBINS (NCX+1) values.  The contents are set to zero. See 
   1DHISTO for VALMAX.  

\ENDCMD

\DEFCMD{HC}{2DHIST}{HISTOGRAM/CREATE}{2DHISTO}{ id title ncx xmin xmax ncy ymin ymax [ valmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{Histogram title}{ D=\EMPTY{}}
\DEFARG{NCX}{I}{Number of channels in X}{ D=40}
\DEFARG{XMIN}{R}{Low edge in X}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge in X}{ D=40.}
\DEFARG{NCY}{I}{Number of channels in Y}{ D=40}
\DEFARG{YMIN}{R}{Low edge in Y}{ D=0.}
\DEFARG{YMAX}{R}{Upper edge in Y}{ D=40.}
\DEFARG{VALMAX}{R}{Maximum bin content}{ D=0.}
\ENDARG

   \par
Create a two dimensional histogram.  The contents are set to zero. See 
   1DHISTO for VALMAX.  

\ENDCMD

\DEFCMD{HC}{PROX}{HISTOGRAM/CREATE}{PROX}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\ENDARG

   \par
Create the projection onto the x axis.  The projection is not filled until 
   the Histo/Project command is executed.  

\ENDCMD

\DEFCMD{HC}{PROY}{HISTOGRAM/CREATE}{PROY}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\ENDARG

   \par
Create the projection onto the y axis.  The projection may be filled with 
   Histo/Project.  

\ENDCMD

\DEFCMD{HC}{SLIX}{HISTOGRAM/CREATE}{SLIX}{ id nslices}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{NSLICES}{I}{Number of slices}{}
\ENDARG

   \par
Create projections onto the x axis, in y-slices.  The projection may be 
   filled with Histo/Project.  

\ENDCMD

\DEFCMD{HC}{SLIY}{HISTOGRAM/CREATE}{SLIY}{ id nslices}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{NSLICES}{I}{Number of slices}{}
\ENDARG

   \par
Create projections onto the y axis, in x-slices.  The projection may be 
   filled with Histo/Project.  

\ENDCMD

\DEFCMD{HC}{BANX}{HISTOGRAM/CREATE}{BANX}{ id ymin ymax}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{YMIN}{R}{Low edge in Y}{}
\DEFARG{YMAX}{R}{Upper edge in Y}{}
\ENDARG

   \par
Create a projection onto the x axis, in a band of y.  The projection may be 
   filled with Histo/Project.  

\ENDCMD

\DEFCMD{HC}{BANY}{HISTOGRAM/CREATE}{BANY}{ id xmin xmax}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{ Loop}
\DEFARG{XMIN}{R}{Low edge in X}{}
\DEFARG{XMAX}{R}{Upper edge in X}{}
\ENDARG

   \par
Create a projection onto the y axis, in a band of x.  The projection may be 
   filled with Histo/Project.  

\ENDCMD

\DEFCMD{HC}{TITLEG}{HISTOGRAM/CREATE}{TITLE\_GLOBAL}{ [ chtitl chopt ]}

\BEGARG
\DEFARG{CHTITL}{C}{Global title}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
The global title is plotted at the top of each picture.
}
\DEFOPT{U}{\par
If the option 'UTIT' is on, a user title is plotted at the bottom of each 
histogram.
}
\ENDOPT

   \par
Set the global title.  The size and the Y position of the global title may 
   be changed by the commands SET GSIZ and SET YGTI respectively. The size and 
   the Y position of the user title may be changed by the commands SET TSIZ 
   and SET YHTI respectively.  

\ENDCMD
\DEFMENU{1}{HIO}{HISTOGRAM/HIO}

Input/Output operations of histograms.  

\DEFCMD{HH}{HRIN}{HISTOGRAM/HIO}{HRIN}{ id [ icycle iofset ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{ICYCLE}{I}{Cycle number}{ D=999}
\DEFARG{IOFSET}{I}{Offset}{ D=0}
\ENDARG

   \par
Read histogram/Ntuple ID from the current directory on direct access file 
   to memory.  An identical histogram is created but with an ID equal to that 
   of the original histogram plus the offset IOFSET.  Identifier may be '0' or 
   '*' (for all histograms).  If ICYCLE \KET{} 1000 and ID=0 read all 
   histograms in all subdirectories as well.  If IOFSET = 99999 then the 
   contents of histogram ID on the disk file are added to the current 
   histogram in memory if it exists. For example to add all histograms from 
   FILE1 and FILE2 in memory, the sequence of commands can be:  
\begin{verbatim}
    PAW > Histo/File 1 FILE1
    PAW > Hrin 0
    PAW > Histo/File 2 FILE2
    PAW > Hrin 0 ! 99999
\end{verbatim}

\ENDCMD

\DEFCMD{HH}{HROUT}{HISTOGRAM/HIO}{HROUT}{ id [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Write histo/Ntuple ID from memory to current directory.
}
\DEFOPT{T}{\par
Writes all histograms in subdirectories as well.
}
\ENDOPT

   \par
Write histo/Ntuple ID from memory to current directory.  Identifier may be 
   '0' or '*' (for all histograms).  

\ENDCMD

\DEFCMD{HH}{HSCRAT}{HISTOGRAM/HIO}{HSCRATCH}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Delete histogram ID in Current Directory on disk.  If ID='0' or '*' delete 
   all histograms.  To delete histograms in memory use command HISTO/DELETE.  

\ENDCMD

\DEFCMD{HH}{HFETCH}{HISTOGRAM/HIO}{HFETCH}{ id fname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Fetch histogram ID from file FNAME.  FNAME has been created by the old 
   version of HBOOK3 (Unformatted).  

\ENDCMD

\DEFCMD{HH}{HREAD}{HISTOGRAM/HIO}{HREAD}{ id fname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Read histogram ID from file FNAME.  FNAME has been created by the old 
   version of HBOOK3 (Formatted).  

\ENDCMD

\DEFCMD{HH}{PRINT}{HISTOGRAM/HIO}{PRINT}{ id [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Print histograms.
}
\DEFOPT{S}{\par
Only statistics (Number of entries, mean, RMS, underflow, overflow) are 
printed.
}
\ENDOPT

   \par
Print histograms (line-printer format) on screen.  The command OUTPUT\_LP 
   may be used to change the output file.  

\ENDCMD

\DEFCMD{HH}{DUMP}{HISTOGRAM/HIO}{DUMP}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\ENDARG

   \par
Dump the histogram ZEBRA data structure on the terminal.  

\ENDCMD

\DEFCMD{HH}{OUTPUT}{HISTOGRAM/HIO}{OUTPUT\_LP}{ [ lun fname ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ D=6}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Change the HBOOK \DQUOTE{}line printer\DQUOTE{} file name.  If FNAME=' ' 
   then OUTPUT is appended to an already opened file on unit LUN.  If LUN is 
   negative, the file is closed and subsequent output is directed to unit 6.  

\ENDCMD

\DEFCMD{HH}{GLOBAL}{HISTOGRAM/HIO}{GLOBAL\_SECT}{ gname}

\BEGARG
\DEFARG{GNAME}{C}{Global section name}{ D=\EMPTY{}}
\ENDARG

   \par
Map the global section GNAME (VAX only).  The current directory is changed 
   to //GNAME.  

\ENDCMD

\DEFCMD{HH}{GRESET}{HISTOGRAM/HIO}{GRESET}{ id}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\ENDARG

   \par
Reset histogram ID in the global section.  

\ENDCMD
\DEFMENU{1}{OPERATIONS}{HISTOGRAM/OPERATIONS}

Histogram operations and comparisons.  

\DEFCMD{HO}{ADD}{HISTOGRAM/OPERATIONS}{ADD}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Add histograms: ID3 = C1*ID1 + C2*ID2.  Applicable to 1-Dim and 2-Dim 
   histograms.  See command HRIN to add histograms with same IDS from 
   different files.  If option 'E' is set, error bars are calculated for ID3.  

\ENDCMD

\DEFCMD{HO}{SUBTRA}{HISTOGRAM/OPERATIONS}{SUBTRACT}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Subtract histograms: ID3 = C1*ID1 - C2*ID2.  Applicable to 1-Dim and 2-Dim 
   histograms.  If option 'E' is set, error bars are calculated for ID3.  

\ENDCMD

\DEFCMD{HO}{MULTIP}{HISTOGRAM/OPERATIONS}{MULTIPLY}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Multiply histogram contents: ID3 = C1*ID1 * C2*ID2.  Applicable to 1-Dim 
   and 2-Dim histograms.  If option 'E' is set, error bars are calculated for 
   ID3.  

\ENDCMD

\DEFCMD{HO}{DIVIDE}{HISTOGRAM/OPERATIONS}{DIVIDE}{ id1 id2 id3 [ c1 c2 option ]}

\BEGARG
\DEFARG{ID1}{C}{First histogram Identifier}{}
\DEFARG{ID2}{C}{Second histogram Identifier}{}
\DEFARG{ID3}{C}{Result histogram Identifier}{}
\DEFARG{C1}{R}{Scale factor for ID1}{ D=1.}
\DEFARG{C2}{R}{Scale factor for ID2}{ D=1.}
\DEFARG{OPTION}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{E}{}
\ENDOPT

   \par
Divide histograms: ID3 = C1*ID1 / C2*ID2.  Applicable to 1-Dim and 2-Dim 
   histograms.  If option 'E' is set, error bars are calculated for ID3.  

\ENDCMD

\DEFCMD{HO}{RESET}{HISTOGRAM/OPERATIONS}{RESET}{ id [ title ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{TITLE}{C}{New title}{ D=\EMPTY{}}
\ENDARG

   \par
Reset contents and errors of an histogram.  Bin definition is not modified. 

\ENDCMD

\DEFCMD{HO}{DIFF}{HISTOGRAM/OPERATIONS}{DIFF}{ id1 id2 [ chopt ]}

\BEGARG
\DEFARG{ID1}{C}{First Histogram Identifier}{}
\DEFARG{ID2}{C}{Second Histogram Identifier}{}
\DEFARG{CHOPT}{C}{Options}{ D='D'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
The comparison is done only on the shape of the two histograms.
}
\DEFOPT{N}{\par
Include also comparison of the relative normalization of the two histograms, 
in addition to comparing the shapes. PROB is then a combined confidence level 
taking account of absolute contents.
}
\DEFOPT{D}{\par
Debug printout, produces a blank line and two lines of information at each 
call, including the ID numbers, the number of events in each histogram, the 
PROB value, and the maximum Kolmogorov distance between the two histograms. 
For 2-Dim histograms, there are two Kolmogorov distances (see below). If 'N' 
is specified, there is a third line of output giving the PROB for shape alone, 
and for normalization.
}
\DEFOPT{O}{\par
Overflow, requests that overflow bins be taken into account.
}
\DEFOPT{U}{\par
Underflow, requests that underflow bins be taken into account.
}
\DEFOPT{L}{\par
Left: include x-underflows
}
\DEFOPT{R}{\par
Right: include x-overflows
}
\DEFOPT{T}{\par
Top: include y-overflows
}
\DEFOPT{B}{\par
Bottom: include y-underflows
}
\DEFOPT{F1}{\par
Histogram 1 has no error (is a function)
}
\DEFOPT{F2}{\par
Histogram 2 has no error (is a function)
}
\ENDOPT

   \par
Test of compatibility for two 1-Dim histograms ID1 and ID2.  A probability 
   PROB is calculated as a number between zero and one, where PROB near one 
   indicates very similar histograms, and PROB near zero means that it is very 
   unlikely that the two arose from the same parent distribution.  For two 
   histograms sampled randomly from the same distribution, PROB will be 
   (approximately) uniformly distributed between 0 and 1.  See discussion in 
   HBOOK manual under \DQUOTE{}HDIFF- Statistical Considerations\DQUOTE{}.  By 
   default (if no options are selected with CHOPT) the comparison is done only 
   on the shape of the two histograms, without consideration of the difference 
   in numbers of events, and ignoring all underflow and overflow bins.  

\ENDCMD

\DEFCMD{HO}{SORT}{HISTOGRAM/OPERATIONS}{SORT}{ id [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{CHOPT}{C}{Options}{ D='XA'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{X}{\par
X-axis is being treated.
}
\DEFOPT{Y}{\par
Y-axis is being treated.
}
\DEFOPT{Z}{\par
Z-axis is being treated.
}
\DEFOPT{A}{\par
Alphabetically.
}
\DEFOPT{E}{\par
Reverse alphabetical order.
}
\DEFOPT{D}{\par
By increasing channel contents.
}
\DEFOPT{V}{\par
By decreasing channel contents.
}
\ENDOPT

   \par
Sort the alphanumeric labels of the histogram ID according to the value of 
   CHOPT.  

\ENDCMD

\DEFCMD{HO}{SMOOTH}{HISTOGRAM/OPERATIONS}{SMOOTH}{ id [ option sensit smooth ]}

\BEGARG
\DEFARG{ID}{C}{Histogram or Ntuple Identifier}{ Minus}
\DEFARG{OPTION}{C}{Options}{ D='2M'}
\DEFARG{SENSIT}{R}{Sensitivity parameter}{ D=1. R=0.3:3.}
\DEFARG{SMOOTH}{R}{Smoothness parameter}{ D=1. R=0.3:3.}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{0}{\par
Replace original histogram by smoothed.
}
\DEFOPT{1}{\par
Replace original histogram by smoothed.
}
\DEFOPT{2}{\par
Store values of smoothed function and its parameters without replacing the 
original histogram (but see note below) - the smoothed function can be 
displayed at editing time - see HISTOGRAM/PLOT.
}
\DEFOPT{M}{\par
Invoke multiquadric smoothing.
}
\DEFOPT{Q}{\par
Invoke the 353QH algorithm (see HBOOK routine HSMOOF).
}
\DEFOPT{S}{\par
Invoke spline smoothing.
}
\DEFOPT{V}{\par
Verbose (default for all except 1-D histogram).
}
\DEFOPT{N}{\par
Do not plot the result of the fit.
}
\DEFOPT{F}{\par
Write Fortran77 function to HQUADF.DAT (multiquadric only)
}
\ENDOPT

   \par
Smooth a histogram or \DQUOTE{}simple\DQUOTE{} ntuple.  
   (\DQUOTE{}simple\DQUOTE{} = 1, 2, or 3 variables.) 

   \par
For multiquadric smoothing, SENSIT controls the sensitivity to statistical 
   fluctuations.  SMOOTH controls the (radius of) curvature of the 
   multiquadric basis functions.  

   \par
Note: 1) The multiquadric basis functions are SQRT(R**2+D**2), where R is 
\begin{verbatim}
              the distance from the "centre", and D is a scale parameter and
              also the curvature at the "centre".  "Centres" are located at
              points where the 2nd differential or Laplacian of event density
              is statistically significant.
         2) The data must be statistically independent, i.e. events (weighted
              or unweighted) drawn randomly from a parent probability
              distribution or differential cross-section.
\end{verbatim}
\ENDVERB
   \par
For spline smoothing, SENSIT and SMOOTH control the no. of knots (= 10 * 
   SENSIT) and degree of splines (= SMOOTH + 2) (thus if SENSIT and SMOOTH are 
   at their default values a 10-knot cubic spline is used).  

   \par
Note: 1) The spline option ALWAYS replaces the contents of a 2-D histogram. 
\begin{verbatim}
              (Also chi-squared is unavailable in this case.)
         2) Use the SPLINE command for more flexibility.
\end{verbatim}

\ENDCMD

\DEFCMD{HO}{SPLINE}{HISTOGRAM/OPERATIONS}{SPLINE}{ id [ isel knotx kx ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{ISEL}{I}{Option flag}{ D=2}
\DEFARG{KNOTX}{I}{Number of knots}{ D=10}
\DEFARG{KX}{I}{Degree of the spline}{ D=3}
\ENDARG

   \par
Smooth 1-Dim or 2-Dim histogram ID using B-splines.  If ID is a 1-Dim 
   histogram then:  
\begin{verbatim}
    ISEL = 0,1 replace original histogram by smoothed.
         = 2   superimpose as a function when editing.
\end{verbatim}
   \par
If ID is a 2-Dim histogram then original contents are replaced.  

\ENDCMD

\DEFCMD{HO}{PARAM}{HISTOGRAM/OPERATIONS}{PARAM}{ id [ isel r2min maxpow ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{ISEL}{I}{Control word}{ D=11}
\DEFARG{R2MIN}{R}{Min correlation coefficient}{ D=1.}
\DEFARG{MAXPOW}{I}{Max degree of polynomials}{ D=5 R=1:20}
\ENDARG

   \par
Perform a regression on contents of the 1-Dim histogram ID.  Find the best 
   parameterization in terms of elementary functions (regressors). See HBOOK 
   guide HPARAM.  Control word ISEL=1000*T +100*W +10*S +P 
\begin{verbatim}
    S = 1 resulting parametric fit superimposed on histogram
        0 no superposition
    P = 0 minimal output: the residual sum of squares is printed
        1 normal output: in addition, the problem characteristics and
          options are printed; also the standard deviations and
          confidence intervals of the coefficients.
        2 extensive output: the results of each iteration are printed
          with the normal output.
    W = 0 weights on histogram contents are already defined via HBARX
          or HPAKE. If not they are taken to be equal to the
          square-root of the contents.
        1 weights are equal to 1.
    T = 0 monomials will be selected as the elementary functions
        1 Chebyshev polynomials with a definition region: [-1,1]
        2 Legendre polynomials with a definition region: [-1,1]
        3 shifted Chebyshev polynomials with a definition region: [0,1]
        4 Laguerre polynomials with a definition region: [0,+infinite]
        5 Hermite polynomials with a definition region: [-inf,+inf]
\end{verbatim}
   \par
The FORTRAN code of the parameterization is written onto the file 
   FPARAM.DAT.  

\ENDCMD

\DEFCMD{HO}{HSETPR}{HISTOGRAM/OPERATIONS}{HSETPR}{ param value}

\BEGARG
\DEFARG{PARAM}{C}{Parameter name}{ D='FEPS'}
\DEFARG{VALUE}{R}{Parameter value}{ D=0.001}
\ENDARG

   \par
Set various parameters for command PARAM.  

\ENDCMD
\DEFMENU{1}{GET\_VECT}{HISTOGRAM/GET\_VECT}

Fill a vector from values stored in HBOOK objects.  

\DEFCMD{HG}{CONTEN}{HISTOGRAM/GET\_VECT}{CONTENTS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get contents of histogram ID into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{ERRORS}{HISTOGRAM/GET\_VECT}{ERRORS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get errors of histogram ID into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{FUNCTI}{HISTOGRAM/GET\_VECT}{FUNCTION}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get function associated to histogram ID into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{ABSCIS}{HISTOGRAM/GET\_VECT}{ABSCISSA}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Get values of center of bins abscissa into vector VNAME.  

\ENDCMD

\DEFCMD{HG}{REBIN}{HISTOGRAM/GET\_VECT}{REBIN}{ id x y ex ey [ n ifirst ilast ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{X}{C}{Name of vector X}{}
\DEFARG{Y}{C}{Name of vector Y}{}
\DEFARG{EX}{C}{Name of vector EX}{}
\DEFARG{EY}{C}{Name of vector EY}{}
\DEFARG{N}{I}{Number of elements to fill}{ D=100}
\DEFARG{IFIRST}{I}{First bin}{ D=1}
\DEFARG{ILAST}{I}{Last bin}{ D=100}
\ENDARG

   \par
Get contents and errors into vectors, grouping bins.  Bin width and centers 
   are also extracted.  Allow to combine 2, 3 or more bins into one.  
\begin{verbatim}
      E.g.:  REBIN 110 X Y EX EY 25 11 85
              will group by 3 channels 11 to 85  and return
              new abscissa, contents and errors.
              Errors in X are equal to 1.5*BINWIDTH.
      N.B.:
             REBIN ID X Y EX EY  is a convenient way to return in
             one call abscissa, contents and errors for 1-Dim histogram.
             In this case the errors in X are equal to 0.5*BINWIDTH.
\end{verbatim}

\ENDCMD
\DEFMENU{1}{PUT\_VECT}{HISTOGRAM/PUT\_VECT}

Replace histogram contents with values in a vector.  

\DEFCMD{HP}{CONTEN}{HISTOGRAM/PUT\_VECT}{CONTENTS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Replace contents of histogram with values of vector VNAME.  

\ENDCMD

\DEFCMD{HP}{ERRORS}{HISTOGRAM/PUT\_VECT}{ERRORS}{ id vname}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{VNAME}{C}{Vector name}{}
\ENDARG

   \par
Replace errors of histogram with values of vector VNAME.  

\ENDCMD
\DEFMENU{1}{SET}{HISTOGRAM/SET}

Set histogram attributes.  

\DEFCMD{HS}{MAXIMU}{HISTOGRAM/SET}{MAXIMUM}{ id vmax}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{VMAX}{R}{Maximum value}{}
\ENDARG

   \par
Set the maximum value on the Y axis.  To select again an automatic scale, 
   just set VMAX less then the minimum.  

\ENDCMD

\DEFCMD{HS}{MINIMU}{HISTOGRAM/SET}{MINIMUM}{ id vmin}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{ Loop}
\DEFARG{VMIN}{R}{Minimum value}{}
\ENDARG

   \par
Set the minimum value on the Y axis.  To select again an automatic scale, 
   just set VMIN greater then the maximum.  

\ENDCMD

\DEFCMD{HS}{NORMAL}{HISTOGRAM/SET}{NORMALIZE\_FACTOR}{ id [ xnorm ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{XNORM}{R}{Normalization factor}{ D=1}
\ENDARG

   \par
Set the contents/errors normalization factor.  Only valid for histograms 
   (1-Dim).  (does not change contents, only presentation).  

\ENDCMD

\DEFCMD{HS}{SCALEF}{HISTOGRAM/SET}{SCALE\_FACTOR\_2D}{ id [ xscale ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{XSCALE}{R}{Scale factor}{ D=0}
\ENDARG

   \par
Set the scale factor for histograms (2-Dim).  

\ENDCMD

\DEFCMD{HS}{IDOPT}{HISTOGRAM/SET}{IDOPT}{ id option}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{OPTION}{C}{Options}{}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{SETD*}{\par
Set all options to the default values
}
\DEFOPT{SHOW}{\par
Print all the options currently set
}
\DEFOPT{BLAC}{\par
1 Dim histogram printed with X characters
}
\DEFOPT{CONT*}{\par
1 Dim histogram is printed with the contour option
}
\DEFOPT{STAR}{\par
1 Dim histogram is printed with a * at the Y value
}
\DEFOPT{SCAT*}{\par
Print a 2 Dim histogram as a scatter-plot
}
\DEFOPT{TABL}{\par
Print a 2 Dim histogram as a table
}
\DEFOPT{PROS*}{\par
Plot errors as the Spread of each bin in Y for profile histograms
}
\DEFOPT{PROE}{\par
Plot errors as the mean of each bin in Y for profile histograms
}
\DEFOPT{STAT}{\par
Mean value and RMS computed at filling time
}
\DEFOPT{NSTA*}{\par
Mean value and RMS computed from bin contents only
}
\DEFOPT{ERRO}{\par
Errors bars printed as SQRT(contents)
}
\DEFOPT{NERR*}{\par
Do not print print error bars
}
\DEFOPT{INTE}{\par
Print the values of integrated contents bin by bin
}
\DEFOPT{NINT*}{\par
Do not print integrated contents
}
\DEFOPT{LOGY}{\par
1 Dim histogram is printed in Log scale in Y
}
\DEFOPT{LINY*}{\par
1 Dim histogram is printed in linear scale in Y
}
\DEFOPT{PCHA*}{\par
Print channel numbers
}
\DEFOPT{NPCH}{\par
Do not print channel numbers
}
\DEFOPT{PCON*}{\par
Print bin contents
}
\DEFOPT{NPCO}{\par
Do not print bin contents
}
\DEFOPT{PLOW*}{\par
Print values of low edge of the bins
}
\DEFOPT{NPLO}{\par
Do not print the low edge
}
\DEFOPT{PERR}{\par
Print the values of the errors for each bin
}
\DEFOPT{NPER*}{\par
Do not print the values of the errors
}
\DEFOPT{PFUN}{\par
Print the values of the associated function bin by bin
}
\DEFOPT{NPFU*}{\par
Do not print the values of the associated function
}
\DEFOPT{PHIS*}{\par
Print the histogram profile
}
\DEFOPT{NPHI}{\par
Do not print the histogram profile
}
\DEFOPT{PSTA*}{\par
Print the values of statistics (entries,mean,RMS,etc.)
}
\DEFOPT{NPST}{\par
Do not print values of statistics
}
\DEFOPT{ROTA}{\par
Print histogram rotated by 90 degrees
}
\DEFOPT{NROT*}{\par
Print histogram vertically
}
\DEFOPT{1EVL}{\par
Force an integer value for the steps in the Y axis
}
\DEFOPT{AEVL*}{\par
Steps for the Y axis are automatically computed
}
\DEFOPT{2PAG}{\par
Histogram is printed over two pages
}
\DEFOPT{1PAG*}{\par
Histogram is printed in one single page
}
\DEFOPT{AUTO*}{\par
Automatic scaling
}
\ENDOPT

   \par
Set options for histogram ID. (* means default).  

\ENDCMD
\DEFMENU{0}{FUNCTION}{FUNCTION}

Operations with Functions. Creation and plotting.  

\DEFCMD{F}{FUN1}{FUNCTION}{FUN1}{ id ufunc ncx xmin xmax [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{UFUNC}{C}{Name of the function}{}
\DEFARG{NCX}{I}{Number of channels}{ D=100 R=1:}
\DEFARG{XMIN}{R}{Low edge}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge}{ D=100.}
\DEFARG{CHOPT}{C}{Options}{ D='P'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{P}{\par
The function is drawn.
}
\ENDOPT

   \par
Create a one dimensional histogram and fill the bins with the values of a 
   (single-valued) function.  The function UFUNC may be given in two ways:  

   \par
-An expression of the variable x in case of a simple function.  
\begin{verbatim}
    Ex: FUN1  10 sin(x)/x  100 0 10
\end{verbatim}
   \par
-UFUNC is the name of a COMIS function in a text file with the name 
   UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).  

\ENDCMD

\DEFCMD{F}{FUN2}{FUNCTION}{FUN2}{ id ufunc ncx xmin xmax ncy ymin ymax [ chopt ]}

\BEGARG
\DEFARG{ID}{C}{Histogram (2-Dim) Identifier}{}
\DEFARG{UFUNC}{C}{Name of the function}{}
\DEFARG{NCX}{I}{Number of channels in X}{ D=40 R=1:}
\DEFARG{XMIN}{R}{Low edge in X}{ D=0.}
\DEFARG{XMAX}{R}{Upper edge in X}{ D=40.}
\DEFARG{NCY}{I}{Number of channels in Y}{ D=40 R=1:}
\DEFARG{YMIN}{R}{Low edge in Y}{ D=0.}
\DEFARG{YMAX}{R}{Upper edge in Y}{ D=40.}
\DEFARG{CHOPT}{C}{Options}{ D='S'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Create the histogram.
}
\DEFOPT{S}{\par
The function is drawn as a surface.
}
\DEFOPT{L}{\par
The function is drawn as a lego plot.
}
\DEFOPT{C}{\par
The function is drawn as a contour plot.
}
\ENDOPT

   \par
Create a two dimensional histogram and fill the bins with the values of a 
   (two-valued) function.  The function UFUNC may be given in two ways:  

   \par
-An expression of the variables x and y in case of a simple function.  
\begin{verbatim}
    Ex: FUN2  10 abs(sin(x**2+y**2)) 40 -2 2 40 -2 2 C
\end{verbatim}
   \par
-UFUNC is the name of a COMIS function in a text file with the name 
   UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).  

\ENDCMD

\DEFCMD{F}{DRAW}{FUNCTION}{DRAW}{ ufunc [ chopt ]}

\BEGARG
\DEFARG{UFUNC}{C}{Name of function}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Draw the function UFUNC in the current ranges specified by the command:  
   RANGE XLOW XUP YLOW YUP ZLOW ZUP and with THETHA and PHI angles specified 
   by the command ANGLE THETA PHI. The number of points to evaluate the 
   function between XLOW, XUP YLOW, YUP, and ZLOW, ZUP can be changed by the 
   command POINTS NPX NPY NPZ.  

   \par
The function UFUNC may be given in two ways:  - As an expression of the 
   variables X, Y, Z in the case of a 
\begin{verbatim}
     simple function.
     Ex:
     PAW >  FUN/DRAW X*Y*Z         | equivalent to :
     PAW >  FUN/DRAW X*Y*Z=0
     PAW >  FUN/DRAW X**2+Y**2+Z**2=1
     PAW >  FUN/DRAW X**2+Y**2=1-Z**2
\end{verbatim}
   \par
- As a COMIS function in a text file with the name UFUNC.FTN or 
\begin{verbatim}
     UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).
     Ex:
     The file FTEST.FOR contains:
\end{verbatim}
\begin{verbatim}
     FUNCTION FTEST(X,Y,Z)
     IF(X.LE.0..AND.Y.LE.0.)THEN
       FTEST=(X+0.5)**2+(Y+0.5)**2+(Z+0.5)**2-0.2
     ELSE
       FTEST=(X-0.5)**2+(Y-0.5)**2+(Z-0.5)**2-0.1
     ENDIF
     END
\end{verbatim}
\begin{verbatim}
     PAW > RANGE -1 1 -1 1 -1 1  | Define the range as a cube between -1 1 in 
   the 3
                                   directions
     PAW > POINTS 20 20 20       | FUN/DRAW will use 20 points in the 3 
   directions
     PAW > FUN/DRAW FTEST.FOR    | Draw 2 spheres centered on (-0.5,-0.5,-0.5)
                                   and (0.5,0.5,0.5) with the radius SQRT(0.2)
                                   and SQRT(0.1)
\end{verbatim}

\ENDCMD

\DEFCMD{F}{PLOT}{FUNCTION}{PLOT}{ ufunc xlow xup [ chopt ]}

\BEGARG
\DEFARG{UFUNC}{C}{Name of function}{}
\DEFARG{XLOW}{R}{Lower limit}{}
\DEFARG{XUP}{R}{Upper limit}{}
\DEFARG{CHOPT}{C}{Options}{ D='C'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of ID to last plotted histogram.
}
\DEFOPT{L}{\par
Connect channel contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\ENDOPT

   \par
Plot single-valued function UFUNC between XLOW and XUP.  The function UFUNC 
   may be given in two ways:  

   \par
-An expression of the variable x in case of a simple function.  
\begin{verbatim}
    Ex: FUN/PLOT   sin(x)/x  0 10
\end{verbatim}
   \par
-UFUNC is the name of a COMIS function in a text file with the name 
   UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).  For example, 
   if the file FTEST.FOR contains:  
\begin{verbatim}
         FUNCTION FTEST(X)
         FTEST=SIN(X)*EXP(-0.1*X)
         END
\end{verbatim}
   \par
Then, FUN/PLOT FTEST.FOR 0 10, will interpret the Fortran code in the file 
   FTEST.FOR and draw the function for x between 0 and 10.  

   \par
The number of points to evaluate the function between XLOW and XUP can be 
   changed by the command /FUN/POINTS. Only 1-Dim functions are supported. For 
   2-Dim use FUN2.  

\ENDCMD

\DEFCMD{F}{POINTS}{FUNCTION}{POINTS}{ [ npx npy npz ]}

\BEGARG
\DEFARG{NPX}{I}{Number of points on X axis}{ D=20 R=2:1000}
\DEFARG{NPY}{I}{Number of points on Y axis}{ D=20 R=2:1000}
\DEFARG{NPZ}{I}{Number of points on Z axis}{ D=20 R=2:1000}
\ENDARG

   \par
Change the number of points to be used by FUN/DRAW and FUN/PLOT. Note that 
   the default for NPX is 20 for 3-Dim plots (FUN/DRAW) but it is 100 for 
   1-Dim plots (FUN/PLOT).  

\ENDCMD

\DEFCMD{F}{RANGE}{FUNCTION}{RANGE}{ [ xlow xup ylow yup zlow zup ]}

\BEGARG
\DEFARG{XLOW}{R}{X Lower limit}{ D=-1.}
\DEFARG{XUP}{R}{X Upper limit}{ D=1.}
\DEFARG{YLOW}{R}{Y Lower limit}{ D=-1.}
\DEFARG{YUP}{R}{Y Upper limit}{ D=1}
\DEFARG{ZLOW}{R}{Z Lower limit}{ D=-1.}
\DEFARG{ZUP}{R}{Z Upper limit}{ D=1.}
\ENDARG

   \par
Change the range used by FUN/DRAW.  

\ENDCMD

\DEFCMD{F}{ANGLE}{FUNCTION}{ANGLE}{ [ theta phi ]}

\BEGARG
\DEFARG{THETA}{R}{Angle THETA in degrees}{ D=30.}
\DEFARG{PHI}{R}{Angle PHI in degrees}{ D=30.}
\ENDARG

   \par
Change the angle used by FUN/DRAW and HISTO/PLOT.  

\ENDCMD
\DEFMENU{0}{NTUPLE}{NTUPLE}

Ntuple creation and related operations.  

\DEFCMD{N}{CREATE}{NTUPLE}{CREATE}{ idn title nvar chrzpa nprime varlist}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{TITLE}{C}{Ntuple title}{ D=\EMPTY{}}
\DEFARG{NVAR}{I}{Number of variables}{ D=1 R=1:512}
\DEFARG{CHRZPA}{C}{RZ path}{ D=\EMPTY{}}
\DEFARG{NPRIME}{I}{Primary allocation}{ D=1000}
\DEFARG{VARLIST}{C}{Names of the NVAR variables}{ Vararg}
\ENDARG

   \par
Create a Row\_Wise\_Ntuple. (See below how to create a 
   Column\_Wise\_Ntuple).  The Ntuple may be created either purely in memory 
   or possibly using an automatic overflow to an RZ file.  Memory allocation 
   works in the following way.  If CHRZPA = '  ', then a bank of NPRIME words 
   is created. When the space in this bank is exhausted at filling time, a new 
   linear structure of length NPRIME is created and this process will be 
   repeated should the structure become exhausted.  If CHRZPA contains the top 
   directory name of an already existing RZ file (as declared with 
   HISTO/FILE), then a bank of length NPRIME is also created, but at filling 
   time, this bank is moved to the RZ file when full, and then it is 
   overwritten by any new entries.  The Ntuple can be filled by calling HFN 
   from an interactively defined subroutine called by the command NTUPLE/LOOP 
   or by NTUPLE/READ.  The number of variables per data point is given in the 
   parameter NVAR.  

   \par
To create a Column\_Wise\_Ntuple, create a file, eg. newnt.f  with:  
\begin{verbatim}
         Subroutine Newnt
         character*8 mother,in1,in2
         common/ntupc/mother,in1,in2
         common/ntupr/xover
         lin=41
         lout=42
         id=1
         open(unit=lin,file='datafile.dat',status='old')
         call hropen(lout,'NTUPLE','New_Ntuple.hbook','N',1024,istat)
         call hbnt(id,'New Ntuple',' ')
         call hbname(id,'ntupr',xover,'XOVER')
         call hbnamc(id,'ntupc',mother,'MOTHER:c*8,in1:c*8,in2:c*8')
     10  read(lin,1000,end=20,err=20)xover,mother,in1,in2
\end{verbatim}
   \par
1000  format(e15.7,2x,a,7x,a,7x,a) 
\begin{verbatim}
         call hfnt(1)
         go to 10
     20  call hrout(id,icycle,' ')
         call hrend('NTUPLE')
         close (lin)
         close (lout)
         end
\end{verbatim}
   \par
and then call this routine via the CALL command:  
\begin{verbatim}
      PAW > call newnt.f
\end{verbatim}

\ENDCMD

\DEFCMD{N}{LIST}{NTUPLE}{LIST}{}

   \par
List all Ntuples in the Current Directory.  Note that the command 
   HISTO/LIST lists all histograms and Ntuples in the Current Directory.  

\ENDCMD

\DEFCMD{N}{PRINT}{NTUPLE}{PRINT}{ idn}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\ENDARG

   \par
Print a summary about Ntuple IDN.  Number of entries, variables names and 
   limits are listed.  

\ENDCMD

\DEFCMD{N}{RECOVE}{NTUPLE}{RECOVER}{ idn}

\BEGARG
\DEFARG{IDN}{I}{Ntuple Identifier}{}
\ENDARG

   \par
To recover Ntuple ID. If the job producing the Ntuple crashed or the header 
   was not stored correctly in the file with HROUT, RECOVER will scan the 
   Ntuple to rebuild the header table and recompute the number of entries. The 
   file on which the Ntuple resides must be open in Update mode.  

\ENDCMD

\DEFCMD{N}{SCAN}{NTUPLE}{SCAN}{ idn [ uwfunc nevent ifirst nvars varlis ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{UWFUNC}{C}{User cut function}{ D='0'}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\DEFARG{NVARS}{I}{Number of variables to scan}{ D=8}
\DEFARG{VARLIS}{C}{Names of the NVARS variables to scan}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Scan the entries of an Ntuple subject to user cuts.  Scan the variables for 
   NEVENT events starting at IFIRST, requiring that the events satisfy cut 
   UWFUNC. Up to 8 variables may be scanned, the default is to scan the first 
   8 variables.  VARLIS may contain a list of the original variables or/and 
   expressions of the original variables.  For example, if IDN=30 has the 3 
   variables X,Y,Z, one can do:  
\begin{verbatim}
    PAW > scan 30
    PAW > scan 30 z>10
    PAW > scan 30 z>10 ! ! 5 z abs(x) y+z x func.for
          where func.for is a COMIS function returning an expression
          of the original variables. This function func.for may be
          generated automatically by the PAW command:
    PAW > uwfunc 30 func.for
\end{verbatim}

\ENDCMD

\DEFCMD{N}{LOOP}{NTUPLE}{LOOP}{ idn uwfunc [ nevent ifirst ]}

\BEGARG
\DEFARG{IDN}{C}{Identifier of Ntuple}{}
\DEFARG{UWFUNC}{C}{Selection function or cut identifier}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\ENDARG

   \par
Invoke the selection function UWFUNC for each event starting at event 
   IFIRST.  In UWFUNC, the user can fill one or several histograms previously 
   booked.  The loop will be terminated if UWFUNC returns a negative value.  
   For more information about UWFUNC, see command NTUPLE/PLOT.  

\ENDCMD

\DEFCMD{N}{MERGE}{NTUPLE}{MERGE}{ idn1 idn2 [ uwfunc nevent ifirst ]}

\BEGARG
\DEFARG{IDN1}{C}{Identifier of first Ntuple}{}
\DEFARG{IDN2}{C}{Identifier of second Ntuple}{}
\DEFARG{UWFUNC}{C}{Selection function or cut identifier}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\ENDARG

   \par
Merge two Ntuples.  Invoke the selection function UWFUNC for each of the 
   NEVENT events starting at event IFIRST of Ntuple IDN1.  Suppose you have 4 
   files containing Ntuple ID=10 and you want to merge the 4 files into the 
   file 4, the sequence is:  
\begin{verbatim}
    PAW >Histo/file 1 file1
    PAW >Histo/file 2 file2
    PAW >Histo/file 3 file3
    PAW >Histo/file 4 file4 1024 U
    PAW >Ntuple/Merge //lun1/10 //lun4/10
    PAW >Ntuple/Merge //lun2/10 //lun4/10
    PAW >Ntuple/Merge //lun3/10 //lun4/10
    PAW >Ntuple/plot 10.x .........
\end{verbatim}
   \par
Only the events with UWFUNC\KET{}0 are appended to IDN2. IDN2 may be empty. 
   Note that the Ntuple variables may be redefined inside UWFUNC.  For more 
   information about UWFUNC, see command NTUPLE/PLOT.  

\ENDCMD

\DEFCMD{N}{PROJEC}{NTUPLE}{PROJECT}{ idh idn [ uwfunc nevent ifirst ]}

\BEGARG
\DEFARG{IDH}{C}{Identifier of histogram to fill}{}
\DEFARG{IDN}{C}{Identifier of Ntuple}{}
\DEFARG{UWFUNC}{C}{Selection function or cut identifier}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\ENDARG

   \par
Project an Ntuple onto a 1-Dim or 2-Dim histogram, possibly using a 
   selection function or predefined cuts.  IDN may be given as IDN or IDN.X , 
   IDN.Y\%X , IDN.1, IDN.2\%1.  Y\%X means variable Y of Ntuple IDN versus 
   variable X.  For more information about UWFUNC, see command NTUPLE/PLOT.  
   The histogram IDH is not reset before filling. This allows several PROJECTs 
   from different Ntuples.  

\ENDCMD

\DEFCMD{N}{READ}{NTUPLE}{READ}{ idn fname [ format chopt nevent ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{FORMAT}{C}{Format}{ D='*'}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=1000000}
\ENDARG

   \par
Read Ntuple values from the alphanumeric file FNAME with the format 
   specifications in FORMAT.  Before executing this command, the Ntuple IDN 
   must have been created with the command Ntuple/Create.  

\ENDCMD

\DEFCBIG{N}{PLOT}{NTUPLE}{PLOT}{ idn [ uwfunc nevent ifirst nupd option idh ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{UWFUNC}{C}{Selection function}{ D='0'}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\DEFARG{NUPD}{I}{Frequency to update histogram}{ D=100000000}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\DEFARG{IDH}{I}{Identifier of histogram to fill}{ D=1000000}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{\EMPTY}{}
\DEFOPT{C}{\par
Draw a smooth curve.
}
\DEFOPT{S}{\par
Superimpose plot on top of existing picture.
}
\DEFOPT{+}{\par
Add contents of IDN to last plotted ntuple.
}
\DEFOPT{B}{\par
Bar chart format.
}
\DEFOPT{L}{\par
Connect channels contents by a line.
}
\DEFOPT{P}{\par
Draw the current polymarker at each channel or cell.
}
\DEFOPT{*}{\par
Draw a * at each channel.
}
\DEFOPT{U}{\par
Update channels modified since last call.
}
\DEFOPT{E}{\par
Compute (HBARX) and draw error bars with current marker.
}
\DEFOPT{A}{\par
Axis labels and tick marks are not drawn.
}
\DEFOPT{\EMPTY}{\par
Draw the ntuple as an histogram.
}
\DEFOPT{PROF}{\par
Fill a Profile histogram (mean option).
}
\DEFOPT{PROFS}{\par
Fill a Profile histogram (spread option).
}
\ENDOPT

   \par
Project and plot an Ntuple as a (1-Dim or 2-Dim) histogram with automatic 
   binning (ID=1000000), possibly using a selection algorithm. See parameter 
   CHOPT in command HISTO/PLOT to have more details on the possible OPTION.  
\begin{verbatim}
    IDN may be given as IDN
                        IDN.X
                        IDN.Y%X
                        IDN.1
                        IDN.2%1
                        IDN.expression1
                        IDN.expression1%expression2
\end{verbatim}
   \par
Y\%X means a scatter-plot Y(I) versus X(I) where I is the event number.  
   2\%1 means a scatter-plot variable 2 versus variable 1.  In this example, X 
   and Y are the names of the variables 1 and 2 respectively.  Expression 1 is 
   any numerical expression of the Ntuple variables.  It may include a call to 
   a COMIS function.  
\begin{verbatim}
    UWFUNC may have the following forms:
    1- UWFUNC='0' or missing (only IDN given). No selection is applied.
    2- UWFUNC is a CUT or combination of valid CUTS created by the
       command NTUPLE/CUTS. Ex:
              UWFUNC=$1            means use cut $1
              UWFUNC=$1.AND.$2
              UWFUNC=.NOT.($1.AND.$2)
              UWFUNC=($1.OR.$2).AND.$3
    3- UWFUNC is a FORTRAN expression
       Ex:    X>3.14.AND.(Y<Z+3.15)
    4- UWFUNC is a variable name or an arithmetic expression
       Ex:   NT/PLOT 30.X Y  weight of each event is variable Y
             NT/PLOT 30.X X**2+Y**2
    5- UWFUNC is the name of a selection function in a text file with
       the name UWFUNC.FTN, UWFUNC.FOR, UWFUNC FORTRAN (Apollo, VAX, IBM).
\end{verbatim}
   \par
The command UWFUNC may be used to generate automatically this function.  
   For example if IDN=30 is an Ntuple with 3 variables per event and 10000 
   events, then 
\begin{verbatim}
       NTUPLE/PLOT 30.X SELECT.FOR
\end{verbatim}
   \par
will process the 10000 events of the Ntuple IDN=30. For each event, the 
   function SELECT is called. It returns the weight of the event.  Example:  
\begin{verbatim}
       FUNCTION SELECT(X)
       DIMENSION X(3)
       IF(X(1)**1+X(2)**2.LT.1.5)THEN
          SELECT=0.
       ELSE
          SELECT=1.
       ENDIF
       END
\end{verbatim}
   \par
The file SELECT.FOR (VAX), SELECT.FTN (Apollo) or SELECT FORTRAN (IBM) can 
   be edited from PAW using the command EDIT. Note that if the suffix (.FTN, 
   .FORTRAN or .FOR) is omitted, then COMIS will start from the precompiled 
   version in memory and not from the file. Results of a selection can be 
   saved in a MASK (See NTUPLE/MASK).  
\begin{verbatim}
    Ex: NT/PLOT 30.X Z<0.4>>MNAME(4)
        means mark bit 4 in mask MNAME for all events satisfying
        the condition Z<0.4
\end{verbatim}
   \par
A MASK may also be given as input to a selection expression.  
\begin{verbatim}
    Ex:  NT/PLOT 30.X MNAME(4).and.Z<0.4
         means all events satisfying bit 4 of MNAME AND Z<0.4
\end{verbatim}
   \par
It is possible to plot expressions of the original variables.  
\begin{verbatim}
    Ex 1:  NT/PLOT 30.SIN(X)%SQRT(Y**2+Z**2)  Z<0.4
        plots a scatter-plot of variable U versus V for all events
        satisfying the condition Z<0.4. U and V are defined as being
        U=SIN(X) and V=SQRT(X**2+Y**2)
    Ex 2:  NT/PLOT 30.FUNC.FTN(X)%(SIN(Y)+3.)  Z<0.2.and.TEST.FTN>6
        plots a scatter-plot of variable U versus V for all events
        satisfying the condition (Z<0.2 and the result of the COMIS
        function TEST.FTN >6). U and V are defined as being
        U=Result of the COMIS function FUNC.FTN,  V=SIN(Y)+3.
\end{verbatim}
   \par
The default identifier of the histogram being filled is IDH=1000000.  At 
   the next invocation of this command, it will be overwritten.  If either 
   NEVENT or IFIRST or NUPD are negative, then the identifier of the histogram 
   being filled will be taken as IDH=-NEVENT or IDH=-IFIRST or IDH=-NUPD. IDH 
   may have been created with H/CREATE.  Before filling IDH, the contents of 
   IDH are reset if IDH already exists. Use NTUPLE/PROJECT to cumulate several 
   passes into IDH.  Note that IDH not equal to 1000000 is a convenient way to 
   force user binning.  Every NUPD events, the current status of the  
   histogram is displayed.  

\ENDCBIG

\DEFCMD{N}{CHAIN}{NTUPLE}{CHAIN}{ [ cname entry ]}

\BEGARG
\DEFARG{CNAME}{C}{Chain Name}{ D=\EMPTY{}}
\DEFARG{ENTRY}{C}{Chain Member(s) \PIPE{} -P Path}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Using the chain command one can build logical Ntuples of unlimited size.  
   The chain command creates an Ntuple chain CNAME and add member(s) ENTRY.  
   If the chain already exists the member is simply added.  More than one 
   member may be specified at a time.  A chain can contain three different 
   type of members: files, logical units and other chains. The member type is 
   deduced from the format of the member. Entries containing the characters . 
   / : ; \$ are considered to be files, entries like //LUN4 are assumed to be 
   logical units and all other type of entries are chains. Chain names must be 
   unique.  After a chain has been defined it can be traversed, by all Ntuple 
   commands (NT/PLOT, NT/PROJ, NT/LOOP), by changing the current working 
   directory to the chain: CD //CNAME.  A member may be deleted from a chain 
   by preceding it by a - sign. A complete chain can be deleted by preceding 
   the chain name by a -. All chains can be deleted by giving a - as chain 
   name. Not specifying any parameters results in the listing of all defined 
   chains. A chain tree will be printed by appending a \KET{} character to the 
   chain name.  The path of all chain members, from chain CNAME downwards, can 
   be changed by specifying a chain path. This is done by giving a chain name 
   followed by the -P option and a path specification. The chain path will be 
   pre-pended to the member names. Chains down the tree can override a path 
   specified higher up in the tree.  
\begin{verbatim}
    Examples of chain (Ntuple tree) definition:
    CHAIN   Year93  Jan Feb March April May ...
    CHAIN   Jan     Week1 Week2 Week3 Week4
    CHAIN   Week1   file1.hbook file2.hbook ...
    CHAIN   Week2   file3.hbook file4.hbook ...
    CD //Jan
    NT/PLOT 10.e     ; loop over all files in chains Week1, Week2, Week3, ...
    CD //Year93      ; loop over all files in chains Jan, Feb, March, ...
    CHAIN Year93 -P /user/delphi   ; all files from chain Year93 downward will
                                     be changed to /user/delphi/file1.hbook, 
   ...
    CHAIN Year93>    ; print the chain tree Year93
    CHAIN -Feb       ; delete chain Feb
    CHAIN Jan -file3.hbook   ; delete file3.hbook from chain Jan
\end{verbatim}

\ENDCMD

\DEFCMD{N}{DRAW}{NTUPLE}{DRAW}{ idn [ value option ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{VALUE}{C}{Isosurface value (for 3-D)}{ D='0'}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Draw a simple ntuple (1, 2 or 3 variables).  For simple ntuples, with 1, 2 
   or 3 variables per event, this command will draw a histogram with HPLOT 
   options.  If the ntuple has an associated functional representation, as the 
   result, e.g., of using SMOOTH, it will also draw the function.  No 
   selections are allowed.  

   \par
For 3-variable ntuples which have been SMOOTHed, give a VALUE for the 
   isosurface of event density.  If VALUE=0, an isosurface value half way 
   between the minimum and maximum fitted smoothing function values will be 
   used.  

\ENDCMD

\DEFCMD{N}{WAVE}{NTUPLE}{WAVE}{ idn [ lun ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{LUN}{I}{Logical unit no.}{ D=-1}
\ENDARG

   \par
Produce a formatted file suitable for Wavefront's Data Visualiser.  Only 
   for simple 3-variable ntuples which have been SMOOTHed.  A file with 
   logical unit no. LUN must previously have been opened with the FORTRAN/FILE 
   command.  

\ENDCMD

\DEFCMD{N}{CUTS}{NTUPLE}{CUTS}{ cutid [ option fname ]}

\BEGARG
\DEFARG{CUTID}{C}{Cut identifier}{}
\DEFARG{OPTION}{C}{Options}{ D='P' Minus}
\DEFARG{FNAME}{C}{File name}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{G}{\par
Define a new cut CUTID using graphics input on the latest 1-Dim or 2-Dim 
projection of the Ntuple. For a 1-Dim projection, give 2 points cutmin,cutmax. 
For a 2-Dim projection, give up to 20 points to delimit the selected area. The 
polygon will automatically be closed by PAW.
}
\DEFOPT{P}{\par
Print definition of cut CUTID.
}
\DEFOPT{-}{\par
Reset cut CUTID.
}
\DEFOPT{R}{\par
Read definition of cut CUTID from file FNAME.
}
\DEFOPT{W}{\par
Write definition of cut CUTID on file FNAME (text file).
}
\DEFOPT{D}{\par
Draw cut contour.
}
\ENDOPT

   \par
Define the CUTID with the format \$nn.  nn is an integer between 1 and 99.  
   This cut can then be used in subsequent commands NTUPLE/PLOT, PROJECT.  
\begin{verbatim}
     OPTION='expression'  allows to define the cut CUTID. For example
     the command:
      PAW > CUTS $1 X<0.8.and.Y<SQRT(X)
     defines the cut $1.
\end{verbatim}
   \par
Note that CUTID=\$0 means all cuts except for 'G' option.  When option G is 
   selected, graphical cuts are only operational for plots of the original 
   Ntuple variables, not for expressions of these variables.  

\ENDCMD

\DEFCMD{N}{CSELEC}{NTUPLE}{CSELECT}{ [ chopt csize ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D='N'}
\DEFARG{CSIZE}{R}{Comment size}{ D=0.28}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Comment is left adjusted to the current zone
}
\DEFOPT{R}{\par
Comment is right adjusted to the current zone
}
\DEFOPT{C}{\par
Comment is centered to the current zone
}
\DEFOPT{B}{\par
Comment is drawn below the top zone line
}
\DEFOPT{N}{\par
All subsequent NTUPLE/PLOT commands will print the selection mechanism with 
the options specified in CHOPT.
}
\ENDOPT

   \par
To write selection mechanism as a comment on the picture.  By default, the 
   comment is drawn left justified above the top zone line.  Example:  
\begin{verbatim}
    CSEL          All coming NT/PLOT commands will draw a comment
                  of size CSIZE=0.28cm Left justified.
    CSEL NRB 0.4  All coming NT/PLOT commands will draw a comment
                  of size 0.4 cm Right justified Below the top line.
    CSEL  CB      Draw previous selection mechanism Centered Below
                  the top zone line.
\end{verbatim}
   \par
The Global title font (SET GFON) with precision 1 is used to draw the text. 

\ENDCMD

\DEFCMD{N}{MASK}{NTUPLE}{MASK}{ mname [ chopt number ]}

\BEGARG
\DEFARG{MNAME}{C}{Mask name}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NUMBER}{I}{Bit number}{ D=0}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Existing mask on file MNAME.MASK is attached for READ only.
}
\DEFOPT{U}{\par
Existing mask on file MNAME.MASK is attached for UPDATE.
}
\DEFOPT{N}{\par
A new mask on file MNAME.MASK is created for NUMBER events.
}
\DEFOPT{P}{\par
The comments for all active bits is printed.
}
\DEFOPT{C}{\par
Mask is closed.
}
\DEFOPT{R}{\par
Reset bit number NUMBER.If NUMBER=99, resets all bits.
}
\ENDOPT

   \par
Perform Operations with masks.  A mask is a direct-access file with the 
   name MNAME.MASK.  It must contain as many 32 bit words as there are events 
   in the associated Ntuple.  Masks are interesting when only a few events of 
   a Ntuple are selected with a time consuming selection algorithm. For 
   example if the command:  
\begin{verbatim}
      NT/PLOT 30.X  Z<0.4.AND.SELECT.FTN>>MNAME(6)
\end{verbatim}
   \par
then for all events in Ntuple 30 satisfying the condition above, the bit 6 
   in the corresponding mask words will be set. One can then use the mask as 
   selection mechanism. Example:  
\begin{verbatim}
      NT/PLOT 30.X MNAME(6)
\end{verbatim}
   \par
will produce the same results than the NT/PLOT command above, but will be 
   much faster if only a small fraction of all the events is selected.  MASKS 
   are automatically saved across PAW sessions on files.  Example:  
\begin{verbatim}
      MASK  TEST N 10000
         creates a new mask on file TEST.MASK with enough words to
         process a Ntuple with 10000 events
      MASK  TEST UP
         opens an existing mask for update and
         prints the active selection bits with explanation
\end{verbatim}

\ENDCMD

\DEFCMD{N}{UWFUNC}{NTUPLE}{UWFUNC}{ idn fname [ chopt ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Generate the FORTRAN skeleton of a selection function.
}
\DEFOPT{E}{\par
Present the selection function in the local editor.
}
\DEFOPT{P}{\par
Code to print events is generated (not valid for new Ntuples).
}
\DEFOPT{T}{\par
Names of the Ntuple variables are generated in DATA statements (not valid for 
new Ntuples).
}
\ENDOPT

   \par
To generate the FORTRAN skeleton of a selection function.  Example:  If 
   Ntuple ID=30 has variable names [X,Y,Z,ETOT,EMISS,etc] then:  

   \par
NTUPLE/UWFUNC 30 SELECT.FOR   will generate the file SELECT.FOR with:  
\begin{verbatim}
         FUNCTION SELECT(XDUMMY)
         COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc
         SELECT=1.
         END
\end{verbatim}
   \par
Then using the command EDIT one can modify this file which could then look 
   something like (IDNEVT is the event number):  
\begin{verbatim}
         FUNCTION SELECT(XDUMMY)
         COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc
         IF(X**2+Y**2.GT.Z**2.OR.ETOT.GT.20.)THEN
            SELECT=1.
         ELSE
            SELECT=0.
         ENDIF
         END
\end{verbatim}
   \par
If in a subsequent command NTUPLE/PLOT, the selection function SELECT is 
   used, then:  
\begin{verbatim}
      If NTUPLE/PLOT 30.ETOT SELECT.FOR
         VIDN1=ETOT
      If NTUPLE/PLOT 30.SQRT(X**2+Y**2)%(ETOT-EMISS)
         VIDN1=ETOT-EMISS
         VIDN2=SQRT(X**2+Y**2)
\end{verbatim}

\ENDCMD

\DEFCMD{N}{LINTRA}{NTUPLE}{LINTRA}{ idn [ chopt nevent ifirst nvars varlis ]}

\BEGARG
\DEFARG{IDN}{C}{Ntuple Identifier}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{NEVENT}{I}{Number of events}{ D=99999999}
\DEFARG{IFIRST}{I}{First event}{ D=1}
\DEFARG{NVARS}{I}{Number of the most significant variables }{ D=20 R=0:20}
\DEFARG{VARLIS}{C}{Names of the NVARS most significant variables }{}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{N}{\par
The variables are normalized. This option is useful in the case the ranges of 
variables are very different
}
\DEFOPT{P}{\par
Print more results about the analysis
}
\ENDOPT

   \par
Data reduction on Ntuple.  The method used is the PRINCIPAL COMPONENTS 
   ANALYSIS.  The Principal Components Analysis method consists in applying a 
   linear transformation to the original variables of a ntuple.  This 
   transformation is described by an orthogonal matrix and is equivalent to a 
   rotation of the original space to a new set of coordinates vectors, which 
   hopefully provide easier identification and dimensionality reduction. This 
   matrix is real positive definite and symmetric and has all its eigenvalues 
   greater than zero.  Among the family of all complete orthonormal bases, the 
   basis formed by the eigenvectors of the covariance matrix and belonging to 
   the largest eigenvalues corresponds to the most significant features for 
   the description of the original ntuple.  Reduction of the variables for 
   NEVENT events starting at IFIRST The default is to take all the 20 first 
   variables.  This command creates a file : -\KET{} XTOXSI.FORTRAN or 
   xtoxsi.for,xtoxsi.ftn.  This file contains a Fortran function which 
   computes the new variables.  These new variables can be visualized in PAW 
   with for example:  
\begin{verbatim}
    PAW > Ntuple/plot id.xtoxsi.ftn(1)
    PAW > Ntuple/plot id.xtoxsi.ftn(1)%xtoxsi.ftn(3)
\end{verbatim}

\ENDCMD

\DEFCMD{N}{VMEM}{NTUPLE}{VMEM}{ [ mxsize ]}

\BEGARG
\DEFARG{MXSIZE}{I}{Maximum size of dynamic memory buffer in MBytes}{ D=-1 R=-2:128}
\ENDARG

   \par
Change or show the size of the dynamic memory buffer used to store Ntuple 
   columns during Ntuple analysis. The default is 10 MB. Giving a value of 0 
   turns the buffer facility off. The upper limit is 128 MB, but be sure you 
   have enough swap space and realize that when the buffer is swapped to disk 
   you loose part of the benefit of the buffer facility (which is to reduce 
   the number of disk accesses). Omitting the argument or specifying -1 will 
   show you the current upper limit and used and free space. Giving -2 shows 
   which columns are currently stored in memory.  

\ENDCMD
\DEFMENU{0}{GRAPHICS}{GRAPHICS}

Interface to the graphics packages HPLOT and HIGZ.  

\DEFCMD{G}{SET}{GRAPHICS}{SET}{ [ chatt value ]}

\BEGARG
\DEFARG{CHATT}{C}{Attribute name}{ D='SHOW'}
\DEFARG{VALUE}{R}{Attribute value}{ D=0}
\ENDARG

   \par
Set a specific HPLOT attribute.  If CHATT='SHOW', print defaults and 
   current values for all attributes.  If CHATT='*', restore default values 
   for all attributes.  If VALUE=0, the attribute is set to its default value. 

\begin{verbatim}
 +-----------------------------------------------------------------------------+
 |                       HPLSET : Current values in use                        |
 +------------+---------------+---------------+--------------------------------+
 |  Parameter | Current value | Default value |          Explanation           |
 +------------+---------------+---------------+--------------------------------+
 |    XSIZ    |     20.00     |     20.00     | length of X axis               |
 |    YSIZ    |     20.00     |     20.00     | length of Y axis               |
 |    XMGL    |      2.00     |      2.00     | X MarGin Left                  |
 |    XMGR    |      2.00     |      2.00     | X MarGin Right                 |
 |    XLAB    |      1.40     |      1.40     | distance y axis to LABel       |
 |    XVAL    |       .40     |       .40     | distance y axis to axis VALues |
 |    XTIC    |       .30     |       .30     | X axis TICk marks length       |
 |    YMGL    |      2.00     |      2.00     | Y MarGin Low                   |
 |    YMGU    |      2.00     |      2.00     | Y MarGin Up                    |
 |    YLAB    |       .80     |       .80     | distance x axis to LABel       |
 |    YVAL    |       .20     |       .20     | distance x axis to axis VALues |
 |    YTIC    |       .30     |       .30     | Y axis TICk marks length       |
 |    YNPG    |       .60     |       .60     | Y position for Number of PaGe  |
 |    YGTI    |      1.50     |      1.50     | Y position of Global TItle     |
 |    YHTI    |      1.20     |      1.20     | Y position of Histogram TItle  |
 |    KSIZ    |       .28     |       .28     | Hershey charact. (HPLKEY) SIZe |
 |    GSIZ    |       .28     |       .28     | Global title SIZe              |
 |    TSIZ    |       .28     |       .28     | histogram Title SIZe           |
 |    ASIZ    |       .28     |       .28     | Axis label SIZe                |
 |    CSIZ    |       .28     |       .28     | Comment and stat SIZe          |
 |    PSIZ    |       .28     |       .28     | Page number SIZe               |
 |    VSIZ    |       .28     |       .28     | axis Values SIZe               |
 |    SSIZ    |       .28     |       .28     | aSterisk SIZe (for functions)  |
 |    2SIZ    |       .28     |       .28     | scatter-plot & table char. SIZe|
 |    XWIN    |      2.00     |      2.00     | X space between WINdows        |
 |    YWIN    |      2.00     |      2.00     | Y space between WINdows        |
 |    HMAX    |       .90     |       .90     | Histogram MAXimum for scale    |
 |    PASS    |      1.00     |      1.00     | number of PASS for characters  |
 |    CSHI    |       .03     |       .03     | Character SHIft between 2 pass |
 |    BARO    |       .25     |       .25     | BAR histogram Offset (%)       |
 |    BARW    |       .50     |       .50     | BAR histogram Width (%)        |
 |    DASH    |       .15     |       .15     | length of basic DASHed segment |
 |    DMOD    |         1     |         1     | Dash MODe (or type) for lines  |
 |    GRID    |         3     |         3     | GRID line type                 |
 |    DATE    |         2     |         2     | DATE position                  |
 |    FILE    |         1     |         1     | FILE name position             |
 |    STAT    |      1111     |      1111     | STAT values to be plotted      |
 |    FIT     |       101     |       101     | FIT values to be plotted       |
 |    HTYP    |         0     |         0     | Histogram  fill area TYPe      |
 |    BTYP    |         0     |         0     | Box fill area TYPe             |
 |    PTYP    |         0     |         0     | Picture fill area TYPe         |
 |    FTYP    |         0     |         0     | Function fill area TYPe        |
 |    HCOL    |       .00     |      1.00     | Histogram fill area COLor      |
 |    BCOL    |      1.00     |      1.00     | Box fill area and shading COLor|
 |    PCOL    |         1     |         1     | Picture fill area COLor        |
 |    FCOL    |         1     |         1     | Function fill area COLor       |
 |    XCOL    |         1     |         1     | X axis COLor                   |
 |    YCOL    |         1     |         1     | Y axis COLor                   |
 |    HWID    |         1     |         1     | Histogram line WIDth           |
 |    BWID    |         1     |         1     | Box line WIDth                 |
 |    PWID    |         1     |         1     | Picture line WIDth             |
 |    FWID    |         1     |         1     | Function line WIDth            |
 |    XWID    |         1     |         1     | X ticks WIDth                  |
 |    YWID    |         1     |         1     | Y ticks WIDth                  |
 |    TFON    |         2     |         2     | Text (and Title) FONT and PREC |
 |    GFON    |         2     |         2     | Global title FONT and PREC     |
 |    VFON    |         2     |         2     | axis Values FONT and PREC      |
 |    LFON    |         2     |         2     | axis Labels FONT and PREC      |
 |    CFON    |         2     |         2     | Comment FONT and PREC          |
 |    NDVX    |  10510.00     |  10510.00     | Number of DIVisions for X axis |
 |    NDVY    |  10510.00     |  10510.00     | Number of DIVisions for Y axis |
 |    NDVZ    |  10510.00     |  10510.00     | Number of DIVisions for Z axis |
 |    FPGN    |         1     |         1     | First PaGe Number              |
 |    ERRX    |       .50     |       .50     | ERRor on X (% of bin width)    |
 |    1DEF    |         0     |         0     | 1D Plot Option                 |
 |    2DEF    |         0     |         0     | 2D Plot Option                 |
 +------------+---------------+---------------+--------------------------------+
 +-----------------------------------------------------------------------------+
 |                        IGSET : Current values in use                        |
 +-------------+---------------+---------------+-------------------------------+
 |  Parameter  | Current value | Default value |          Explanation          |
 +-------------+---------------+---------------+-------------------------------+
 |    FAIS     |       0       |        0      | Fill area interior style      |
 |    FASI     |       1       |        1      | Fill area style index         |
 |    LTYP     |       1       |        1      | Line type                     |
 |    BASL     |        .150   |         .010  | Basic segment length (NDC)    |
 |    LWID     |       1.000   |        1.000  | Line width                    |
 |    MTYP     |       1       |        1      | Marker type                   |
 |    MSCF     |       1.000   |        1.000  | Marker scale factor           |
 |    PLCI     |       1       |        1      | Polyline color index          |
 |    PMCI     |       1       |        1      | Polymarker color index        |
 |    FACI     |       1       |        1      | Fill area color index         |
 |    TXCI     |       1       |        1      | Text color index              |
 |    TXAL     |       0  0    |        0  0   | Text alignment                |
 |    CHHE     |        .280   |         .010  | Character height              |
 |    TANG     |        .000   |         .000  | Text angle                    |
 |    TXFP     |       0  2    |        0  2   | Text font and precision       |
 |    PICT     |       1       |        1      | Current automatic number      |
 |    BORD     |       0       |        0      | Border flag                   |
 |    PASS     |       1       |        1      | Number of pass in IGTEXT      |
 |    CSHI     |        .030   |         .020  | IGTEXT shift                  |
 |    LASI     |        .018   |         .018  | Label axis size               |
 |    LAOF     |        .013   |         .013  | Label axis offset             |
 |    TMSI     |        .019   |         .019  | Tick marks size               |
 |    AWLN     |        .000   |         .000  | Axis wire lenght              |
 |    BARO     |        .250   |         .250  | Offset of IGHIST (IGRAPH) bars|
 |    BARW     |        .500   |         .500  | Width of IGHIST (IGRAPH) bars |
 |    NCOL     |       8       |        8      | Number of COLors              |
 |    CLIP     |       1       |        1      | Clipping mode                 |
 |    NLIN     |      40       |       40      | Number of line for 3D shapes  |
 |    AURZ     |       0       |        0      | Automatic saving flag         |
 |    DIME     |       2       |        2      | Dimension used (2D or 3D)     |
 +-------------+---------------+---------------+-------------------------------+
\end{verbatim}
\ENDCMD

\DEFCMD{G}{OPTION}{GRAPHICS}{OPTION}{ [ choptn ]}

\BEGARG
\DEFARG{CHOPTN}{C}{Option name}{ D='SHOW'}
\ENDARG

   \par
Set general plotting options for HPLOT.  If CHOPTN='SHOW' print all current 
   and default options.  If CHOPTN='*', restore all default options.  

\begin{verbatim}
 +-----------------------------------------------------------------------------+
 |                            HPLOPT : Option values                           |
 +-------------+-------------+---------------+---------------------------------+
 |   Current   |   Default   |  Alternative  |           Explanation           |
 +-------------+-------------+---------------+---------------------------------+
 |     VERT    |     VERT    |      HORI     | VERTical or HORIzontal          |
 |             |             |               | orientation of paper            |
 |     NEAH    |     NEAH    |      EAH      | Error bars And Histogram are    |
 |             |             |               | plotted (if both are present)   |
 |     NCHA    |     NCHA    |      CHA      | scatter plots drawn with dots   |
 |             |             |               | (NCHA) or 1 char./bin (CHA)     |
 |     NAST    |     NAST    |      AST      | functions drawn with (AST)      |
 |             |             |               | or without (NAST) asterisks     |
 |     SOFT    |     SOFT    |      HARD     | SOFTware or HARDware characters |
 |             |             |               | are used                        |
 |     NSQR    |     NSQR    |      SQR      | size is set to the largest      |
 |             |             |               | square (SQR)                    |
 |     HTIT    |     HTIT    |      UTIT     | HBOOK TITle (HTIT)              |
 |             |             |               | or User TITle (UTIT) is printed |
 |     TAB     |     TAB     |      NTAB     | table printed as TABles (TAB)   |
 |             |             |               | or scatter plots (NTAB)         |
 |     BOX     |     BOX     |      NBOX     | a box is (BOX) or is not (NBOX) |
 |             |             |               | drawn around picture            |
 |     NTIC    |     NTIC    |      TIC      | cross-wires are drawned (TIC)   |
 |             |             |               | or not (NTIC) on each plot      |
 |     NSTA    |     NSTA    |      STA      | STAtistics are printed (STA)    |
 |             |             |               | or not (NSTA) on each plot      |
 |     NFIT    |     NFIT    |      FIT      | FIT parameters are printed      |
 |             |             |               | or not (NFIT) on each plot      |
 |     NZFL    |     NZFL    |      ZFL      | picture is (ZFL) or is not      |
 |             |             |               | (NZFL) put in Z data base       |
 |     NPTO    |     NPTO    |      PTO      | PTO (Please Turn Over)          |
 |             |             |               | (NPTO)                          |
 |     NBAR    |     NBAR    |      BAR      | BAR charts for histogram        |
 |             |             |               | (NBAR)                          |
 |     DVXR    |     DVXR    |      DVXI     | Integer (DVXI) or Real (DVXR)   |
 |             |             |               | divisions for X axis            |
 |     DVYR    |     DVYR    |      DVYI     | Integer (DVYI) or Real (DVYR)   |
 |             |             |               | divisions for Y axis            |
 |     NGRI    |     NGRI    |      GRID     | GRID or not grid (NGRI)         |
 |             |             |               | on X and Y axis                 |
 |     NDAT    |     NDAT    |      DATE     | DATE is printed (DATE)          |
 |             |             |               | or not (NDAT) on each plot      |
 |     NFIL    |     NFIL    |      FILE     | FILE name is printed (FILE)     |
 |             |             |               | or not (NFIL) on each plot      |
 |     A4      |     A4      |      A0/6     | page format for the plotter     |
 |             |             |               | (A0,A1,A2,A3,A4,A5,A6)          |
 |     NOPG    |     NOPG    |      P        | page number is (P   )           |
 |             |             |               | or is not (NOPG) printed        |
 |     LINY    |     LINY    |      LOGY     | LINear or LOGarithmic scale     |
 |             |             |               | in Y                            |
 |     LINX    |     LINX    |      LOGX     | LINear or LOGarithmic scale     |
 |             |             |               | in X                            |
 |     LINZ    |     LINZ    |      LOGZ     | LINear or LOGarithmic scale     |
 |             |             |               | in Z (Lego or Surface)          |
 +-------------+-------------+---------------+---------------------------------+
\end{verbatim}
\ENDCMD

\DEFCBIG{G}{METAFI}{GRAPHICS}{METAFILE}{ [ lun metafl chmeta ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ D=0}
\DEFARG{METAFL}{I}{Metafile ID}{ D=0}
\DEFARG{CHMETA}{C}{Metafile name}{ D=\EMPTY{}}
\ENDARG

   \par
Set the metafile logical unit and metafile type.  This command controls the 
   destination of the subsequent graphics output.  Example:  
\begin{verbatim}
    LUN =-10 output only on metafile opened on unit 10;
    LUN =  0 output only on screen;
    LUN = 10 output on both screen and metafile opened on unit 10;
\end{verbatim}
   \par
Use the command FORTRAN/FILE to open a new file, FORTRAN/CLOSE to close it. 
   Note that PAW opens the file PAW.METAFILE on the unit 10 at initialization 
   time.  
\begin{verbatim}
    METAFL=   4 Appendix E GKS.
    METAFL=-111 HIGZ/PostScript (Portrait).
    METAFL=-112 HIGZ/PostScript (Landscape).
    METAFL=-113 HIGZ/Encapsulated PostScript.
    METAFL=-114 HIGZ/PostScript Color (Portrait).
    METAFL=-115 HIGZ/PostScript Color (Landscape).
    METAFL=-777 HIGZ/LaTex Encapsulated.
    METAFL=-778 HIGZ/LaTex.
\end{verbatim}
   \par
The PostScript metafile types have the following format:  
\begin{verbatim}
                      -[Format][Nx][Ny][Type]
    Where:
\end{verbatim}
   \par
[Format] Is an integer between 0 and 99 which defines the format of the 
\begin{verbatim}
            paper. For example if Format=3 the paper is in the standard
            A3 format. Format=4 and Format=0 are the same and
            define an A4 page.
            The A0 format is selected by Format=99.
            The US format Letter is selected by Format=100.
            The US format Legal is selected by Format=200.
            The US format Ledger is selected by Format=300.
\end{verbatim}
   \par
[Nx, Ny] Specify respectively the number of zones on the x and y axis.  
\begin{verbatim}
            Nx and Ny are integers between 1 and 9.
\end{verbatim}
   \par
[Type]   Can be equal to:  
\begin{verbatim}
            1: Portrait mode with a small margin at the bottom of the page.
            2: Landscape mode with a small margin at the bottom of the page.
            4: Portrait mode with a large margin at the bottom of the page.
            5: Landscape mode with a large margin at the bottom of the page.
               The large margin is useful for some PostScript printers (very
               often for the colour printers) as they need more space to grip
               the paper for mechanical reasons. Note that some PostScript
               colour printers can also use the so called "special A4" format
               permitting the full usage of the A4 area; in this case larger
               margins are not necessary and {\tt Type}=1 or 2 can be used.
            3: Encapsulated PostScript. This Type permits the generation of
               files which can be included in other documents, for example
               in LaTeX files. Note that with this Type, Nx and Ny must always
               be equal to 1, and Format has no meaning. The size of the 
   picture
               must be specified by the user via the SIZE command. Therefore
               the workstation type for Encapsulated PostScript is -113. For
               example if the name of an encapsulated PostScript file is
               example.eps, the inclusion of this file into a LaTeX file will
               be possible via (in the LaTeX file):

                       \begin{figure}
                        \epsffile{example.eps}
                        \caption{Example of Encapsulated PostScript in LaTeX.}
                        \label{EXAMPLE}
                       \end{figure}

\end{verbatim}
   \par
With Type=1,2,4 and 5 the pictures are centered on the page, and the usable 
   area on paper is proportional to the dimensions of A4 format.  Examples:  
   -111 or -4111 defines an A4 page not divided.  -6322 define an A6 landscape 
   page divided in 3 columns and 2 rows.  
\begin{verbatim}
                       +-------+-------+-------+
                       |   1   |   2   |   3   |
                       +-------+-------+-------+
                       |   4   |   5   |   6   |
                       +-------+-------+-------+
\end{verbatim}
   \par
The first picture  will be drawn  in the area 1. After each clear the 
   screen, the graphics output will appear in the next area in the order 
   defined above.  If a page is filled, a new page is used with the same grid. 
   Note that empty pages are not printed in order to save paper.  Ignoring 
   formats smaller than A12, the total number of possible different PostScript 
   workstation types is: 4x9x9x13+1 = 4213 ! 

\ENDCBIG

\DEFCMD{G}{WORKST}{GRAPHICS}{WORKSTATION}{ iwkid [ chopt iwtyp ]}

\BEGARG
\DEFARG{IWKID}{I}{Workstation ID}{ D=1 Loop}
\DEFARG{CHOPT}{C}{Options}{ D='OA'}
\DEFARG{IWTYP}{I}{Workstation type}{ D=1}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{O}{\par
Open a new workstation
}
\DEFOPT{C}{\par
Close a workstation
}
\DEFOPT{A}{\par
Activate a workstation
}
\DEFOPT{D}{\par
Deactivate a workstation
}
\DEFOPT{L}{\par
Give the list of open workstations
}
\ENDOPT

   \par
To create/delete workstations or change status.  
\begin{verbatim}
       IWKID > 0  Do the action specified by CHOPT on the
                  workstation identified by IWKID.
       IWKID = 0  Do the action specified by CHOPT on all
                  workstations.
       IWKID < 0  Do the action specified by CHOPT on the
                  workstation identified by -IWKID and the
                  complementary action on all the others.
\end{verbatim}

\ENDCMD

\DEFCMD{G}{SLIDE}{GRAPHICS}{SLIDE}{}

   \par
Invoke the SLIDE package.  

\begin{verbatim}

\end{verbatim}
\ENDCMD
\DEFMENU{1}{MISC}{GRAPHICS/MISC}

Miscellaneous HPLOT functions.  

\DEFCMD{GM}{NEXT}{GRAPHICS/MISC}{NEXT}{}

   \par
Clear the screen.  Initialize a new HIGZ picture if option ZFL or ZFL1 has 
   been selected.  Select the Normalization Transformation number 1 (cm).  

\ENDCMD

\DEFCMD{GM}{CLR}{GRAPHICS/MISC}{CLR}{}

   \par
Clear the screen.  

\ENDCMD

\DEFCMD{GM}{LOCATE}{GRAPHICS/MISC}{LOCATE}{ [ ntpri chopt ]}

\BEGARG
\DEFARG{NTPRI}{I}{Transformation with highest priority}{ D=-1}
\DEFARG{CHOPT}{C}{Options}{ D='R'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{R}{\par
Request mode is used to locate the points (default)
}
\DEFOPT{S}{\par
Sample mode is used to locate the points
}
\DEFOPT{I}{\par
Integrate an histogram between 2 bins
}
\DEFOPT{+}{\par
Use the tracking cross (default is cross-hair)
}
\DEFOPT{T}{\par
The output is done on the terminal.
}
\ENDOPT

   \par
Locate points on the screen using the graphics cursor and output 
   coordinates on terminal.  Control is returned when the BREAK (right) mouse 
   button is clicked (or CRTL/E) or when 20 points are located.  The optional 
   parameter NTPRI may be specified to locate a point in the specific 
   transformation number NTPRI.  NTPRI=-1 (default) means that all the 
   histogram transformation numbers (10, 20, etc.) have priority on 
   transformation number 1.  Note: With the Motif version of PAW the locator 
   is automatically invoke when the mouse cursor enter the window.  

\ENDCMD

\DEFCMD{GM}{VLOCAT}{GRAPHICS/MISC}{VLOCATE}{ vecx vecy [ chopt ntpri ]}

\BEGARG
\DEFARG{VECX}{C}{Vector for coordinates X}{}
\DEFARG{VECY}{C}{Vector for coordinates Y}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{} Minus}
\DEFARG{NTPRI}{I}{Transformation with highest priority}{ D=-1}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Use the cross-hair
}
\DEFOPT{+}{\par
Use the tracking cross
}
\DEFOPT{-}{\par
Use the rubber line
}
\DEFOPT{L}{\par
Connect points by a polyline
}
\DEFOPT{P}{\par
Draw the current polymarker at each point
}
\DEFOPT{*}{\par
Draw a * at each point
}
\DEFOPT{S}{\par
Sample mode is used. Allows to see the coordinates of point before clicking
}
\ENDOPT

   \par
Locate a set of points using the graphics cursor.  Return corresponding 
   coordinates in vectors X and Y.  If vectors X or Y do not exist, they are 
   automatically created.  Control is returned when the point is outside 
   picture limits or when the BREAK (right) mouse button is clicked (or 
   CRTL/E).  The optional parameter NTPRI may be specified to locate a point 
   in the specific transformation number NTPRI (see LOCATE).  

\ENDCMD

\DEFCMD{GM}{HMOVE}{GRAPHICS/MISC}{HMOVE}{}

   \par
Change the contents of a histogram channel using the cursor.  Position the 
   cursor to the channel to be changed, trigger graphics input, position the 
   cursor to the new channel value (a rubber band box is used to visualize the 
   change), trigger graphics input to fix the new value.  

\ENDCMD
\DEFMENU{1}{VIEWING}{GRAPHICS/VIEWING}

To define Normalization transformations.  Either automatically (ZONE and 
   SIZE) or 'by hand' (SVP, SWN and SELNT).  

\DEFCMD{GV}{ZONE}{GRAPHICS/VIEWING}{ZONE}{ [ nx ny ifirst chopt ]}

\BEGARG
\DEFARG{NX}{I}{Number of divisions along X}{ D=1}
\DEFARG{NY}{I}{Number of divisions along Y}{ D=1}
\DEFARG{IFIRST}{I}{First division number}{ D=1}
\DEFARG{CHOPT}{C}{Option}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{}
\DEFOPT{S}{\par
Redefine zones on current picture
}
\DEFOPT{\EMPTY}{\par
Define the zones for all subsequent pictures.
}
\ENDOPT

   \par
Subdivide the picture into NX by NY zones, starting at zone IFIRST (count 
   along X first).  

\ENDCMD

\DEFCMD{GV}{SIZE}{GRAPHICS/VIEWING}{SIZE}{ [ xsize ysize ]}

\BEGARG
\DEFARG{XSIZE}{R}{Size along X}{ D=20.}
\DEFARG{YSIZE}{R}{Size along Y}{ D=20.}
\ENDARG

   \par
Set the size of the picture.  On the terminal, the pictures will have the 
   ratio YSIZE/XSIZE, and, if a metafile is produced, pictures will be YSIZE 
   by XSIZE cm.  This command sets the parameters for the normalization 
   transformation number 1 to [0-XSIZE], [0-YSIZE].  

\ENDCMD

\DEFCMD{GV}{SVP}{GRAPHICS/VIEWING}{SVP}{ nt x1 x2 y1 y2}

\BEGARG
\DEFARG{NT}{I}{Normalization transformation number}{}
\DEFARG{X1}{R}{Low X  of viewport in NDC}{ D=0 R=0:1}
\DEFARG{X2}{R}{High X of viewport in NDC}{ D=1 R=0:1}
\DEFARG{Y1}{R}{Low Y  of viewport in NDC}{ D=0 R=0:1}
\DEFARG{Y2}{R}{High Y of viewport in NDC}{ D=1 R=0:1}
\ENDARG

   \par
Set the viewport of the normalization transformation NT in the Normalized 
   Device Coordinates (NDC).  

\ENDCMD

\DEFCMD{GV}{SWN}{GRAPHICS/VIEWING}{SWN}{ nt x1 x2 y1 y2}

\BEGARG
\DEFARG{NT}{I}{Normalize transformation number}{}
\DEFARG{X1}{R}{Low X  of window in WC}{ D=0}
\DEFARG{X2}{R}{High X of window in WC}{ D=20}
\DEFARG{Y1}{R}{Low Y  of window in WC}{ D=0}
\DEFARG{Y2}{R}{High Y of window in WC}{ D=20}
\ENDARG

   \par
Set the window of the normalization transformation NT in World Coordinates 
   (WC).  

\ENDCMD

\DEFCMD{GV}{SELNT}{GRAPHICS/VIEWING}{SELNT}{ nt}

\BEGARG
\DEFARG{NT}{I}{Normalization transformation number}{}
\ENDARG

   \par
Select a normalization transformation number.  
\begin{verbatim}
     If ZONE 2 2 is active , then:        If ZONE 1 1 is active, then:
    +------------------------------+    +-----------------------------+
    |                              |    |                             |
    |  +----------+   +---------+  |    |  +-----------------------+  |
    |  |          |   |         |  |    |  |                       |  |
    |  |   NT=10  |   |  NT=20  |  |    |  |                       |  |
    |  |          |   |         |  |    |  |                       |  |
    |  +----------+   +---------+  |    |  |                       |  |
    |                              |    |  |         NT=10         |  |
    |  +----------+   +---------+  |    |  |                       |  |
    |  |          |   |         |  |    |  |                       |  |
    |  |   NT=30  |   |  NT=40  |  |    |  |                       |  |
    |  |          |   |         |  |    |  |                       |  |
    |  +----------+   +---------+  |    |  |                       |  |
    |                              |    |  +-----------------------+  |
    |             NT=1             |    |             NT=1            |
    +------------------------------+    +-----------------------------+
\end{verbatim}

\ENDCMD
\DEFMENU{1}{PRIMITIVES}{GRAPHICS/PRIMITIVES}

Call HIGZ drawing primitives 

\DEFCMD{GP}{PLINE}{GRAPHICS/PRIMITIVES}{PLINE}{ n x y}

\BEGARG
\DEFARG{N}{I}{Number of points}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\ENDARG

   \par
Draw a polyline of N points X,Y in the current Normalization 
   transformation.  Use commands SLN, SLWSC and SPLCI (or IGSET) to change 
   line attributes.  

\ENDCMD

\DEFCMD{GP}{LINE}{GRAPHICS/PRIMITIVES}{LINE}{ x1 y1 x2 y2}

\BEGARG
\DEFARG{X1}{R}{X first coordinate}{}
\DEFARG{Y1}{R}{Y first coordinate}{}
\DEFARG{X2}{R}{X second coordinate}{}
\DEFARG{Y2}{R}{Y second coordinate}{}
\ENDARG

   \par
Draw a line connecting points (X1,Y1) and (X2,Y2) in the current 
   Normalization transformation.  Use commands SLN, SLWSC and SPLCI (or IGSET) 
   to change line attributes.  

\ENDCMD

\DEFCMD{GP}{FAREA}{GRAPHICS/PRIMITIVES}{FAREA}{ n x y}

\BEGARG
\DEFARG{N}{I}{Number of points}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\ENDARG

   \par
Fill the area defined by the N points X,Y in the current Normalization 
   transformation.  Use commands SFASI, SFAIS and SFACI (or IGSET) to change 
   fill area attributes.  

\ENDCMD

\DEFCMD{GP}{PMARKE}{GRAPHICS/PRIMITIVES}{PMARKER}{ n x y}

\BEGARG
\DEFARG{N}{I}{Number of points}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\ENDARG

   \par
Draw polymarkers at the N points X,Y in the current Normalization 
   transformation.  Use commands SMK and SPMCI (or IGSET) to change polymarker 
   attributes.  

\ENDCMD

\DEFCMD{GP}{BOX}{GRAPHICS/PRIMITIVES}{BOX}{ x1 x2 y1 y2}

\BEGARG
\DEFARG{X1}{R}{X coordinate of first corner}{}
\DEFARG{X2}{R}{X coordinate of second corner}{}
\DEFARG{Y1}{R}{Y coordinate of first corner}{}
\DEFARG{Y2}{R}{Y coordinate of second corner}{}
\ENDARG

   \par
Draw and fill a box with the current fill area attributes.  Use the current 
   Normalization transformation.  

\ENDCMD

\DEFCMD{GP}{FBOX}{GRAPHICS/PRIMITIVES}{FBOX}{ x1 x2 y1 y2 x3 x4 y3 y4}

\BEGARG
\DEFARG{X1}{R}{X coord of 1st corner of ext box}{}
\DEFARG{X2}{R}{X coord of 2nd corner of ext box}{}
\DEFARG{Y1}{R}{Y coord of 1st corner of ext box}{}
\DEFARG{Y2}{R}{Y coord of 2nd corner of ext box}{}
\DEFARG{X3}{R}{X coord of 1st corner of int box}{}
\DEFARG{X4}{R}{X coord of 2nd corner of int box}{}
\DEFARG{Y3}{R}{Y coord of 1st corner of int box}{}
\DEFARG{Y4}{R}{Y coord of 2nd corner of int box}{}
\ENDARG

   \par
Draw and fill a frame (2 nested boxes) with the current fill area 
   attributes.  Use the current Normalization transformation.  

\ENDCMD

\DEFCMD{GP}{ARROW}{GRAPHICS/PRIMITIVES}{ARROW}{ x1 x2 y1 y2 [ size ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of start point}{}
\DEFARG{X2}{R}{X coordinate of end point}{}
\DEFARG{Y1}{R}{Y coordinate of start point}{}
\DEFARG{Y2}{R}{Y coordinate of end point}{}
\DEFARG{SIZE}{R}{Arrow size}{ D=0.4}
\ENDARG

   \par
Draw an arrow (X1,Y1) ----\KET{} (X2,Y2) if SIZE\KET{}0.  Draw an arrow 
   (X1,Y1) \BRA{}---\KET{} (X2,Y2) if SIZE\BRA{}0.  Use the current 
   Normalization transformation.  

\ENDCMD

\DEFCMD{GP}{HELIX}{GRAPHICS/PRIMITIVES}{HELIX}{ [ x1 y1 x2 y2 r wi phi ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of the begin of helix}{ D=0.}
\DEFARG{Y1}{R}{Y coordinate of the begin of helix}{ D=0.}
\DEFARG{X2}{R}{X coordinate of the end of helix}{ D=10.}
\DEFARG{Y2}{R}{Y coordinate of the end of helix}{ D=10.}
\DEFARG{R}{R}{Radius of helix}{ D=.3}
\DEFARG{WI}{R}{Number of turns  }{ D=1.}
\DEFARG{PHI}{R}{Projection angle }{ D=15.}
\ENDARG

   \par
Plots an helix on current page Feynman graph: gluon phi = 30, photon phi = 
   0.  

\ENDCMD

\DEFCMD{GP}{ARCHEL}{GRAPHICS/PRIMITIVES}{ARCHELIX}{ [ x1 y1 x2 y2 r wi phi rl ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of the begin of helix}{ D=0.}
\DEFARG{Y1}{R}{Y coordinate of the begin of helix}{ D=0.}
\DEFARG{X2}{R}{X coordinate of the end of helix}{ D=10.}
\DEFARG{Y2}{R}{Y coordinate of the end of helix}{ D=10.}
\DEFARG{R}{R}{Radius of helix}{ D=.3}
\DEFARG{WI}{R}{Number of turns  }{ D=1.}
\DEFARG{PHI}{R}{Projection angle }{ D=30.}
\DEFARG{RL}{R}{Radius   of loop }{ D=15.}
\ENDARG

   \par
Plots an helix on current page Feynman graph: gluon phi = 30, photon phi = 
   0.  

\ENDCMD

\DEFCMD{GP}{ARLINE}{GRAPHICS/PRIMITIVES}{ARLINE}{ [ x1 y1 x2 y2 h ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of the begin}{ D=0.}
\DEFARG{Y1}{R}{Y coordinate of the begin}{ D=0.}
\DEFARG{X2}{R}{X coordinate of the end}{ D=10.}
\DEFARG{Y2}{R}{Y coordinate of the end}{ D=10.}
\DEFARG{H}{R}{arrow size}{ D=.5}
\ENDARG

   \par
Line with arrow (fermion line) 

\ENDCMD

\DEFCMD{GP}{FPOINT}{GRAPHICS/PRIMITIVES}{FPOINT}{ [ x y r ]}

\BEGARG
\DEFARG{X}{R}{X      }{ D=0.}
\DEFARG{Y}{R}{Y      }{ D=0.}
\DEFARG{R}{R}{Radius }{ D=.5}
\ENDARG

   \par
Draw filled point (vertex) 

\ENDCMD

\DEFCBIG{GP}{AXIS}{GRAPHICS/PRIMITIVES}{AXIS}{ x0 x1 y0 y1 wmin wmax ndiv [ chopt ]}

\BEGARG
\DEFARG{X0}{R}{X axis origin in WC}{}
\DEFARG{X1}{R}{X end axis in WC}{}
\DEFARG{Y0}{R}{Y axis origin in WC}{}
\DEFARG{Y1}{R}{Y end axis in WC}{}
\DEFARG{WMIN}{R}{Lowest value for labels}{}
\DEFARG{WMAX}{R}{Highest value for labels}{}
\DEFARG{NDIV}{I}{Number of divisions}{ D=510}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{} Minus}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw an axis with default values.
}
\DEFOPT{G}{\par
Logarithmic scale, default is linear.
}
\DEFOPT{B}{\par
Blank axis. Useful to superpose axis.
}
\DEFOPT{U}{\par
Unlabeled axis, default is labeled.
}
\DEFOPT{+}{\par
Tick marks are drawn on Positive side. (default)
}
\DEFOPT{-}{\par
Tick marks are drawn on the negative side.
}
\DEFOPT{=}{\par
Tick marks are drawn on Equal side
}
\DEFOPT{P}{\par
Labels are drawn Parallel to the axis
}
\DEFOPT{O}{\par
Labels are drawn Orthogonal to the axis (Top to Down).
}
\DEFOPT{0}{\par
Labels are drawn Orthogonal to the axis (Down to Top).
}
\DEFOPT{R}{\par
labels are Right adjusted on tick mark.
}
\DEFOPT{L}{\par
labels are Left adjusted on tick mark.
}
\DEFOPT{C}{\par
labels are Centered on tick mark.
}
\DEFOPT{M}{\par
In the Middle of the divisions.
}
\DEFOPT{Y}{\par
Direction of labels DOWN . Default is RIGHT
}
\DEFOPT{.}{\par
Dot obligatory
}
\DEFOPT{T}{\par
Alphanumeric labels .
}
\DEFOPT{S}{\par
Tick marks Size
}
\DEFOPT{H}{\par
Labels Height
}
\DEFOPT{D}{\par
Distance labels-axis
}
\DEFOPT{N}{\par
No bining optimization
}
\DEFOPT{I}{\par
Integer labeling
}
\ENDOPT

   \par
Draw an axis in the current Normalization transformation.  
\begin{verbatim}
           NDIV=N1 + 100*N2 + 10000*N3
           N1, N2, N3 = Number of 1st, 2nd, 3rd divisions respectively, eg:.
               NDIV=0 --> no tick marks.
               NDIV=2 --> 2 divisions, one tick mark in the middle
                        of the axis.
     Orientation of tick marks on axis: Tick marks are normally drawn
     on the positive side of the axis.However, if X0=X1, then Negative .
           CHOPT='+': tick marks are drawn on Positive side. (default)
           CHOPT='-': tick marks are drawn on the negative side.
           i.e: '+-' --> tick marks are drawn on both sides of the axis.
     Position of labels on axis: Labels are normally drawn on side
     opposite to tick marks.However:
           CHOPT= '='   on Equal side
     Orientation of labels on axis: Labels are normally drawn
     parallel to the axis. However if X0=X1, then Orthogonal
                                   if Y0=Y1, then Parallel
           CHOPT= 'P' : Parallel to the axis
           CHOPT= 'O' : Orthogonal to the axis (Top to Down).
           CHOPT= '0' : Orthogonal to the axis (Down to Top).
     Position of labels on tick marks: Labels are centered on
     tick marks. However , if X0=X1, then they are right adjusted.
           CHOPT='R': labels are Right adjusted on tick mark.
                      (default is centered)
           CHOPT='L': labels are Left adjusted on tick mark.
           CHOPT='C': labels are Centered on tick mark.
           CHOPT='M': In the Middle of the divisions.
     Direction of labels: Default is RIGHT
           CHOPT='Y':   Down
     Format of labels: Blank characters are stripped, and then the
     label is correctly aligned. The dot,if last character of the
     string, is also stripped, unless
           CHOPT='.'     Dot obligatory
     In the following, we have some parameters, like
     tick marks length and characters height (in percentage
     of the length of the axis).The default values are as follows:
        Primary tick marks: 3.0 %
        Secondary tick marks: 1.5 %
        Third order tick marks: .75 %
        Characters height for labels: 2%
        Characters spacing (related to height): 40%
        Labels offset: 4.0 %
     Type of labels: Labels are normally numeric . However, alphanumeric
     labels can be drawn (see command LABEL).
           CHOPT='T':   Alphanumeric labels .
     Intrinsic parameters: These values can be changed with the command
     IGSET. The default value is used unless the corresponding option is
     selected by CHOPT:
           CHOPT='D' The distance between the labels and the axis
                     (the offset) is given by the preceding command
                     IGSET with the parameter LAOF.
           CHOPT='H' The size (height) of the labels is given by the
                     preceding command IGSET with the parameter LASI.
           CHOPT='S' The size of the tick marks is given by the preceding
                     command IGSET with the parameter TMSI.
     Axis bining optimization: By default the axis bining is optimized .
           CHOPT='N': No bining optimization
           CHOPT='I': Integer labeling
\end{verbatim}

\ENDCBIG

\DEFCMD{GP}{ARC}{GRAPHICS/PRIMITIVES}{ARC}{ x1 y1 r1 [ r2 phimin phimax ]}

\BEGARG
\DEFARG{X1}{R}{X coordinate of centre}{}
\DEFARG{Y1}{R}{Y coordinate of centre}{}
\DEFARG{R1}{R}{Inner radius}{}
\DEFARG{R2}{R}{Outer radius}{ D=-1.}
\DEFARG{PHIMIN}{R}{Minimum angle}{ D=0.}
\DEFARG{PHIMAX}{R}{Maximum angle}{ D=360.}
\ENDARG

   \par
Draw an arc of circle in the current Normalization transformation.  If R1 
   is not equal to R2 the area between the two arcs of radius R1 and R2 is 
   filled according to the current fill area attributes.  The border is never 
   drawn unless the interior style is hollow or the command IGSET BORD 1 has 
   been called. If R1 is equal to R2 a polyline is drawn.  

\ENDCMD

\DEFCMD{GP}{PIE}{GRAPHICS/PRIMITIVES}{PIE}{ x0 y0 radius n values [ chopt iao ias iac ]}

\BEGARG
\DEFARG{X0}{R}{X coordinate of centre of the pie}{}
\DEFARG{Y0}{R}{Y coordinate of centre of the pie}{}
\DEFARG{RADIUS}{R}{Radius of the pie chart}{}
\DEFARG{N}{I}{Number of values}{}
\DEFARG{VALUES}{C}{Vector name for N values}{}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{IAO}{C}{Name of vector with offsets}{ D=\EMPTY{}}
\DEFARG{IAS}{C}{Name of vector with styles}{ D=\EMPTY{}}
\DEFARG{IAC}{C}{Name of vector with colors}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw a Pie Chart with default values.
}
\DEFOPT{C}{\par
Colours array is present.
}
\DEFOPT{L}{\par
Alphanumeric labels are required.
}
\DEFOPT{O}{\par
Offset array is present.
}
\DEFOPT{N}{\par
The label of each slice will be the corresponding numeric value in array 
VALUES.
}
\DEFOPT{P}{\par
The label of each slice will be in expressed in percentage.
}
\DEFOPT{S}{\par
Style array is present.
}
\DEFOPT{H}{\par
Force the labels size to be the current character height. Without this option 
the labels size is computed automatically.
}
\DEFOPT{R}{\par
Draw the labels aligned on the radius of each slice.
}
\ENDOPT

   \par
Draw a pie chart in the current Normalization transformation.  

\ENDCMD

\DEFCMD{GP}{TEXT}{GRAPHICS/PRIMITIVES}{TEXT}{ x y text size [ angle chopt ]}

\BEGARG
\DEFARG{X}{R}{X coordinate}{}
\DEFARG{Y}{R}{Y coordinate}{}
\DEFARG{TEXT}{C}{Text to be drawn}{}
\DEFARG{SIZE}{R}{Text size}{ D=0.3}
\DEFARG{ANGLE}{R}{Comment angle}{ D=0}
\DEFARG{CHOPT}{C}{Justification option}{ D='L'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{L}{\par
Text is Left justified.
}
\DEFOPT{C}{\par
Text is Centered.
}
\DEFOPT{R}{\par
Text is Right justified.
}
\ENDOPT

   \par
Draw text at position X,Y in the current normalization transformation using 
   the software font IGTEXT.  SIZE is always given in centimeters (as defined 
   by the command SIZE).  Boldface effects can be obtained using the 
   parameters PASS and CSHI of the command SET. The text color can be changed 
   by IGSET TXCI.  

\ENDCMD

\DEFCMD{GP}{ITX}{GRAPHICS/PRIMITIVES}{ITX}{ x y text}

\BEGARG
\DEFARG{X}{R}{X coordinate}{}
\DEFARG{Y}{R}{Y coordinate}{}
\DEFARG{TEXT}{C}{Text to be drawn}{}
\ENDARG

   \par
Draw text at position X,Y in the current Normalization transformation, 
   using the current font parameters.  The font and the precision can be 
   changed by IGSET TXFP.  The character size can be changed by IGSET CHHE.  
   The text color can be changed by IGSET TXCI.  The text orientation can be 
   changed with IGSET TXAL.  The text angle can be changed by IGSET TANG.  

\ENDCMD

\DEFCMD{GP}{LABELS}{GRAPHICS/PRIMITIVES}{LABELS}{ labnum nlabs chlabs}

\BEGARG
\DEFARG{LABNUM}{I}{Label identifier}{ D=1 R=1:9}
\DEFARG{NLABS}{I}{Number of labels}{ D=0 R=0:50}
\DEFARG{CHLABS}{C}{List of labels}{ D=\EMPTY{} Vararg}
\ENDARG

   \par
Define a list of labels to be used by subsequent commands such as PIE and 
   AXIS.  The position of the labels on the axis may be changed with SET NDVX 
   (NDVY).  

\ENDCMD

\DEFCMD{GP}{PAVE}{GRAPHICS/PRIMITIVES}{PAVE}{ x1 x2 y1 y2 [ dz isbox isfram chopt ]}

\BEGARG
\DEFARG{X1}{R}{X bottom left corner of box}{}
\DEFARG{X2}{R}{X top right corner of box}{}
\DEFARG{Y1}{R}{Y bottom left corner of box}{}
\DEFARG{Y2}{R}{Y top right corner of box}{}
\DEFARG{DZ}{R}{Box width}{ D=0.4}
\DEFARG{ISBOX}{I}{Box style}{ D=0}
\DEFARG{ISFRAM}{I}{Frame style}{ D=5}
\DEFARG{CHOPT}{C}{Option}{ D='TR'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{TR}{\par
Top and Right frame are drawn
}
\DEFOPT{TL}{\par
Top and Left frame
}
\DEFOPT{BR}{\par
Bottom and Right frame
}
\DEFOPT{BL}{\par
Bottom and Left frame
}
\DEFOPT{L}{\par
Left frame only
}
\DEFOPT{R}{\par
Right frame only
}
\DEFOPT{T-}{\par
Top frame only pointing left
}
\DEFOPT{B-}{\par
Bottom frame only pointing left
}
\DEFOPT{S}{\par
Shadow mode
}
\DEFOPT{K}{\par
Key mode
}
\ENDOPT

   \par
Draw a paving-block (box with 3D effect).  ISBOX (ISFRAM) may be 
   1000+ICOLOR where ICOLOR is the color index of the box (frame), otherwise 
   the style index.  If ISBOX (ISFRAM) =0, only the box contour is drawn with 
   the current polyline attributes.  

\ENDCMD

\DEFCMD{GP}{HIST}{GRAPHICS/PRIMITIVES}{HIST}{ n x y [ chopt ]}

\BEGARG
\DEFARG{N}{I}{Number of values}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\DEFARG{CHOPT}{C}{Options}{ D='AHW'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
X and Y axes are drawn (default).
}
\DEFOPT{H}{\par
An histogram is drawn as a contour (default).
}
\DEFOPT{W}{\par
The Window/Viewport parameters are automatically computed from the X and Y 
values (default).
}
\DEFOPT{R}{\par
The histogram is Rotated, i.e. the values in X are used for the ordinate and 
the values in Y for the abscissa (default is the contrary). If option R is 
selected (and option 'N' is not selected), the user must give: 2 values for Y 
(Y(1)=YMIN and Y(2)=YMAX) N values for X, one for each bin. Otherwise the user 
must give: N values for Y, one for each bin. 2 values for X (X(1)=XMIN and 
X(2)=XMAX) If option 'N' is selected see below.
}
\DEFOPT{N}{\par
Non equidistant bins (default is equidistant). The arrays X and Y must be 
dimensioned as follows: If option R is not selected (default) then give: (N+1) 
values for X (limits of bins). N values for Y, one for each bin. Otherwise 
give: (N+1) values for Y (limits of bins). N values for X, one for each bin.
}
\DEFOPT{F}{\par
The area delimited by the histogram is filled according to the fill area 
interior style and the fill area style index or colour index. Contour is not 
drawn unless CHOPT='H' is also selected.
}
\DEFOPT{C}{\par
A Smooth curve is drawn across points at the centre of each bin of the 
histogram.
}
\DEFOPT{L}{\par
A straight Line is drawn across points at the centre of each bin of the 
histogram.
}
\DEFOPT{*}{\par
A star is plotted at the center of each bin of the histogram.
}
\DEFOPT{P}{\par
Idem as '*' but with the current marker.
}
\DEFOPT{B}{\par
A Bar chart with equidistant bins is drawn as fill areas. (Contours are 
drawn). The bar origin and the bar width can be controlled by the routine 
IGSET using the options BARO and BARW respectively.
}
\ENDOPT

   \par
Draw an histogram defined by arrays X and Y.  The number of components 
   needed in vectors X and/or in Y may be dependent upon the value of CHOPT 
   (see options 'R' and 'N').  To set Log scales in X and/or Y, use OPT 
   LOGX/LOGY.  Note that when an option is specified, it is also necessary to 
   specify the options 'AW' or 'AHW' in order to start a new zone or/and draw 
   the axes.  

\ENDCMD

\DEFCMD{GP}{GRAPH}{GRAPHICS/PRIMITIVES}{GRAPH}{ n x y [ chopt ]}

\BEGARG
\DEFARG{N}{I}{Number of values}{}
\DEFARG{X}{C}{Vector name for X coordinates}{}
\DEFARG{Y}{C}{Vector name for Y coordinates}{}
\DEFARG{CHOPT}{C}{Options}{ D='ALW'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{A}{\par
X and Y axes are drawn (default).
}
\DEFOPT{L}{\par
Every point is connected with a straight line. (default)
}
\DEFOPT{W}{\par
The Window/Viewport parameters are automatically computed from the X and Y 
values (default).
}
\DEFOPT{C}{\par
The values in Y are plotted in the form of a smooth curve. A Spline 
approximation algorithm is used.
}
\DEFOPT{F}{\par
A fill area is drawn. If the option 'CF' is used the contour of the fill area 
is smooth. The border of the fill area is drawn if the command IGSET BORD 1 
has been typed. The fill area type may be changed via the IGSET parameters 
FASI and FASI
}
\DEFOPT{R}{\par
The graph is Rotated, i.e. the values in X are used for the ordinate and the 
values in Y for the abscissa (default is the contrary).
}
\DEFOPT{B}{\par
A Bar chart with equidistant bins is drawn as fill areas. (Contours are 
drawn). The bar origin and the bar width can be controlled by the routine 
IGSET using the options BARO and BARW respectively.
}
\DEFOPT{*}{\par
A star is plotted at every point.
}
\DEFOPT{P}{\par
A marker is plotted at every point, according to current marker type and 
polymarker colour index.
}
\ENDOPT

   \par
Draw a curve through a set of points.  To set Log scales in X and/or Y, use 
   OPT LOGX/LOGY.  Note that when an option is specified, it is also necessary 
   to specify the options 'AW' or 'ALW' in order to start a new zone or/and 
   draw the axes.  

\ENDCMD
\DEFMENU{1}{ATTRIBUTES}{GRAPHICS/ATTRIBUTES}

Change HIGZ attributes.  

\DEFCMD{GA}{SLN}{GRAPHICS/ATTRIBUTES}{SLN}{ [ iln ]}

\BEGARG
\DEFARG{ILN}{I}{Line style}{ D=1 R=1:}
\ENDARG

   \par
Set the line style (IGSET LTYP can also be used).  

\ENDCMD

\DEFCMD{GA}{SFAIS}{GRAPHICS/ATTRIBUTES}{SFAIS}{ [ ints ]}

\BEGARG
\DEFARG{INTS}{I}{Fill area interior style}{ D=0 R=0:3}
\ENDARG

   \par
Set the fill area interior style (IGSET FAIS can also be used):  
\begin{verbatim}
    Hollow=0, Solid=1, Pattern=2, Hatch=3
\end{verbatim}

\ENDCMD

\DEFCMD{GA}{SFASI}{GRAPHICS/ATTRIBUTES}{SFASI}{ [ styli ]}

\BEGARG
\DEFARG{STYLI}{I}{Fill area style index}{ D=1}
\ENDARG

   \par
Set the fill area style index (IGSET FASI can also be used).  

\ENDCMD

\DEFCMD{GA}{SFACI}{GRAPHICS/ATTRIBUTES}{SFACI}{ [ ifaci ]}

\BEGARG
\DEFARG{IFACI}{I}{Fill area color index}{ D=1}
\ENDARG

   \par
Set the fill area color index (IGSET FACI can also be used).  

\ENDCMD

\DEFCMD{GA}{SPLCI}{GRAPHICS/ATTRIBUTES}{SPLCI}{ [ iplci ]}

\BEGARG
\DEFARG{IPLCI}{I}{Polyline color index}{ D=1}
\ENDARG

   \par
Set the polyline color index (IGSET PLCI can also be used).  

\ENDCMD

\DEFCMD{GA}{SPMCI}{GRAPHICS/ATTRIBUTES}{SPMCI}{ [ ipmci ]}

\BEGARG
\DEFARG{IPMCI}{I}{Polymarker color index}{ D=1}
\ENDARG

   \par
Set the polymarker color index (IGSET PMCI can also be used).  

\ENDCMD

\DEFCMD{GA}{STXCI}{GRAPHICS/ATTRIBUTES}{STXCI}{ [ itxci ]}

\BEGARG
\DEFARG{ITXCI}{I}{Text color index}{ D=1}
\ENDARG

   \par
Set the text color index (IGSET TXCI can also be used).  

\ENDCMD

\DEFCMD{GA}{STXFP}{GRAPHICS/ATTRIBUTES}{STXFP}{ [ ifont iprec ]}

\BEGARG
\DEFARG{IFONT}{I}{Font number}{ D=0}
\DEFARG{IPREC}{I}{Font precision}{ D=2}
\ENDARG

   \par
Set text font and precision (IGSET TXFP can also be used).  

\ENDCMD

\DEFCMD{GA}{SCHH}{GRAPHICS/ATTRIBUTES}{SCHH}{ [ chh ]}

\BEGARG
\DEFARG{CHH}{R}{Character height}{ D=0.28}
\ENDARG

   \par
Set the character height (IGSET CHHE can also be used).  

\ENDCMD

\DEFCMD{GA}{SLWSC}{GRAPHICS/ATTRIBUTES}{SLWSC}{ [ lw ]}

\BEGARG
\DEFARG{LW}{R}{Line width}{ D=1 R=1:}
\ENDARG

   \par
Set the line width scale factor (IGSET LWID can also be used).  

\ENDCMD

\DEFCMD{GA}{SMK}{GRAPHICS/ATTRIBUTES}{SMK}{ [ mkt ]}

\BEGARG
\DEFARG{MKT}{I}{Marker type}{ D=1}
\ENDARG

   \par
Set the marker type (IGSET MTYP can also be used).  

\ENDCMD

\DEFCMD{GA}{COLORT}{GRAPHICS/ATTRIBUTES}{COLOR\_TABLE}{ icol [ red green blue ]}

\BEGARG
\DEFARG{ICOL}{I}{Color Index}{ D=1}
\DEFARG{RED}{R}{Weight of red}{ D=0. R=0.:1.}
\DEFARG{GREEN}{R}{Weight of green}{ D=0. R=0.:1.}
\DEFARG{BLUE}{R}{Weight of blue}{ D=0. R=0.:1.}
\ENDARG

   \par
Define the color ICOL.  

\ENDCMD

\DEFCMD{GA}{PALETT}{GRAPHICS/ATTRIBUTES}{PALETTE}{ palnb [ nel list ]}

\BEGARG
\DEFARG{PALNB}{I}{Palette number}{ D=0 R=0:9}
\DEFARG{NEL}{I}{Number of elements in the palette}{ D=0 R=0:50}
\DEFARG{LIST}{I}{List of the palette elements}{ D=0}
\ENDARG

   \par
Define a palette of attributes.  The palette number is used in the command 
   SET. The command SET HCOL 0.1 defines the palette number 1 as colour 
   indices used by the command LEGO in case of stacked lego plots and plotting 
   of SURFACE with options 1 or 2, LEGO with option 2 and CONTOUR with option 
   3.  

   \par
By default the palettes are initialized with 6 elements:  2,3,4,5,6,7.  

   \par
If the number of elements (NEL) is equal to 0 (default), the palette is 
   filled automatically according to the number of colours defined with the 
   command IGSET NCOL:  

\begin{verbatim}
    a) If NCOL is smaller or equal to 8, the palette is filled with a
       subset of the 8 basic colours.
       Examples:
       PAW > IGSET NCOL 8      | Define the number of colours
       PAW > PALETTE 1         | The palette 1 is filled with
                               | 8 elements: 0,5,7,3,6,2,4,1
       PAW > IGSET NCOL 4      | Define the number of colours
       PAW > PALETTE 1         | The palette 1 is filled with
                               | 4 elements: 0,5,7,3
\end{verbatim}
\begin{verbatim}
    b) If NCOL is greater than 8, the palette is filled
       with colours varying continuously from blue to red. This is
       called a "geographical palette".
       Examples:
       PAW > IGSET NCOL 16     | Define the number of colours
       PAW > PALETTE 1         | Fill palette 1 with 8 elements
                               | (8,9,10,11,12,13,14,15) varying
                               | continuously from blue to red
       Note that after the command IGSET NCOL, the color indices from
       8 to NCOL are set with gray levels. The command PALETTE 1
       reset the same indices with a "geographical palette" varying
       continuously from blue to red.
\end{verbatim}

\ENDCMD
\DEFMENU{1}{HPLOT}{GRAPHICS/HPLOT}
Draw various HPLOT objects (symbols, errors, key, etc.).  

\DEFCMD{GH}{SYMBOL}{GRAPHICS/HPLOT}{SYMBOLS}{ x y n [ isymb ssize ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{N}{I}{Number of points}{ D=1}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{SSIZE}{R}{Symbol size}{ D=0.28}
\ENDARG

   \par
Draw the same symbol at several points x,y in the current normalization 
   transformation.  

\ENDCMD

\DEFCMD{GH}{ERRORS}{GRAPHICS/HPLOT}{ERRORS}{ x y ex ey n [ isymb ssize chopt ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{EX}{C}{Vector of X error bars}{}
\DEFARG{EY}{C}{Vector of Y error bars}{}
\DEFARG{N}{I}{Number of points}{ D=1}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{SSIZE}{R}{Symbol size}{ D=0.28}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Coordinates are expressed in histogram coordinates (of the last drawn 
histogram). Error bars are drawn.
}
\DEFOPT{C}{\par
Coordinates are expressed in centimeters.
}
\DEFOPT{W}{\par
A new window is defined and axis are drawn.
}
\DEFOPT{0}{\par
Draw the error bars (default).
}
\DEFOPT{1}{\par
Draw small lines at the end of the error bars.
}
\DEFOPT{2}{\par
Draw error rectangles.
}
\DEFOPT{3}{\par
Draw a filled area through the end points of the vertical error bars.
}
\DEFOPT{4}{\par
Draw a smoothed filled area through the end points of the vertical error bars.
}
\ENDOPT

   \par
Draw (according to the CHOPT value) a series of points using a symbol and 
   error bars in horizontal and vertical direction in the current 
   normalization transformation.  If ISYMB = 0 or SSIZE = 0. no symbol is 
   drawn.  Note that the options can be cumulated.  

\ENDCMD

\DEFCMD{GH}{AERROR}{GRAPHICS/HPLOT}{AERRORS}{ x y exl exu eyl eyu n [ isymb ssize chopt ]}

\BEGARG
\DEFARG{X}{C}{Vector of X coordinates}{}
\DEFARG{Y}{C}{Vector of Y coordinates}{}
\DEFARG{EXL}{C}{Vector of X error bars (Low)}{}
\DEFARG{EXU}{C}{Vector of X error bars (Up)}{}
\DEFARG{EYL}{C}{Vector of Y error bars (Low)}{}
\DEFARG{EYU}{C}{Vector of Y error bars (Up)}{}
\DEFARG{N}{I}{Number of points}{ D=1}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{SSIZE}{R}{Symbol size}{ D=0.28}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Coordinates are expressed in histogram coordinates (of the last drawn 
histogram). Error bars are drawn.
}
\DEFOPT{C}{\par
Coordinates are expressed in centimeters.
}
\DEFOPT{W}{\par
A new window is defined and axis are drawn.
}
\DEFOPT{0}{\par
Draw the error bars (default).
}
\DEFOPT{1}{\par
Draw small lines at the end of the error bars.
}
\DEFOPT{2}{\par
Draw error rectangles.
}
\DEFOPT{3}{\par
Draw a filled area through the end points of the vertical error bars.
}
\DEFOPT{4}{\par
Draw a smoothed filled area through the end points of the vertical error bars.
}
\ENDOPT

   \par
Draw (according to the CHOPT value) a series of points using a symbol and 
   asymmetric error bars in horizontal and vertical direction in the current 
   normalization transformation.  If ISYMB = 0 or SSIZE = 0. no symbol is 
   drawn.  Note that the options can be cumulated.  

\ENDCMD

\DEFCMD{GH}{KEY}{GRAPHICS/HPLOT}{KEY}{ x y [ isymb text ]}

\BEGARG
\DEFARG{X}{R}{X coordinate of comment}{}
\DEFARG{Y}{R}{Y coordinate of comment}{}
\DEFARG{ISYMB}{I}{Symbol number}{ D=24}
\DEFARG{TEXT}{C}{Legend}{ D=\EMPTY{}}
\ENDARG

   \par
Draw one symbol and its explanation (legend) at a point x,y in the current 
   normalization transformation.  

\ENDCMD

\DEFCMD{GH}{TICKS}{GRAPHICS/HPLOT}{TICKS}{ [ chopt xval yval ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\DEFARG{XVAL}{R}{X position}{ D=1.E30}
\DEFARG{YVAL}{R}{Y position}{ D=1.E30}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Tick marks are drawn on the edges of the picture
}
\DEFOPT{X}{\par
Cross-wire drawn perpendicular to the X-axis
}
\DEFOPT{Y}{\par
Cross-wire drawn perpendicular to the Y-axis
}
\DEFOPT{A}{\par
Value drawn Above cross-wire
}
\DEFOPT{B}{\par
Value drawn Below cross-wire
}
\DEFOPT{L}{\par
Value drawn Left of cross-wire
}
\DEFOPT{R}{\par
Value drawn Right of cross-wire
}
\ENDOPT

   \par
Draw 'cross-wires' on a picture, optionally with tick marks and values.  
   Cross-wires are lines perpendicular to the X and/or Y axis.  
\begin{verbatim}
    XVAL intersection on the X-axis
    YVAL intersection on the Y-axis
\end{verbatim}
   \par
The values of XVAL are always histogram coordinates.  The tick marks will 
   be drawn on both side of the cross wire, unless the cross-wires are 
   requested on the boundary of the box surrounding the histogram (i.e. at the 
   extreme limits of the drawn histogram). In this case tick marks will only 
   be drawn inside the box.  The options 'A' and 'B' (for Above and Below) 
   refer only to the cross-wire perpendicular to the Y axis.  In each case 
   only one cross-wire will be drawn.  Similarly 'L' and 'R' (Left and Right) 
   refer only to the cross-wires perpendicular to the X-axis.  It is possible 
   to redefine the length of tick marks on the X or Y axis with SET XTIC or 
   SET YTIC.  The position of the axis values may be changed with SET XVAL or 
   SET YVAL.  

\ENDCMD

\DEFCMD{GH}{ATITLE}{GRAPHICS/HPLOT}{ATITLE}{ [ xtit ytit ]}

\BEGARG
\DEFARG{XTIT}{C}{X Axis title}{ D=\EMPTY{}}
\DEFARG{YTIT}{C}{Y Axis title}{ D=\EMPTY{}}
\ENDARG

   \par
Draw axis titles on the axes of the present plot zone.  

\ENDCMD

\DEFCMD{GH}{GRID}{GRAPHICS/HPLOT}{GRID}{}

   \par
Draw a grid in cm.  

\ENDCMD

\DEFCMD{GH}{NULL}{GRAPHICS/HPLOT}{NULL}{ [ xmin xmax ymin ymax chopt ]}

\BEGARG
\DEFARG{XMIN}{R}{Low range in X}{ D=0.}
\DEFARG{XMAX}{R}{High range in X}{ D=1.}
\DEFARG{YMIN}{R}{Low range in Y}{ D=0.}
\DEFARG{YMAX}{R}{High range in Y}{ D=1.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Draw a frame box only.
}
\DEFOPT{S}{\par
Redefine the scale for the current zone.
}
\DEFOPT{A}{\par
Axis labels and tick marks are not drawn.
}
\DEFOPT{B}{\par
The box is not drawn.
}
\ENDOPT

   \par
Draw a frame box.  If XMIN, XMAX, etc. are given, draw a frame box with the 
   window coordinates set to XMIN, XMAX, YMIN, YMAX. Axis labels and tick 
   marks are drawn by default.  

\ENDCMD
\DEFMENU{0}{PICTURE}{PICTURE}

Creation and manipulation of HIGZ pictures.  

\DEFCMD{P}{FILE}{PICTURE}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in words}{ D=1024}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Existing file is opened.
}
\DEFOPT{N}{\par
A new file is opened.
}
\DEFOPT{U}{\par
Existing file is modified.
}
\DEFOPT{A}{\par
Automatic saving.
}
\ENDOPT

   \par
Open a HIGZ direct access picture file.  If CHOPT='AU' or 'AN', pictures 
   will be automatically saved on the direct access file. This automatic 
   saving facility can be switched off using IGSET AURZ 0.  

\ENDCMD

\DEFCMD{P}{LIST}{PICTURE}{LIST}{}

   \par
List all the HIGZ pictures currently stored in memory.  

\ENDCMD

\DEFCMD{P}{CREATE}{PICTURE}{CREATE}{ pname}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ Loop}
\ENDARG

   \par
Create a new picture, named PNAME, in memory.  Note that all commands which 
   start a new picture (clear workstation) automatically create pictures named 
   PICT1, PICT2, etc.  if the command OPTION ZFL or OPTION ZFL1 has been 
   executed.  

\ENDCMD

\DEFCMD{P}{DELETE}{PICTURE}{DELETE}{ pname}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Delete the picture PNAME from memory.  PNAME='*' means all pictures.  

\ENDCMD

\DEFCMD{P}{SCRATC}{PICTURE}{SCRATCH}{ pname [ icycle ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\DEFARG{ICYCLE}{I}{Cycle number }{ D=9999}
\ENDARG

   \par
Delete the picture PNAME from current directory on disk.  

\ENDCMD

\DEFCMD{P}{PLOT}{PICTURE}{PLOT}{ [ pname ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Plot the picture PNAME.  PNAME=' ' means the current picture.  PNAME='*' 
   means all pictures.  

\ENDCMD

\DEFCMD{P}{MODIFY}{PICTURE}{MODIFY}{ [ pname chopt ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{S}{\par
Software characters are used for the text in menus.
}
\DEFOPT{A}{\par
The option shadow is used.
}
\ENDOPT

   \par
Edit the picture PNAME.  PNAME=' ' means the current picture.  This command 
   is only available on workstations.  

\ENDCMD

\DEFCMD{P}{MERGE}{PICTURE}{MERGE}{ pname [ x y scale chopt ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{}
\DEFARG{X}{R}{X coordinates (NDC) where to draw PNAME}{ D=0}
\DEFARG{Y}{R}{Y coordinates (NDC) where to draw PNAME}{ D=0}
\DEFARG{SCALE}{R}{Scale factor}{ D=1.}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Merge the picture PNAME with the current picture.
}
\DEFOPT{D}{\par
Picture PNAME is displayed during merging.
}
\ENDOPT

   \par
Add the picture PNAME to the current picture.  

\ENDCMD

\DEFCMD{P}{COPY}{PICTURE}{COPY}{ pname1 pname2}

\BEGARG
\DEFARG{PNAME1}{C}{Picture name}{}
\DEFARG{PNAME2}{C}{New picture name}{ Loop}
\ENDARG

   \par
Copy a picture.  

\ENDCMD

\DEFCMD{P}{RENAME}{PICTURE}{RENAME}{ pname1 pname2}

\BEGARG
\DEFARG{PNAME1}{C}{Old picture name}{}
\DEFARG{PNAME2}{C}{New picture name}{}
\ENDARG

   \par
Rename a picture.  

\ENDCMD

\DEFCMD{P}{PRINT}{PICTURE}{PRINT}{ [ file ]}

\BEGARG
\DEFARG{FILE}{C}{File name}{ D=\EMPTY{}}
\ENDARG

   \par
Print the current picture.  The current picture is transformed into a 
   printable file.  The file type is defined according to the extension of the 
   file name i.e.  

\begin{verbatim}
      FILE = filename.ps    A PostScript file is generated (-111)
      FILE = filename.eps   A Encapsulated PostScript file
                            is generated (-113)
      FILE = filename.tex   A LaTex file is generated (-778)
\end{verbatim}
   \par
Do HELP META for details about the metafile types.  Note that a new picture 
   is automatically created for each new plot if the OPTION ZFL1 is on.  

   \par
If FILE=HIGZPRINTER or FILE=' ' the PostScript file paw.ps (-111) is 
   generated and the operating system command defined by the environment 
   variable HIGZPRINTER is executed.  

   \par
The environment variable HIGZPRINTER should be defined as follow:  
\begin{verbatim}
      On UNIX sytems:
             setenv HIGZPRINTER 'lp -dprinter_name paw.ps'
        or
             export HIGZPRINTER='lp -dprinter_name paw.ps'
      On VAX/VMS sytems:
             HIGZPRINTER == "XPRINT paw.ps /PRINTER=printer_name"
      On CERNVM:
             setenv HIGZPRINTER 'XPRINT PAW PS (PR printer_name'
\end{verbatim}
\ENDVERB
   \par
Note that if the environment variable HIGZPRINTER is not defined the file 
   paw.ps is created but not printed.  

\ENDCMD

\DEFCMD{P}{IZOUT}{PICTURE}{IZOUT}{ [ pname ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ D=\EMPTY{} Loop}
\ENDARG

   \par
Write the picture PNAME to a direct access picture file (see command 
   PICTURE/FILE).  PNAME=' ' means the current picture.  PNAME='*' means all 
   pictures.  

\ENDCMD

\DEFCMD{P}{IZIN}{PICTURE}{IZIN}{ pname [ icycle ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{ Loop}
\DEFARG{ICYCLE}{I}{Cycle number }{ D=9999}
\ENDARG

   \par
Read picture into memory from a direct access picture file.  (see command 
   PICTURE/FILE).  PNAME='*' means all pictures.  

\ENDCMD

\DEFCMD{P}{IZPICT}{PICTURE}{IZPICT}{ pname [ chopt ]}

\BEGARG
\DEFARG{PNAME}{C}{Picture name}{}
\DEFARG{CHOPT}{C}{Options}{ D='M'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{M}{\par
Make a new picture in memory with name PNAME. An empty structure is created in 
memory and becomes the current picture. If PNAME = ' ', the picture is 
automatically named as PICTnnn, where the starting value of nnn is either 0 
(default), or the value assigned by IGSET to the parameter PICT.
}
\DEFOPT{D}{\par
Display the picture PNAME in memory.
}
\DEFOPT{S}{\par
Scratch the picture PNAME from memory. If PNAME = ' ' the current picture is 
scratched.
}
\DEFOPT{N}{\par
The picture following the current picture in memory becomes the current 
picture. If the current picture is the last one in memory, the first picture 
in memory becomes the current picture.
}
\DEFOPT{L}{\par
Give the list of the pictures in memory, following the sequence of their 
storage in memory.
}
\DEFOPT{F}{\par
The First picture in memory becomes the current picture.
}
\DEFOPT{P}{\par
Print the picture data structure. Useful to debug programs.
}
\DEFOPT{C}{\par
Set Current picture. All calls to HIGZ graphic functions are stored in the 
current structure according to the option selected be IGZSET.
}
\ENDOPT

   \par
Perform various operations on a picture.  PNAME=' ' means the current 
   picture.  PNAME='*' means all pictures.  

\ENDCMD

\DEFCMD{P}{SWITCH}{PICTURE}{SWITCH}{ [ chopt ]}

\BEGARG
\DEFARG{CHOPT}{C}{Options}{ D='G'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{G}{\par
graphics output only.
}
\DEFOPT{Z}{\par
Graphics primitives stored in ZEBRA memory only.
}
\ENDOPT

   \par
Set the graphics switch to control plotting output to terminal (G) and/or 
   picture in memory (Z).  

\ENDCMD

\DEFCMD{P}{IGSET}{PICTURE}{IGSET}{ [ chatt value ]}

\BEGARG
\DEFARG{CHATT}{C}{Attribute name}{ D='SHOW'}
\DEFARG{VALUE}{R}{Attribute value}{ D=0.}
\ENDARG

   \par
Set a HIGZ attribute.  If CHATT='SHOW' print default and current values for 
   all attributes.  If CHATT='*' restore default values for all attributes.  
   If VALUE=0, the attribute is set to its default value.  

\begin{verbatim}
 +-----------------------------------------------------------------------------+
 |                        IGSET : Current values in use                        |
 +-------------+---------------+---------------+-------------------------------+
 |  Parameter  | Current value | Default value |          Explanation          |
 +-------------+---------------+---------------+-------------------------------+
 |    FAIS     |       0       |        0      | Fill area interior style      |
 |    FASI     |       1       |        1      | Fill area style index         |
 |    LTYP     |       1       |        1      | Line type                     |
 |    BASL     |        .150   |         .010  | Basic segment length (NDC)    |
 |    LWID     |       1.000   |        1.000  | Line width                    |
 |    MTYP     |       1       |        1      | Marker type                   |
 |    MSCF     |       1.000   |        1.000  | Marker scale factor           |
 |    PLCI     |       1       |        1      | Polyline color index          |
 |    PMCI     |       1       |        1      | Polymarker color index        |
 |    FACI     |       1       |        1      | Fill area color index         |
 |    TXCI     |       1       |        1      | Text color index              |
 |    TXAL     |       0  0    |        0  0   | Text alignment                |
 |    CHHE     |        .280   |         .010  | Character height              |
 |    TANG     |        .000   |         .000  | Text angle                    |
 |    TXFP     |       0  2    |        0  2   | Text font and precision       |
 |    PICT     |       1       |        1      | Current automatic number      |
 |    BORD     |       0       |        0      | Border flag                   |
 |    PASS     |       1       |        1      | Number of pass in IGTEXT      |
 |    CSHI     |        .030   |         .020  | IGTEXT shift                  |
 |    LASI     |        .018   |         .018  | Label axis size               |
 |    LAOF     |        .013   |         .013  | Label axis offset             |
 |    TMSI     |        .019   |         .019  | Tick marks size               |
 |    AWLN     |        .000   |         .000  | Axis wire lenght              |
 |    BARO     |        .250   |         .250  | Offset of IGHIST (IGRAPH) bars|
 |    BARW     |        .500   |         .500  | Width of IGHIST (IGRAPH) bars |
 |    NCOL     |       8       |        8      | Number of COLors              |
 |    CLIP     |       1       |        1      | Clipping mode                 |
 |    NLIN     |      40       |       40      | Number of line for 3D shapes  |
 |    AURZ     |       0       |        0      | Automatic saving flag         |
 |    DIME     |       2       |        2      | Dimension used (2D or 3D)     |
 +-------------+---------------+---------------+-------------------------------+
\end{verbatim}
\ENDCMD
\DEFMENU{0}{ZEBRA}{ZEBRA}

Interfaces to the ZEBRA RZ, FZ and DZ packages.  

\DEFMENU{1}{RZ}{ZEBRA/RZ}

ZEBRA/RZ package: direct access Input/Output.  

\DEFCMD{ZR}{FILE}{ZEBRA/RZ}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in WORDS}{ D=1024}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
Read only mode.
}
\DEFOPT{U}{\par
Update mode.
}
\ENDOPT

   \par
Open an existing direct access file.  

\ENDCMD

\DEFCMD{ZR}{MAKE}{ZEBRA/RZ}{MAKE}{ lun fname [ lrecl nrec nwkey chform chtags ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in WORDS}{ D=1024}
\DEFARG{NREC}{I}{Number of records}{ D=1000}
\DEFARG{NWKEY}{I}{Number of words per Key}{ D=1}
\DEFARG{CHFORM}{C}{Key format}{ D='I' R='I,B,A,H'}
\DEFARG{CHTAGS}{C}{List of Tags}{ D='HBOOK-ID'}
\ENDARG

   \par
Open a new direct access file.  

\ENDCMD

\DEFCMD{ZR}{MDIR}{ZEBRA/RZ}{MDIR}{ chdir [ nwkey chform chtags ]}

\BEGARG
\DEFARG{CHDIR}{C}{Directory name}{}
\DEFARG{NWKEY}{I}{Number of words per Key}{ D=1}
\DEFARG{CHFORM}{C}{CHFORM}{ D='I'}
\DEFARG{CHTAGS}{C}{List of Tags}{ D='HBOOK-ID'}
\ENDARG

   \par
Create a new RZ directory below the current directory.  

\ENDCMD

\DEFCMD{ZR}{DDIR}{ZEBRA/RZ}{DDIR}{ chdir}

\BEGARG
\DEFARG{CHDIR}{C}{Directory name}{}
\ENDARG

   \par
Delete the directory CHDIR from the current directory.  

\ENDCMD

\DEFCMD{ZR}{LDIR}{ZEBRA/RZ}{LDIR}{ [ chpath chopt ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{\EMPTY}{\par
List contents of a directory.
}
\DEFOPT{A}{\par
List all the Ntuple extensions.
}
\DEFOPT{T}{\par
List a directory Tree.
}
\ENDOPT

   \par
List contents of a directory (memory or disk).  To list all RZ files 
   currently opened, type 'LD //'.  Note that if the Current Directory is 
   //PAWC, this command uses the same format as HISTO/LIST.  

\ENDCMD

\DEFCMD{ZR}{CDIR}{ZEBRA/RZ}{CDIR}{ [ chpath chopt ]}

\BEGARG
\DEFARG{CHPATH}{C}{Path name}{ D=\EMPTY{}}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Change the current working directory (CWD).  IF CHPATH is given make it the 
   new CWD.  Otherwise, print the pathname of the CWD.  
\begin{verbatim}
    Ex.  CD dir1         ; make DIR1 the new CWD
         CD //file1/dir2 ; make //FILE1/DIR2 the new CWD
         CD              ; print the name of the CWD
\end{verbatim}

\ENDCMD

\DEFCMD{ZR}{PURGE}{ZEBRA/RZ}{PURGE}{ [ keep ]}

\BEGARG
\DEFARG{KEEP}{I}{Number of cycles to be kept}{ D=1}
\ENDARG

   \par
Purge an RZ directory.  

\ENDCMD

\DEFCMD{ZR}{LOCK}{ZEBRA/RZ}{LOCK}{ [ chlock ]}

\BEGARG
\DEFARG{CHLOCK}{C}{Lock identifier}{ D='RZFILE'}
\ENDARG

   \par
Lock an RZ directory.  

\ENDCMD

\DEFCMD{ZR}{FREE}{ZEBRA/RZ}{FREE}{ [ chlock ]}

\BEGARG
\DEFARG{CHLOCK}{C}{Lock identifier}{ D='RZFILE'}
\ENDARG

   \par
Free an RZ directory.  

\ENDCMD

\DEFCMD{ZR}{STAT}{ZEBRA/RZ}{STAT}{ chpath}

\BEGARG
\DEFARG{CHPATH}{C}{Name of top directory}{}
\ENDARG

   \par
Print space statistics for an RZ file.  

\ENDCMD
\DEFMENU{1}{FZ}{ZEBRA/FZ}

ZEBRA/FZ package: sequential access Input/Output.  

\DEFCMD{ZF}{FILE}{ZEBRA/FZ}{FILE}{ lun fname [ lrecl chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\DEFARG{FNAME}{C}{File name}{}
\DEFARG{LRECL}{I}{Record length in words}{ D=900}
\DEFARG{CHOPT}{C}{Options}{ D='IX'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{I}{\par
Input file.
}
\DEFOPT{O}{\par
Output file.
}
\DEFOPT{X}{\par
Binary exchange mode.
}
\DEFOPT{A}{\par
Alphanumeric exchange mode.
}
\ENDOPT

   \par
Open an FZ sequential formatted or unformatted file.  

\ENDCMD

\DEFCMD{ZF}{TOFZ}{ZEBRA/FZ}{TOFZ}{ lun [ chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number of FZ file}{ R=1:128}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Copy the current directory tree onto an FZ file.  

\ENDCMD

\DEFCMD{ZF}{FRFZ}{ZEBRA/FZ}{FRFZ}{ lun [ chopt ]}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number of FZ file}{ R=1:128}
\DEFARG{CHOPT}{C}{Options}{ D=\EMPTY{}}
\ENDARG

   \par
Copy the FZ file into the current directory tree.  

\ENDCMD

\DEFCMD{ZF}{TOALPH}{ZEBRA/FZ}{TOALPHA}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{Name of the FZ text file}{}
\ENDARG

   \par
Copy the current directory tree onto a FZ file.  An alphanumeric format is 
   used.  The file FNAME can be exchanged between different machines.  

\ENDCMD

\DEFCMD{ZF}{FRALPH}{ZEBRA/FZ}{FRALPHA}{ fname}

\BEGARG
\DEFARG{FNAME}{C}{Name of the FZ text file}{}
\ENDARG

   \par
Copy the FZ alphanumeric file into the current directory.  

\ENDCMD
\DEFMENU{1}{DZ}{ZEBRA/DZ}

ZEBRA/DZ package: debugging.  

\DEFCMD{ZD}{SHOW}{ZEBRA/DZ}{SHOW}{ name [ number chopt ]}

\BEGARG
\DEFARG{NAME}{C}{Bank name}{}
\DEFARG{NUMBER}{I}{Bank number}{ D=1}
\DEFARG{CHOPT}{C}{Options}{ D='BSV'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{B}{\par
Print the bank.
}
\DEFOPT{S}{\par
Print the bank contents from left to right Sideways with up to ten elements 
per line.
}
\DEFOPT{V}{\par
Print the vertical (down) structure.
}
\DEFOPT{D}{\par
Print the bank contents from top to bottom Downwards with five elements per 
line.
}
\DEFOPT{L}{\par
Print the linear structure.
}
\DEFOPT{Z}{\par
Print the data part of each bank in hexadecimal format
}
\ENDOPT

   \par
Display the contents of a bank or a data structure identified by its NAME 
   and NUMBER.  The output format of the data part is controlled by the 
   internal or external I/O characteristic.  

\ENDCMD

\DEFCMD{ZD}{SURV}{ZEBRA/DZ}{SURV}{ name [ number ]}

\BEGARG
\DEFARG{NAME}{C}{Bank name}{}
\DEFARG{NUMBER}{I}{Bank number}{ D=1}
\ENDARG

   \par
Print a survey of the structure identified by NAME, NUMBER.  

\ENDCMD

\DEFCMD{ZD}{SNAP}{ZEBRA/DZ}{SNAP}{ [ idiv chopt ]}

\BEGARG
\DEFARG{IDIV}{I}{Division number }{ D=2 R=0:24}
\DEFARG{CHOPT}{C}{Options}{ D='M'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{M}{\par
Print Map entry for each bank
}
\DEFOPT{E}{\par
Extend map entry to dump all links of each bank (otherwise only as many links 
as will fit on a line)
}
\DEFOPT{F}{\par
Full. Dump all active banks, links and data
}
\DEFOPT{K}{\par
Kill. Dropped banks to be treated as active (dropped banks are not normally 
dumped under D or F option)
}
\DEFOPT{L}{\par
Dump all Link areas associated with the store
}
\DEFOPT{W}{\par
Dump the Working space, links and data
}
\DEFOPT{Z}{\par
Dump the information in hexadecimal.
}
\ENDOPT

   \par
Snap of one or more divisions.  Provides a snapshot of one or more 
   divisions in a ZEBRA store.  The kind of information provided is controlled 
   by CHOPT.  

\ENDCMD

\DEFCMD{ZD}{VERIFY}{ZEBRA/DZ}{VERIFY}{ [ idiv chopt ]}

\BEGARG
\DEFARG{IDIV}{I}{Division number }{ D=0 R=0:24}
\DEFARG{CHOPT}{C}{Options}{ D='CLSU'}
\ENDARG
\BEGOPT{CHOPT}
\DEFOPT{C}{\par
Check chaining of banks only
}
\DEFOPT{L}{\par
Check validity of the structural links (implies 'C')
}
\DEFOPT{S}{\par
Check the store parameters
}
\DEFOPT{U}{\par
Check the validity of the up and origin (implies 'C')
}
\DEFOPT{F}{\par
Errors are considered fatal and generate a call to ZFATAL
}
\ENDOPT

   \par
Check the structure of one or more ZEBRA divisions.  The verification 
   detail depends on the settings in CHOPT.  

\ENDCMD

\DEFCMD{ZD}{STORE}{ZEBRA/DZ}{STORE}{ [ ixstor ]}

\BEGARG
\DEFARG{IXSTOR}{I}{Store number}{ D=0 R=0:24}
\ENDARG

   \par
Display the structure of the ZEBRA store IXSTOR.  Output the parameters 
   characterizing the store, followed by a list of all divisions and all link 
   areas associated with the store in question.  

\ENDCMD
\DEFMENU{0}{FORTRAN}{FORTRAN}

Interface to MINUIT, COMIS, SIGMA and FORTRAN Input/Output.  

\DEFCMD{F}{HMINUI}{FORTRAN}{HMINUIT}{}

   \par
To input commands for Interactive MINUIT in a macro.  Example:  
\begin{verbatim}
    Application HMINUIT EXIT
    SET EPS 1.E-14
    MIGRAD
    SET PRIN 2
    MINOS
    EXIT
    Histo/fit 10 g m
\end{verbatim}

\ENDCMD

\DEFCMD{F}{COMIS}{FORTRAN}{COMIS}{}

   \par
Invoke the COMIS FORTRAN interpreter.  COMIS allows to execute FORTRAN 
   routines without recompiling and relinking. It communicates with PAW 
   commands through vectors and functions. COMIS has its PAW-independent 
   command structure.  Example in command mode:  
\begin{verbatim}
    PAW > Comis
    CS >    do 10 i=1,10
    MND>       x=sqrt(i)*10.
    MND>       print *,i,x
    MND> 10 continue
    MND>    END
    CS > quit
    PAW >
\end{verbatim}
   \par
COMIS code may be inserted into a macro. Example:  
\begin{verbatim}
    Vector/Create Y(10) r 1 2 3 4 5 6 7 8 9 10
    *
    *  In the following COMIS code, the statement "Vector Y" declares
    *  to COMIS an existing KUIP vector. KUIP dimension is assumed.
    *  The statement "Vector X(10)" creates a new KUIP vector.
    *  (Note that SUBROUTINEs must be declared before the MAIN program)
    *  (KUIP vectors cannot be created into the MAIN program)
    *
    APPLIcation COMIS QUIT
          SUBROUTINE DEMO
          Vector Y
          Vector X(10)
          do 10 i=1,10
             XX=i
             X(i)=Y(i)*sqrt(XX)*10.
      10  CONTINUE
          END
          CALL DEMO
          END
    QUIT
    Vector/print X       | Print KUIP vector created by COMIS
\end{verbatim}

\ENDCMD

\DEFCMD{F}{CALL}{FORTRAN}{CALL}{ urout}

\BEGARG
\DEFARG{UROUT}{C}{User routine}{}
\ENDARG

   \par
Execute the routine UROUT.  UROUT may be a routine compiled and linked with 
   PAW.  For example : CALL HPRINT(10).  UROUT may also be the name of a file 
   which can be edited interactively with the command EDIT. For example if 
   file UROUT.FOR contains:  
\begin{verbatim}
        SUBROUTINE UROUT(N)
        SUM=0.
        DO 10 I=1,N
          SUM=SUM+I
     10 CONTINUE
        PRINT *,SUM
        END
\end{verbatim}
   \par
Then one can type CALL UROUT.FOR(10). The routine UROUT may also contains 
   references to the library routines mentioned below.  The following routines 
   from the CERN Program Library can be called:  

\begin{verbatim}
   From HBOOK:
      HBOOK1,HBOOK2,HBOOKN,HFILL,HF1,HPRINT,HDELET,HRESET
      HFITGA,HFITPO,HFITEX,HPROJ1,HPROJ2,HFN,HGFIT
      HROPEN,PAOPEN,PACLOS,PAREAD,PAWRIT,HCDIR,HGIVEN
      HTITLE,HBFUN1,HBFUN2,HRNDM1,HRNDM2,HBARX,HBARY
      HPAK,HPAKE,HUNPAK,HGIVE,HGN,HGNF,HGNPAR,HF2,HFF1,HFF2
      HRIN,HROUT,HI,HIE,HIX,HIJ,HIF,HIDALL,HNOENT,HX,HXY
      HTITLE,HCOPY,HSTATI,HBPROF,HOPERA,HIDOPT,HDERIV
      HMAXIM,HMINIM,HMAX,HMIN,HSUM,HNORMA,HREND
      HEXIST,HRGET,HRPUT,HSCR,HFIND,HCX,HCXY,HLABEL
      HBPROX,HBPROY,HBANDX,HBANDY,HBSLIX,HBSLIY,HPROF2
      HBOOKB,HBSTAT,HDIFF,HUNPKE,HREBIN,HERROR,HGNTB
      HOUTPU,HERMES,HISTDO,HFUNC,HIJXY,HXYIJ,HLPOS,HFC1
      HSPLI1,HSPLI2,HMDIR,HLDIR,HLOCAT,HFITH,HFITV,HFINAM
      HBNT,HBNAME,HBNAMC,HFNT,HFNTB,HGNT,HGNTF,HGNTV,HBSET
   From HPLOT:
      HPLOT,HPLSYM,HPLERR,HPLEGO,HPLNT,HPLSUR,HPLSOF,HPLFRA
      HPLABL,HPLSET,HPLGIV,HPLOC,HPLTOC,HPLNEW,HPLOPT
   From ZEBRA:
      FZIN,FZOUT,FZFILE,FZENDI,FZENDO
      RZCDIR,RZLDIR,RZFILE,RZEND,RZIN,RZOUT,RZVIN,RZVOUT
      RZOPEN,RZIODO,RZCLOS,RZQUOT
   From KUIP:
      KUGETV,KUDPAR,KUVECT,KILEXP,KUTIME,KUEXEL,KUPROS
      KUNWG,KUCMD,KUGUID,KUNDPV,KUPAR,KUPVAL,KUACT
   From HIGZ:
      IPL,IPM,IFA,IGTEXT,IGBOX,IGAXIS,IGPIE,IGRAPH,IGHIST
      IGARC,IGLBL,IGRNG,IGMETA,IGSA,IGSET,IRQLC,IRQST,ISCR
      ISELNT,ISFAIS,ISFASI,ISLN,ISMK,ISVP,ISWN,ITX,ICLRWK
      IGPAVE,IGTERM
   From KERNLIB:
      VZERO,UCOPY,RNDM,RANNOR,LENOCC,SBIT0,SBIT1,SBYT
      JBIT,JBYT,UCTOH,UHTOC,CLTOU,CUTOL,ERF,ERFC,FREQ
      PROB,DENLAN,DSTLAN,DIFLAN,XM1LAN,XM2LAN,RANLAN

   The following common blocks may be referenced:
     /PAWC/, /QUEST/, /KCWORK/, /PAWPAR/, /PAWIDN/
     /HCFITS/, /HCFITD/
\end{verbatim}
\ENDCMD

\DEFCMD{F}{LOOP}{FORTRAN}{LOOP}{ ntimes urout}

\BEGARG
\DEFARG{NTIMES}{I}{Number of calls}{ D=1}
\DEFARG{UROUT}{C}{User routine}{}
\ENDARG

   \par
The routine UROUT is called NTIMES times.  See command CALL for explanation 
   of UROUT.  

\ENDCMD

\DEFCMD{F}{FILE}{FORTRAN}{FILE}{ lun fname}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{}
\DEFARG{FNAME}{C}{File name}{}
\ENDARG

   \par
Open a FORTRAN formatted text file.  

\ENDCMD

\DEFCMD{F}{CLOSE}{FORTRAN}{CLOSE}{ lun}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\ENDARG

   \par
Close the file on unit LUN.  If the file has been opened with HISTO/FILE, 
   PICTURE/FILE, etc, then before closing the unit, PAW will close correctly 
   the file with CALL HREND or FZENDI(O), ICLWK, etc.  

\ENDCMD

\DEFCMD{F}{REWIND}{FORTRAN}{REWIND}{ lun}

\BEGARG
\DEFARG{LUN}{I}{Logical unit number}{ R=1:128}
\ENDARG

   \par
Rewind the file on unit LUN.  

\ENDCMD

\DEFCMD{F}{SIGMA}{FORTRAN}{SIGMA}{ [ expr ]}

\BEGARG
\DEFARG{EXPR}{C}{Expression}{ D=\EMPTY{}}
\ENDARG

   \par
Invoke the SIGMA package.  SIGMA is an array manipulation package using its 
   own vector-oriented language, outside the PAW command conventions.  SIGMA 
   may be invoked in one of the three following ways:  
\begin{verbatim}
    1- Using the KUIP $SIGMA function. Example:
       PAW > Vector/Create x(10) r 1 2 3 4 5 6 7 8 9 10
       PAW > Graph 10 x $sigma(sqrt(x))
\end{verbatim}
\begin{verbatim}
    2- Using the SIGMA command. Example:
       PAW > sigma x=array(10,1#10)
       PAW > sigma y=sqrt(x)
       PAW > Graph 10 x y
\end{verbatim}
\begin{verbatim}
    3- Using the APPLication command. Example:
       PAW > APPLication SIGMA
       SIGMA > x=array(10,1#10)
       SIGMA > y=sqrt(x)
       SIGMA > exit
       PAW > Graph 10 x y
\end{verbatim}

\ENDCMD
\DEFMENU{0}{NETWORK}{NETWORK}

To access files on remote computers.  To send messages to a remote process 
   (ZEBRA server) 

\DEFCMD{N}{RLOGIN}{NETWORK}{RLOGIN}{ host}

\BEGARG
\DEFARG{HOST}{C}{Host name}{ D=\EMPTY{}}
\ENDARG

   \par
Start a communication with a remote machine HOST.  Current Directory will 
   be changed to //HOST.  

\ENDCMD

\DEFCMD{N}{RSHELL}{NETWORK}{RSHELL}{ message}

\BEGARG
\DEFARG{MESSAGE}{C}{Message to remote host}{ D=\EMPTY{}}
\ENDARG

   \par
Send MESSAGE to current remote host.  Note that the Current Directory must 
   be //HOST (see RLOGIN).  Some PAW commands (Histo/Plot, Histo/List) can 
   communicate directly with HOST.  

\ENDCMD
\DEFMENU{1}{PIAF}{NETWORK/PIAF}

To establish and control the connection to the Piaf server.  The Parallel 
   Interactive Analysis Facility (Piaf) is a cluster of 5 high-performance HP 
   workstations.  

   \par
A locally running PAW session (client) connected to the Piaf server can 
   access Hbook RZ files stored on the server side in a transparent way.  
   Commands with high CPU or I/O requirements, e.g. NT/PLOT and NT/PROJECT are 
   processed by the server and only the resulting histograms etc. are sent 
   back to the client.  

   \par
In order to use the Piaf server the PAW client must have been compiled with 
   the communications option CZ using TCP/IP as transport protocol.  

\DEFCMD{NP}{CONNEC}{NETWORK/PIAF}{CONNECT}{ [ server node ]}

\BEGARG
\DEFARG{SERVER}{C}{Server name}{ D='piaf'}
\DEFARG{NODE}{C}{Front-end node}{ D='128.141.201.28'}
\ENDARG

   \par
Establish a connection to the Piaf server.  Subsequent HISTO/FILE commands 
   can refer to files on the server using path names '//piaf/file.hbook'.  

\ENDCMD

\DEFCMD{NP}{STAGE}{NETWORK/PIAF}{STAGE}{ source [ target option ]}

\BEGARG
\DEFARG{SOURCE}{C}{Source file identifier}{}
\DEFARG{TARGET}{C}{Target file name}{ D=\EMPTY{}}
\DEFARG{OPTION}{C}{Options}{ D=\EMPTY{}}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{N}{\par
NoWait. Submit the request to the staging system and return immediately.
}
\ENDOPT

   \par
Stage an Ntuple file on the Piaf server.  The source file identifier can be 
   the name of a local file on the client system, a Fatmen path, or a tape 
   identifier.  If the target file name is not specified it is constructed 
   from the source identifier.  

   \par
Unless the option N is used the STAGE command waits until the staging is 
   completed and the file is ready to be used.  

\ENDCMD

\DEFCMD{NP}{GET}{NETWORK/PIAF}{GET}{ remote [ local format recl ]}

\BEGARG
\DEFARG{REMOTE}{C}{Remote file name}{}
\DEFARG{LOCAL}{C}{Local file name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Text or binary}{ D='RZ'}
\DEFARG{RECL}{I}{Record length in bytes}{ D=0 R=0:}
\ENDARG
\BEGOPT{FORMAT}
\DEFOPT{T}{\par
Text file.
}
\DEFOPT{RZ}{\par
Zebra RZ file in exchange format.
}
\DEFOPT{BIN}{\par
Binary file with record length given by RECL.
}
\ENDOPT

   \par
Copy a file from the Piaf server to the client system.  If not specified 
   the local file name will be same as the remote file name.  RECL needs to be 
   specified only for BIN format.  For IBM only: A text file with RECL=0 is 
   written in V-format.  Otherwise it is written in F-format with the given 
   LRECL.  

\ENDCMD

\DEFCMD{NP}{PUT}{NETWORK/PIAF}{PUT}{ local [ remote format ]}

\BEGARG
\DEFARG{LOCAL}{C}{Local file name}{}
\DEFARG{REMOTE}{C}{Remote file name}{ D=\EMPTY{}}
\DEFARG{FORMAT}{C}{Text or binary}{ D='RZ'}
\ENDARG
\BEGOPT{FORMAT}
\DEFOPT{T}{\par
Text file.
}
\DEFOPT{RZ}{\par
Zebra RZ file in exchange format.
}
\DEFOPT{BIN}{\par
Binary file.
}
\ENDOPT

   \par
Copy a file from the client system to the Piaf server.  If not specified 
   the remote file name will be same as the local file name.  Note for VMS: 
   Avoid text files with variable record length.  Use Stream\_LF format 
   instead.  

\ENDCMD

\DEFCMD{NP}{LS}{NETWORK/PIAF}{LS}{ [ files ]}

\BEGARG
\DEFARG{FILES}{C}{File pattern}{ D=\EMPTY{}}
\ENDARG

   \par
List files stored on the Piaf server.  

\ENDCMD

\DEFCMD{NP}{CAT}{NETWORK/PIAF}{CAT}{ file}

\BEGARG
\DEFARG{FILE}{C}{File name}{}
\ENDARG

   \par
Print a Piaf file on the terminal.  

\ENDCMD

\DEFCMD{NP}{RM}{NETWORK/PIAF}{RM}{ file}

\BEGARG
\DEFARG{FILE}{C}{File name}{}
\ENDARG

   \par
Delete a Piaf file.  

\ENDCMD

\DEFCMD{NP}{MV}{NETWORK/PIAF}{MV}{ from to}

\BEGARG
\DEFARG{FROM}{C}{Old file name}{}
\DEFARG{TO}{C}{New file name}{}
\ENDARG

   \par
Rename a Piaf file.  

\ENDCMD

\DEFCMD{NP}{CP}{NETWORK/PIAF}{CP}{ from to}

\BEGARG
\DEFARG{FROM}{C}{Old file name}{}
\DEFARG{TO}{C}{New file name}{}
\ENDARG

   \par
Copy a Piaf file to a new file.  

\ENDCMD

\DEFCMD{NP}{STATUS}{NETWORK/PIAF}{STATUS}{}

   \par
Inquire the status of the Piaf server.  

\ENDCMD

\DEFCMD{NP}{MODE}{NETWORK/PIAF}{MODE}{ [ option ]}

\BEGARG
\DEFARG{OPTION}{C}{Processing mode}{ D='?'}
\ENDARG
\BEGOPT{OPTION}
\DEFOPT{?}{\par
Inquire the current mode.
}
\DEFOPT{SEQ}{\par
Set sequential processing mode.
}
\DEFOPT{PAR}{\par
Set parallel processing mode.
}
\ENDOPT

   \par
Inquire or change the processing mode of the Piaf server.  In parallel mode 
   the Piaf server uses slave servers to process Ntuple requests on all 
   available machines in parallel.  

   \par
With certain types of COMIS selection functions, e.g. when reading from an 
   external file for each event, parallel processing is not possible.  The 
   Piaf server should be switched to sequential mode, i.e. the master server 
   alone processes the Ntuple request.  

\ENDCMD

\DEFCMD{NP}{LOGLEV}{NETWORK/PIAF}{LOGLEVEL}{ level}

\BEGARG
\DEFARG{LEVEL}{I}{Log level}{ D=0}
\ENDARG

   \par
Set the level of diagnostic output from the Piaf server.  

\ENDCMD

\DEFCMD{NP}{DISCON}{NETWORK/PIAF}{DISCONNECT}{}

   \par
Close the connection to the Piaf server.  

\ENDCMD
\DEFMENU{0}{OBSOLETE}{OBSOLETE}

Obsolete commands.  
\DEFMENU{1}{HISTOGRAM}{OBSOLETE/HISTOGRAM}

\DEFMENU{2}{FIT}{OBSOLETE/HISTOGRAM/FIT}

Fitting and smoothing (1-Dim or 2-Dim) histograms.  Results are given as 
   histogram-associated functions, and fit parameters printed on screen.  

\DEFCMD{OHF}{EXPONE}{OBSOLETE/HISTOGRAM/FIT}{EXPONENTIAL}{ id [ isel iftlow iftup ]}

\BEGARG
\DEFARG{ID}{C}{histogram Identifier}{}
\DEFARG{ISEL}{I}{option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
\ENDARG

   \par
Fit histogram ID with an exponential function between channels IFTLOW and 
   IFTUP.  Obsolete command. Use Command Hist/Fit instead.  Control word ISEL 
   = 100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
\end{verbatim}

\ENDCMD

\DEFCMD{OHF}{GAUSS}{OBSOLETE/HISTOGRAM/FIT}{GAUSS}{ id [ isel iftlow iftup ]}

\BEGARG
\DEFARG{ID}{C}{histogram Identifier}{}
\DEFARG{ISEL}{I}{option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
\ENDARG

   \par
Fit histogram ID with a Gaussian between channels IFTLOW and IFTUP.  
   Obsolete command. Use Command Hist/Fit instead.  Control word ISEL = 
   100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
\end{verbatim}

\ENDCMD

\DEFCMD{OHF}{POLYNO}{OBSOLETE/HISTOGRAM/FIT}{POLYNOMIAL}{ id ncoeff [ isel iftlow iftup ]}

\BEGARG
\DEFARG{ID}{C}{histogram Identifier}{}
\DEFARG{NCOEFF}{I}{Number of coefficients}{ D=3}
\DEFARG{ISEL}{I}{option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
\ENDARG

   \par
Fit histogram ID with a polynomial between channels IFTLOW and IFTUP.  
   NCOEFF is the degree of the polynomial plus one.  Obsolete command. Use 
   Command Hist/Fit instead.  Control word ISEL = 100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
\end{verbatim}

\ENDCMD

\DEFCMD{OHF}{FUNCTI}{OBSOLETE/HISTOGRAM/FIT}{FUNCTION}{ id func np dpar [ isel iftlow iftup step pmin pmax ]}

\BEGARG
\DEFARG{ID}{C}{Histogram Identifier}{}
\DEFARG{FUNC}{C}{Function name}{}
\DEFARG{NP}{I}{Number of parameters}{}
\DEFARG{DPAR}{C}{Vector of parameters}{}
\DEFARG{ISEL}{I}{Option flag }{ D=12}
\DEFARG{IFTLOW}{I}{First channel}{ D=1}
\DEFARG{IFTUP}{I}{Last channel }{ D=99999}
\DEFARG{STEP}{C}{Vector of steps size}{}
\DEFARG{PMIN}{C}{Vector of lower bounds}{}
\DEFARG{PMAX}{C}{Vector of upper bounds}{}
\ENDARG

   \par
Obsolete command. Use Command Hist/Fit instead.  Fit a user defined (and 
   parameter dependent) function to a histogram ID between channels IFTLOW and 
   IFTUP.  FUNC is the name of a file which contains the user defined function 
   to be minimized. For example file FUNC.FOR is:  
\begin{verbatim}
         DOUBLE PRECISION FUNCTION FUNC(X)
         DOUBLE PRECISION X,DPAR
         COMMON/PAWPAR/DPAR(100)
         FUNC=DPAR(1)*X +DPAR(2)*EXP(-X)
         END
\end{verbatim}
   \par
After the fit, the vector DPAR contains the new values of parameters.  
   Control word ISEL = 10000*B+100*W+10*P+S.  
\begin{verbatim}
     S=2 superimposes function to histogram
       1 no superimposing
     P=1 output from final iteration
      >1 output at iterations from 0 to (P-1), N=0,1,2,..
       0 no output
     W=1 sets weights equal to 1
       0 calculates statistical errors as
         E=SQRT(CONTENTS) unless the 1-Dim  histogram
         ID is weighted with HBARX or HPAKE
     B=0 All parameters vary freely (vectors STEP,PMIN,PMAX not required)
       1 Some or all parameters are bounded
         STEP(I)=0 means parameter I is fixed to its initial value
\end{verbatim}

\ENDCMD
@
