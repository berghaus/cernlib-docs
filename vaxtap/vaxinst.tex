%??.*****************************************************************>
%??.* VAXTAP Reference Guide - Installation Guide                   *>
%??.*  Last Mod.   29 Jan 1992  09:40   mg                          *>
%??.*****************************************************************>
\Filename{H1vaxinst-Installing-VAXTAP}
\chapter{Installing VAXTAP}
\index{installation}
\par
The following steps are required to install VAXTAP.
\begin{OL}
\item
Obtain the VAXTAP.CAR, e.g. copy from VXCRNA, ASIS, etc.
\index{VAXTAP.CAR}
\item
Extract the installation command file as described below
\item
Run the installation command file to generate the executables,
help files and command files
\item
Define the appropriate logical names
\end{OL}
\Filename{H2vaxinst-Extracting-the-installation-command-file}
\section{Extracting the installation command file}
The package is installed by running a command file that can
be generated by the following PATCHY run:
\index{YPATCHY}
\begin{XMP}
$YPATCHY CERN:[PRO.PAM]VAXTAP.PAM INSTALL.COM :GO
+USE,INSTALL,T=EXE.
+PAM.
+QUIT
\end{XMP}
\Filename{H2vaxinst-Running-the-installation-command-file}
\section{Running the installation command file}
\index{INSTALL.COM}
\par
Once this command file has been extracted, installation of the package
proceeds by typing
\begin{XMP}
@INSTALL
\end{XMP}
and answering the questions. If VAXTAP is to be installed on a system
without access to the HEPVM Tape Management System, as is likely
to be the case when installing it outside CERN, answer NO to the first
question. Answering A or ALL to the second question will cause
the installation to complete without any further dialogue.
\par
This procedure generates the executables, help files and command
files that are required.
An example session is shown below.
\begin{XMPt}{Installation of VAXTAP}
VXCRNA? @install

You may install the VAXTAP utilities with or without the TMS option.
If you chose the TMS option, information such as the generic device
type, label type and checks on the volumes existance will be performed
by the TMS. At CERN, this option requires:

- Wollongong TCP/IP
- A SYSREQ interface

Please contact J. Shiers for more information

Use TMS flag       (Y/N/default=N) y
LIB$ = CERN:[PRO.LIB]PACKLIB/LIB,KERNLIB/LIB,SYS$LIBRARY:VAXCRTL/LIB
>>> Step 1: extract source files from PAM

(PATCHY output suppressed)

>>> Step 2: build VAXTAP library
>>> Step 3: create command files
Creating SETUP_STARTUP.COM...
Creating CLEAN_STAGE.COM...
Creating STAGELIST.COM...
Creating TAPECOPY.COM...
Creating TPDAEMON.COM...
Creating STAGECLN.COM...
Creating DUMMY.COM...
Creating ENABLE_STAGING.COM...
>>> Step 4: build .EXE files
Build EINIT       (Y/N/A/Q) a
>>> Building EINIT...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building LABELDUMP...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building SETUP...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building STAGE...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building STAGECLN...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building TAPECOPY...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building WRTAPE...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...
>>> Building XTAPE...
Patchy step...
Compile step...
Compiling CLD file...
Link step...
Multinet TCP/IP...

You should now do the following:
 1) Modify SETUP_STARTUP.COM to suit your system
 2) Add the help files to the required help library
 3) Copy the .EXE files to the directory SETUP_EXE

See the file VAXTAP.SGML for details.
\end{XMPt}
\Filename{H2vaxinst-Defining-the-logical-names}
\section{Defining the logical names}
\index{logical names}
\par
The installation procedure generates a file SETUP\_STARTUP.COM,
which should be tailored to suit your system and then run
at boot time.
\par
The following logical name definitions are required in the LNM\$SYSTEM table.
\begin{DLtt}{123456789012345678901234567890}
\index{logical names}
\item[SETUP\_EXE]Points to the directory where the .EXE files are kept
\item[SETUP\_LOGS]Points to the directory for log files from cleanup jobs
\item[SETUP\_ENABLED]Defined as INTERACTIVE, if interactive tape mounting
is to be allowed
\item[SETUP\_GENERIC]List of users for whom the check on generic device
name against the TMS is not performed.
\item[SETUP\_MAXDEV]Maximum number of devices of a given type
that can be allocated per user per node. If not defined, the default is 999.
\item[SETUP\_NOTAPES]Can be used to define a list of users that are not
allowed to use the VAXTAP commands
\item[SETUP\_QUEUES]Points to a list of batch queue names in which
SETUP commands may be issued (or * for no restriction)
\item[STAGE\_TAPES]Defined as YES if tape staging is enabled.
\item[DISK\$STAGE]Points to the disk (or volume set, stripe set or
search list) to be used for tape staging.
\end{DLtt}
\par
In addition, a logical name must exist for each generic device type.
The logical name is SETUP\_generic-deviceS, thus, for a generic
device of type 8MM, the corresponding logical name is SETUP\_8MMS.
The generic device type is selected using the /GENERIC qualifier of
the various VAXTAP commands.
\index{symbols}
\begin{XMPt}{SETUP\_STARTUP.COM}
$ !---------------------------------------------------------------------------*
$ !
$ !      Startup command file for SETUP/STAGE/LABELDUMP
$ !      Modify logical name definitions as required for your node.
$ !---------------------------------------------------------------------------*
$ !
$ !
$ !*** Following lines are CERN specific ***
$ !      Create lnm table for SETUP information ...
$ !      This is used at CERN in conjunction with the TMS
$        create/name_table/parent=lnm$system_table/prot=w:wred lnm$setup
$ !
$ !      Issue TMS flush command
$ !
$        machine = f$trnlnm("SYS$NODE") - "::"
$        command = "TMS FLUSH ALL SYSTEM ''machine'"
$        'command'
$ !*** End of CERN specific code ***
$ !
$ !      Define directory for .EXE files
$        define/system setup_exe cern_root:[exe]
$ !
$ !      Define symbols for commands
$ !
$        einit    :==$setup_exe:einit
$        labeldump:==$setup_exe:labeldump
$        setup    :==$setup_exe:setup
$        stage    :==$setup_exe:stage
$        wrtape   :==$setup_exe:wrtape
$        tapecopy :==@setup_exe:tapecopy ! Tapecopy is a command file
$        xtape    :==$setup_exe:xtape
$ !
$ !      Allow usage of tapes interactively
$ !
$        define/system setup_enabled "INTERACTIVE"
$ !
$ !      Disallow specific users from using tapes (useful to stop troublemakers)
$ !
$ !      define/system setup_notapes "DECNET,CERNET"
$ !
$ !      Allow tapes in these batch queues
$ !
$ !      define/system setup_queues "SYS$TAPES"
$ !      define/system setup_queues "SYS$BATCH,SYS$TAPES"
$ !      define/system setup_queues "*" ! all queues
$ !
$ !      Set up lists of available device types
$ !
$        define/system setup_tk50s "VSDD18$MKA700:"
$        define/system setup_8200s "UXDDB1$MUB0:"
$        define/system setup_exabytes setup_8200s ! Can also have aliases...
$ !
$ !      Allow tape staging
$ !
$        define/system stage_tapes "YES"
$ !      Must also ensure that DISK$STAGE exists...
$ !
$ !     Define directory for log files (CLEAN_STAGE.COM called from
$ !     STAGECLN)
$       if f$trnlnm("SYS$LOG") .eqs. ""
$          then
$             define/system setup_logs sys$manager
$          else
$             define/system setup_logs sys$log
$          endif
\end{XMPt}
\Filename{H2vaxinst-Installing-the-VAXTAP-images}
\section{Installing the VAXTAP images}

The {\tt VAXTAP-TMS} interface consists of two parts. The first
part, selected by the {\tt PATCHY} flag {\tt TMS}, obtains
information such as the label type and device type from the
TMS. If this option is selected, then the {\tt /LABEL} and
{\tt /GENERIC} qualifiers should not be specified. If the
are specified, the information must match that obtained from
the TMS. This can be overridden for users in the list
defined by the logical name {\tt SETUP\_GENERIC}.


In addition, the flag {\tt TMSMOUNT} selects code which
will record mounts in the TMS.
If you have selected the TMSMOUNT option, then all images, with the exception
of EINIT, must be installed with {\bf SYSPRV} privilege. This is to
permit the programs to communicate correctly with the TMS system.

An example of such an installation is shown below.

\begin{XMPt}{Installing the VAXTAP images on a system with a TMS interface}
$ ins:==$install/command
$ INS
CREATE SETUP_EXE:SETUP/OPEN/SHARE/HEAD/PRIV=SYSPRV
\end{XMPt}

In addition, the STAGE executable must be installed with SYSLCK privilege.
This is required whether a TMS interface exists or not. SYSLCK is used
to communicate with the process that cleans up the staging disk.
\Filename{H2vaxinst-Configuring-the-staging-system}
\section{Configuring the staging system}
\par
To use the STAGE command, one must also allocate some disk space.
It is recommended that a seperate disk or disks be used for
staging, rather than mixing the staging area with, say, user disks.
In fact, the current clean up procedures assume that this has been
done and will {\bf DELETE} and files which do not conform to the
staging file name convention.

At CERN, the cluster size for the staging disk, which is in fact
a stripe set, is set to 250 blocks. The average size of a staged
file is typically 180 MB and so the default cluster size is far
too low.

The staging disk may be also be a volume set or a search list.
In the latter case, the staging system uses that disk with
the most free blocks.

Once the staging disk has been allocated, access must be enabled
on a group basis. This is typically by UIC group, such as
PUBZV at CERN. One may also use the logical name {\tt STAGE\_GROUP}
to group users together. In this case, care must be taken to
establish the correct access to the staging directories, using
for example ACLs and rights identifiers. The command file to
enable staging is shown below.

\index{ACLs}
\index{stage}
\index{enabling stage access}
\index{STAGE\_GROUP}
\begin{XMPt}{Command file to enable stage access}
$ !
$ ! Command file to enable tape staging for a given group
$ ! Tapes are staged to disk DISK$STAGE to subdirectories
$ ! 'IN' and 'OUT' of directory 'UIC-GROUP'
$ !
$ !   Get top directory of staging disk
$ !
$  stage_disk = f$trnlnm("DISK$STAGE")
$  if f$locate(":",stage_disk) .eq. f$length(stage_disk) then -
      stage_disk = f$trnlnm(stage_disk)
$  if f$locate(".]",stage_disk) .lt. f$length(stage_disk)
$     then
$        stage_disk = stage_disk - ".]" + "]"
$     else
$        stage_disk = stage_disk + "[000000]"
$     endif
$ !
$ if f$logical("STAGE_TAPES") .eqs. "YES" then goto uic
$ write sys$output "Tape staging is currently not enabled"
$ inquire/nopunc ans "Do you wish to enable tape staging? "
$ if ans then define/system stage_tapes "YES"
$ uic:
$ type/nopage sys$input

Enter group UIC of group that you wish to enable for tape staging.

$eod
$ inquire/nopunc uic "Group UIC (RETURN=exit)? "
$ if uic .eqs. "" then exit
$ uic = uic - "[" - "]"
$ if f$locate(uic,"ALEPH,DELPHI,L3,OPAL") .lt. -
f$length("ALEPH,DELPHI,L3,OPAL") then goto lep_groups
$ number = f$identifier(uic,"NAME_TO_NUMBER")
$ if number .eq. 0 then goto bad_uic
$ group_ok:
$  in_dir  = stage_disk - "]" + ".''uic']"
$  out_dir = stage_disk - "]" + ".''uic'.OUT]"
$  write sys$output "Input directory  = ''in_dir'"
$  write sys$output "Output directory = ''out_dir'"
$ if f$search("''stage_disk'''uic'.DIR;") .nes. "" then goto exists
$ create/dir 'in_dir' /version_limit=1/owner=['uic',*] -
/protection=(s:rwe,g:rwe,w:re)
$ create/dir 'out_dir' /version_limit=1/owner=['uic',*] -
/protection=(s:rwe,g:rwe,w:re)
$ all:
$ set file/acl=(default_protection,s:rwed,o:rwed,g:rwed,w:re) -
'stage_disk''uic'.dir
$ set file/acl=(default_protection,s:rwed,o:rwed,g:rwed,w:re) -
'in_dir'out.dir
$ goto uic
$ bad_uic:
$ write sys$output ""
$ write sys$output "Tape staging is normally enabled by UIC group ", -
"and ''uic' is an invalid group UIC."
$ write sys$output "Each user in this group must ", -
"have a logical name STAGE_GROUP defined"
$ write sys$output "e.g. DEFINE STAGE_GROUP ''uic'"
$ write sys$output ""
$ inquire/nopunc ans -
"Type any character to reenter a staging group, or return to accept ''uic' "
$ if ans .eqs. "" then goto group_ok
$ goto uic
$ exists:
$ write sys$output "Group ''uic' is already enabled for staging"
$ goto uic
$ lep_groups:
$ create/dir disk$stage:['uic'] /version_limit=1/owner=id$_'uic' -
/protection=(s:rwe,g:rwe,w:re)
$ create/dir disk$stage:['uic'.OUT] /version_limit=1/owner=id$_'uic' -
/protection=(s:rwe,g:rwe,w:rwe)
$ set file/acl=(id=id$_'uic',access=read+write+execute) -
disk$stage:[000000]'uic'.dir
$ set file/acl=(id=id$_'uic',options=default,access=read+write+delete+execute) -
disk$stage:[000000]'uic'.dir
$ set file/acl=(id=id$_'uic',access=read+write+execute) -
disk$stage:['uic']out.dir
$ set file/acl=(id=id$_'uic',options=default,access=read+write+delete+execute) -
disk$stage:['uic']out.dir
$ goto uic
\end{XMPt}

\Filename{H2vaxinst-Multi-file-staging}
\section{Multi-file staging}
\index{Multi-file staging}

One may enable multi-file staging using the logical name
{\tt STAGE\_FULLTAPE}. This name should point to a list of
generic device types for which multi-file staging is to be
enabled. When a stage request is issued for a tape of the
appropriate type, all files are automatically staged.

This can be useful to prevent multiple mount requests for the
same volume.

\Filename{H2vaxinst-Multi-file-concatenation}
\section{Multi-file concatenation}
\index{Multi-file concatenation}

The qualifier {\tt /CONCATENATE} may be used to stage
all files on a tape to a single disk file. This option
is not valid with {\tt /RMS}.
\Filename{H2vaxinst-Remote-staging}
\section{Remote staging}
\index{Remote staging}
\index{FATMEN}

Remote staging is currently only available through the
FATMEN~\cite{bib-FATMEN}
package. However, the implementation requires the creation of
special batch queues, definition of logical names and other
configuration details which are best described here. The technique
used to provide remote staging requires no modification to VAXTAP.

Remote staging is possible in two cases:
\begin{OL}
\item
The remote tape drive is attached to a VAX in the same VAXcluster
as the client
\item
The remote tape drive is attached to a VAX that is in not in
the same VAXcluster
\end{OL}

On the client machine, a file SETUP\_EXE:TPSERV.CONF must be
created. This file contains a list of generic device names
and the nodes on which they are served.

\index{TPSERV}
\begin{XMPt}{An example TPSERV.CONF file}

TPSERV 8200 VXCRNQ

TPSERV CTRS FNALD

\end{XMPt}

When a remote stage is required, a batch job will be submitted
to a special queue on that node. If the server node is in the
same VAXcluster as the client, the batch job is submitted directly.
In other cases, DECnet task to task is used to start a server
to submit the job and check its status.

\subsection{Configuring the batch queues}

A generic batch queue is required for each generic device
type that is to be served. If the queue is to be used to
stage devices of type 8200, then the queue name must be
{\tt STAGE\_8200S}. A physical queue fed by this generic queue
must be created on each node that is to serve devices of this
type. The job limit should be set to the number of devices
that are concurrently available for this type of operation.
Thus, if one has two devices of type 8200 that are dedicated
to staging, the job limit should be set to 2.

\subsection{Log files from the batch jobs}

The log files from the staging jobs are written to the
directory defined by the system logical name {\tt STAGE\_LOGS}.

\subsection{Accessing the staging disk}

It is assumed that the staging disk is DFS mounted on the client
machine.

\subsection{Installing the stage server}

On server systems which are not in the same VAXcluster as prospective
clients, a small stage server must be built and defined as a DECnet
object.

\index{DECNET}
\index{NCP}
\index{TASK}
\index{STGSERV}
\begin{XMPt}{DECnet definitions for the stage server}
MCR NCP
NCP>SET OBJECT STGSERV NUMBER 0 FILE CERN:[PRO.EXE]STGSERV.COM
NCP>DEF OBJECT STGSERV NUMBER 0 FILE CERN:[PRO.EXE]STGSERV.COM
NCP>EXIT
\end{XMPt}

The actual command file simple runs the corresponding .EXE,
and is automatically extracted as part of the FATMEN installation
procedure.

\begin{XMPt}{The STGSERV command file}
$ set noon
$!
$! STGSERV.COM
$!
$! This command file is invoked when a remote stage operation is
$! required.
$!
$! Display remote user and node name
$!
$  remote_user = f$trnlnm("SYS$REM_ID")
$  remote_node = f$trnlnm("SYS$REM_NODE")
$!
$  date_time   = f$cvtime(,"ABSOLUTE")
$!
$  write sys$output ""
$  write sys$output ">>> Start of STGSERV command file"
$  write sys$output ""
$!
$  write sys$output "Remote stage submit/query request from user ",-
"''remote_user' at ''remote_node' at ''date_time'"
$!
$! Set messages how we want them...
$!
$  SET MESSAGE/FACILITY/IDENTIFICATION/SEVERITY/TEXT
$!
$! Run the server
$!
$  RUN SETUP_EXE:STGSERV
$!
$  write sys$output ""
$  write sys$output ">>> End of STGSERV command file"
$  write sys$output ""
$!
\end{XMPt}

The server code can be extracted with the following command file

\begin{XMPt}{Extracting the stage server}
$ypatchy cern:[pro.src.car]fatmen.car stgserv.for :go <<!
+use,qcde.
+use,vaxvms,*stgserv.
+exe.
+pam,11,t=c.
+quit
$for stgserv.for
\end{XMPt}

\Filename{H2vaxinst-Server-mode-staging}
\section{Server mode staging}

The {\tt STAGE} command is normally typed interactively,
or is issued as part of a command file.
An additional possibility exists, which is particularly
useful in the case of multi-file tapes. This is
{\tt server mode} staging, where stage requests are
written to a special directory and processed from there.
Server mode staging requires a further logical name definition,
namely {\tt STAGE\_QUEUE}, which should point to a directory
that can be written to by users for whom server mode staging
is permitted. Typically this will be handled by the use of
a rights identifier.

If disk quotas are enabled on the volume to which the logical
name {\tt STAGE\_QUEUE} points, then the directory must be
set up as in the example below:

\begin{XMP}
(IDENTIFIER=owner,ACCESS=READ+WRITE+EXECUTE+DELETE+CONTROL)
(IDENTIFIER=stage\_user,ACCESS=READ+WRITE+EXECUTE)
(IDENTIFIER=owner,OPTIONS=DEFAULT,ACCESS=READ+WRITE+EXECUTE+DELETE+CONTROL)
(IDENTIFIER=stage\_user,OPTIONS=DEFAULT,ACCESS=READ+WRITE+EXECUTE)
\end{XMP}

where {\tt owner} is the owner of the directory, with a corresponding
disk quota entry and {\tt stage\_user} the rights identifier
that permits access to this directory.

If disk quotas are not enabled on the volume in question, then
allowing group or world write access to the directory is sufficient.

Server mode stage requests consist of a file whose name identifies
the volume and file to be staged. The file name corresponds to the
normal naming convention, i.e. {\tt vsn\_vid.fseq\_labeltype}.
The contents of the file are ignored, but it can be useful to
record the origin of the stage request. In the case of requests
issued from {\tt FATMEN}, the file contains the line

{\small
\begin{XMP}
Stage request for vsn\_vid.fseq\_labeltype issued at yymmdd hhmm by user on node nodename
\end{XMP}
}

If the {\tt STAGE\_QUEUE} logical name is defined, then an existing
staging process for the volume in question will automatically
satisfy any requests in the queue. This is done as follows:

\begin{itemize}
\item
The {\tt STAGE} command checks whether the logical name {\tt STAGE\_QUEUE}
is defined
\item
If so, server mode staging is automatically enabled
\item
It then positions the tape to each file in turn and looks to
see if there are any requests for the file in question.
\item
If so, the request is processed and the request file deleted
\item
If not, the tape is positioned to the next file
\item
Requests are always processed by increasing file sequence number.
If required, the tape will be rewound and a further pass made
to satisfy new requests
\end{itemize}

The logic to decide when to launch a new staging process is
embodied into the FATMEN package and is transparent to the user.

\Filename{H2vaxinst-Cleaning-the-staging-disk}
\section{Cleaning the staging disk}
\index{cleanup}
\index{CLEAN\_STAGE}
\index{STAGECLN}

When a stage command is issued, the stage program checks to
see how much space exists on the staging disk. If there is
insufficient space, it signals a cleanup process and waits
until enough space has been freed.

This cleanup process should be permanently running and is
started by running the {\tt STAGECLN} command file, e.g.
at system startup.

The STAGECLN program takes out a lock on a resource named
STAGE\_PURGER. It establishes a blocking AST routine which
is fired whenever a user issues a STAGE command that requires
more disk space than is currently available on the staging disk.

The program then spawns a subprocess which then executes the command
file CLEAN\_STAGE.COM. This command file performs the following actions.

\begin{OL}
\item
Illegal files are deleted from the staging disk
\item
It then deletes files older than a specified time.
\item
If enough space is recovered, it exist, otherwise
the lifetime is decreased and the process repeated.
\end{OL}

There are a number of parameters that can be set to
control the action of this command file. These are
shown below.

\begin{XMPt}{Configuring the CLEAN\_STAGE command file}
$ !
$ !    The following settings are for VXCERN...
$ !
$      days     = "7"      ! Start by deleting files older than DAYS days
$      hours    = "23"     ! then switch to hours when DAYS < 1
$      max_pass = 15       ! Maximum number of passes
$ !
$ !    Deletion is done on creation date. To delete according to
$ !    file usage do:
$ !
$ !    SET VOLUME/RETENTION=(1,1-) DISK$STAGE
$ !
$ !    This means that, when files are created, the expiry date is set
$ !    to now plus one day. On each access, 1 hour is added to the current
$ !    time. If this is greater than the current expiry date then the expiry
$ !    date is reset.
$ !
$ !    Then, change DELETE/CREATED/SINCE to
$ !                 DELETE/EXPIRED/BEFORE
$ !    which deletes files whose expiry date is BEFORE the specified
$ !    date & time
$ !
\end{XMPt}
