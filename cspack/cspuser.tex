%.*****************************************************************>
%.* CSPACK Reference Guide - User Guide                           *>
%.*  Last Mod.   22 Jun 1993  11:00   mg                          *>
%.*****************************************************************>

\Filename{H1cspuser-ZFTP}
\chapter{ZFTP}

ZFTP is a file transfer program tuned to the needs of the HEP environment.
Using the standard FTP program, files often reach the remote system
in an unreadable format. This is due to differences such as file format
(presence or absence of FORTRAN control words etc.) or, more importantly,
differences used in the internal representation of data between machines.
When files are transferred between systems using ZFTP, these problems
are solved. Not only is data conversion performed automatically on the fly,
but the file format is such that no further manipulation is required before
processing with standard programs. Thus, an ntuple file produced on the
Cray may be transferred to an Apollo workstation with a single command.
\par
In addition, considerable advantages arise from the standard interface
on all systems and the power of KUIP which provides macros and many other
facilities. All of the functionality is also available through FORTRAN
routines which are available as part of PACKLIB. This is used to advantage
in the FATMEN package, to provide convenient remote file transfer.
\par
The ZFTP program is started by typing the command \Ucom{zftp}.
As with the standard ftp program, if the nodename is given
on the command-line, a connection will be established to that
node, e.g. \Ucom{zftp vxcrnb}
Otherwise, use the OPEN command to establish a connection to a remote
machine.
\par
Valid options are described in the description of the OPEN command.
\Filename{H2cspuser-File-conversion-and-commands}
\section{File conversion and commands}
\Sbox{RFRF}{RFRF}{FZFILE RZFILE [LRECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[FZFILE]File name of the input FZ file
\item[RZFILE]File name for the output RZ file
\item[LRECL]Record length for the output RZ file in bytes. If zero is
specified, the record length of the original RZ file will be used.
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[A]the input file is in FZ alpha format
\item[S]display statistics on the RZ file
\item[X]the RZ file will be created in eXchange mode
\item[C]respect case of file names
\end{DLtt}
\end{DLtt}
This command converts an FZ exchange format file to an
RZ file on the LOCAL machine. No network transfer is
performed. The FZFILE must be the output of a previous
RTOF command, or have been created using the RTOX or RTOA
programs. On Unix systems, this file will be read with
FORTRAN direct-access and will hence be transferable and
readable on other systems.

By default, the output RZ file will have the same record
length as the original RZ file. However, if LRECL is
specified then this value will be used instead.
\Sbox{RTOF}{RTOF}{RZFILE FZFILE [LRECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[RZFILE]File name of the input RZ file
\item[FZFILE]File name for the output FZ file
\item[LRECL]Record length for the output FZ file in bytes. If zero is
specified, a record length of 3600 bytes will be used for binary files,
or 80 bytes for ASCII files.
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[A]the output file is to be in FZ alpha format
\item[S]display statistics on the RZ file
\item[C]respect case of file names
\end{DLtt}
\end{DLtt}
This command converts an RZ file into an FZ exchange mode
format file on the LOCAL machine. No network transfer is
performed. By default a binary exchange mode FZ file is
created. On Unix systems, this file will be written with
FORTRAN direct-access and will hence be transferable and
readable on other systems.

\Sbox{FZCOPY}{FZCOPY}{FZIN FZOUT [IFORM] [IRECL] [OFORM] [ORECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[FZIN]input  FZ file name
\item[FZOUT]output FZ file name
\item[IFORM]Format of input FZ file
\item[IRECL]Input record length (in bytes)
\item[OFORM]Format of output FZ file
\item[ORECL]Output record length (in bytes)
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[A]lpha exchange mode format           - RECL not needed
\item[N]native data but exchange file format - RECL not needed
\item[X]exchange format file                 - RECL not needed
\item[Z]native data and file format          - RECL must be specified
\end{DLtt}
\end{DLtt}
This command copies an FZ file on the local machine. At
the same time, file format and data format conversion is
possible. Thus, FZCOPY can be used to convert a binary
native format file into a alpha exchange format file etc.

\Sbox{RZCOPY}{RZCOPY}{RZIN RZOUT [ORECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[RZIN]input  RZ file name
\item[RZOUT]output RZ file name
\item[ORECL]Output record length (in bytes). If not specified, the record
length of the input file will be used.
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[N]convert exchange RZ file into native RZ file
\item[X]convert native RZ file into exchange RZ file
\end{DLtt}
\end{DLtt}
This command copies an RZ file on the local machine. At
the same time, the record length or data format may be
changed. Thus, RZCOPY can be used to convert a native
format RZ file with record length 512 into an exchange
format file with record length 8192.

If not specified, the output record length will be set equal
to that of the input file.

\Sbox{CTOF}{CTOF}{CFILE FFILE [LRECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[CFILE]input  file name
\item[FFILE]output file name
\item[LRECL]record length (in bytes)
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[X]Zebra exchange format file - RECL not needed
\item[ ]other files - RECL must be specified
\end{DLtt}
\end{DLtt}
This command copies a file written with C or FORTRAN
direct-access I/O to one written with FORTRAN sequential I/O.
\Sbox{FTOC}{FTOC}{FFILE CFILE [LRECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[FFILE]input  file name
\item[CFILE]output file name
\item[LRECL]record length (in bytes)
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[X]Zebra exchange format file - RECL not needed
\item[ ]other files - RECL must be specified
\end{DLtt}
\end{DLtt}
This command copies a file written with FORTRAN sequential
I/O to one written with FORTRAN direct-access I/O. The
output file may be read with C I/O or FORTRAN direct access.
\Filename{H2cspuser-File-transfer-commands}
\section{File transfer commands}
\Sbox{GETA}{GETA}{REMOTE LOCAL [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\item[V]Create the remote file with variable length record format
\end{DLtt}
\end{DLtt}
Transfer a text file from the remote machine to a local file.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.
\Sbox{PUTA}{PUTA}{LOCAL REMOTE [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\item[V]Create the remote file with variable length record format
\end{DLtt}
\end{DLtt}
Transfer a text file from the local machine to the remote system.
If the remote file name is not given, or a = sign specified,
the remote file will have the same name as on the local system.
\Sbox{GETB}{GETB}{REMOTE LOCAL [LRECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[LRECL]Record length in bytes
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a binary file from the remote machine to a local file.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.
The file must contain fixed length blocks (EPIO or FZ exchange format).
\Sbox{PUTB}{PUTB}{LOCAL REMOTE [LRECL] [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[LRECL]Record length in bytes
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a binary file from the local machine to the remote system.
If the remote file name is not given, or a = sign specified,
the remote file will have the same name as on the local system.
The file must contain fixed length blocks (EPIO
or FZ exchange format).
\Sbox{GETD}{GETD}{REMOTE LOCAL LRECL [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[LRECL]Record length in bytes
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a binary direct access
file from the remote machine to a local file.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.
The file must contain
fixed length blocks (EPIO or FZ exchange format).

\Sbox{PUTD}{PUTD}{LOCAL REMOTE LRECL [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[LRECL]Record length in bytes
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a binary direct access
file from the local machine to the remote system.
If the remote file name is not given, or a = sign specified,
the remote file will have the same name as on the local system.
The file must contain fixed length blocks (EPIO
or FZ exchange format).

\Sbox{GETP}{GETP}{REMOTE LOCAL [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a compact binary PAM
file from the remote machine to a local file.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.

\Sbox{PUTP}{PUTP}{LOCAL REMOTE [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a compact binary PAM
file from the local machine to the remote system.
If the remote file name is not given, or a = sign specified,
the remote file will have the same name as on the local system.

\Sbox{GETFZ}{GETFZ}{REMOTE LOCAL RRECL RFORM LRECL LFORM [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[RRECL]Record length of the remote file in bytes
\item[RFORM]Format of the remote file
\begin{DLtt}{12}
\item[ ]Native file format - record length required
\item[A]Alpha exchange format - record length forced to be 80 bytes
\item[D]Direct access I/O - ignored if option X is not also specified
\item[Z]Native file format - record length required
\item[X]Binary exchange format - record length will be obtained from
the file itself if not specified.
\end{DLtt}
\item[LRECL]Record length of the local file in bytes
\item[LFORM]
\begin{DLtt}{12}
\item[ ]Native file format - record length required
\item[A]Alpha exchange format - record length forced to be 80 bytes
\item[D]Direct access I/O - ignored if option X is not also specified
\item[Z]Native file format
\item[X]Binary exchange format
\end{DLtt}
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a ZEBRA FZ
file from the remote machine to the local system.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.
The FZ file is created on the local computer with the same
parameters as on the remote machine.
If the format of the local and remote files are not specified,
this command file copies a remote native format file to a local
native format file.

\Sbox{PUTFZ}{PUTFZ}{LOCAL REMOTE LFORM LRECL RFORM RRECL [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[LRECL]Record length of the local file in bytes
\item[LFORM]
\begin{DLtt}{12}
\item[ ]Native file format - record length required
\item[A]Alpha exchange format - record length forced to be 80 bytes
\item[D]Direct access I/O - ignored if option X is not also specified
\item[Z]Native file format - record length required
\item[X]Binary exchange format - record length will be obtained from
the file itself if not specified.
\end{DLtt}
\item[RRECL]Record length of the remote file in bytes
\item[RFORM]Format of the remote file
\begin{DLtt}{12}
\item[ ]Native file format - record length required
\item[A]Alpha exchange format - record length forced to be 80 bytes
\item[D]Direct access I/O - ignored if option X is not also specified
\item[Z]Native file format
\item[X]Binary exchange format
\end{DLtt}
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a ZEBRA FZ
file to the remote machine from the local system.
If the remote file name is not given, or a = sign specified,
the remote file will have the same name as on the local system.
The FZ file is created on the remote computer with the same
parameters as on the local machine.
If the format of the local and remote files are not specified,
this command file copy a local native format file to a remote
native format file.

\Sbox{GETRZ}{GETRZ}{REMOTE LOCAL [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[R]the local file will have RELATIVE organisation (VAX)
\item[L]a list of the top level directories in the received file
is displayed.
\item[T]the entire directory tree is displayed.
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}

\Sbox{PUTRZ}{PUTRZ}{LOCAL REMOTE [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[R]the remote file will have RELATIVE organisation (VAX)
\item[L]a list of the top level directories in the received file
is displayed.
\item[T]the entire directory tree is displayed.
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a local RZ file to the remote machine.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.
The RZ file is created on the remote computer with the same
parameters as on the local machine.

\Sbox{GETX}{GETX}{REMOTE LOCAL LRECL [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[LRECL]Record length in bytes
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a binary direct access
file from the remote machine to a local file.
If the local file name is not given, or a = sign specified,
the local file will have the same name as on the remote system.
The file must contain
fixed length blocks (EPIO or FZ exchange format).
The \Rind{GETX} command uses Fortran
sequential I/O on all systems except Unix, where files are
processed with direct access I/O to avoid the control
words that are written at the beginning and end of each
record with binary sequential Fortran I/O.

\Sbox{PUTX}{PUTX}{LOCAL REMOTE LRECL [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[LRECL]Record length in bytes
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer a binary direct access
file from the local machine to the remote system.
If the remote file name is not given, or a = sign specified,
the remote file will have the same name as on the local system.
The file must contain fixed length blocks (EPIO
or FZ exchange format).
The \Rind{PUTX} command uses Fortran
sequential I/O on all systems except Unix, where files are
processed with direct access I/O to avoid the control
words that are written at the beginning and end of each
record with binary sequential Fortran I/O.

\Sbox{MGET}{MGET}{REMOTE LOCAL [CHOPT]}
\begin{DLtt}{1234567}
\item[REMOTE]Remote file name
\item[LOCAL]Local file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer all files matching the specified remote file name
to the local system. The file name given may contain
*, to match one or more characters, or %, to match a single
character.
By default the transfer is performed
using GETA, unless the file name has a known extension.
\begin{XMP}
e.g.
*.PAM         --> GETP
*.CETA, *.CET --> GETB, LRECL=3600
*.CMZ,  *.RZ  --> GETRZ
\end{XMP}

\Sbox{MPUT}{MPUT}{LOCAL REMOTE [CHOPT]}
\begin{DLtt}{1234567}
\item[LOCAL]Local file name
\item[REMOTE]Remote file name
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[S]Print statistics on the file transfer
\end{DLtt}
\end{DLtt}
Transfer all files matching the specified local file name
to the remote system. The file name given may contain
*, to match one or more characters, or %, to match a single
character.
By default the transfer is performed
using PUTA, unless the file name has a known extension.
\begin{XMP}
e.g.
*.PAM         --> GETP
*.CETA, *.CET --> GETB, LRECL=3600
*.CMZ,  *.RZ  --> GETRZ
\end{XMP}
\Filename{H2cspuser-General-commands}
\section{General commands}
\Sbox{RSHELL}{RSHELL}{COMMAND}
\begin{DLtt}{1234567}
\item[COMMAND]Command to be executed on the remote machine
\end{DLtt}
the specified command is transmitted for execution to the
remote machine.

\Sbox{OPEN}{OPEN}{MACHINE [CHOPT]}
\begin{DLtt}{1234567}
\item[MACHINE]Name of remote machine
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[ ]Use TCP/IP to connect to remote systems.
\item[D]Use DECnet to connect to remote systems. Only valid between
VAX/VMS systems
\item[V]The remote system is running VM/CMS. This option is required
unless the remote node is known to the CSPACK software
\item[M]The remote system is running MVS. This option is required
unless the remote node is known to the CSPACK software
\end{DLtt}
\end{DLtt}
Opens a communication with the remote machine named MACHINE.
MACHINE may be an alphanumeric host name or a TCP/IP address
(e.g. CERNVM, 128.141.1.181)
This command will prompt you for user authentification.
Normally, a server is started by software known as the Internet
Daemon, or inetd. This is not available with certain versions
of TCP/IP, notably DEC/UCX, IBM VM/CMS and MVS. On VM/CMS systems
only, the server is started using the REXEC remote execution
client, supplied as part of IBM's TCP/IP software. More
information on the inetd can be obtained by typing "man inetd"
on a Unix system.

\Sbox{CLOSE}{CLOSE}{}
Close communication with the current remote host.

\Sbox{CD}{CD}{[PATHNAME] [PASSWORD] [CHOPT]}
\begin{DLtt}{1234568}
\item[PATHNAME]Pathname
\item[PASSWORD]Password - for password protected VM/CMS minidisks only
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[C]Case sensitive directory name. If not specified,
pathnames are folded to lower case on Unix systems.
\end{DLtt}
\end{DLtt}
Change remote working directory.
If a pathname is not specified, the current working directory
is displayed.
\begin{XMP}
ZFTP>cd JaMiE -c
\end{XMP}
\par
On remote VM systems, one can change directory to a mini-disk that
has a read or write password by specifying the password and access
mode required, as in the examples below.
\begin{XMP}
ZFTP> cd jamie.400 mypass -r | Read only link

ZFTP> cd fatmen.222 mypass -w | Write link

\end{XMP}
\Sbox{LCD}{LCD}{[PATHNAME] [PASSWORD] [CHOPT]}
\begin{DLtt}{1234568}
\item[PATHNAME]Pathname
\item[PASSWORD]Password - for password protected VM/CMS minidisks only
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[C]Case sensitive directory name. If not specified,
pathnames are folded to lower case on Unix systems.
\end{DLtt}
\end{DLtt}
Change local working directory.
If a pathname is not specified, the current working directory
is displayed.

\Sbox{PWD}{PWD}{}
Print remote working directory.

\Sbox{LPWD}{LPWD}{}
Print local working directory.

\Sbox{LS}{LS}{[PATTERN] [CHOPT]}
\begin{DLtt}{1234567}
\item[PATTERN]Filenames to list. If not specified, all files in the
current working directory will be displayed
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[L]Long listing
\end{DLtt}
\end{DLtt}
Issue remote LS command
If option -l is given, a 'long listing' will be generated.
This corresponds to the Unix ls -l option or the VM/CMS
LISTFILE (L command.

\Sbox{LLS}{LLS}{[PATTERN] [CHOPT]}
\begin{DLtt}{1234567}
\item[PATTERN]Filenames to list. If not specified, all files in the
current working directory will be displayed
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[L]Long listing
\end{DLtt}
\end{DLtt}
Issue local LS command
If option -l is given, a 'long listing' will be generated.
This corresponds to the Unix ls -l option or the VM/CMS
LISTFILE (L command.

\Sbox{MV}{MV}{SOURCE TARGET CHOPT}
\begin{DLtt}{1234567}
\item[SOURCE]
\item[TARGET]
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[C]Respect case of file names (Unix systems)
\end{DLtt}
\end{DLtt}
Move remote file from SOURCE to TARGET.

\Sbox{LMV}{LMV}{SOURCE TARGET CHOPT}
\begin{DLtt}{1234567}
\item[SOURCE]
\item[TARGET]
\item[CHOPT]List of options
\begin{DLtt}{12}
\item[C]Respect case of file names (Unix systems)
\end{DLtt}
\end{DLtt}
Move local file from SOURCE to TARGET.

\Sbox{RM}{RM}{FILENAME}
\begin{DLtt}{12345678}
\item[FILENAME]Filename to be removed
Filename 'Filename' C D=' '
\end{DLtt}
Remove (delete) remote file

\Sbox{LRM}{LRM}{FILENAME}
\begin{DLtt}{12345678}
\item[FILENAME]Filename to be removed
Filename 'Filename' C D=' '
\end{DLtt}
Remove (delete) local file
\Sbox{LOGLEVEL}{LOGLEVEL}{LEVEL}
\begin{DLtt}{1234567}
\item[LEVEL]Loglevel to set, default=0
\end{DLtt}
Use the LOGLEVEL command to set the level of logging/debug of
the ZFTP command.

\Sbox{SVERSION}{SVERSION}{}
\par
Print version of server program

\Sbox{VERSION}{VERSION}{}
\par
Print version of client program

\Filename{H1cspuser-Distributed-PAW}
\chapter{Distributed PAW}
\par
Distributed PAW is currently limited to the ability to access remote
histogram files, or histograms and ntuples existing in global
sections on remote VMS systems. This will be extended over time
to provide the equivalent of global sections on Unix systems,
and to distribute CPU intensive parts of PAW on
mainframes or powerful CPU servers.
\Filename{H1cspuser-FORTRAN-callable-interface}
\chapter{FORTRAN callable interface}
\par
The FORTRAN callable interface consists of the CZ and XZ packages.
Normally, only the XZ package is of concern to the user: any calls
to the CZ package being made in a completely transparent manner.
The exception to this case is of course when a new application
that requires a different server is to be built.
\Filename{H2cspuser-Basic-client-server-routines}
\Section{5cm}{Basic client-server routines}
\Subsection{4cm}{Open communication with a remote node}
\Shubr{CZOPEN}{(SERVICE,HOST,IRC*)}
\begin{DLtt}{1234567890}
\item[SERVICE]Character variable specifying the name of the service required,
e.g. ZSERV
\item[HOST]Character variable specifying the name of the remote host.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine opens a connection with a remote node. A new process
is automatically created on the specified node using the username
and password that are prompted for at the terminal.
\par
When TCPAW is used as the network layer, usernames and passwords
may also be given in a {\bf .netrc} file in the user's home
directory (Unix systems).
In the case of VAX/VMS systems,
the name of this file is .ftplogin;.
For VM/CMS systems running the C version of TCPAW,
this file is DOT NETRC A0.
For a description of the format of these files, see page \pageref{NETRC}.
\index{netrc}
\index{ftplogin}
\index{DOT NETRC}
\index{PROXY}
\par
In the case of VM systems, the virtual machine of the specified
user is autologged. This requires that the user in question
is not currently logged on.
\begin{XMPt}{Example of using the CZOPEN routine}
      CALL CZOPEN('ZSERV','CERNVM',IRC)
      IF(IRC.NE.0) PRINT *,'Return code ',IRC,' from CZOPEN
\end{XMPt}
\par
To select DECnet instead of TCP/IP as the communications protocol,
the variable IPROT in the sequence CZSOCK should be set to 1.
\begin{XMPt}{Example of using DECnet as the communications protocal}
+CDE,CZSOCK. From CSPACK PAM
     IPROT = 1
     CALL CZOPEN('ZSERV','VXCRNA',IRC)
\end{XMPt}
\par
When using DECnet as the communications protocol, username and
password prompting only occurs for interactive sessions.
For other sessions, a server is started using the standard
DECnet techniques, i.e. using a {\tt PROXY} account if one
exists, or else the default DECnet account.
\par
To disable username and password prompting for interactive sessions,
set the logical name {\tt CZPROXY} to {\tt TRUE}, e.g.
\begin{XMPt}{Turning off username prompting for DECnet connections}

DEFINE CZPROXY TRUE

\end{XMPt}

\Subsection{3cm}{Close communication with the current remote node}
\Shubr{CZCLOS}{(IRC*)}
\begin{DLtt}{1234567890}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine closes the connection with the current remote node.
The process on the remote node is automatically terminated.
The current remote node is the one specified in the last call
to CZOPEN, or set by the routine CZSWAP.
\begin{XMPt}{Example of using the CZCLOS routine}
      CALL CZCLOS(IRC)
      IF(IRC.NE.0) PRINT *,'Return code ',IRC,' from CZCLOS
\end{XMPt}

\Subsection{4cm}{Switch communication to another node}
\Shubr{CZSWAP}{(NODE,LUN,IRC*)}
\begin{DLtt}{1234567890}
\item[NODE]Character variable specifying the node name to which communication
should be swapped.
\item[LUN]Integer variable specifying the logical unit associated with
the remote node.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine changes the current node to that associated with the
specified logical unit or nodename. If the nodename is non-blank,
communication is swapped to the specified node. If the nodename
is blank, communication is swapped to the node associated
to LUN (e.g. from a call to XZOPEN, see on Page~\pageref{XZOPEN}).
This routine is called automatically
by the routines of the XZ package and need normally not be called
by a user.
\begin{XMPt}{Example of using the CZSWAP routine}
      CALL CZSWAP(' ',77,IRC)
      IF(IRC.NE.0) PRINT *,'Return code ',IRC,' from CZSWAP
\end{XMPt}
\Subsection{3cm}{Return real time elapsed since last call}
\Shubr{CZRTIM}{(ELAPSED*)}
\begin{DLtt}{1234567890}
\item[ELAPSED]Character variable in which the elpased time is returned in the
format HH:MM:SS.
\end{DLtt}
\par
The CZRTIM routine is used by the XZGET/PUT routines if the option
S is specified in order to print statistics on data transfer rates.
This routine must always be called twice: once
to start the timer and a second time to return the elapsed time.
\begin{XMPt}{Example of using the CZRTIM routine}
*
*     Start timer
*
      CALL CZRTIM(ELAPSD)
*     Work a little
*     ...
*
*     Get elapsed time since last call
      CALL CZRTIM(ELAPSD)
\end{XMPt}
\Subsection{4cm}{Send text string to current remote node}
\Shubr{CZPUTA}{(STRING,IRC*)}
\begin{DLtt}{1234567890}
\item[STRING]Character variable containing the data to be sent to the remote node.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a text string to the remote server.
\begin{XMPt}{Example of using the CZPUTA routine}
*
*     Extract from the ZFTP routine ZFTPCD (action routine for
*     the CD command.
*
      CALL CZPUTA('XZIO :CD '//PATH(1:LPATH)',IRC)
      IF(IRC.NE.0) PRINT *,'Return code ',IRC,' from CZPUTA
\end{XMPt}
\Subsection{4cm}{Read text string from remote server}
\Shubr{CZGETA}{(STRING,IRC*)}
\begin{DLtt}{1234567890}
\item[STRING]Character variable in which the data read from the remote server is
returned.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine gets a text string from the remote server.
An example of its use in the ZFTP program is shown on the following
page.

\begin{XMPt}{Example of using the CZGETA routine}
*
*     Sequence CZMESS from CSPACK - this sequence is used by the
*     various XZ routines to process server messages.
*
+KEEP,CZMESS.
*
*     Process server messages
*
10    CONTINUE
      CALL CZGETA(CHMAIL,ISTAT)
      LCH = LENOCC(CHMAIL)
      IF(CHMAIL(1:1).EQ.'0') THEN
*
*        Nop
*
      ELSEIF(CHMAIL(1:1).EQ.'1') THEN
         PRINT *,CHMAIL(2:LCH)
      ELSEIF(CHMAIL(1:1).EQ.'2') THEN
         PRINT *,CHMAIL(2:LCH)
         GOTO 10
      ELSEIF(CHMAIL(1:1).EQ.'3') THEN
         PRINT *,CHMAIL(2:LCH)
         IQUEST(1) = 1
         IRC       = 1
      ELSEIF(CHMAIL(1:1).EQ.'E') THEN
         IQUEST(1) = -1
         IRC       = -1
      ELSEIF(CHMAIL(1:1).EQ.'V') THEN
*
*        Number of bytes read from a variable length read
*
         READ(CHMAIL(2:11),'(I10)') NGOT
         GOTO 10
      ELSE
         PRINT *,'Unknown server message ',CHMAIL
         IQUEST(1) = 1
         IRC       = 1
      ENDIF
*
\end{XMPt}
\Subsection{4cm}{Send character array to remote server process}
\Shubr{CZPUTC}{(NCHAR,IRC*)}
\begin{DLtt}{1234567890}
\item[NCHAR]Integer variable giving the number of characters to be sent. The
data is in the common block /CZBUFC/ in the character variable
CHBUF.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a character string to the remote server.
\begin{XMPt}{Example of using the CZPUTC routine}
      CALL CZPUTC(NTOT,ISTAT)
      IF(ISTAT.NE.0)GO TO 99
\end{XMPt}
\Subsection{4cm}{Get character array from remote server process}
\Shubr{CZGETC}{(NCHAR,IRC*)}
\begin{DLtt}{1234567890}
\item[NCHAR]Integer variable giving the number of characters to be sent. The
data is in the common block /CZBUFC/ in the character variable
CHBUF.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine reads a character string from the remote server.
\begin{XMPt}{Example of using the CZGETC routine}
      CALL CZGETC(NTOT,ISTAT)
      IF(ISTAT.NE.0)GO TO 99
\end{XMPt}
\Subsection{5cm}{Transfer data between client and server}
\Shubr{CZTCP}{(IBUFF,ICONTR)}
\begin{DLtt}{1234567890}
\item[IBUFF]Array containing hollerith or binary data to be sent to the server
or received from the server depending on the ICONTR vector.
\item[ICONTR]Integer vector of length 2 to determine mode of operation.
ICONTR(1) = IMODE, ICONTR(2) = NBYTES
\end{DLtt}
\par
This routine sends or receives data to/from the remote server.
\begin{XMP}IMODE = 0: receive binary
IMODE = 1: send binary
IMODE = 2: receive character data
IMODE = 3: send character data
\end{XMP}
\begin{XMPt}{Example of using the CZTCP routine}
*
*     Send the data
*
            ICONT(1) = 1
            LBUF     = NWORDS
            CALL CZTCP(IBUFF,ICONT)
            ENDIF

\end{XMPt}
\Filename{H2cspuser-Routines-to-convert-or-copy-files}
\Section{17cm}{Routines to convert or copy files}
\Subsection{5cm}{Convert RZ file to FZ exchange format}
\Shubr{XZRTOF}{(CHRZ,CHFZ,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[CHRZ]Character string giving the name of the RZ file
to be converted.
\item[CHFZ]Character string giving the name of the output
FZ file.
\item[LRECL]Integer variable specifying the record length
for the output file in bytes. If not specified, a default
of 3600 bytes will be used for binary exchange format files
and 80 bytes for alpha exchange format files.
\item[CHOPT]Character variable specifying the options required
\begin{DLtt}{12}
\item[A]Output file should be in alpha exchange format (default is binary).
\item[C]Respect case of input and output file names
\item[R]Replace output file, if it exists
\end{DLtt}
\item[IRC]Integer variable in which the completion status is
returned.
\end{DLtt}
\par
This routine will convert a ZEBRA RZ file into FZ exchange format.
The resultant file may then be transferred to another system
and reconverted using \Rind{XZRFRF}.
\begin{XMPt}{Example of using the XZRTOF routine}
*
*     Convert an RZ file to a FZ alpha file
*
      CALL XZRTOF('NTUPLE.DAT','NTUPLE.FA',0,'A',IRC)
\end{XMPt}
\Subsection{5cm}{Convert RZ file from FZ exchange format}
\Shubr{XZRFRF}{(CHFZ,CHRZ,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[CHFZ]Character string giving the name of the FZ file
to be converted.
\item[CHRZ]Character string giving the name of the output
RZ file.
\item[LRECL]Integer variable specifying the record length
for the output file in bytes. If not specified, the record
length of the original RZ file is used.
\item[CHOPT]Character variable specifying the options required
\begin{DLtt}{12}
\item[C]Respect case of input and output file names
\item[R]Replace output file, if it exists
\item[X]Output file should be in exchange format (default is native).
\end{DLtt}
\item[IRC]Integer variable in which the completion status is
returned.
\end{DLtt}
\par
This routine will convert a ZEBRA FZ file created using
the routine \Rind{XZRTOF} into FZ exchange format.
\begin{XMPt}{Example of using the XZRFRF routine}
*
*     Convert an FZ exchange file back into an RZ file
*     Override the record length in the process
*
      CALL XZRTOF('NTUPLE.FX','NTUPLE.RZ',16384,'X',IRC)
\end{XMPt}
\Shubr{XZCTOF}{(CHIN,CHOUT,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[CHIN]Character string giving the name of the file
to be converted.
\item[CHOUT]Character string giving the name of the output
file.
\item[LRECL]Integer variable giving the record length of the
input file in bytes. In case of option X, the record length
is automatically determined from the file itself.
\item[CHOPT]Character string specifying the options required.
\begin{DLtt}{12}
\item[C]Respect case of input and output file names
\item[R]Replace output file, if it exists
\item[X]Input file is in ZEBRA exchange format
\end{DLtt}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
This routine converts a binary file written with C or FORTRAN
direct-access I/O into a file written with FORTRAN sequential
I/O. This can be useful on Unix systems, when an FZ or EPIO
file that has been transferred from another system is to be read using
FORTRAN I/O.
\begin{XMPt}{Example of using the XZCTOF routine}
*
*     Convert an FZ file for processing with FORTRAN
*
      CALL XZCTOF('FXFILE.DAT','FXFILE.OUT',0,'X',IRC)
\end{XMPt}
\Shubr{XZFTOC}{(CHIN,CHOUT,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[CHIN]Character string giving the name of the file
to be converted.
\item[CHOUT]Character string giving the name of the output
file.
\item[LRECL]Integer variable giving the record length of the
input file in bytes. In case of option X, the record length
is automatically determined from the file itself.
\item[CHOPT]Character string specifying the options required.
\begin{DLtt}{12}
\item[C]Respect case of input and output file names
\item[R]Replace output file, if it exists
\item[X]Input file is in ZEBRA exchange format
\end{DLtt}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
This routine converts a binary file written with FORTRAN
sequential I/O into a file written with FORTRAN direct access
I/O. This can be useful on Unix systems, when an FZ or EPIO
file written with FORTRAN sequential I/O is to be transferred
to another system.
\begin{XMPt}{Example of using the XZFTOC routine}
*
*     Convert an EPIO file for ftp-ing to another system
*
      CALL XZFTOC('EPIO.DAT','EPIO.OUT',3600,' ',IRC)
\end{XMPt}
\Shubr{XZFZCP}{(CHIN,CHOUT,IRECL,IFORM,ORECL,OFORM,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[CHIN]Character string giving the name of the file
to be copied.
\item[CHOUT]Character string giving the name of the output
file.
\item[IRECL]Integer variable giving the record length of the
input file. The record length need only be specified in case
of option Z below.
\item[IFORM]Character variable giving the format of the output file
\begin{DLtt}{12}
\item[A]Input file is in alpha exchange format
\item[N]Input file is in exchange file format, but native data
\item[X]Input file is in binary exchange format
\item[Z]Input file is in native data and file format
\end{DLtt}
\item[ORECL]Integer variable giving the record length of the
output file. If not specified, the input record length will
be taken, except for alpha exchange mode files, where a record
length of 80 will be used.
\item[OFORM]Character variable giving the format of the input file
\begin{DLtt}{12}
\item[A]Output file is in alpha exchange format
\item[N]Output file is in exchange file format, but native data
\item[X]Output file is in binary exchange format
\item[Z]Output file is in native data and file format
\end{DLtt}
\item[CHOPT]Character string specifying the options required.
\begin{DLtt}{12}
\item[C]Respect case of input and output file names
\item[R]Replace output file, if it exists
\end{DLtt}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
This routine copies an FZ file on the local machine, with
optional format and/or data conversion.
\begin{XMPt}{Example of using the XZFZCP routine}
*
*     Copy an alpha FZ file to a native FZ file
*
      CALL XZFZCP('fafile.dat','fzfile.dat',0,'A',32400,'Z',IRC)
\end{XMPt}
\Shubr{XZRZCP}{(CHIN,CHOUT,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[CHIN]Character string giving the name of the file
to be copied.
\item[CHOUT]Character string giving the name of the output
file.
\item[LRECL]Integer variable giving the record length for
the output file. The record length of the input file will
be used if a value of 0 is given for LRECL.
\item[CHOPT]Character string specifying the options required.
\begin{DLtt}{12}
\item[C]Respect case of input and output file names
\item[N]Output file should be in native format (default)
\item[R]Replace output file, if it exists
\item[X]Output file should be in exchange format
\end{DLtt}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
This routine copies an RZ file on the local machine, with
optional data conversion and/or record length conversion.
\begin{XMPt}{Example of using the XZRZCP routine}
*
*     Copy an ntuple, changing the record length and
*     data representation at the same time
*
      CALL XZRZCP('HRZTEST.DAT','hrztest.rz',8192,'CX',IRC)
\end{XMPt}
\Filename{H2cspuser-Routines-to-transfer-files}
\Section{17cm}{Routines to transfer files}
\par
N.B. for all of the following routines, a connection must
first be established using CZOPEN (see on Page~\pageref{CZOPEN}).
All of the following routines return:
\begin{XMP}
IRC < 0 : error - explanatory message will be printed by routine
IRC = 0 : success : see statistics in IQUEST
IRC = 1 : cannot open remote file
IRC = 2 : cannot open local  file
IRC = 3 : problem in file transfer

For IRC = 0:

IQUEST(11) = Number of records transferred
IQUEST(12) = Number of kilobytes transferred
IQUEST(13) = Transfer rate in KB/second
IQUEST(14) = Number of hours elapsed (real time)
IQUEST(15) = Number of minutes elapsed (real time)
IQUEST(16) = Number of seconds elapsed (real time)
IQUEST(17) = Number of seconds elapsed (CPU time)
\end{XMP}

\par
N.B. file names for VM/CMS systems should be specified in
the form {\bf filename.filetype\lsb .filemode\rsb }, e.g.
PROFILE.EXEC.A. VM mini-disks should be specified in the form
{\bf \lsb username\lsb .address\rsb \rsb },e.g.
\lsb JAMIE\rsb , \lsb PUBWS.197\rsb .
File transfer to and from VM/CMS systems and access to files
stored in VM/CMS systems is only possible to the current 'A-disk',
which can be changed using the XZCD routine (see on Page~\pageref{XZCD}).
\Subsection{5cm}{Get text file}
\Shubr{XZGETA}{(LOCAL,REMOTE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer vriable in which the return code is returned.
\end{DLtt}
\par
This routine gets a text file from the remote system.
If option 'S' is specified, statistics on the file transfer
are printed. If option 'V' is specified, the local file will
have variable length record format (IBM-VM systems only).
\begin{XMPt}{Example of using the XZGETA routine}
      CALL XZGETA('=','CZPACK.CARDS','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{5cm}{Send text file}
\Shubr{XZPUTA}{(LOCAL,REMOTE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a text file to the remote system.
If option 'S' is specified, statistics on the file transfer
are printed. If option 'V' is specified, the remote file will
have variable length record format (IBM-VM systems only).
\begin{XMPt}{Example of using the XZPUTA routine}
      CALL XZPUTA('CZPACK.CARDS','=','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{6cm}{Get binary file: fixed length records}
\Shubr{XZGETB}{(LOCAL,REMOTE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL
]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[LRECL]Integer variable specifying the record length of the file in bytes.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine gets a binary file from the remote system.
The file must have fixed length records. ZEBRA FZ files in
binary exchange format, PATCHY CETA files and EPIO files
are examples of files that can be transferred with this routine.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZGETB routine}
      CALL XZGETB('FXFILE.DAT','FXFILE.VAX',32400,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{6cm}{Send binary file: fixed length records}
\Shubr{XZPUTB}{(LOCAL,REMOTE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[LRECL]Integer variable specifying the record length of the file in bytes.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a binary file to the remote system.
The file must have fixed length records. ZEBRA FZ files in
binary exchange format, PATCHY CETA files and EPIO files
are examples of files that can be transferred with this routine.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZPUTB routine}
      CALL XZPUTB('CZPACK.CETA','=',3600,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}

\Subsection{6cm}{Get FORTRAN direct access file}
\Shubr{XZGETD}{(LOCAL,REMOTE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[LRECL]Integer variable specifying the record length of the file in bytes.
\item[CHOPT]Characer variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine gets a direct access  file from the remote system.
ZEBRA FZ files in binary exchange format written with option D,
ZEBRA RZ files (between
like machines)
are examples of files that can be transferred with this routine.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZGETD routine}
      CALL XZGETD('FXFILE.DAT','FXFILE.VAX',32400,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{6cm}{Send FORTRAN direct access file}
\Shubr{XZPUTD}{(LOCAL,REMOTE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[LRECL]Integer variable specifying the record length of the file in bytes.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a direct access file to the remote system.
ZEBRA FZ files in binary exchange format written with option D,
ZEBRA RZ files (between
like machines)
are examples of files that can be transferred with this routine.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZPUTD routine}
      CALL XZPUTD('FXFILE.DATA','=',32400,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{5cm}{Get binary PAM file}
\Shubr{XZGETP}{(LOCAL,REMOTE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine gets a binary PAM file from the remote system.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZGETP routine}
      CALL XZGETP('=','ZEBRA.PAM','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{5cm}{Send binary PAM file}
\Shubr{XZPUTP}{(LOCAL,REMOTE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a binary PAM file to the remote system.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZPUTP routine}
      CALL XZPUTP('KERNAPO.PAM','/cern/new/pam/kernapo/pam','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{7cm}{Get ZEBRA FZ file}
\Shubr{XZGETF}{(LOCAL,REMOTE,LRECL,LFORM,RRECL,RFORM,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[LRECL]Integer variable specifying the record length of the local
file in bytes.
\item[LFORM]Character variable specifying the format of the local file.
\item[RRECL]Integer variable specifying the record length of the remote
file in bytes.
\item[RFORM]Character variable specifying the format of the remote file.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine gets a binary file from the remote system.
If the local file format or record length are not given,
they default to the same values as on the remote system.
The format may be 'A', for FZ exchange, ASCII mapping,
'X', for FZ exchange, binary, or ' ' for FZ native.
For ASCII files the record length defaults to 80 bytes.
For binary exchange format files, the record length is taken
from the file itself. For native format files the record
length must be specified. For binary exchange format files,
a 'D' may also be specified, indicating that the file should
be processed using direct-access I/O.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZGETB routine}
*
*     Transfer a remote ASCII exhange format file to a local
*     binary exchange format file
*
      CALL XZGETF('FXFILE.DAT','FXFILE.VAX',80,'A',32400,'X','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{7cm}{Send ZEBRA FZ file}
\Shubr{XZPUTF}{(LOCAL,REMOTE,LRECL,LFORM,RRECL,RFORM,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[LRECL]Integer variable specifying the record length of the local
file in bytes.
\item[LFORM]Character variable specifying the format of the local file.
\item[RRECL]Integer variable specifying the record length of the remote
file in bytes.
\item[RFORM]Character variable specifying the format of the remote file.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a ZEBRA FZ file to the remote system.
If the remote file format or record length are not given,
they default to the same values as on the local system.
The format may be 'A', for FZ exchange, ASCII mapping,
'X', for FZ exchange, binary, or ' ' for FZ native.
For ASCII files the record length defaults to 80 bytes.
For binary exchange format files, the record length is taken
from the file itself. For native format files the record
length must be specified. For binary exchange format files,
a 'D' may also be specified, indicating that the file should
be processed using direct-access I/O.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZPUTF routine}
*
*     Transfer the local exchange format file to a remote native
*     format file
*
      CALL XZPUTF('FZFILE.DATA','=',32400,'X',32400,' ','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{6cm}{Get RZ file}
\Shubr{XZGETR}{(LOCAL,REMOTE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine gets a ZEBRA RZ file from the remote system.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZGETR routine}
      CALL XZGETR('=','HBOOK.CMZ','S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{5cm}{Send ZEBRA RZ file}
\Shubr{XZPUTR}{(LOCAL,REMOTE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends a ZEBRA RZ file to the remote system.
ZEBRA RZ files include HBOOK histogram files, ntuples, CMZ files etc.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZPUTR routine}
      CALL XZPUTR('FPACK.CMZ','=,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{6cm}{Get exchange format file}
\Shubr{XZGETX}{(LOCAL,REMOTE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
If LOCAL = '=', then the file on the local system will
have the same name as on the remote system.
\item[REMOTE]Character variable specifying the remote file name.
\item[LRECL]Integer variable specifying the record length of the file in bytes.
\item[CHOPT]Characer variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine retrieves an exchange format file from the remote system.
An exchange format file is one with fixed length records and
no control words.
The \Rind{XZGETX} routine uses Fortran
sequential I/O on all systems except Unix, where files are
processed with direct access I/O to avoid the control
words that are written at the beginning and end of each
record with binary sequential Fortran I/O.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZGETX routine}
      CALL XZGETX('FXFILE.DAT','FXFILE.VAX',32400,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Subsection{6cm}{Send exchange format file}
\Shubr{XZPUTX}{(LOCAL,REMOTE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LOCAL]Character variable specifying the local file name.
\item[REMOTE]Character variable specifying the remote file name.
If REMOTE = '=', then the file on the remote system will
have the same name as on the local system.
\item[LRECL]Integer variable specifying the record length of the file in bytes.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sends an exchange format file to the remote system.
An exchange format file is one with fixed length records and
no control words.
The \Rind{XZPUTX} routine uses Fortran
sequential I/O on all systems except Unix, where files are
processed with direct access I/O to avoid the control
words that are written at the beginning and end of each
record with binary sequential Fortran I/O.
If option 'S' is specified, statistics on the file transfer
are printed.
\begin{XMPt}{Example of using the XZPUTX routine}
      CALL XZPUTX('FXFILE.DATA','=',32400,'S',IRC)
      IF(IRC.NE.0) PRINT *,'File transfer failed'
\end{XMPt}
\Filename{H2cspuser-Routines-to-perform-remote-IO}
\Section{7cm}{Routines to perform remote I/O}
\Subsection{6cm}{Open remote file}
\Shubr{XZOPEN}{(LUN,FILE,NODE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[FILE]Character variable specifying the remote file name.
\item[NODE]Characer variable specifying the remote node name.
\item[LRECL]Integer ariable specifying the record length in bytes.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine opens a file on the specified node. If a connection
to the remote system is not yet established, a call to CZOPEN
is made automatically.
The record length is currently only required for direct access files.
\begin{XMP}
CHOPT: 'D' - Open the file for direct access (default=sequential)
CHOPT: 'F' - Open the file 'FORMATTED' (default=unformatted)
CHOPT: 'N' - Open the file with STATUS='NEW' (default=unknown)
\end{XMP}
\begin{XMPt}{Example of using the XZOPEN routine}
      CALL XZOPEN(11,'/user/jamie/cspack/cspack.ceta',3600,' ',IRC)
      IF(IRC.NE.0) PRINT *,'Cannot open remote file'
\end{XMPt}
\Subsection{4cm}{Close remote file}
\Shubr{XZCLOS}{(LUN,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine closes a remote file previously opened by XZOPEN.
\begin{XMP}
CHOPT: 'D' - Delete remote file
\end{XMP}
\begin{XMPt}{Example of using the XZCLOS routine}
      CALL XZCLOS(11,' ',IRC)
      IF(IRC.NE.0) PRINT *,'Error closing remote file'
\end{XMPt}
\Subsection{4cm}{Open a remote RZ file}
\Shubr{XZRZOP}{(LUN,NODE,CHFILE,CHOPT,LRECL,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[NODE]Characer variable specifying the remote node name.
\item[CHFILE]Character variable specifying the remote file name.
\item[CHOPT]Character variable to specify the options desired.
\item[LRECL]Integer ariable specifying the record length in bytes.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
Use the XZROPN to open a remote RZ file. See the description of
the \Rind{RZOPEN} routine in the Zebra manual for more details.
\Subsection{7cm}{Read record from remote file}
\Shubr{XZREAD}{(LUN,IBUFF,NREC,NWANT,NGOT,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[IBUFF]Array to receive the data.
\item[NREC]Integer variable specifying the record number to read
(for direct access files only).
\item[NWANT]Integer variable specifying the number of bytes to read
(for files with variable length records NWANT specifies the
maximum number of bytes that can be accepted).
\item[NGOT]Integer variable specifying the number of bytes read
for files with variable length records.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine reads a record from a remote file
previously opened by XZOPEN.
\begin{XMPt}{Example of using the XZREAD routine}
      CALL XZREAD(11,IBUFF,0,32400,NGOT,' ',IRC)
      IF(IRC.NE.0) PRINT *,'Error reading remote file'
\end{XMPt}
\Subsection{6cm}{Write record to remote file}
\Shubr{XZRITE}{(LUN,IBUFF,NREC,NWRITE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[IBUFF]Array to containing the data to be written.
\item[NREC]Integer variable specifying the record number to write
(for direct access files only).
\item[NWRITE]Integer variable specifying the number of bytes to write.
for files with variable length records.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine writes a record from a remote file
previously opened by \Rind{XZOPEN}.
\begin{XMPt}{Example of using the XZRITE routine}
      NREC    = 30
      LENBUFF = 8192
      CALL XZRITE(11,IBUFF,NREC,32400,LENBUFF,' ',IRC)
      IF(IRC.NE.0) PRINT *,'Error writing to remote file'
\end{XMPt}
\Subsection{4cm}{Read a line from a remote file}
\Shubr{XZGETL}{(LUN,CHLINE,CHFORM,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[CHLINE]Character variable to receive the line
\item[CHFORM]Character variable specifying the format to
be used for reading the line
\item[CHOPT]Character variable specifying the options required
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
This routine reads a record from a remote formatted
file previously opened with the \Rind{XZOPEN} routine.
\begin{XMPt}{Example of using the XZGETL routine}
         CALL XZGETL(LUFZFA,CHLINE,'(A)',' ',IRC)
         IF(IRC.NE.0) GOTO 20
\end{XMPt}
\Subsection{4cm}{Write a line to a remote file}
\Shubr{XZPUTL}{(LUN,CHLINE,CHFORM,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[CHLINE]Character variable containing the data to be written
\item[CHFORM]Character variable specifying the format to
be used for writing the line
\item[CHOPT]Character variable specifying the options required
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
This routine writes a record to a remote formatted
file previously opened with the \Rind{XZOPEN} routine.
\begin{XMPt}{Example of using the XZPUTL routine}
         CALL XZPUTL(LUFZFA,CHLINE,'(A)',' ',IRC)
         IF(IRC.NE.0) GOTO 20
\end{XMPt}

\Subsection{4cm}{Rewind remote file}
\Shubr{XZREWD}{(LUN,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine rewinds a remote file
previously opened by XZOPEN.
\begin{XMPt}{Example of using the XZREWD routine}
      CALL XZREWD(11,' ',IRC)
      IF(IRC.NE.0) PRINT *,'Error rewinding to remote file'
\end{XMPt}
\Subsection{5cm}{Inquire if remote file exists}
\Shubr{XZINQR}{(LUN,FILE,NODE,IEXIST,LRECL,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[FILE]Character variable specifying the remote file name.
\item[NODE]Character variable specifying the node on which the
file resides
\item[IEXIST]Integer variable in which the remote file status is returned.
\item[LRECL]Integer variable in which the record length of the
remote file status is returned.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine checks whether a remote file exists or is OPENed.
\begin{XMPt}{Example of using the XZINQR routine}
      CALL XZINQR(11,'DISK$CERN:<JAMIE>ZEBRA.PAM',
     +   'VXCRNA',IEXIST,LRECL,IRC)
      IF(IRC.NE.0) PRINT *,'Error issuing remote inquire'
\end{XMPt}
\Filename{H2cspuser-General-utility-routines}
\Section{7cm}{General utility routines}
\Subsection{6cm}{Initialise XZ package}
\Shubr{XZINIT}{(LPRINT,LDEBUG,LUNI,LUNO,IRC)}
\begin{DLtt}{1234567890}
\item[LPRINT]Integer variable specifying logical unit to be used to
print diagnostic messages.
\item[LDEBUG]Integer variable specifying the level of debug messages
to be printed.
See the description of the XZLOGL routine for details of the
various log levels.
\item[LUNI]Integer variable specifying the logical unit used for file input
by the XZGETx/XZPUTx routines.
\item[LUNO]Integer variable specifying the logical unit used for file output
by the XZGETx/XZPUTx routines.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine sets the logical units to be used by the XZ package
and the log level. The log level may be reset at any time by
a call to XZLOGL or by a further call to XZINIT.
\begin{XMPt}{Example of using the XZINIT routine}
      CALL XZINIT(6,0,11,21,IRC)
      IF(IRC.NE.0) PRINT *,'Error from XZINIT'
\end{XMPt}
\Subsection{3cm}{Set log level of XZ package}
\Shubr{XZLOGL}{(LDEBUG)}
\begin{DLtt}{1234567890}
\item[LDEBUG]Integer variable specifying the level of debug messages
to be printed.
\end{DLtt}
\par
This routine sets the log level of the XZ package
The log level may be reset at any time by
a further call to XZLOGL or by XZINIT.
\par
The various levels are described below.
\begin{UL}
\item
-3 Suppress all log messages
\item
-2 Error messages
\item
-1 Terse logging
\item
 0 Normal
\item
 1 Log calls to XZ routines
\item
 2 Log to monitor XZ internals
\item
 3 Debug messages
\end{UL}
\begin{XMPt}{Example of using the XZLOGL routine}
      CALL XZLOGL(-3)
\end{XMPt}
\Subsection{3cm}{Print date of generation of package}
\Shubr{XZVERS}{}
\par
This routine prints the PAM file title from the CSPACK
PAM file and the date and time of the PATCHY run
that generated the code.
\begin{XMPt}{Example of using the XZVERS routine}
      CALL XZVERS
\end{XMPt}
\Filename{H2cspuser-Directory-utilities}
\Section{5cm}{Directory utilities}
\Subsection{4cm}{Change remote directory}
\Shubr{XZCD}{(PATH,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable specifying the name of the remote directory
to be set.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine changes the remote directory to that specified by
the character variable PATH. On VM systems, the remote directory
should be given in the form user.address or <user.address>
If the address is omitted, 191 is assumed.
\begin{XMPt}{Example of using the XZCD routine}
      CALL XZCD('FAT3.192',IRC)
      IF(IRC.NE.0) PRINT *,'Error setting remote directory'
\end{XMPt}
On remote VM systems, one can change directory to a mini-disk that
has a read or write password by specifying the password and access
mode required, as in the examples below.
\begin{XMP}
*
*     Read link to FAT3.192
*
      CALL XZCD('FAT3.192 MYPASS R',IRC)
*
*     Write link to FAT3.192
*
      CALL XZCD('FAT3.192 MYPASS W',IRC)
\end{XMP}
\Subsection{4cm}{Change local directory}
\Shubr{XZLCD}{(PATH,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable specifying the name of the local directory
to be set.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine changes the local directory to that specified by
the character variable PATH. On VM systems, the local directory
should be given in the form user.address or <user.address>
If the address is omitted, 191 is assumed.
\begin{XMPt}{Example of using the XZLCD routine}
      CALL XZLCD('FAT3.192',IRC)
      IF(IRC.NE.0) PRINT *,'Error setting local directory'
\end{XMPt}
\Subsection{4cm}{Get current remote directory}
\Shubr{XZPWD}{(PATH,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable in which the current remote directory
is returned.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine returns the current remote directory.
\begin{XMPt}{Example of using the XZPWD routine}
      CALL XZPWD(PATH,IRC)
      IF(IRC.NE.0) THEN
         PRINT *,'Error setting remote directory'
      ELSE
         PRINT *,'Current working directory is ',PATH(1:LENOCC(PATH))
      ENDIF
\end{XMPt}
\Subsection{4cm}{Get current local directory}
\Shubr{XZLPWD}{(PATH,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable in which the current local directory
is returned.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine returns the current local directory.
\begin{XMPt}{Example of using the XZLPWD routine}
      CALL XZLPWD(PATH,IRC)
      IF(IRC.NE.0) THEN
         PRINT *,'Error obtaining local directory'
      ELSE
         PRINT *,'Current working directory is ',PATH(1:LENOCC(PATH))
      ENDIF
\end{XMPt}
\Subsection{19cm}{Issue remote LS command}
\Shubr{XZLS}{(PATH,FILES,MAXFIL,NFILES,ICONT,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable specifying the path name for the remote
ls command. If the intention is to list the current working
directory, PATH should be set to a single blank.
\item[FILES]Character array of size MAXFIL in which the remote file names
are returned. If more than MAXFIL files are found, IRC will be set
to -1. XZLS may be called again with ICONT.NE.0 to receive the
the next batch of file names.
{\bf N.B. no further communication with the remote node is possible
until all pending file names have been read. Use the PATCHY sequence
CZFLUSH to flush pending file names if required. }
\item[MAXFIL]Integer constant specifying the dimension of the character array
FILES.
\item[NFILES]Integer variable in specifying
the number of files returned in FILES.
\item[ICONT]Integer variable specifying
the number of files returned in FILES.
\item[CHOPT]Character variable specifying the required options:
If CHOPT = 'L' a 'long listing' will be returned.
This corresponds to the Unix ls option -l and the VM LISTFILE option L.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine issues a remote LS command and returns the output
in the character array FILES.
\begin{XMPt}{Example of using the XZLS routine}
      CALL XZLS('*.CARDS',FILES,100,NFILES,0,'L',IRC)
      IF(IRC.NE.0) THEN
         PRINT *,'Error issuing remote LS command'
      ELSE
         DO 10 I=1,NFILES
            PRINT *,FILES(I)(1:LENOCC(FILES(I)))
10       CONTINUE
      ENDIF
\end{XMPt}
\Subsection{8cm}{Issue local LS command}
\Shubr{XZLLS}{(PATH,FILES,MAXFIL,NFILES,ICONT,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable specifying the path name for the local
ls command. If the intention is to list the current working
directory, PATH should be set to a single blank.
\item[FILES]Character array of size MAXFIL in which the remote file names
are returned. If more than MAXFIL files are found, IRC will be set
to -1. XZLS may be called again with ICONT.NE.0 to receive the
\item[MAXFIL]Integer constant specifying the dimension of the character array
FILES.
\item[NFILES]Integer variable in specifying
the number of files returned in FILES.
\item[ICONT]Integer variable specifying
the number of files returned in FILES.
\item[CHOPT]Character variable specifying the required options:
If CHOPT = 'L' a 'long listing' will be returned.
This corresponds to the Unix ls option -l and the VM LISTFILE option L.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine issues a remote LS command and returns the output
in the character array FILES.
\begin{XMPt}{Example of using the XZLLS routine}
      CALL XZLLS('*.CARDS',FILES,100,NFILES,0,'L',IRC)
      IF(IRC.NE.0) THEN
         PRINT *,'Error issuing LS command'
      ELSE
         DO 10 I=1,NFILES
            PRINT *,FILES(I)(1:LENOCC(FILES(I)))
10       CONTINUE
      ENDIF
\end{XMPt}
\Subsection{4cm}{Issue remote MV command}
\Shubr{XZMV}{(SOURCE,TARGET,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[SOURCE]Character variable specifying the source file name
\item[TARGET]Character variable specifying the target file name
\item[CHOPT]Options
\begin{DLtt}{12}
\item[C]Respect case of file names (Unix systems)
\end{DLtt}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine moves the remote file from SOURCE to TARGET.
\Subsection{4cm}{Issue local MV command}
\Shubr{XZLMV}{(SOURCE,TARGET,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[SOURCE]Character variable specifying the source file name
\item[TARGET]Character variable specifying the target file name
\item[CHOPT]Options
\begin{DLtt}{12}
\item[C]Respect case of file names (Unix systems)
\end{DLtt}
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine moves the local file from SOURCE to TARGET.
\Subsection{4cm}{Issue remote RM command}
\Shubr{XZRM}{(FILE,IRC)}
\begin{DLtt}{1234567890}
\item[FILE]Character variable specifying the name of the file to be removed.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine issues deletes the specified file on the remote system.
\begin{XMPt}{Example of using the XZRM routine}
      CALL XZRM('CSPACK.CARDS',IRC)
      IF(IRC.NE.0)  PRINT *,'Error issuing RM command'
\end{XMPt}
\Subsection{4cm}{Issue local RM command}
\Shubr{XZLRM}{(FILE,IRC)}
\begin{DLtt}{1234567890}
\item[FILE]Character variable specifying the name of the file to be removed.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine issues deletes the specified file on the local system.
\begin{XMPt}{Example of using the XZLRM routine}
      CALL XZLRM('CSPACK.CARDS',IRC)
      IF(IRC.NE.0)  PRINT *,'Error issuing RM command'
\end{XMPt}
\Filename{H1cspuser-TELNETG-and-TAG++}
\chapter{TELNETG and TAG++}
\par
When using the standard TELNET program to login to a remote host,
such as an IBM mainframe, from a local workstation,
the graphics capabilities of the workstation are normally lost.
TELNETG is a modified version of TELNET which overcomes this
deficiency for HIGZ applications such as PAW or GEANT in a rather
elegant manner.
Not only is the user able to display graphical output from the
remote session in a window on the local station, the mouse
may also be used to provide input. More importantly,
the HIGZ macro primitives are very compact, resulting in
a significant reduction in network traffic (and corresponding
increase in performance). Factors of 10 improvement are typical
for one dimensional histograms, rising to 100 or more for two dimensional
histograms, surfaces, LEGO plots etc.)
The only change that the user must make (apart from typing TELNETG
instead of TELNET,
is to specify the negative value of the
workstation type in the remote application. Thus, when using
TELNETG from an Apollo DN3000 to run PAW on CERNVM, the workstation
type -10002 should be used.
\par
TAG++ is a terminal emulator that provides full-screen access
to IBM VM systems. The version included in CSPACK has been enhanced
to provide the same kind of graphics support as in TELNETG.
As with TELNETG, HIGZ applications, such as PAW, may display
graphical output in a local window and receive graphical input, e.g.
using the mouse.
\Filename{H1cspuser-SYSREQ-and-SYSREQ-TCP}
\chapter{SYSREQ and SYSREQ-TCP}
\par
On VM/CMS systems, two versions of SYSREQ exist. The first requires
a CP modification to add a new command plus a diagnose (Diagnose 140).
The second version uses {\tt IUCV} and is enabled by selecting
{\tt IUCVREQ} when installing the package via the {\tt PATCHY}~\cite{bib-PATCHY}
command {\tt +USE,IUCVREQ}.
\par
SYSREQ-TCP provides a remote interface to a central SYSREQ server
over TCP/IP connections.
SYSREQ-TCP is currently only used to provide remote access to the HEPVM
Tape Management System (TMS) from nodes at CERN other than CERNVM, where the
TMS currently resides. However, the mechanism of passing commands
and messages to a server that is already running is of general
use and so it is planned to release this code as a separate
component that avoids all use of SYSREQ on the IBM system.
\par
Both command line and FORTRAN callable interfaces to SYSREQ exist.
The command line interface is shown below.
\begin{XMPt}{Using the SYSREQ command line interface}

SYSREQ service command

e.g.

SYSREQ TMS QVOL I29021

\end{XMPt}
\Filename{H2cspuser-The-SYSREQ-FORTRAN-interface}
\section{The SYSREQ FORTRAN interface}
\Shubr{SYSREQ}{(SERVICE,COMMAND,IRC*,REPLY*,*LENREP*)}
\begin{DLtt}{1234567}
\item[SERVICE]Character variable specifying the service required
\item[COMMAND]Character variable specifying the command to pass to that service
\item[IRC]Integer variable in which the return code is returned
\item[REPLY]Character array of length LENREP in which the reply is returned
\item[LENREP]Integer variable containing the number of elements of REPLY
on input and the number of elements of REPLY containing returned data on
output
\end{DLtt}
\par
This routine sends the specified command to the named service via the
SYSREQ mechanism.
One may also use the routine FMSREQ, which is part of the FATMEN~\cite{bib-FATMEN}
and resides in PACKLIB. This routine as the same calling sequence as SYSREQ,
but provides automatic protection against network problems (timeouts etc.)
with retry were required.
\index{return code!IRC}
\begin{DLtt}{123456789}
\item[IRC]Return status
\begin{DLtt}{12}
\item[0]Normal completion
\item[2]Reply longer then LENREP. The COMMAND(LENREP) contains the
command to issue to get the remaining part of the reply.
\end{DLtt}
\end{DLtt}
\begin{XMPt}{Example of using the SYSREQ routine}
      CHARACTER*240 COMMAND
      CHARACTER*8   SERVICE
      INTEGER       IRC
      INTEGER       REPLEN
      PARAMETER     (REPLEN=100)
      CHARACTER*132 TMSREP(REPLEN)

      IRC = 0

      SERVICE = 'TMS'
      COMMAND = 'Q VID I29001 - I29010'
      LCOMM   = LENOCC(COMMAND)

 500  CONTINUE
      I = REPLEN
      CALL SYSREQ(SERVICE,COMMAND(1:LCOMM),IRC,TMSREP,I)

      DO 20 J=1,I-1
      WRITE (6,200) TMSREP(J)
 200  FORMAT(1X,A80)
 20   CONTINUE

      IF (IRC .EQ. 2) THEN
*
*     Reply exceeded buffer length. Print command that we
*     should issue to get remainder of reply
*
         COMMAND = TMSREP(I)
         LCOMM   = LENOCC(COMMAND)
         PRINT *,'Issuing ',COMMAND(1:LCOMM)
         GOTO 500
      ENDIF
C       Print the Last Line
      WRITE (6,200) TMSREP(I)

 9999 CONTINUE
      PRINT *,'SYSREQ(Fortran): RC(',IRC,')'

      END

\end{XMPt}
\Filename{H1cspuser-The-ZEBRA-and-PAW-servers}
\chapter{The ZEBRA and PAW servers}
\par
The ZEBRA and PAW servers (ZSERV, PAWSERV)
are all built as part of the standard
program library installation. More details can be found in the
Installation and Management section of this manual.
\par
The following server routines are all controlled by a single
server steering routine. This routine receives messages
from the client, unpacks the messages and calls the appropriate
server routine with a standard FORTRAN call.
\par
The remote file transfer routines behave similarly. However,
rather than just issue remote reads or writes record by
record, the individual records of the files to be transferred
are blocked to reduce the number of network operations.
This has a significant effect on the file transfer rate.
\par
Error and informational messages from the server are sent
back to the client using the CZPUTA routine. These are processed
in a standard manner using the PATCHY sequence CZMESS.
\Filename{H2cspuser-Server-Routines-to-perform-remote-IO}
\Section{6cm}{Server Routines to perform remote I/O}
\Subsection{5cm}{Open remote file}
\Shubr{SZOPEN}{(LUN,FILE,LRECL,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[FILE]Character variable specifying the file name.
\item[LRECL]Integer variable specifying the record length in bytes.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine opens a file on the server node.
\begin{XMP}
CHOPT: 'D' - Open the file for direct access
CHOPT: 'F' - Open the file 'FORMATTED' (default=unformatted)
CHOPT: 'N' - Open the file with STATUS='NEW'
\end{XMP}
\Subsection{4cm}{Close remote file}
\Shubr{SZCLOS}{(LUN,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine closes a remote file previously opened by SZOPEN.
\begin{XMP}
CHOPT: 'D' - Delete remote file
\end{XMP}
\Subsection{7cm}{Read record from remote file}
\Shubr{SZREAD}{(LUN,IBUFF,NREC,NWANT,NGOT,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[IBUFF]Array to receive the data.
\item[NREC]Integer variable specifying the record number to read
(for direct access files only).
\item[NWANT]Integer variable specifying the number of bytes to read
(for files with variable length records NWANT specifies the
maximum number of bytes that can be accepted).
\item[NGOT]Integer variable specifying the number of bytes read
for files with variable length records.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine reads a record from a remote file
previously opened by SZOPEN.
\Subsection{6cm}{Write record to remote file}
\Shubr{SZRITE}{(LUN,IBUFF,NREC,NWRITE,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[IBUFF]Array to containing the data to be written.
\item[NREC]Integer variable specifying the record number to write
(for direct access files only).
\item[NWRITE]Integer variable specifying the number of bytes to write.
for files with variable length records.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine writes a record from a remote file
previously opened by SZOPEN.
\Subsection{4cm}{Rewind remote file}
\Shubr{SZREWD}{(LUN,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[CHOPT]Character variable to specify the options desired.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine rewinds a remote file
previously opened by SZOPEN.
\Subsection{6cm}{Inquire if remote file exists}
\Shubr{SZINQR}{(LUN,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[LUN]Integer variable specifying logical unit to be used.
\item[FILE]Character variable specifying the remote file name.
\item[NODE]Character variable specifying the remote node name.
\item[IEXIST]Integer variable in which the remote file status is returned.
\item[LRECL]Integer variable in which the record length of the
remote file status is returned.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine checks whether a remote file exists or is OPENed.
\Filename{H2cspuser-General-utility-routines}
\Section{5cm}{General utility routines}
\Subsection{3cm}{Print date of generation of package}
\Shubr{SZVERS}{}
\par
This routine prints the PAM file title from the CSPACK
PAM file and the date and time of the PATCHY run
that generated the code.
\Filename{H2cspuser-Remote-directory-utilities}
\Section{5cm}{Remote directory utilities}
\Subsection{4cm}{Change remote directory}
\Shubr{SZCD}{(PATH,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable specifying the name of the remote directory
to be set.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine changes the remote directory to that specified by
the character variable PATH. On VM systems, the remote directory
should be given in the form user.address or <user.address>
If the address is omitted, 191 is assumed.
\Subsection{4cm}{Get current remote directory}
\Shubr{SZPWD}{(PATH,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable in which the current remote directory
is returned.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine returns the current remote directory.
\Subsection{4cm}{Issue remote LS command}
\Shubr{SZLS}{(PATH,CHOPT,IRC)}
\begin{DLtt}{1234567890}
\item[PATH]Character variable specifying the path name for the remote
ls command. If the intention is to list the current working
directory, PATH should be set to a single blank.
\item[CHOPT]Character variable specifying the required options:
If CHOPT = 'L' a 'long listing' will be returned (Unix and VM systems).
This corresponds to the Unix ls option -l and the VM LISTFILE option L.
\item[IRC]Integer variable in which the return code is returned.
\end{DLtt}
\par
This routine issues a remote LS command and returns the output
to the client.

\Filename{H1cspuser-Format-of-the-netrc-and-ftplogin-files}
\chapter{Format of the netrc and ftplogin files}
\label{NETRC}
\index{netrc}
\index{ftplogin}
\index{DOT NETRC}
\par
On Unix and VM/CMS systems, the {\tt .netrc} {\tt DOT NETRC A0} on
VM/CMS systems)  have the following format. On Unix systems these
files must reside in the home directory of the relevant user and
be correctly protected using the command
\begin{XMPt}{Protecting a .netrc file}

chmod 0600 .netrc

\end{XMPt}
\begin{XMPt}{Format of the .netrc files}

machine <host-name> login <user-name> password <password>

e.g.

machine cernvm login zftptest password kwerdal

\end{XMPt}
\par
On VAX/VMS systems, the file is named {\tt ftplogin.;} and should again
reside in the home directory. It should be protected as follows:
\begin{XMPt}{Protecting an ftplogin file}

SET FILE/PROTECTION=(S,W,G,O:R) FTPLOGIN.;

\end{XMPt}
\par
The format of this file is somewhat simpler, containing no keywords,
as shown in the following example.
\begin{XMPt}{An example of an ftplogin file}

cernvnm zftptest kwerdal

vxcrna  zftptest -

\end{XMPt}
\par
Note that the minus sign will cause a prompt for the password.
